/* eslint-disable */

try {
(function() {
  var OO = {};

  OO.VERSION = {
    "core" : {"releaseVersion": "4.33.25", "rev": "<CORE_REV>"}
  };

  OO.playerParams = {
    "core_version" : 4,
    "vast_proxy_url" : "http://player.ooyala.com/adinsertion/vast_proxy",
    "namespace": "OOV4"  
  };
(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
if (!OO) {
  OO = {};
}

},{}],2:[function(require,module,exports){
require("./InitOO.js");

if (!window._) {
  window._ = require('underscore');
}

if (!OO._) {
  OO._ = window._.noConflict();
}

},{"./InitOO.js":1,"underscore":36}],3:[function(require,module,exports){
(function (OO, _, $) {
  OO.getRandomString = function () {
    return Math.random().toString(36).substring(7);
  };

  OO.safeClone = function (source) {
    if (_.isNumber(source) || _.isString(source) || _.isBoolean(source) || _.isFunction(source) || _.isNull(source) || _.isUndefined(source)) {
      return source;
    }

    var result = source instanceof Array ? [] : {};

    try {
      $.extend(true, result, source);
    } catch (e) {
      OO.log("deep clone error", e);
    }

    return result;
  };

  OO.d = function () {
    if (OO.isDebug) {
      OO.log.apply(OO, arguments);
    }

    OO.$("#OOYALA_DEBUG_CONSOLE").append(JSON.stringify(OO.safeClone(arguments)) + '<br>');
  }; // Note: This inherit only for simple inheritance simulation, the Parennt class still has a this binding
  // to the parent class. so any variable initiated in the Parent Constructor, will not be available to the
  // Child Class, you need to copy paste constructor to Child Class to make it work.
  // coffeescript is doing a better job here by binding the this context to child in the constructor.
  // Until we switch to CoffeeScript, we need to be careful using this simplified inherit lib.


  OO.inherit = function (ParentClass, myConstructor) {
    if (typeof ParentClass !== "function") {
      OO.log("invalid inherit, ParentClass need to be a class", ParentClass);
      return null;
    }

    var SubClass = function () {
      ParentClass.apply(this, arguments);

      if (typeof myConstructor === "function") {
        myConstructor.apply(this, arguments);
      }
    };

    var parentClass = new ParentClass();

    OO._.extend(SubClass.prototype, parentClass);

    SubClass.prototype.parentClass = parentClass;
    return SubClass;
  };

  var styles = {}; // keep track of all styles added so we can remove them later if destroy is called

  OO.attachStyle = function (styleContent, playerId) {
    var s = $('<style type="text/css">' + styleContent + '</style>').appendTo("head");
    styles[playerId] = styles[playerId] || [];
    styles[playerId].push(s);
  };

  OO.removeStyles = function (playerId) {
    OO._.each(styles[playerId], function (style) {
      style.remove();
    });
  }; // object: object to get the inner property for, ex. {"mod":{"fw":{"data":{"key":"val"}}}}
  // keylist: list of keys to find, ex. ["mod", "fw", "data"]
  // example output: {"key":"val"}


  OO.getInnerProperty = function (object, keylist) {
    var innerObject = object;
    var list = keylist;

    while (list.length > 0) {
      var key = list.shift(); // Note that function and arrays are objects

      if (_.isNull(innerObject) || !_.isObject(innerObject) || _.isFunction(innerObject) || _.isArray(innerObject)) return null;
      innerObject = innerObject[key];
    }

    return innerObject;
  };

  OO.formatSeconds = function (timeInSeconds) {
    var seconds = parseInt(timeInSeconds, 10) % 60;
    var hours = parseInt(timeInSeconds / 3600, 10);
    var minutes = parseInt((timeInSeconds - hours * 3600) / 60, 10);

    if (hours < 10) {
      hours = '0' + hours;
    }

    if (minutes < 10) {
      minutes = '0' + minutes;
    }

    if (seconds < 10) {
      seconds = '0' + seconds;
    }

    return parseInt(hours, 10) > 0 ? hours + ":" + minutes + ":" + seconds : minutes + ":" + seconds;
  };

  OO.timeStringToSeconds = function (timeString) {
    var timeArray = (timeString || '').split(":");
    return _.reduce(timeArray, function (m, s) {
      return m * 60 + parseInt(s, 10);
    }, 0);
  };

  OO.leftPadding = function (num, totalChars) {
    var pad = '0';
    var numString = num ? num.toString() : '';

    while (numString.length < totalChars) {
      numString = pad + numString;
    }

    return numString;
  };

  OO.getColorString = function (color) {
    return '#' + OO.leftPadding(color.toString(16), 6).toUpperCase();
  };

  OO.hexToRgb = function (hex) {
    var r = (hex & 0xFF0000) >> 16;
    var g = (hex & 0xFF00) >> 8;
    var b = hex & 0xFF;
    return [r, g, b];
  };

  OO.changeColor = function (color, ratio, darker) {
    var minmax = darker ? Math.max : Math.min;
    var boundary = darker ? 0 : 255;
    var difference = Math.round(ratio * 255) * (darker ? -1 : 1);
    var rgb = OO.hexToRgb(color);
    return [OO.leftPadding(minmax(rgb[0] + difference, boundary).toString(16), 2), OO.leftPadding(minmax(rgb[1] + difference, boundary).toString(16), 2), OO.leftPadding(minmax(rgb[2] + difference, boundary).toString(16), 2)].join('');
  };

  OO.decode64 = function (s) {
    s = s.replace(/\n/g, "");
    var results = "";
    var j,
        i = 0;
    var enc = [];
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; //shortcut for browsers with atob

    if (window.atob) {
      return atob(s);
    }

    do {
      for (j = 0; j < 4; j++) {
        enc[j] = b64.indexOf(s.charAt(i++));
      }

      results += String.fromCharCode(enc[0] << 2 | enc[1] >> 4, enc[2] == 64 ? 0 : (enc[1] & 15) << 4 | enc[2] >> 2, enc[3] == 64 ? 0 : (enc[2] & 3) << 6 | enc[3]);
    } while (i < s.length); //trim tailing null characters


    return results.replace(/\0/g, "");
  };

  OO.pixelPing = function (url) {
    var img = new Image();

    img.onerror = img.onabort = function () {
      OO.d("onerror:", url);
    };

    img.src = OO.getNormalizedTagUrl(url);
  }; // ping array of urls.


  OO.pixelPings = function (urls) {
    if (_.isEmpty(urls)) {
      return;
    }

    _.each(urls, function (url) {
      OO.pixelPing(url);
    }, this);
  }; // helper function to convert types to boolean
  // the (!!) trick only works to verify if a string isn't the empty string
  // therefore, we must use a special case for that


  OO.stringToBoolean = function (value) {
    if (typeof value === 'string') return value.toLowerCase().indexOf("true") > -1 || value.toLowerCase().indexOf("yes") > -1;
    return !!value;
  };

  OO.regexEscape = function (value) {
    var specials = /[<>()\[\]{}]/g;
    return value.replace(specials, "\\$&");
  };

  OO.getNormalizedTagUrl = function (url, embedCode) {
    var ts = new Date().getTime();
    var pageUrl = escape(document.URL);

    var placeHolderReplace = function (template, replaceValue) {
      _.each(template, function (placeHolder) {
        var regexSearchVal = new RegExp("(" + OO.regexEscape(placeHolder) + ")", 'gi');
        url = url.replace(regexSearchVal, replaceValue);
      }, this);
    }; // replace the timestamp and referrer_url placeholders


    placeHolderReplace(OO.TEMPLATES.RANDOM_PLACE_HOLDER, ts);
    placeHolderReplace(OO.TEMPLATES.REFERAK_PLACE_HOLDER, pageUrl); // first make sure that the embedCode exists, then replace the
    // oo_embedcode placeholder

    if (embedCode) {
      placeHolderReplace(OO.TEMPLATES.EMBED_CODE_PLACE_HOLDER, embedCode);
    }

    return url;
  };

  OO.safeSeekRange = function (seekRange) {
    return {
      start: seekRange.length > 0 ? seekRange.start(0) : 0,
      end: seekRange.length > 0 ? seekRange.end(0) : 0
    };
  };

  OO.loadedJS = OO.loadedJS || {};
  OO.jsOnSuccessList = OO.jsOnSuccessList || {};

  OO.safeFuncCall = function (fn) {
    if (typeof fn !== "function") {
      return;
    }

    try {
      fn.apply();
    } catch (e) {
      OO.log("Can not invoke function!", e);
    }
  };

  OO.loadScriptOnce = function (jsSrc, successCallBack, errorCallBack, timeoutInMillis) {
    OO.jsOnSuccessList[jsSrc] = OO.jsOnSuccessList[jsSrc] || [];

    if (OO.loadedJS[jsSrc]) {
      // invoke call back directly if loaded.
      if (OO.loadedJS[jsSrc] === "loaded") {
        OO.safeFuncCall(successCallBack);
      } else if (OO.loadedJS[jsSrc] === "loading") {
        OO.jsOnSuccessList[jsSrc].unshift(successCallBack);
      }

      return false;
    }

    OO.loadedJS[jsSrc] = "loading";
    $.ajax({
      url: jsSrc,
      type: 'GET',
      cache: true,
      dataType: 'script',
      timeout: timeoutInMillis || 15000,
      success: function () {
        OO.loadedJS[jsSrc] = "loaded";
        OO.jsOnSuccessList[jsSrc].unshift(successCallBack);

        OO._.each(OO.jsOnSuccessList[jsSrc], function (fn) {
          OO.safeFuncCall(fn);
        }, this);

        OO.jsOnSuccessList[jsSrc] = [];
      },
      error: function () {
        OO.safeFuncCall(errorCallBack);
      }
    });
    return true;
  };

  try {
    OO.localStorage = window.localStorage;
  } catch (err) {
    OO.log(err);
  }

  if (!OO.localStorage) {
    OO.localStorage = {
      getItem: function (sKey) {
        if (!sKey || !this.hasOwnProperty(sKey)) {
          return null;
        }

        return unescape(document.cookie.replace(new RegExp("(?:^|.*;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*"), "$1"));
      },
      key: function (nKeyId) {
        return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, "").split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]);
      },
      setItem: function (sKey, sValue) {
        if (!sKey) {
          return;
        }

        document.cookie = escape(sKey) + "=" + escape(sValue) + "; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/";
        this.length = document.cookie.match(/\=/g).length;
      },
      length: 0,
      removeItem: function (sKey) {
        if (!sKey || !this.hasOwnProperty(sKey)) {
          return;
        }

        document.cookie = escape(sKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
        this.length--;
      },
      hasOwnProperty: function (sKey) {
        return new RegExp("(?:^|;\\s*)" + escape(sKey).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=").test(document.cookie);
      }
    };
    OO.localStorage.length = (document.cookie.match(/\=/g) || OO.localStorage).length;
  } // A container to properly request OO.localStorage.setItem


  OO.setItem = function (sKey, sValue) {
    try {
      OO.localStorage.setItem(sKey, sValue);
    } catch (err) {
      OO.log(err);
    }
  };
  /**
   * Converts a value to a number or returns null if it can't be converted or is not a finite value.
   * @public
   * @method OO#ensureNumber
   * @param {*} value The value to convert.
   * @param {*} defaultValue A default value to return when the input is not a valid number.
   * @return {Number} The Number equivalent of value if it can be converted and is finite.
   * When value doesn't meet the criteria the function will return either defaultValue (if provided) or null.
   */


  OO.ensureNumber = function (value, defaultValue) {
    var number;

    if (value === null || _.isArray(value)) {
      value = NaN;
    }

    if (_.isNumber(value)) {
      number = value;
    } else {
      number = Number(value);
    }

    if (!isFinite(number)) {
      return typeof defaultValue === 'undefined' ? null : defaultValue;
    }

    return number;
  };

  OO.JSON = window.JSON;
})(OO, OO._, OO.$);

},{}],4:[function(require,module,exports){
require("./InitAnalyticsNamespace.js");
/**
 * If Analytics.EVENTS or Analytics.REQUIRED_PLUGIN_FUNCTIONS do not already
 * exist, create them.
 */

/**
 * @public
 * @description These are the ad types Ooyala Player supports
 * @namespace OO.Analytics.AD_TYPE
 */


if (!OO.Analytics.AD_TYPE) {
  var AD_TYPE = {
    LINEAR_OVERLAY: "linearOverlay",
    NONLINEAR_OVERLAY: "nonlinearOverlay",
    LINEAR_VIDEO: "linearVideo",
    COMPANION: "companion"
  };
  OO.Analytics.AD_TYPE = AD_TYPE;
}
/**
 * @public
 * @description These are the stream types Ooyala Player supports
 * @namespace OO.Analytics.STREAM_TYPE
 */


if (!OO.Analytics.STREAM_TYPE) {
  var STREAM_TYPE = {
    VOD: "vod",
    LIVE_STREAM: "liveStream"
  };
  OO.Analytics.STREAM_TYPE = STREAM_TYPE;
}
/**
 * @public
 * @description [DEPRECATED]
 * These are the Ooyala Player error codes
 * @namespace OO.Analytics.ERROR_CODE
 */


if (!OO.Analytics.ERROR_CODE) {
  var ERROR_CODE = {
    "100": "General Error"
  };
  OO.Analytics.ERROR_CODE = ERROR_CODE;
}
/**
 * @public
 * @description These are the events associated with the Analytics Framework.
 * @namespace OO.Analytics.EVENTS
 */


if (!OO.Analytics.EVENTS) {
  var EVENTS = {
    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_PLAYER_CREATED
     * @description This message is sent when the player is first created.
     * @param {Array} paramArray Array of length 1, containing the original parameters
     * passed into the player
     */
    VIDEO_PLAYER_CREATED: 'video_player_created',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_ELEMENT_CREATED
     * @description This message is sent when the video element is first created.
     */
    VIDEO_ELEMENT_CREATED: 'video_element_created',

    /**
     * @public
     * @event OO.Analytics.EVENTS#INITIAL_PLAYBACK_REQUESTED
     * @description This message is sent the first time the user tries to play the video.
     * In the case of autoplay, it will be sent immediately after the player is ready to play.
     */
    INITIAL_PLAYBACK_REQUESTED: 'initial_playback_requested',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_CONTENT_COMPLETED
     * @description This message is sent when main content playback has completed.
     */
    VIDEO_CONTENT_COMPLETED: 'video_content_completed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#PLAYBACK_COMPLETED
     * @description This message is sent when video and ad playback has completed.
     */
    PLAYBACK_COMPLETED: 'playback_completed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_PLAY_REQUESTED
     * @description This message is sent every time there is a request to try and
     * initiate video playback (except the first time. See VIDEO_FIRST_PLAY_REQUESTED).
     * This is only the request, not when video playback has actually started.
     */
    VIDEO_PLAY_REQUESTED: 'video_play_requested',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_PAUSE_REQUESTED
     * @description This message is sent every time there is a request to try and
     * pause the video. This is only the request, not when video playback has actually
     * paused.
     */
    VIDEO_PAUSE_REQUESTED: 'video_pause_requested',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_PLAYING
     * @description This message is sent when video playback has started or resumed.
     */
    VIDEO_PLAYING: 'video_playing',

    /**
     * @event OO.Analytics.EVENTS#VIDEO_PAUSED
     * @description This message is sent when video playback has paused.
     */
    VIDEO_PAUSED: 'video_paused',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_REPLAY_REQUESTED
     * @description This message is sent after VIDEO_ENDED, when the player is
     * requested to start video playback from the beginning of the video. This
     * is only the request, not when the video actually start playing again.
     */
    VIDEO_REPLAY_REQUESTED: 'video_replay_requested',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_SOURCE_CHANGED
     * @description This message is sent when the player has received a new video source
     * to load.  This will happen when the first video initially starts to load,
     * when switching video sources during playback and also when switching to a
     * new video after VIDEO_ENDED.  This will not be received on VIDEO_REPLAY_REQUESTED.
     * @param {Array} paramArray Array of length 1, containing an instance of
     * OO.Analytics.EVENT_DATA.VideoSourceData
     */
    VIDEO_SOURCE_CHANGED: 'video_source_changed',

    /**
     * @event OO.Analytics.EVENTS#VIDEO_STREAM_METADATA_UPDATED
     * @description This message is sent when video stream metadata has been
     * downloaded.  In contains information about the stream and metadata
     * for any plugins that should be loaded.
     * @param {Array} paramArray Array of length 1, contains an object holding all
     * the metadata for each plugin that should be loaded
     */
    VIDEO_STREAM_METADATA_UPDATED: 'video_stream_metadata_updated',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_CONTENT_METADATA_UPDATED
     * @description This message is sent when the video content data has been
     * downloaded. This will contain information about the video content. For
     * example, title and description.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoContentMetadata
     */
    VIDEO_CONTENT_METADATA_UPDATED: 'video_content_metadata_updated',

    /**
     * @public
     * @event OO.Analytics.EVENTS#STREAM_TYPE_UPDATED
     * @description This message is sent when the content stream type has been
     * determined by the player.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.StreamTypeMetadata
     */
    STREAM_TYPE_UPDATED: 'stream_type_updated',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_SEEK_REQUESTED
     * @description This message is sent when a video seek is requested.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoSeekRequestedData
     */
    VIDEO_SEEK_REQUESTED: 'video_seek_requested',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_SEEK_COMPLETED
     * @description This message is sent when a video seek has completed.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoSeekCompletedData
     */
    VIDEO_SEEK_COMPLETED: 'video_seek_completed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_STREAM_DOWNLOADING
     * @description This message is sent when a video stream is downloading data.
     * If the stream has to stop because of a buffer underrun, that is considered
     * a buffering event.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoDownloadingMetadata
     */
    VIDEO_STREAM_DOWNLOADING: 'video_stream_downloading',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_BUFFERING_STARTED
     * @description This message is sent when a video stream has to pause playback
     * to load more data. It is also sent when the stream is buffering before
     * initial playback is started.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoBufferingStartedData
     */
    VIDEO_BUFFERING_STARTED: 'video_buffering_started',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_BUFFERING_ENDED
     * @description This message is sent when a video stream has buffered and
     * is ready to resume playback.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoBufferingEndedData
     */
    VIDEO_BUFFERING_ENDED: 'video_buffering_ended',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_STREAM_BITRATE_PROFILES
     * @description This message is sent when all of the possible bitrate profiles for a stream are available.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoBitrateProfileLookupData
     */
    VIDEO_STREAM_BITRATE_PROFILES: 'video_stream_bitrate_profiles',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_STREAM_TARGET_BITRATE_REQUESTED
     * @description Sent when the a specific bitrate profile is requested. Automatic
     * bitrate selection is "auto".
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoTargetBitrateData
     */
    VIDEO_STREAM_TARGET_BITRATE_REQUESTED: 'video_stream_target_bitrate_requested',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_STREAM_BITRATE_CHANGED
     * @description This message is sent when the video stream's bitrate changes.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoBitrateProfileData
     */
    VIDEO_STREAM_BITRATE_CHANGED: 'video_stream_bitrate_changed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_STREAM_POSITION_CHANGED
     * @description This message is sent, periodically, when the video stream position changes.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoStreamPositionChangedData
     */
    VIDEO_STREAM_POSITION_CHANGED: 'video_stream_position_changed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VIDEO_ERROR
     * @description [DEPRECATED]
     * (NOTE: replaced by OO.Analytics.EVENTS.ERROR#VIDEO_PLAYBACK)
     * This message is sent when a video error occurs.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VideoErrorData
     */
    VIDEO_ERROR: 'video_error',

    /**
     * @public
     * @event OO.Analytics.EVENTS#WILL_PLAY_FROM_BEGINNING
     * @description This message is sent whenever player plays the video from the video start. 
     * Different from initial play as it can be a replay
     */
    WILL_PLAY_FROM_BEGINNING: "willPlayFromBeginning",

    /**
     * @public
     * @event OO.Analytics.EVENTS#INITIAL_PLAY_STARTING
     * @description This message is sent when the player has begun playback for the first time, first frame has been received.
     */
    INITIAL_PLAY_STARTING: 'initialPlayStarting',

    /**
     * @public
     * @event OO.Analytics.EVENTS#PLAYBACK_READY
     * @description This message is sent when the player has indicated that it is in a playback-ready state.
     */
    PLAYBACK_READY: 'playbackReady',

    /**
     * @public
     * @event OO.Analytics.EVENTS#API_ERROR
     * @description This message is sent if an api related error has occurred.
     */
    API_ERROR: 'apiError',

    /**
     * @public
     * @event OO.Analytics.EVENTS#BITRATE_INITIAL
     * @description This message contains the bitrate used at the start of playback.
     */
    BITRATE_INITIAL: 'bitrateInitial',

    /**
     * @public
     * @event OO.Analytics.EVENTS#BITRATE_FIVE_SEC
     * @description This message contains the bitrate used five seconds into playback.
     */
    BITRATE_FIVE_SEC: 'bitrateFiveSec',

    /**
     * @public
     * @event OO.Analytics.EVENTS#BITRATE_STABLE
     * @description This message contains the bitrate used thirty seconds into playback.
     */
    BITRATE_STABLE: 'bitrateStable',

    /**
     * @public
     * @event OO.Analytics.EVENTS#PLAYBACK_START_ERROR
     * @description This message is sent when a playback error has occurred before the video start.
     */
    PLAYBACK_START_ERROR: 'playbackStartError',

    /**
     * @public
     * @event OO.Analytics.EVENTS#PLAYBACK_MIDSTREAM_ERROR
     * @description This message is sent when a playback error has occurred midstream.
     */
    PLAYBACK_MIDSTREAM_ERROR: 'playbackMidstreamError',

    /**
     * @public
     * @event OO.Analytics.EVENTS#PLUGIN_LOADED
     * @description This message is sent when a plugin is loaded in core.
     */
    PLUGIN_LOADED: 'pluginLoaded',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VC_PLUGIN_ERROR
     * @description This message is sent when the video plugin has reported an error message.
     */
    VC_PLUGIN_ERROR: 'videoPluginError',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_SDK_LOADED
     * @description This message is sent when ad sdk has loaded successfully.
     */
    AD_SDK_LOADED: 'adSdkLoaded',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_SDK_LOAD_FAILURE
     * @description This message is sent when ad sdk has failed to load.
     */
    AD_SDK_LOAD_FAILURE: 'adSdkLoadFailed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_REQUEST
     * @description This message is sent when an ad request is sent to the ad sdk.
     */
    AD_REQUEST: 'adRequest',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_REQUEST_SUCCESS
     * @description This event is sent when an ad request successfully returns an ad or playlist of ads.
     */
    AD_REQUEST_SUCCESS: 'adRequestSuccess',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_REQUEST_ERROR
     * @description This event is sent when an ad request fails due to an error.
     */
    AD_REQUEST_ERROR: 'adRequestError',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_REQUEST_EMPTY
     * @description This event is sent when an ad request returns but contains no ads.
     */
    AD_REQUEST_EMPTY: 'adRequestEmpty',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_PLAYBACK_ERROR
     * @description This event is sent when an ad playback fails due to an error.
     */
    AD_PLAYBACK_ERROR: 'adPlaybackError',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_SDK_IMPRESSION
     * @description This message is sent when an impression is recorded 
     * by the ad plugin SDK.
     */
    AD_SDK_IMPRESSION: 'adSdkImpression',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_BREAK_STARTED
     * @description This message is sent when the player stops the main content
     * to start playing linear ads.
     */
    AD_BREAK_STARTED: 'ad_break_started',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_BREAK_ENDED
     * @description This message is sent when the player has finished playing ads
     * and is ready to playback the main video.
     */
    AD_BREAK_ENDED: 'ad_break_ended',

    /**
     * @event OO.Analytics.EVENTS#AD_POD_STARTED
     * @description This message is sent when an ad pod starts.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.AdPodStartedData
     */
    AD_POD_STARTED: 'ad_pod_started',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_POD_ENDED
     * @description This message is sent when an ad pod ends.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.AdPodEndedData
     */
    AD_POD_ENDED: 'ad_pod_ended',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_STARTED
     * @description This message is sent when the player starts an ad playback.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.AdStartedData
     */
    AD_STARTED: 'ad_started',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_ENDED
     * @description This message is sent when the player ends an ad playback.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.AdEndedData
     */
    AD_ENDED: 'ad_ended',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_SKIPPED
     * @description This message is sent when an ad is skipped.
     */
    AD_SKIPPED: 'ad_skipped',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_ERROR
     * @description This message is sent when there is an error during ad playback.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.AdErrorData
     */
    AD_ERROR: 'ad_error',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_CLICKED
     * @description This message is sent when the skin reports an ads clicked event.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.AdClickedData
     */
    AD_CLICKED: 'ad_clicked',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_IMPRESSION
     * @description This message is sent when the ad video element first plays.
     */
    AD_IMPRESSION: 'ad_impression',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_COMPLETED
     * @description This message is sent when the ad playback is completed.
     */
    AD_COMPLETED: 'adCompleted',

    /**
     * @public
     * @event OO.Analytics.EVENTS#AD_CLICKTHROUGH_OPENED
     * @description This message is sent when an ad clickthrough event has occurred.
     */
    AD_CLICKTHROUGH_OPENED: 'ad_clickthrough_opened',

    /**
     * @private
     * @event OO.Analytics.EVENTS#SDK_AD_EVENT
     * @description This message is sent when an SDK Ad Event has occurred.
     */
    SDK_AD_EVENT: 'sdkAdEvent',

    /**
     * @private
     * @event OO.Analytics.EVENTS#REPORT_DISCOVERY_CLICK
     * @description This message is sent when a discovery asset is clicked or autoplayed
     */
    REPORT_DISCOVERY_CLICK: 'reportDiscoveryClick',

    /**
     * @private
     * @event OO.Analytics.EVENTS#REPORT_DISCOVERY_IMPRESSION
     * @description This message is sent when an asset found by discovery is shown on the player.
     */
    REPORT_DISCOVERY_IMPRESSION: 'reportDiscoveryImpression',

    /**
     * @public
     * @event OO.Analytics.EVENTS#FULLSCREEN_CHANGED
     * @description This message is sent when the player enters and exits fullscreen.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.FullscreenChangedData
     */
    FULLSCREEN_CHANGED: 'fullscreen_changed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#SSAI_PLAY_SINGLE_AD
     * @description This message is sent when an SSAI ad starts playing.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.SsaiPlaySingleAd
     */
    SSAI_PLAY_SINGLE_AD: 'ssai_play_single_ad',

    /**
     * @public
     * @event OO.Analytics.EVENTS#SSAI_SINGLE_AD_PLAYED
     * @description This message is sent when the an SSAI ad has finished playing.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.SsaiSingleAdPlayed
     */
    SSAI_SINGLE_AD_PLAYED: 'ssai_single_ad_played',

    /**
     * @public
     * @event OO.Analytics.EVENTS#SSAI_AD_TIMELINE_RECEIVED
     * @description This message is sent when a timeline of SSAI ads for vod is received.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.SsaiAdTimelineReceived 
     */
    SSAI_AD_TIMELINE_RECEIVED: 'ssai_ad_timeline_received',

    /**
     * @public
     * @event OO.Analytics.EVENTS#VOLUME_CHANGED
     * @description This message is sent when the player volume has changed.
     * @param {Array} paramArray Array of length 1, contains an instance of
     * OO.Analytics.EVENT_DATA.VolumeChangedData
     */
    VOLUME_CHANGED: 'volume_changed',

    /**
     * @public
     * @event OO.Analytics.EVENTS#DESTROY
     * @description This message is sent when the player and its plugins are destroying.
     */
    DESTROY: 'destroy',

    /**
     * @public
     * @event OO.Analytics.EVENTS.ERROR
     * @description This property contains different the categories of Ooyala Player Errors.
     */
    ERROR: {
      /**
       * @public
       * @event OO.Analytics.EVENTS.ERROR#GENERAL
       * @description This message is sent when a general error occurs.
       * @param {Array} paramArray Array of length 1, contains an instance of
       * OO.Analytics.EVENT_DATA.GeneralErrorData
       */
      GENERAL: 'general_error',

      /**
       * @public
       * @event OO.Analytics.EVENTS.ERROR#METADATA_LOADING
       * @description This message is sent when a metadata loading error occurs
       * (invalid metadata, invalid content, or a network error when loading metadata).
       * @param {Array} paramArray Array of length 1, contains an instance of
       * OO.Analytics.EVENT_DATA.MetadataLoadingError
       */
      METADATA_LOADING: 'metadata_loading_error',

      /**
       * @public
       * @event OO.Analytics.EVENTS.ERROR#VIDEO_PLAYBACK
       * @description This message is sent when a video playback error occurs.
       * @param {Array} paramArray Array of length 1, contains an instance of
       * OO.Analytics.EVENT_DATA.VideoPlaybackErrorData
       */
      VIDEO_PLAYBACK: 'video_playback_error',

      /**
       * @public
       * @event OO.Analytics.EVENTS.ERROR#AUTHORIZATION
       * @description This message is sent when a stream authorization server (SAS) error occurs.
       * @param {Array} paramArray Array of length 1, contains an instance of
       * OO.Analytics.EVENT_DATA.AuthorizationErrorData
       */
      AUTHORIZATION: 'authorization_error'
    }
  };
  OO.Analytics.EVENTS = EVENTS;
}

if (!OO.Analytics.EVENT_DATA) {
  var EVENT_DATA = {};
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoElementData
   * @classdesc Contains the data passed along with VIDEO_ELEMENT_CREATED. This includes
   * the stream url of the video element.
   * @property {string} streamUrl This is the video element's stream URL
   */

  EVENT_DATA.VideoElementData = function (streamUrl) {
    var checkElementData = OO._.bind(checkDataType, this, "VideoElementData");

    this.streamUrl = checkElementData(streamUrl, "streamUrl", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoSourceData
   * @classdesc Contains the data passed along with VIDEO_SOURCE_CHANGED. This
   * includes the embed code (video id) and any metadata this video stream needs
   * pass along to other plugins (for example, it could contain ad tag data or analytics
   * account information).
   * @property  {string} embedCode This is the video stream's unique id
   * @property  {object} metadata   An object containing metadata about the video stream and player id to be used
   */


  EVENT_DATA.VideoSourceData = function (embedCode, metadata) {
    var checkSourceData = OO._.bind(checkDataType, this, "VideoSourceData");

    this.embedCode = checkSourceData(embedCode, "embedCode", ["string"]);
    this.metadata = checkSourceData(metadata, "metadata", ["object"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoContentMetadata
   * @classdesc Contains information about the content of the video stream,
   * such as title and description.
   * @property  {string} title Title of the video
   * @property  {string} description Video description
   * @property  {number} duration Duration of the video in milliseconds
   * @property  {object} closedCaptions Object containing information about the closed captions available
   * @property  {string} contentType A string indicating the type of content in the stream (ex. "video").
   * @property  {string} hostedAtURL The url the video is being hosted from
   */


  EVENT_DATA.VideoContentMetadata = function (title, description, duration, closedCaptions, contentType, hostedAtURL) {
    var checkContentData = OO._.bind(checkDataType, this, "VideoContentMetadata");

    this.title = checkContentData(title, "title", ["string"]);
    this.description = checkContentData(description, "description", ["string"]);
    this.duration = checkContentData(duration, "duration", ["number"]);
    this.closedCaptions = checkContentData(closedCaptions, "closedCaptions", ["object"]);
    this.contentType = checkContentData(contentType, "contentType", ["string"]);
    this.hostedAtURL = checkContentData(hostedAtURL, "hostedAtURL", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#StreamTypeMetadata
   * @classdesc Contains information about the content stream type
   * @property {string} streamType OO.Analytics.STREAM_TYPE of the stream.
   */


  EVENT_DATA.StreamTypeMetadata = function (streamType) {
    var checkStreamTypeData = OO._.bind(checkDataType, this, "StreamTypeMetadata");

    this.streamType = checkStreamTypeData(streamType, "streamType", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#GeoMetadata
   * @classdesc Contains information the user's geo location based on ip
   * @property {object} userGeoData The resolved geo data from the user's ip
   */


  EVENT_DATA.GeoMetadata = function (userGeoData) {
    var checkUserGeoData = OO._.bind(checkDataType, this, "GeoMetadata");

    if (userGeoData === undefined || userGeoData === null) {
      userGeoData = {};
    } //only populate the fields if they exist in the incoming userGeoData


    if (userGeoData.country) {
      this.country = checkUserGeoData(userGeoData.country, "country", ["string"]);
    }

    if (userGeoData.region) {
      this.region = checkUserGeoData(userGeoData.region, "region", ["string"]);
    }

    if (userGeoData.state) {
      this.state = checkUserGeoData(userGeoData.state, "state", ["string"]);
    }

    if (userGeoData.city) {
      this.city = checkUserGeoData(userGeoData.city, "city", ["string"]);
    }

    if (userGeoData.latitude) {
      this.latitude = checkUserGeoData(userGeoData.latitude, "latitude", ["number"]);
    }

    if (userGeoData.longitude) {
      this.longitude = checkUserGeoData(userGeoData.longitude, "longitude", ["number"]);
    }

    if (userGeoData.dma) {
      this.dma = checkUserGeoData(userGeoData.dma, "dma", ["string"]);
    }
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoDownloadingMetadata
   * @classdesc Contains information about the stream that is being downloaded.
   * @property {number} currentTime The current time of the player
   * @property {number} totalStreamDuration The duration of the video stream
   * @property {number} streamBufferedUntilTime The stream is buffered until this timestamp
   * @property {number} seekableRangeStart The earliest time the user can seek to
   * @property {number} seekableRangeEnd The latest time the user can seek to
   */


  EVENT_DATA.VideoDownloadingMetadata = function (currentTime, totalStreamDuration, streamBufferedUntilTime, seekableRangeStart, seekableRangeEnd) {
    var checkDownloadData = OO._.bind(checkDataType, this, "VideoDownloadingMetadata");

    this.currentTime = checkDownloadData(currentTime, "currentTime", ["number"]);
    this.totalStreamDuration = checkDownloadData(totalStreamDuration, "totalStreamDuration", ["number"]);
    this.streamBufferedUntilTime = checkDownloadData(streamBufferedUntilTime, "streamBufferedUntilTime", ["number"]);
    this.seekableRangeStart = checkDownloadData(seekableRangeStart, "seekableRangeStart", ["number"]);
    this.seekableRangeEnd = checkDownloadData(seekableRangeEnd, "seekableRangeEnd", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoBufferingStartedData
   * @classdesc Contains information about the stream that has started buffering.
   * @property {string} streamUrl The url of the stream that is buffering
   * @property {string} videoId The video Id (main, etc.)
   * @property {number} position The playhead position buffering started
   */


  EVENT_DATA.VideoBufferingStartedData = function (streamUrl, videoId, position) {
    var checkBufferingStartedData = OO._.bind(checkDataType, this, "VideoBufferingStartedData");

    this.streamUrl = checkBufferingStartedData(streamUrl, "streamUrl", ["string"]);
    this.videoId = checkBufferingStartedData(videoId, "videoId", ["string"]);
    this.position = checkBufferingStartedData(position, "position", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoBufferingEndedData
   * @classdesc Contains information about the stream that finished buffering.
   * @property {string} streamUrl The url of the stream that finished buffering
   */


  EVENT_DATA.VideoBufferingEndedData = function (streamUrl) {
    var checkBufferingEndedData = OO._.bind(checkDataType, this, "VideoBufferingEndedData");

    this.streamUrl = checkBufferingEndedData(streamUrl, "streamUrl", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoBitrateProfileLookupData
   * @classdesc Contains a lookup table for all the possible bitrates available. The
   * keys are the profile ids for each profile.
   * @property {object} profiles A lookup table containing instances of VideoBitrateProfileData. The key is the 'id' of each VideoBitrateProfileData.
   *
   * @constructor
   * @param {object} bitrateProfileArray An array of objects containing profile data
   * (bitrate, width, height, and id)
   */


  EVENT_DATA.VideoBitrateProfileLookupData = function (bitrateProfileArray) {
    var checkBitrateProfileList = OO._.bind(checkDataType, this, "VideoBitrateProfileLookupData");

    var list = checkBitrateProfileList(bitrateProfileArray, "bitrateProfileArray", ["array"]) || [];
    this.profiles = {};

    for (var i = 0; i < list.length; i++) {
      var entry = list[i];

      if (entry && entry.id) {
        this.profiles[entry.id] = entry;
      }
    }
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoBitrateProfileData
   * @classdesc Contains information about a bitrate profile.
   * @property {string} id The id of this profile
   * @property {number} bitrate The bitrate of this profile
   * @property {number} width The width of this profile
   * @property {number} height The height of this profile
   */


  EVENT_DATA.VideoBitrateProfileData = function (bitrateProfile) {
    var checkBitrateProfile = OO._.bind(checkDataType, this, "VideoBitrateProfileData");

    this.bitrate = checkBitrateProfile(bitrateProfile.bitrate, "bitrate", ["number", "string"]);
    this.height = checkBitrateProfile(bitrateProfile.height, "height", ["number"]);
    this.width = checkBitrateProfile(bitrateProfile.width, "width", ["number"]);
    this.id = checkBitrateProfile(bitrateProfile.id, "id", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoTargetBitrateData
   * @classdesc Contains information what bitrate profile is being requested.
   * @property {string} targetProfile The id of the bitrate profile being requested.
   */


  EVENT_DATA.VideoTargetBitrateData = function (targetProfile) {
    var checkTargetBitrate = OO._.bind(checkDataType, this, "VideoTargetBitrateData");

    this.targetProfile = checkTargetBitrate(targetProfile, "targetProfile", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoSeekRequestedData
   * @classdesc Contains information about seeking to a particular time in the stream.
   * @property {number} seekingToTime The time requested to be seeked to
   */


  EVENT_DATA.VideoSeekRequestedData = function (seekingToTime) {
    var checkSeekStartedData = OO._.bind(checkDataType, this, "VideoSeekRequestedData");

    this.seekingToTime = checkSeekStartedData(seekingToTime, "seekingToTime", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoSeekCompletedData
   * @classdesc Contains information about the result of seeking to a particular
   * time in the stream.
   * @property {number} timeSeekedTo The time that was actually seeked to
   */


  EVENT_DATA.VideoSeekCompletedData = function (timeSeekedTo) {
    var checkSeekEndedData = OO._.bind(checkDataType, this, "VideoSeekCompletedData");

    this.timeSeekedTo = checkSeekEndedData(timeSeekedTo, "timeSeekedTo", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoStreamPositionChangedData
   * @classdesc Contains information about the current stream position and the length of the stream.
   * @property {number} streamPosition The current stream position
   * @property {number} totalStreamDuration The total length/duration of the stream
   * @property {string} videoId Id used to differentiate between various streams (such as ad vs content playback).
   *                            Possible values are defined in OO.VIDEO.
   */


  EVENT_DATA.VideoStreamPositionChangedData = function (streamPosition, totalStreamDuration, videoId, currentLiveTime) {
    var checkVideoStreamPositionChangedData = OO._.bind(checkDataType, this, "VideoStreamPositionChangedData");

    this.streamPosition = checkVideoStreamPositionChangedData(streamPosition, "streamPosition", ["number"]);
    this.totalStreamDuration = checkVideoStreamPositionChangedData(totalStreamDuration, "totalStreamDuration", ["number"]);
    this.videoId = checkVideoStreamPositionChangedData(videoId, "videoId", ["string"]);
    this.currentLiveTime = checkVideoStreamPositionChangedData(currentLiveTime, "currentLiveTime", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoErrorData
   * @classdesc [DEPRECATED]
   * (NOTE: replaced by Analytics.EVENT_DATA.VideoPlaybackErrorData)
   * Contains information about the error code and message of the video error.
   * @property {string} errorCode The error code
   * @property {string} errorMessage The error message
   *
   * @constructor
   * @param {string} errorCode The error code
   */


  EVENT_DATA.VideoErrorData = function (errorCode) {
    var checkVideoErrorData = OO._.bind(checkDataType, this, "VideoErrorData");

    this.errorCode = checkVideoErrorData(errorCode, "errorCode", ["string"]);
    this.errorMessage = translateErrorCode(errorCode);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#GeneralErrorData
   * @classdesc Contains information about the error code and message of a general error.
   * @property {string} errorCode The error code
   * @property {string} errorMessage The error message
   */


  EVENT_DATA.GeneralErrorData = function (errorCode, errorMessage) {
    var checkGeneralErrorData = OO._.bind(checkDataType, this, "GeneralErrorData");

    this.errorCode = checkGeneralErrorData(errorCode, "errorCode", ["string"]);
    this.errorMessage = checkGeneralErrorData(errorMessage, "errorMessage", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#MetadataLoadingErrorData
   * @classdesc Contains information about the error code and message of a metadata loading
   * error.
   * @property {string} errorCode The error code
   * @property {string} errorMessage The error message
   */


  EVENT_DATA.MetadataLoadingErrorData = function (errorCode, errorMessage) {
    var checkMetadataLoadingErrorData = OO._.bind(checkDataType, this, "MetadataLoadingErrorData");

    this.errorCode = checkMetadataLoadingErrorData(errorCode, "errorCode", ["string"]);
    this.errorMessage = checkMetadataLoadingErrorData(errorMessage, "errorMessage", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoPlaybackErrorData
   * @classdesc Contains information about the error code and message of the video error.
   * @property {string} errorCode The error code
   * @property {string} errorMessage The error message
   */


  EVENT_DATA.VideoPlaybackErrorData = function (errorCode, errorMessage) {
    var checkVideoPlaybackErrorData = OO._.bind(checkDataType, this, "VideoPlaybackErrorData");

    this.errorCode = checkVideoPlaybackErrorData(errorCode, "errorCode", ["string"]);
    this.errorMessage = checkVideoPlaybackErrorData(errorMessage, "errorMessage", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AuthorizationErrorData
   * @classdesc Contains information about the error code and message of the authorization error.
   * @property {string} errorCode The error code
   * @property {string} errorMessage The error message
   */


  EVENT_DATA.AuthorizationErrorData = function (errorCode, errorMessage) {
    var checkAuthorizationErrorData = OO._.bind(checkDataType, this, "AuthorizationErrorData");

    this.errorCode = checkAuthorizationErrorData(errorCode, "errorCode", ["string"]);
    this.errorMessage = checkAuthorizationErrorData(errorMessage, "errorMessage", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdPodStartedData
   * @classdesc Contain information about how many ads are in the ad pod.
   * @property {number} numberOfAds The number of ads in the pod
   */


  EVENT_DATA.AdPodStartedData = function (numberOfAds) {
    var checkAdPodStartedData = OO._.bind(checkDataType, this, "AdPodStartedData");

    this.numberOfAds = checkAdPodStartedData(numberOfAds, "numberOfAds", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdPodEndedData
   * @classdesc Contain information about the adId of the ad pod.
   * @property {string} adId The id of the ad pod
   */


  EVENT_DATA.AdPodEndedData = function (adId) {
    var checkAdPodEndedData = OO._.bind(checkDataType, this, "AdPodEndedData");

    this.adId = checkAdPodEndedData(adId, "adId", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdStartedData
   * @classdesc Contains information about the type of ad that has started and its ad data.
   * @property {string} adType The type of ad (linear video, linear overlay, nonlinear overlay)
   * @property {object} adMetadata The metadata associated with the ad(i.e. EVENT_DATA.LinearVideoData or EVENT_DATA.NonLinearOverlayData)
   */


  EVENT_DATA.AdStartedData = function (adType, adMetadataIn) {
    var checkAdStartedData = OO._.bind(checkDataType, this, "AdStartedData");

    this.adType = checkAdStartedData(adType, "adType", ["string"]);
    this.adMetadata = selectAdType(adType, adMetadataIn);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#LinearVideoData
   * @classdesc Contains information about the linear video ad data.
   * @property {string} adId The id of the ad
   * @property {number} adDuration The duration of the ad video stream
   * @property {number} adPodPosition The index of the current ad in its ad pod
   */


  EVENT_DATA.LinearVideoData = function (adId, adDuration, adPodPosition) {
    var checkLinearVideoData = OO._.bind(checkDataType, this, "LinearVideoData");

    this.adId = checkLinearVideoData(adId, "adId", ["string"]);
    this.adDuration = checkLinearVideoData(adDuration, "adDuration", ["number"]);
    this.adPodPosition = checkLinearVideoData(adPodPosition, "adPodPosition", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#NonLinearOverlayData
   * @classdesc Contains information about the non linear overlay ad data.
   * @property {string} adId The id of the ad
   */


  EVENT_DATA.NonLinearOverlayData = function (adId) {
    var checkNonLinearOverlayData = OO._.bind(checkDataType, this, "NonLinearOverlayData");

    this.adId = checkNonLinearOverlayData(adId, "adId", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdEndedData
   * @classdesc Contains information about the type of ad that has ended and its ad data.
   * @property {string} adType The type of ad (linear video, linear overlay, nonlinear overlay)
   * @property {string} adId The id of the ad
   */


  EVENT_DATA.AdEndedData = function (adType, adId) {
    var checkAdEndedData = OO._.bind(checkDataType, this, "AdEndedData");

    this.adType = checkAdEndedData(adType, "adType", ["string"]);
    this.adId = checkAdEndedData(adId, "adId", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdErrorData
   * @classdesc Contains information about the ad error.
   * @property {object|string} The error object or string
   */


  EVENT_DATA.AdErrorData = function (error) {
    var checkAdErrorData = OO._.bind(checkDataType, this, "AdErrorData");

    this.error = checkAdErrorData(error, "error", ["string", "object"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdClickedData
   * @classdesc Contains information about the ad clicked event.
   * @property {object} The metadata sent with the event
   */


  EVENT_DATA.AdClickedData = function (metadata) {
    var checkAdClickedData = OO._.bind(checkDataType, this, "AdClickedData");

    this.metadata = checkAdClickedData(metadata, "metadata", ["object"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VideoPlayerCreatedData
   * @classdesc Contains information about the player created event
   * @property {string} playerCoreVersion The player core version
   * @property {object} params The configuration metadata associated with the player
   * (i.e. pcode, playerBrandingId, skin configuration, player configuration parameters)
   * @property {string} embedCode The embed code of the asset attempting to play
   * @property {string} playerUrl The url of the page containing the player
   * @property {string} pcode The provider pcode
   */


  EVENT_DATA.VideoPlayerCreatedData = function (playerCoreVersion, params, embedCode, playerUrl) {
    var checkVideoPlayerCreatedData = OO._.bind(checkDataType, this, "VideoPlayerCreatedData");

    this.playerCoreVersion = checkVideoPlayerCreatedData(playerCoreVersion, "playerCoreVersion", ["string"]);
    this.params = checkVideoPlayerCreatedData(params, "params", ["object"]);
    this.embedCode = checkVideoPlayerCreatedData(embedCode, "embedCode", ["string"]);
    this.playerUrl = checkVideoPlayerCreatedData(playerUrl, "playerUrl", ["string"]);
    this.pcode = checkVideoPlayerCreatedData(this.params.pcode, "pcode", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#InitialPlayStartingData
   * @classdesc Contains the information about the initial play starting event.
   * @property {string} playerCoreVersion The player core version
   * @property {number} timeSinceInitialPlay The time since the initial play request was made
   * @property {boolean} autoplayed Boolean for if the video was autoplayed or not
   * @property {boolean} hadPreroll Boolean for if the video had an ad play before it started
   * @property {number} position The initial position of the playhead upon playback start. This includes 
   *   midrolls that play before content due to an initial playhead time > 0
   * @property {string} plugin The video plugin used for playback
   * @property {string} technology The browser technology used - HTML5, Flash, Mixed, or Other
   * @property {string} encoding The stream encoding type, i.e. MP4, HLS, Dash, etc.
   * @property {string} streamUrl The URL of the content being played
   * @property {string} drm The DRM being used, none if there is no DRM
   * @property {boolean} isLive Boolean that is true if a live stream is playing. If false it is VOD.
   */


  EVENT_DATA.InitialPlayStartingData = function (playerCoreVersion, timeSinceInitialPlay, autoplayed, hadPreroll, position, plugin, technology, encoding, streamUrl, drm, isLive) {
    var checkInitialPlayStartingData = OO._.bind(checkDataType, this, "VideoPlayerCreatedData");

    this.playerCoreVersion = checkInitialPlayStartingData(playerCoreVersion, "playerCoreVersion", ["string"]);
    this.timeSinceInitialPlay = checkInitialPlayStartingData(timeSinceInitialPlay, "timeSinceInitialPlay", ["number"]);
    this.autoplayed = checkInitialPlayStartingData(autoplayed, "autoplayed", ["boolean"]);
    this.hadPreroll = checkInitialPlayStartingData(hadPreroll, "hadPreroll", ["boolean"]);
    this.position = checkInitialPlayStartingData(position, "position", ["number"]);
    this.plugin = checkInitialPlayStartingData(plugin, "plugin", ["string"]);
    this.technology = checkInitialPlayStartingData(technology, "technology", ["string"]);
    this.encoding = checkInitialPlayStartingData(encoding, "encoding", ["string"]);
    this.streamUrl = checkInitialPlayStartingData(streamUrl, "streamUrl", ["string"]);
    this.drm = checkInitialPlayStartingData(drm, "drm", ["string"]);
    this.isLive = checkInitialPlayStartingData(isLive, "isLive", ["boolean"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#PlaybackReadyData
   * @classdesc Contains the information about the playback ready event
   * @property {string} playerCoreVersion The player core version
   * @property {number} timeSincePlayerCreated The time between player creation and playback ready state
   * @property {array} pluginList List of plugins loaded
   */


  EVENT_DATA.PlaybackReadyData = function (playerCoreVersion, timeSincePlayerCreated, pluginList) {
    var checkPlaybackReadyData = OO._.bind(checkDataType, this, "PlaybackReadyData");

    this.playerCoreVersion = checkPlaybackReadyData(playerCoreVersion, "playerCoreVersion", ["string"]);
    this.timeSincePlayerCreated = checkPlaybackReadyData(timeSincePlayerCreated, "timeSincePlayerCreated", ["number"]);
    this.pluginList = checkPlaybackReadyData(pluginList, "pluginList", ["array"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#ApiErrorData
   * @classdesc Contains information about the api error.
   * @property {string} playerCoreVersion The player core version
   * @property {number} errorCode The error code if any
   * @property {string} errorMessage The error message
   * @property {string} url The ad tag url post macro substitution
   */


  EVENT_DATA.ApiErrorData = function (playerCoreVersion, errorCode, errorMessage, url) {
    var checkApiErrorData = OO._.bind(checkDataType, this, "ApiErrorData");

    this.playerCoreVersion = checkApiErrorData(playerCoreVersion, "playerCoreVersion", ["string"]);
    this.errorCode = checkApiErrorData(errorCode, "errorCode", ["number"]);
    this.errorMessage = checkApiErrorData(errorMessage, "errorMessage", ["string"]);
    this.url = checkApiErrorData(url, "url", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#BitrateInitialData
   * @classdesc Contains the information about the bitrate initial event
   * @property {number} The bitrate at the start of playback
   */


  EVENT_DATA.BitrateInitialData = function (bitrate) {
    var checkBitrateInitialData = OO._.bind(checkDataType, this, "BitrateInitialData");

    this.bitrate = checkBitrateInitialData(bitrate, "bitrate", ["number"]);
  };
  /**
  * @public
  * @class Analytics.EVENT_DATA#BitrateFiveSecData
  * @classdesc  Contains the information about the bitrate five sec event
  * @property {number} The bitrate at five seconds into the video
  */


  EVENT_DATA.BitrateFiveSecData = function (bitrate) {
    var checkBitrateFiveSecData = OO._.bind(checkDataType, this, "BitrateFiveSecData");

    this.bitrate = checkBitrateFiveSecData(bitrate, "bitrate", ["number"]);
  };
  /**
  * @public
  * @class Analytics.EVENT_DATA#BitrateStableData
  * @classdesc  Contains the information about the bitrate stable event
  * @property {number} The bitrate at thirty seconds into the video
  */


  EVENT_DATA.BitrateStableData = function (bitrate) {
    var checkBitrateStableData = OO._.bind(checkDataType, this, "BitrateStableData");

    this.bitrate = checkBitrateStableData(bitrate, "bitrate", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#PlaybackStartErrorData
   * @classdesc Contains information about the playback start error.
   * @property {object} errorCodes Object containing all error codes associated with the error
   * @property {object} errorMessages Object containing error messages associated with the error
   * @property {object} drm The DRM information, if relevant and available
   */


  EVENT_DATA.PlaybackStartErrorData = function (errorCodes, errorMessages, drm) {
    var checkPlaybackStartErrorData = OO._.bind(checkDataType, this, "PlaybackStartErrorData");

    this.errorCodes = checkPlaybackStartErrorData(errorCodes, "errorCodes", ["object"]);
    this.errorMessages = checkPlaybackStartErrorData(errorMessages, "errorMessages", ["object"]);
    this.drm = checkPlaybackStartErrorData(drm, "drm", ["object"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#PlaybackMidstreamErrorData
   * @classdesc Contains information about the playback midstream error.
   * @property {object} errorCodes Object containing all error codes associated with the error
   * @property {object} errorMessages Object containing error messages associated with the error
   * @property {number} position The playhead position the error occurred at
   */


  EVENT_DATA.PlaybackMidstreamErrorData = function (errorCodes, errorMessages, position) {
    var checkPlaybackMidstreamErrorData = OO._.bind(checkDataType, this, "PlaybackMidstreamErrorData");

    this.errorCodes = checkPlaybackMidstreamErrorData(errorCodes, "errorCodes", ["object"]);
    this.errorMessages = checkPlaybackMidstreamErrorData(errorMessages, "errorMessages", ["object"]);
    this.position = checkPlaybackMidstreamErrorData(position, "position", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#PluginLoadedData
   * @classdesc Contains information about the plugin loaded event.
   * @property {string} playerCoreVersion The player core version
   * @property {string} pluginType Type of the loaded plugin - ads, playback, analytics, playlist, or skin
   * @property {string} pluginName The name of the plugin loaded
   * @property {number} loadTime The time it took for the plugin to reach the ready state
   */


  EVENT_DATA.PluginLoadedData = function (playerCoreVersion, pluginType, pluginName, loadTime) {
    var checkPluginLoadedData = OO._.bind(checkDataType, this, "PluginLoadedData");

    this.playerCoreVersion = checkPluginLoadedData(playerCoreVersion, "playerCoreVersion", ["string"]);
    this.pluginType = checkPluginLoadedData(pluginType, "pluginType", ["string"]);
    this.pluginName = checkPluginLoadedData(pluginName, "pluginName", ["string"]);
    this.loadTime = checkPluginLoadedData(loadTime, "loadTime", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdErrorData
   * @classdesc Contains information about the ad error.
   * @property {object|string} The error object or string
   */


  EVENT_DATA.AdErrorData = function (error) {
    var checkAdErrorData = OO._.bind(checkDataType, this, "AdErrorData");

    this.error = checkAdErrorData(error, "error", ["string", "object"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdRequestData
   * @classdesc Contains information about the ad request event. 
   * @property {string} adPluginName The name of the ad plugin used
   * @property {number} adPosition The position, in seconds, the ad is scheduled to play
   */


  EVENT_DATA.AdRequestData = function (adPluginName, adPosition) {
    var checkAdRequestData = OO._.bind(checkDataType, this, "AdRequestData");

    this.adPluginName = checkAdRequestData(adPluginName, "adPluginName", ["string"]);
    this.adPosition = checkAdRequestData(adPosition, "adPosition", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdRequestSuccssData
   * @classdesc Contains information about the ad request success event. 
   * @property {string} adPluginName The name of the ad plugin used
   * @property {number} adPosition The position, in seconds, the ad is scheduled to play
   * @property {number} responseTime The time in milliseconds that it took to get a response for the ad request
   * @property {number} timeSinceInitialPlay The time in milliseconds from the initial play request time to ad request success
   */


  EVENT_DATA.AdRequestSuccessData = function (adPluginName, adPosition, responseTime, timeSinceInitialPlay) {
    var checkAdRequestSuccessData = OO._.bind(checkDataType, this, "AdRequestSuccessData");

    this.adPluginName = checkAdRequestSuccessData(adPluginName, "adPluginName", ["string"]);
    this.adPosition = checkAdRequestSuccessData(adPosition, "adPosition", ["number"]);
    this.responseTime = checkAdRequestSuccessData(responseTime, "responseTime", ["number"]);
    this.timeSinceInitialPlay = checkAdRequestSuccessData(timeSinceInitialPlay, "timeSinceInitialPlay", ["number"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdRequestEmptyData
   * @classdesc Contains information about the ad request empty event. 
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {number} adPosition The position, in seconds, the ad is scheduled to play
   * @property {string} adTagUrl The ad tag url post macro substitution
   * @property {object} errorCodes Object containing all error codes received
   * @property {string} errorMessage The error message
   */


  EVENT_DATA.AdRequestEmptyData = function (adPluginName, adPosition, adTagUrl, errorCodes, errorMessage) {
    var checkAdRequestEmptyData = OO._.bind(checkDataType, this, "AdRequestEmptyData");

    this.adPluginName = checkAdRequestEmptyData(adPluginName, "adPluginName", ["string"]);
    this.adPosition = checkAdRequestEmptyData(adPosition, "adPosition", ["number"]);
    this.adTagUrl = checkAdRequestEmptyData(adTagUrl, "adTagUrl", ["string"]);
    this.errorCodes = checkAdRequestEmptyData(errorCodes, "errorCodes", ["object"]);
    this.errorMessage = checkAdRequestEmptyData(errorMessage, "errorMessage", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdRequestErrorData
   * @classdesc Contains information about the ad request error event. 
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {number} adPosition The position, in seconds, the ad is scheduled to play
   * @property {string} adTagUrl The ad tag url post macro substitution
   * @property {object} errorCodes Object containing all error codes received
   * @property {string} errorMessage The error message
   * @property {boolean} isTimeout If ad request timed out or not
   */


  EVENT_DATA.AdRequestErrorData = function (adPluginName, adPosition, adTagUrl, errorCodes, errorMessage, isTimeout) {
    var checkAdRequestErrorData = OO._.bind(checkDataType, this, "AdRequestErrorData");

    this.adPluginName = checkAdRequestErrorData(adPluginName, "adPluginName", ["string"]);
    this.adPosition = checkAdRequestErrorData(adPosition, "adPosition", ["number"]);
    this.adTagUrl = checkAdRequestErrorData(adTagUrl, "adTagUrl", ["string"]);
    this.errorCodes = checkAdRequestErrorData(errorCodes, "errorCodes", ["object"]);
    this.errorMessage = checkAdRequestErrorData(errorMessage, "errorMessage", ["string"]);
    this.isTimeout = checkAdRequestErrorData(isTimeout, "isTimeout", ["boolean"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdPlaybackErrorData
   * @classdesc Contains information about the ad playback error event. 
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {number} adPosition The position, in seconds, the ad is scheduled to play
   * @property {string} adTagUrl The ad tag url post macro substitution
   * @property {object} errorCodes Object containing all error codes received
   * @property {string} errorMessage The error message
   * @property {array} videoPluginList Array containing names of all video plugins registered
   * @property {string} mediaFileUrl The url used to retrieve the ad media file
   */


  EVENT_DATA.AdPlaybackErrorData = function (adPluginName, adPosition, adTagUrl, errorCodes, errorMessage, videoPluginList, mediaFileUrl) {
    var checkAdPlaybackErrorData = OO._.bind(checkDataType, this, "AdPlaybackErrorData");

    this.adPluginName = checkAdPlaybackErrorData(adPluginName, "adPluginName", ["string"]);
    this.adPosition = checkAdPlaybackErrorData(adPosition, "adPosition", ["number"]);
    this.adTagUrl = checkAdPlaybackErrorData(adTagUrl, "adTagUrl", ["string"]);
    this.errorCodes = checkAdPlaybackErrorData(errorCodes, "errorCodes", ["object"]);
    this.errorMessage = checkAdPlaybackErrorData(errorMessage, "errorMessage", ["string"]);
    this.videoPluginList = checkAdPlaybackErrorData(videoPluginList, "videoPluginList", ["array"]);
    this.mediaFileUrl = checkAdPlaybackErrorData(mediaFileUrl, "mediaFileUrl", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdSdkImpressionData
   * @classdesc Contains information about the ad sdk impression event. 
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {number} adPosition The position, in seconds, the ad is scheduled to play
   * @property {number} adLoadTime The time in milliseconds between the ad request success and started
   * @property {string} adProtocol The ad protocol (VAST / VPAID)
   * @property {string} adType The ad type (LinearOverlay, LinearVideo, NonLinearOverlay, NonLinearVideo)
   */


  EVENT_DATA.AdSdkImpressionData = function (adPluginName, adPosition, adLoadTime, adProtocol, adType) {
    var checkAdSdkImpressionData = OO._.bind(checkDataType, this, "AdSdkImpressionData");

    this.adPluginName = checkAdSdkImpressionData(adPluginName, "adPluginName", ["string"]);
    this.adPosition = checkAdSdkImpressionData(adPosition, "adPosition", ["number"]);
    this.adLoadTime = checkAdSdkImpressionData(adLoadTime, "adLoadTime", ["number"]);
    this.adProtocol = checkAdSdkImpressionData(adProtocol, "adProtocol", ["string"]);
    this.adType = checkAdSdkImpressionData(adType, "adType", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdCompletedData
   * @classdesc Contains information about the ad completed event. 
   * @property {string} adPluginName The name of the ad plugin used
   * @property {number} timeSinceImpression The time passed since the ad impression 
   *                                          was recorded in milliseconds
   * @property {boolean} skipped True if ad was skipped by user.
   * @property {string} adTagUrl The ad tag url post macro substitution
   */


  EVENT_DATA.AdCompletedData = function (adPluginName, timeSinceImpression, skipped, adTagUrl) {
    var checkAdCompletedData = OO._.bind(checkDataType, this, "AdCompletedData");

    this.adPluginName = checkAdCompletedData(adPluginName, "adPluginName", ["string"]);
    this.timeSinceImpression = checkAdCompletedData(timeSinceImpression, "timeSinceImpression", ["number"]);
    this.skipped = checkAdCompletedData(skipped, "skipped", ["boolean"]);
    this.adTagUrl = checkAdCompletedData(adTagUrl, "adTagUrl", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdSdkLoadedData
   * @classdesc Contains information about the ad SDK loaded event. 
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {string} playerCoreVersion The player core version
   */


  EVENT_DATA.LoadAdSdkData = function (adPluginName, playerCoreVersion) {
    var checkLoadAdSdkData = OO._.bind(checkDataType, this, "LoadAdSdkData");

    this.adPluginName = checkLoadAdSdkData(adPluginName, "adPluginName", ["string"]);
    this.playerCoreVersion = checkLoadAdSdkData(playerCoreVersion, "playerCoreVersion", ["string"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#AdSdkLoadFailureData
   * @classdesc Contains information about the ad SDK load failure event. 
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {string} playerCoreVersion The player core version
   * @property {string} errorMessage The error message associated with the ad sdk load failure
   */


  EVENT_DATA.LoadAdSdkFailureData = function (adPluginName, playerCoreVersion, errorMessage) {
    var checkLoadAdSdkFailureData = OO._.bind(checkDataType, this, "LoadAdSdkFailureData");

    this.adPluginName = checkLoadAdSdkFailureData(adPluginName, "adPluginName", ["string"]);
    this.playerCoreVersion = checkLoadAdSdkFailureData(playerCoreVersion, "playerCoreVersion", ["string"]);
    this.errorMessage = checkLoadAdSdkFailureData(errorMessage, "errorMessage", ["string"]);
  };
  /**
   * @private
   * @class Analytics.EVENT_DATA#ReportDiscoveryImpressionEventData
   * @classdesc Contains information about report discovery impression event. This has been marked private because
   * we do not want to expose this as a public event.
   * @property {object} metadata An object containing details of the ad event. This may vary
   *                               between ad plugin to ad plugin.
   */


  EVENT_DATA.ReportDiscoveryImpressionEventData = function (metadata) {
    var checkReportDiscoveryImpressionEventData = OO._.bind(checkDataType, this, "ReportDiscoveryImpressionEventData");

    this.metadata = checkReportDiscoveryImpressionEventData(metadata, "metadata", ["object"]);
  };
  /**
   * @private
   * @class Analytics.EVENT_DATA#ReportDiscoveryClickEventData
   * @classdesc Contains information about report discovery click event. This has been marked private because
   * we do not want to expose this as a public event.
   * @property {object} metadata An object containing details of the ad event. This may vary
   *                               between ad plugin to ad plugin.
   */


  EVENT_DATA.ReportDiscoveryClickEventData = function (metadata) {
    var checkReportDiscoveryClickEventData = OO._.bind(checkDataType, this, "ReportDiscoveryClickEventData");

    this.metadata = checkReportDiscoveryClickEventData(metadata, "metadata", ["object"]);
  };
  /**
   * @private
   * @class Analytics.EVENT_DATA#SdkAdEventData
   * @classdesc Contains information about SDK Ad Event. This has been marked private because
   * we do not want to expose this as a public event.
   * @property {string} adPluginName The name of the ad plugin that sent this event
   * @property {string} adEventName The name of this event from the ad plugin
   * @property {object} adEventData An object containing details of the ad event. This may vary
   *                               between ad plugin to ad plugin.
   */


  EVENT_DATA.SdkAdEventData = function (adPluginName, adEventName, adEventData) {
    var checkSdkAdEventData = OO._.bind(checkDataType, this, "SdkAdEventData");

    this.adPluginName = checkSdkAdEventData(adPluginName, "adPluginName", ["string"]);
    this.adEventName = checkSdkAdEventData(adEventName, "adEventName", ["string"]);
    this.adEventData = checkSdkAdEventData(adEventData, "adEventData", ["object"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#FullscreenChangedData
   * @classdesc Contains information about whether the player is entering or exiting fullscreen.
   * @property {boolean} changingToFullscreen Whether or not the player is entering fullscreen.
   * true represents that the player is entering fullscreen. false represents that the player is
   * exiting fullscreen.
   */


  EVENT_DATA.FullscreenChangedData = function (changingToFullscreen) {
    var checkFullscreenChangedData = OO._.bind(checkDataType, this, "FullscreenChangedData");

    this.changingToFullscreen = checkFullscreenChangedData(changingToFullscreen, "changingToFullscreen", ["boolean"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#SsaiPlaySingleAdData
   * @param {object} ad Object containing the ssai ad data
   */


  EVENT_DATA.SsaiPlaySingleAdData = function (ad) {
    var checkSsaiPlaySingleAdData = OO._.bind(checkDataType, this, "SsaiPlaySingleAdData");

    this.ad = checkSsaiPlaySingleAdData(ad, "ad", ["object"]);
  };
  /**
    * @public
    * @class Analytics.EVENT_DATA#SsaiAdTimelineReceivedData
    * @param {array} timeline Array of ssai ad objects. Ordered by ad start time
    */


  EVENT_DATA.SsaiAdTimelineReceivedData = function (timeline) {
    var checkSsaiAdTimelineReceivedData = OO._.bind(checkDataType, this, "SsaiAdTimelineReceivedData");

    this.timeline = checkSsaiAdTimelineReceivedData(timeline, "timeline", ["array"]);
  };
  /**
   * @public
   * @class Analytics.EVENT_DATA#VolumeChangedData
   * @classdesc Contains information about the value of the current volume.
   * @property {number} volume  The current volume after the change; the volume is a value from 0 - 1, with 0
   * representing a muted state and 1 representing the maximum volume.
   */


  EVENT_DATA.VolumeChangedData = function (currentVolume) {
    var checkVolumeChangedData = OO._.bind(checkDataType, this, "VolumeChangedData");

    this.currentVolume = checkVolumeChangedData(currentVolume, "currentVolume", ["number"]);
  };

  var checkDataType = function (className, data, varName, expectedTypes) {
    var error = true;
    var toRet = data;

    for (var i = 0; i < expectedTypes.length; i++) {
      var expectedType = expectedTypes[i];

      if (expectedType === "string") {
        if (OO._.isString(toRet)) {
          error = false;
          break;
        }
      } else if (expectedType === "object") {
        if (toRet && OO._.isObject(toRet)) {
          error = false;
          break;
        }
      } else if (expectedType === "array") {
        if (toRet && OO._.isArray(toRet)) {
          error = false;
        }
      } else if (expectedType === "number") {
        // in the case number comes in as a string, try parsing it.
        var toRetFloat = parseFloat(toRet);

        if (OO._.isNumber(toRet)) {
          error = false;
          break;
        } else if (!isNaN(toRetFloat)) {
          toRet = toRetFloat;
          error = false;
          break;
        }
      } else if (expectedType === "boolean") {
        if (OO._.isBoolean(toRet)) {
          error = false;
        } else if (toRet === "true") {
          toRet = true;
          error = false;
          break;
        } else if (toRet === "false") {
          toRet = false;
          error = false;
          break;
        }
      }
    }

    if (error) {
      logErrorString("Analytics.EVENT_DATA." + className + " being created with invalid " + varName + ". Should be one of these types [" + expectedTypes + "] but was [" + typeof data + "].");
      return undefined;
    }

    return toRet;
  };
  /**
   * @private
   * @class Analytics#selectAdType
   * @classdesc Checks for a recognized Ad Type and returns the corresponding EVENT_DATA object.
   * @property {string} adType The type of ad (linear video, linear overlay, nonlinear overlay)
   * @property {object} adMetadata The metadata associated with the ad
   * @returns {object} The EVENT_DATA object that associates with the Ad Type.
   */


  var selectAdType = function (adType, adMetadataIn) {
    var adMetadataOut;

    switch (adType) {
      case OO.Analytics.AD_TYPE.LINEAR_VIDEO:
        adMetadataOut = new EVENT_DATA.LinearVideoData(adMetadataIn.name, adMetadataIn.duration, adMetadataIn.indexInPod);
        break;

      case OO.Analytics.AD_TYPE.NONLINEAR_OVERLAY:
        adMetadataOut = new EVENT_DATA.NonLinearOverlayData(adMetadataIn.id);
        break;

      default:
        logErrorString("Ad Type not recognized. Should be one of these values [" + OO._.values(OO.Analytics.AD_TYPE) + "] but was [" + adType + "].");
        break;
    }

    return adMetadataOut;
  };
  /**
   * @private
   * @class Analytics#translateErrorCode
   * @classdesc Translates the error code provided into the corresponding error message.
   * @property {number} code The error code
   * @returns {string} The error string associated with the error code number.
   */


  var translateErrorCode = function (code) {
    var errorMessage;

    if (_.has(ERROR_CODE, code)) {
      errorMessage = ERROR_CODE[code];
    } else {
      logErrorString("Error code not recognized. Error code provided was: " + code);
    }

    return errorMessage;
  };
  /**
   * @private
   * @class Analytics#logErrorString
   * @classdesc Helper function to return an error string with the Analytics Constants prefix.
   * @property {string} origStr the error string
   * @returns {string} The new error string.
   */


  var logErrorString = function (origStr) {
    OO.log("Error AnalyticsConstants: " + origStr);
  };

  OO.Analytics.EVENT_DATA = EVENT_DATA;
}

if (!OO.Analytics.REQUIRED_PLUGIN_FUNCTIONS) {
  /**
   * @public
   * @constant
   * @type string[]
   * @description This is a list of the required functions for a plugin to
   * be considered valid by the Analytics Framework.
   * <ul>
   *    <li>getName() - Returns a non-empty string containing the name of the plugin.</li>
   *    <li>getVersion() - Returns a non-empty string containing the version of the plugin.</li>
   *    <li>setPluginID(id) - A function for setting the plugin id on an instance of the plugin.</li>
   *    <li>getPluginID() - Returns the plugin id assigned by setPluginID().</li>
   *    <li>init() - A function for initializing the plugin.</li>
   *    <li>setMetadata(metadata) - A function for passing metadata specific to this plugin.</li>
   *    <li>destroy() - Destructor function for cleanup.</li>
   *    <li>processEvent(eventName, paramArray) - A function to receive events that are published through the framework.</li>
   * </ul>
   */
  var REQUIRED_PLUGIN_FUNCTIONS = ["getName", "getVersion", "setPluginID", "getPluginID", "init", "setMetadata", "destroy", "processEvent"];
  OO.Analytics.REQUIRED_PLUGIN_FUNCTIONS = REQUIRED_PLUGIN_FUNCTIONS;
}

},{"./InitAnalyticsNamespace.js":6}],5:[function(require,module,exports){
require("../../html5-common/js/utils/InitModules/InitOOUnderscore.js");

require("./InitAnalyticsNamespace.js");

require("./AnalyticsConstants.js");
/**
 * @public
* @class OO.Analytics.RecordedEvent
* @classdesc Store the information for a published event, including the time
* was sent.
* @param  {int}    timeStamp The time the event was published
* @param  {string} eventName The event name
* @param  {Array}  params The parameters passed in with the event
*/


OO.Analytics.RecordedEvent = function (timeStamp, eventName, params) {
  this.timeStamp = timeStamp;
  this.eventName = eventName;
  this.params = params;
};
/**
 * @public
 * @class OO.Analytics.Framework
 * @classdesc The Analytics Framework's goal is to abstract capturing all the events
 * in code for the purpose of analytics reporting (from any source). When a plugin
 * is registered with the framework, it will be validated, registered and automatically
 * receive all messages that are published to the framework.  The list of events that are
 * currently supported are located in AnalyticsConstants.js.  That file also contains
 * all the methods that need to be implemented by a plugin for it to be considered valid.
 */


OO.Analytics.Framework = function () {
  var _ = OO._;
  var _registeredPlugins = {};
  var _recordedEventList = [];
  var _recording = true;

  var _pluginMetadata;

  var _eventExistenceLookup = {};
  var _uniquePluginId = 0;
  var _isPublishingEvents = true;
  var MAX_PLUGINS = 20; //this is an arbitrary limit but we shouldn't ever reach this (not even close).

  var MAX_EVENTS_RECORDED = 500;
  /**
   * Helper function for readability mainly. Binds private functions to 'this' instance
   * of Framework, to give access to private variables.
   * @private
   * @method OO.Analytics.Framework#privateMember
   * @param  {function} functionVar The function to be bound to this instance of Framework
   * @return {function}             Bound function.
   */

  var privateMember = _.bind(function (functionVar) {
    if (!_.isFunction(functionVar)) {
      throw createErrorString("Trying to make private function but " + functionVar + " is not a function.");
      return;
    }

    return _.bind(functionVar, this);
  }, this);
  /**
   * Set the metadata for all plugins. Each plugin will only receive the data
   * pluginMetadata["myPluginName"]. This can only be set once per framework instance.
   * @public
   * @method OO.Analytics.Framework#setPluginMetadata
   * @param  {object}  pluginMetadata Object containing metadata for all plugins
   * @return {boolean}                Return true if metadata is valid and has not been set before.
   */


  this.setPluginMetadata = function (pluginMetadata) {
    var success = false; //just a warning if we are setting the metadata multiple times. This may be valid
    //if so, this can be removed.

    if (_pluginMetadata) {
      OO.log(createErrorString("Trying to run setPluginMetadata more than once. Ignoring new data."));
    }

    if (_.isObject(pluginMetadata)) {
      //set the metadata and then set it on any plugin that is already registered
      _pluginMetadata = pluginMetadata;
      var pluginList = this.getPluginIDList();

      for (var i = 0; i < pluginList.length; i++) {
        var plugin = getPluginInstance(pluginList[i]);
        passMetadataToPlugin(plugin);
      }

      success = true;
    } else {
      OO.log(createErrorString("Calling setPluginMetadata without valid metadata object. Defaulting to no metadata"));
    }

    return success;
  };
  /**
   * Destructor/cleanup for OO.Analytics.Framework.
   * @public
   * @method OO.Analytics.Framework#destroy
   */


  this.destroy = privateMember(function () {
    OO.Analytics.UnregisterFrameworkInstance(this);

    for (var pluginID in _registeredPlugins) {
      this.unregisterPlugin(pluginID);
    }

    _ = null;
    _registeredPlugins = null;
    _recordedEventList = null;
    _pluginMetadata = null;
    _eventExistenceLookup = null;
  });
  /**
   * Adds event and params to list of recorded events.  Plugins can later grab
   * this info in case events are published before the plugin is ready to process
   * them.
   * @private
   * @method OO.Analytics.Framework#recordEvent
   * @param  {string} eventName Event name to record
   * @param  {Array}  params    The params sent along with the event.
   */

  var recordEvent = privateMember(function (eventName, params) {
    if (_recording && _recordedEventList.length < MAX_EVENTS_RECORDED) {
      var timeStamp = new Date().getTime();
      var eventToRecord = new OO.Analytics.RecordedEvent(timeStamp, eventName, params);

      _recordedEventList.push(eventToRecord);
    } else {
      stopRecordingEvents();
    }
  });
  /**
   * Clears the list of recorded events.
   * @private
   * @method OO.Analytics.Framework#clearRecordedEvents
   */

  var clearRecordedEvents = privateMember(function () {
    _recordedEventList = [];
  });
  /**
   * Enable recording of events.
   * @private
   * @method OO.Analytics.Framework#startRecordingEvents
   */

  var startRecordingEvents = privateMember(function () {
    _recording = true;
  });
  /**
   * Disable recording of events.
   * @private
   * @method OO.Analytics.Framework#stopRecordingEvents
   */

  var stopRecordingEvents = privateMember(function () {
    _recording = false;
  });
  /**
   * Returns a shallow copy array of the currently stored recordedEvents in chronological
   * order.
   * @public
   * @method OO.Analytics.Framework#getRecordedEvents
   * @return {Array} Shallow copy of recordedEvents in chronological order.
   */

  this.getRecordedEvents = function () {
    if (_recordedEventList) {
      return _.clone(_recordedEventList);
    }

    return [];
  };
  /**
   * Register plugin as a factory. It will be validated and an instance of it will
   * be maintained internally.  The plugin will then be able to receive events
   * from the framework. Multiple of the same plugin factory can be registered.
   * Each one will have its own unique plugin id.
   * @public
   * @method OO.Analytics.Framework#registerPlugin
   * @param  {function} pluginFactory Plugin factory function
   * @return {string}                 Returns a unique plugin id for this plugin factory.
   */


  this.registerPlugin = function (pluginFactory) {
    var pluginID;
    var plugin;
    var errorOccured = false; //sanity check

    if (!pluginFactory) {
      OO.log(createErrorString("Trying to register plugin class that is a falsy value."));
      errorOccured = true;
    }

    if (!errorOccured) {
      try {
        plugin = new pluginFactory(this);
      } catch (error) {
        OO.log(error);
        OO.log(createErrorString("Error was thrown during plugin creation."));
        errorOccured = true;
      }
    }

    if (!errorOccured) {
      if (!this.validatePlugin(plugin)) {
        errorOccured = true;
      } else {
        //initialize the plugin. If we have metadata then give it to the plugin. Otherwise it will be sent in Analytics.Framework.setPluginMetadata;
        safeFunctionCall(plugin, "init");

        if (_pluginMetadata) {
          passMetadataToPlugin(plugin);
        }
      }
    }

    if (!errorOccured) {
      pluginID = createPluginId(plugin);

      if (!pluginID) {
        errorOccured = true;
      } else if (!_registeredPlugins[pluginID]) {
        _registeredPlugins[pluginID] = {
          factory: pluginFactory,
          instance: plugin,
          active: true
        };
        safeFunctionCall(plugin, "setPluginID", [pluginID]);
      }
    }

    if (errorOccured) {
      if (pluginID) {
        OO.log(createErrorString("\'" + pluginID + "\' is not valid and was not registered."));
      } else {
        var pluginName = safeFunctionCall(plugin, "getName");

        if (pluginName) {
          OO.log(createErrorString("\'" + pluginName + "\' is not valid and was not registered."));
        } else {
          OO.log(createErrorString("Plugin validation failed and was not registered."));
        }
      }
    }

    return pluginID;
  };
  /**
   * Remove plugin from the framework. All instances will stop receiving messages from
   * the framework.
   * @public
   * @method OO.Analytics.Framework#unregisterPlugin
   * @param  {string}  pluginIDToRemove Plugin id to be removed
   * @return {boolean}                  Return true if plugin was found and removed.
   */


  this.unregisterPlugin = function (pluginIDToRemove) {
    var removedSuccessfully = false;

    if (pluginIDToRemove && _registeredPlugins && _registeredPlugins[pluginIDToRemove]) {
      var plugin = getPluginInstance(pluginIDToRemove);
      safeFunctionCall(plugin, "destroy");
      delete _registeredPlugins[pluginIDToRemove];
      removedSuccessfully = true;
    }

    return removedSuccessfully;
  };
  /**
   * Validates that a plugin instance has all the correct functions.
   * @public
   * @method OO.Analytics.Framework#validatePlugin
   * @param  {object} plugin Plugin instance to be validated
   * @return {boolean}       Return true if plugin contains all the correct functions.
   */


  this.validatePlugin = function (plugin) {
    var isValid = true;

    if (!plugin) {
      isValid = false;
      OO.log(createErrorString("Plugin has falsy value and is not valid. Actual value: "), plugin);
    } /////////////////////////////////////////////////////////////////////////////////////////////
    ///IMPORTANT: This should be the only function to break the rule of using safeFunctionCall
    ///           for calling plugin functions, since it's checking if the plugin is valid to
    ///           begin with.
    /////////////////////////////////////////////////////////////////////////////////////////////


    if (isValid) {
      //test if all required functions are in the plugin
      for (var i = 0; i < OO.Analytics.REQUIRED_PLUGIN_FUNCTIONS.length; i++) {
        var reqFunc = OO.Analytics.REQUIRED_PLUGIN_FUNCTIONS[i];

        if (!plugin.hasOwnProperty(reqFunc) || typeof plugin[reqFunc] !== 'function') {
          isValid = false;

          if (plugin.getName && typeof plugin.getName === 'function') {
            try {
              OO.log(createErrorString("Plugin \'" + plugin.getName() + "\' missing function: " + reqFunc));
            } catch (e) {
              OO.log(createErrorString("Plugin missing function: " + reqFunc));
            }
          } else {
            OO.log(createErrorString("Plugin missing function: " + reqFunc));
          }

          break;
        }
      } //if it's still valid check whether the getName returns a non empty string


      if (isValid) {
        try {
          var name = plugin.getName();

          if (!name || !_.isString(name)) {
            OO.log(createErrorString("Plugin does not have \'string\' as return type of getName() or is empty string"));
            isValid = false;
          }
        } catch (e) {
          OO.log(createErrorString("Plugin throws error on call to getName"));
          isValid = false;
        }
      } //if it's still valid check whether the getVersion returns a non empty string


      if (isValid) {
        try {
          var version = plugin.getVersion();

          if (!version || !_.isString(version)) {
            OO.log(createErrorString("Plugin does not have \'string\' as return type of getVersion() or is empty string"));
            isValid = false;
          }
        } catch (e) {
          OO.log(createErrorString("Plugin throws error on call to getVersion"));
          isValid = false;
        }
      }
    }

    return isValid;
  };
  /**
   * Get a list of plugin ids for the currently registered plugins.
   * @public
   * @method OO.Analytics.Framework#getPluginIDList
   * @return {Array} An array of plugin IDs.
   */


  this.getPluginIDList = function () {
    var list = [];

    if (_registeredPlugins) {
      for (var pluginID in _registeredPlugins) {
        list.push(pluginID);
      }
    }

    return list;
  };
  /**
   * Return the instance of the plugin for a given id. This is for convinience
   * since the factory and instance are stored together in an object.
   * @private
   * @method OO.Analytics.Framework#getPluginInstance
   * @param  {string} pluginID The id of the plugin.
   * @return {object}          Returns the plugin instance.
   */


  var getPluginInstance = privateMember(function (pluginID) {
    var toReturn;

    if (_registeredPlugins && _registeredPlugins[pluginID]) {
      toReturn = _registeredPlugins[pluginID].instance;
    }

    return toReturn;
  });
  /**
   * Return whether or not a plugin is active and able to receive events.
   * @public
   * @method OO.Analytics.Framework#isPluginActive
   * @param {string}  pluginID Plugin id to check
   * @return {boolean}         Returns true if plugin is active. If plugin isn't registered, it will return false.
   */

  this.isPluginActive = function (pluginID) {
    if (pluginID && _registeredPlugins && _registeredPlugins[pluginID] && _.isBoolean(_registeredPlugins[pluginID].active)) {
      return _registeredPlugins[pluginID].active;
    }

    return false;
  };
  /**
   * Set a plugin to be active and receive messages.
   * @public
   * @method OO.Analytics.Framework#makePluginActive
   * @param {string}   pluginID Plugin id to set to active
   * @return {boolean}          Returns true if plugin found and was able to be activated.
   */


  this.makePluginActive = function (pluginID) {
    var success = false;

    if (pluginID && _registeredPlugins && _registeredPlugins[pluginID]) {
      _registeredPlugins[pluginID].active = true;
      success = true;
    }

    return success;
  };
  /**
   * Set a plugin to be inactive.
   * @public
   * @method OO.Analytics.Framework#makePluginInactive
   * @param  {string}  pluginID Plugin id to set to inactive
   * @return {boolean}          Returns true if plugin found and was able to be deactivated.
   */


  this.makePluginInactive = function (pluginID) {
    var success = false;

    if (pluginID && _registeredPlugins && _registeredPlugins[pluginID]) {
      _registeredPlugins[pluginID].active = false;
      success = true;
    }

    return success;
  };
  /**
   * Helper function to flatten an object with a nested objects into a single array of values.
   * @public
   * @method OO.Analytics.Framework#flattenEvents
   * @param {object} eventObject The event key-value pair to flatten
   * @returns {string[]} An array of strings representing the flattened values of the object.
   */


  this.flattenEvents = function (eventObject) {
    var eventArray = [];

    var eventKeys = _.keys(eventObject);

    for (var i = 0; i < eventKeys.length; i++) {
      var eventKey = eventKeys[i];
      var eventValue = eventObject[eventKey];

      if (typeof eventValue === "object") {
        var innerEvents = this.flattenEvents(eventValue);

        for (var j = 0; j < innerEvents.length; j++) {
          var innerEvent = innerEvents[j];
          eventArray.push(innerEvent);
        }
      } else {
        eventArray.push(eventValue);
      }
    }

    return eventArray;
  };
  /**
   * Helper function to create the events lookup dictionary.
   * @public
   * @method OO.Analytics.Framework#createEventDictionary
   * @returns {object|null} The created events dictionary. Returns null if there are any errors.
   */


  this.createEventDictionary = function () {
    var eventDictionary = null;
    var eventArray = this.flattenEvents(OO.Analytics.EVENTS);

    if (eventArray && eventArray instanceof Array) {
      eventDictionary = {};

      for (var i = 0; i < eventArray.length; i++) {
        var eventName = eventArray[i];
        eventDictionary[eventName] = true;
      }
    }

    return eventDictionary;
  };

  _eventExistenceLookup = this.createEventDictionary();
  /**
   * The analytics framework will stop publishing events to registered plugins
   * when the publishEvent() method is called. The events will also not be recorded.
   * @public
   * @method OO.Analytics.Framework#stopPublishingEvents
   */

  this.stopPublishingEvents = function () {
    _isPublishingEvents = false;
  };
  /**
   * The analytics framework will resume publishing events to registered plugins
   * and recording events can resume.
   * @public
   * @method OO.Analytics.Framework#resumePublishingEvents
   */


  this.resumePublishingEvents = function () {
    _isPublishingEvents = true;
  };
  /**
   * Publish an event to all registered and active plugins.
   * @public
   * @method OO.Analytics.Framework#publishEvent
   * @param  {string} eventName Name of event to publish
   * @param  {Array}  params    Parameters to pass along with the event.
   * @return {boolean}          Return true if message is in OO.Analytics.EVENTS and was successfully published.
   */


  this.publishEvent = function (eventName, params) {
    if (!_isPublishingEvents) {
      return false;
    }

    var eventPublished = false;

    if (_eventExistenceLookup[eventName]) {
      //if the params don't come in as an Array then create an empty array to pass in for everything.
      if (!_.isArray(params)) {
        params = [];
      } //record the message


      if (_recording) {
        recordEvent(eventName, params);
      } //propogate the message to all active plugins.


      var pluginID;

      for (pluginID in _registeredPlugins) {
        if (this.isPluginActive(pluginID)) {
          var plugin = getPluginInstance(pluginID);
          safeFunctionCall(plugin, "processEvent", [eventName, params]);
        }
      }

      eventPublished = true;
    } else {
      OO.log(createErrorString("Event \'" + eventName + "\' being published and it's not in the list of OO.Analytics.EVENTS"));
    }

    return eventPublished;
  };
  /**
   * Create a unique id for a given plugin/factory. In case someone needs to register
   * multiple of the same plugin or two plugins  have the same name, this creates
   * unique ids for each.
   * @private
   * @method OO.Analytics.Framework#createPluginId
   * @param  {object} plugin Instance of plugin to create id for.
   * @return {string}        The plugin id.
   */


  var createPluginId = privateMember(function (plugin) {
    var id = null;
    var error; //Plugin ID's are create using sequential numbers. Nothing fancy but this
    //way the framework can keep track of how many have been registered. There is
    //a chance that someone could have an infinite loop where plugins get registered
    //unregistered all the time, so this will output some error messages to help
    //debug that.

    if (plugin) {
      var name = safeFunctionCall(plugin, "getName");
      var version = safeFunctionCall(plugin, "getVersion");

      if (name && version) {
        id = _uniquePluginId + "_" + name + "_" + version; //we shouldn't have any naming conflicts but just in case, throw an error

        if (!_registeredPlugins[id]) {
          _uniquePluginId++;
        } else {
          OO.log(createErrorString("Failed to create a unique name for plugin " + name + "_" + version));
          id = null;
        }

        if (_uniquePluginId > MAX_PLUGINS) {
          OO.log(createErrorString("You have tried to create more than " + MAX_PLUGINS + " unique plugin ids. There is probably an infinite loop or some other error."));
        }
      }
    }

    return id;
  });
  /**
   * Helper function to give a plugin it's correct set of metadata.
   * @private
   * @method OO.Analytics.Framework#passMetadataToPlugin
   * @param  {object} plugin The plugin instance to give the metadata to
   */

  var passMetadataToPlugin = privateMember(function (plugin) {
    if (_pluginMetadata) {
      var pluginName = safeFunctionCall(plugin, "getName");

      if (!pluginName) {
        OO.log(createErrorString("Trying to pass in metadata to plugin that does not have valid name"));
        return;
      }

      var metadataForThisPlugin = _pluginMetadata[pluginName];
      safeFunctionCall(plugin, "setMetadata", [metadataForThisPlugin]);
    }
  });
  /**
   * Helper function to create consistent error messages.
   * @private
   * @method OO.Analytics.Framework#createErrorString
   * @param  {string} errorDetails The error details.
   * @return {string}              The new error message.
   */

  var createErrorString = function (errorDetails) {
    return "ERROR Analytics Framework: " + errorDetails;
  };
  /**
   * This function does several things:
   * -Safely call a function on an instance of a plugin.
   * -Elminates checking to see if function exists.
   * -If an error is thrown while calling the function, this will catch it and
   * output a message and the framework can continue running.
   * -If OO.DEBUG is true, safeFunctionCall will check if the function being called
   * is in the list of required functions. If it's not, then it will output a message.
   * Only functions in the required list should be called in the framework code.
   * @private
   * @method OO.Analytics.Framework#safeFunctionCall
   * @param  {object} plugin   Plugin instance to call function on.
   * @param  {string} funcName Name of function to call.
   * @param  {array}  params   The parameters to pass into the function.
   * @return {varies}          Returns the function's return value. If an error occurred, returns null.
   */


  var safeFunctionCall = privateMember(function (plugin, funcName, params) {
    if (OO.DEBUG) {
      debugCheckFunctionIsInRequiredList(funcName);
    }

    try {
      if (_.isFunction(plugin[funcName])) {
        return plugin[funcName].apply(plugin, params);
      }
    } catch (err) {
      try {
        if (plugin && _.isFunction(plugin.getName)) {
          OO.log(createErrorString("Error occurred during call to function \'" + funcName + "\' on plugin \'" + plugin.getName() + "\'\n"));
          OO.log(err);
        }
      } catch (e) {
        OO.log(createErrorString("Error occurred during call to function \'" + funcName + "\' on plugin\n", err));
      }
    }

    return null;
  });
  /**
   * Check if function name exists in the list of require functions for plugins.
   * Outputs error message if it doesn't exist.
   * @private
   * @method OO.Analytics.Framework#safeFunctionCall
   * @param  {string} funcName Name of the function to check.
   */

  var debugCheckFunctionIsInRequiredList = privateMember(function (funcName) {
    if (!_.contains(OO.Analytics.REQUIRED_PLUGIN_FUNCTIONS, funcName)) {
      OO.log(createErrorString("Calling function \'" + funcName + "\' in framework code and it's not in the REQUIRED_PLUGIN_FUNCTIONS list."));
    }
  }); //Register this instance so it will register all the plugin factories currently loaded.

  OO.Analytics.RegisterFrameworkInstance(this);
};

},{"../../html5-common/js/utils/InitModules/InitOOUnderscore.js":2,"./AnalyticsConstants.js":4,"./InitAnalyticsNamespace.js":6}],6:[function(require,module,exports){
require("../../html5-common/js/utils/InitModules/InitOO.js");

require("../../html5-common/js/utils/InitModules/InitOOUnderscore.js");

if (!OO.Analytics) {
  OO.Analytics = {};
}

if (!OO.Analytics.FrameworkInstanceList) {
  OO.Analytics.FrameworkInstanceList = [];
}

if (!OO.Analytics.PluginFactoryList) {
  OO.Analytics.PluginFactoryList = [];
}

if (!OO.Analytics.RegisterPluginFactory) {
  /**
   * Registers a plugin factory in a global list of factories and then
   * registers the factory with any existing framework instances.
   * @public
   * @method OO.Analytics.Framework#RegisterPluginFactory
   * @param  {object} factory The factory creation function
   */
  OO.Analytics.RegisterPluginFactory = function (factory) {
    //Add plugin to the factory list.
    OO.Analytics.PluginFactoryList.push(factory); //Register this plugin with any existing frameworks.

    if (OO.Analytics.FrameworkInstanceList && OO.Analytics.FrameworkInstanceList.length) {
      for (var i = 0; i < OO.Analytics.FrameworkInstanceList.length; i++) {
        OO.Analytics.FrameworkInstanceList[i].registerPluginFactory(factory);
      }
    }
  };
}

if (!OO.Analytics.FrameworkRegistrationObject) {
  /**
   * @class FrameworkRegistrationObject
   * @classdesc This class wraps a framework object to only expose
   * registerPluginFactory.  It will be used to let plugins register to frameworks
   * at the global scope. Please note that this class is not important to analytics plugins. You only need to use this class if you're creating your own version of the Analytics Framework.
   * @public
   * @param  {object} framework Analytics framework instance
   */
  OO.Analytics.FrameworkRegistrationObject = function (framework) {
    this.registerPluginFactory = function (pluginFactory) {
      framework.registerPlugin(pluginFactory);
    };
  };
}

if (!OO.Analytics.RegisterFrameworkInstance) {
  /**
   * Registers a framework instance in a global list of frameworks and then
   * register any plugin factory that are in the global plugin factory list.
   * @public
   * @method OO.Analytics.Framework#RegisterFrameworkInstance
   * @param  {object} framework Instance of the framework to register
   */
  OO.Analytics.RegisterFrameworkInstance = function (framework) {
    var frameworkRegistrationObject = new OO.Analytics.FrameworkRegistrationObject(framework);
    framework.frameworkRegistrationObject = frameworkRegistrationObject;
    OO.Analytics.FrameworkInstanceList.push(frameworkRegistrationObject); //check to see if any plugin factories already existed and register them to this plugin.

    if (OO._.isArray(OO.Analytics.PluginFactoryList) && OO.Analytics.PluginFactoryList.length > 0) {
      for (var i = 0; i < OO.Analytics.PluginFactoryList.length; i++) {
        framework.registerPlugin(OO.Analytics.PluginFactoryList[i]);
      }
    }
  };
}

if (!OO.Analytics.UnregisterFrameworkInstance) {
  /**
   * Remove a framework instance from the global list of instance. You must have
   * a reference to the FrameworkRegistrationObject from that framework to remove it.
   * This is meant for framework instances to remove themselves from the list only.
   * @public
   * @method OO.Analytics.Framework#UnregisterFrameworkInstance
   * @param  {object} framework Instance of the FrameworkRegistrationObject created when framework instance was registered
   */
  OO.Analytics.UnregisterFrameworkInstance = function (framework) {
    if (framework) {
      var regObj = framework.frameworkRegistrationObject;

      if (regObj) {
        OO.Analytics.FrameworkInstanceList = OO._.without(OO.Analytics.FrameworkInstanceList, regObj);
      }
    }
  };
}

},{"../../html5-common/js/utils/InitModules/InitOO.js":1,"../../html5-common/js/utils/InitModules/InitOOUnderscore.js":2}],7:[function(require,module,exports){
require("../framework/InitAnalyticsNamespace.js");

require("../../html5-common/js/utils/utils.js");
/**
 * @class IqPlugin
 * @classdesc Ooyala IQ analytics.js plugin that works with the Ooyala Analytics Framework.
 * @param {object} framework The Analytics Framework instance
 */


var IqPlugin = function (framework) {
  var _framework = framework;
  var name = "iq";
  var version = "v1";
  var id;
  var SDK_LOAD_TIMEOUT = 3000;
  var autoPlay = false;
  var pcode = null;
  var playerId = null;
  var lastEmbedCode = "";
  var currentEmbedCode = null;
  var contentType = "ooyala";
  var playingInstreamAd = false;
  var iqEnabled = false;
  var allowThrift = false;
  var thriftPcode = null;
  var jsonPcode = null;
  var adFirstQuartile = false;
  var adSecondQuartile = false;
  var adThirdQuartile = false;
  var adLastQuartile = false;
  var currentPlayhead = 0;
  var lastReportedPlayhead = 0;
  var adOffset = 0;
  var adTimeline = [];
  var playingSsaiAd = false;
  var ssaiAdTransition = false;
  var geoMetadata = null;
  this.ooyalaReporter = null;
  this.videoStartSent = false;
  this.testMode = false;
  /**
   * [Required Function] Return the name of the plugin.
   * @public
   * @method IqPlugin#getName
   * @return {string} The name of the plugin.
   */

  this.getName = function () {
    return name;
  };
  /**
   * [Required Function] Return the version string of the plugin.
   * @public
   * @method IqPlugin#getVersion
   * @return {string} The version of the plugin.
   */


  this.getVersion = function () {
    return version;
  };
  /**
   * Return the autoPlay value.
   * @public
   * @method IqPlugin@getAutoPlay
   * @return {boolean} The value of autoPlay.
   */


  this.getAutoPlay = function () {
    return autoPlay;
  };
  /**
   * Return the iqEnabled value.
   * @public
   * @method IqPlugin@getIqEnabled
   * @return {boolean} The value of iqEnabled.
   */


  this.getIqEnabled = function () {
    return iqEnabled;
  };
  /**
   * Return the allowThrift value.
   * @public
   * @method IqPlugin@getAllowThrift
   * @return {boolean} The value of allowThrift.
   */


  this.getAllowThrift = function () {
    return allowThrift;
  };
  /**
   * Return the thriftPcode value.
   * @public
   * @method IqPlugin@thriftPcode
   * @return {boolean} The value of thriftPcode.
   */


  this.getThriftPcode = function () {
    return thriftPcode;
  };
  /**
   * Return the jsonPcode value.
   * @public
   * @method IqPlugin@jsonPcode
   * @return {boolean} The value of jsonPcode.
   */


  this.getJsonPcode = function () {
    return jsonPcode;
  };
  /**
   * [Required Function] Set the plugin id given by the Analytics Framework when
   * this plugin is registered.
   * @public
   * @method IqPlugin#setPluginID
   * @param  {string} newID The plugin id
   */


  this.setPluginID = function (newID) {
    id = newID;
  };
  /**
   * [Required Function] Returns the stored plugin id, given by the Analytics Framework.
   * @public
   * @method IqPlugin#setPluginID
   * @return  {string} The pluginID assigned to this instance from the Analytics Framework.
   */


  this.getPluginID = function () {
    return id;
  };
  /**
   * [Required Function] Initialize the plugin with the given metadata.
   * @public
   * @method IqPlugin#init
   */


  this.init = function () {
    if (this.testMode) {
      trySetupAnalytics();
    } else if (!this.ooyalaReporter) {
      OO.loadScriptOnce("//analytics.ooyala.com/static/v3/analytics.js", trySetupAnalytics, sdkLoadError, SDK_LOAD_TIMEOUT);
    }
  };
  /**
   * [Required Function] Set the metadata for this plugin.
   * @public
   * @method IqPlugin#setMetadata
   * @param  {object} metadata The metadata for this plugin
   */


  this.setMetadata = function (metadata) {
    if (metadata && metadata.metadata) {
      if (metadata.metadata.enabled != null) {
        iqEnabled = metadata.metadata.enabled == true || metadata.metadata.enabled === "true";
      } // Are we possibly sending thrift events as well? If so we do not want to send
      // any duplicate events with analytics.js here, only new events not reported by
      // thrift in core with ooyala_analytics.js 


      if (metadata.metadata.allowThrift != null) {
        allowThrift = metadata.metadata.allowThrift == true || metadata.metadata.allowThrift === "true";
      }

      if (metadata.metadata.thriftPcode != null) {
        thriftPcode = metadata.metadata.thriftPcode;
      }

      if (metadata.metadata.jsonPcode != null) {
        jsonPcode = metadata.metadata.jsonPcode;
        pcode = jsonPcode;
      }
    }

    OO.log("Analytics Template: PluginID \'" + id + "\' received this metadata:", metadata);
  };
  /**
    * Processes the timeline of ads received by the SSAI server metadata call.
    * Converts an array of ads to have an end time and offset, and cleans up unused values.
    * It is assumed that the timeline is ordered by ad start time
    * @private
    * @method IqPlugin#processAdTimeline
    * @param {array} timeline The raw array of ads returned by the SSAI server
    */


  this.processAdTimeline = function (timeline) {
    if (timeline === null || typeof timeline !== "array") {
      return [];
    }

    var processedTimeline = [];
    var totalOffset = 0;

    for (var index = 0; index < timeline.length; index++) {
      var durationMillis = Math.floor(timeline[index].duration * 1000);
      var startTimeMillis = Math.floor(timeline[index].start * 1000);
      totalOffset += durationMillis;
      var adData = {
        "adId": timeline[index].id,
        "start": startTimeMillis,
        "end": startTimeMillis + durationMillis,
        "duration": durationMillis,
        "offset": totalOffset
      };
      processedTimeline.push(adData);
    }

    return processedTimeline;
  };
  /**
    * Updates the ad offset for calculating the correct playhead for videos
    * with SSAI ads embedded after a seek has been performed.
    * @private
    * @method IqPlugin#updateAdOffset
    * @param {number} playhead The raw playhead returned by the video plugin (in seconds)
    */


  this.updateAdOffset = function (playhead) {
    if (adTimeline !== null) {
      adOffset = 0;

      for (var index = 0; index < adTimeline.length; index++) {
        if (adTimeline[index].start <= playhead) {
          adOffset += adTimeline[index].duration;
        }
      }
    }
  };
  /**
    * Checks the player is inside an SSAI ad block.
  * Checks the passed playhead against the ad timeline and returns true
  * if it is inside an SSAI ad block, false otherwise
    * @private
    * @method IqPlugin#isSSAIAdPlaying
    * @param {number} playhead the playhead time to check (in seconds)
    */


  this.isSSAIAdPlaying = function (playhead) {
    for (var index = 0; index < adTimeline.length; index++) {
      if (playhead >= adTimeline[index].start && playhead < adTimeline[index].end) {
        return true;
      }
    }

    return false;
  };
  /**
    * Convenience function for reporting the custom ad playthrough percent event to IQ
    * @private
    * @method IqPlugin#reportAdPlaythrough
    * @param {number} playhead the playhead time to check (in seconds)
    * @param {number} duration the stream total duration (in seconds)
    */


  this.reportAdPlaythrough = function (eventName, playhead, duration) {
    var percentPlayed = 0;
    var reportQuartile = false;

    if (OO._.isFinite(playhead) && playhead >= 0 && OO._.isFinite(duration) && duration > 0) {
      var playheadMillis = Math.floor(playhead * 1000);
      var durationMillis = Math.floor(duration * 1000);

      if (playheadMillis >= 0.25 * durationMillis && !adFirstQuartile) {
        percentPlayed = 0.25;
        adFirstQuartile = true;
        reportQuartile = true;
      } else if (playheadMillis >= 0.50 * durationMillis && !adSecondQuartile) {
        percentPlayed = 0.50;
        adSecondQuartile = true;
        reportQuartile = true;
      } else if (playheadMillis >= 0.75 * durationMillis && !adThirdQuartile) {
        percentPlayed = 0.75;
        adThirdQuartile = true;
        reportQuartile = true;
      } else if (playheadMillis >= 1.0 * durationMillis && !adLastQuartile) {
        percentPlayed = 1.00;
        adLastQuartile = true;
        reportQuartile = true;
      }

      if (reportQuartile) {
        OO.log("IQ: Reported: reportCustomEvent() for event: adPlaythrough with args:" + JSON.stringify(percentPlayed));
        this.ooyalaReporter.reportCustomEvent(eventName, {
          "adEventName": "adPlaythrough",
          "percent": percentPlayed
        });
      }
    }
  };
  /**
   * [Required Function] Process an event from the Analytics Framework, with the given parameters.
   * @public
   * @method IqPlugin#processEvent
   * @param  {string} eventName Name of the event
   * @param  {Array} params     Array of parameters sent with the event
   */


  this.processEvent = function (eventName, params) {
    OO.log("IQ: PluginID \'" + id + "\' received this event \'" + eventName + "\' with these params:", params); // This first switch is for non IQ reporting events that require changes to the internal plugin state

    switch (eventName) {
      // First check the events that do not actually report to analytics
      // Need to always check this event to see if we can enable analytics.js reporting. 
      //OO.EVENTS.METADATA_FETCHED -> OO.Analytics.EVENTS.VIDEO_STREAM_METADATA_UPDATED.
      case OO.Analytics.EVENTS.VIDEO_STREAM_METADATA_UPDATED:
        if (params && params[0]) {
          var modules = params[0].modules;

          if (modules) {
            this.setMetadata(modules.iq);
          }
        }

        break;
      //OO.EVENTS.EMBED_CODE_CHANGED -> OO.Analytics.EVENTS.VIDEO_SOURCE_CHANGED.

      case OO.Analytics.EVENTS.VIDEO_SOURCE_CHANGED:
        if (params && params[0] && params[0].metadata) {
          autoPlay = params[0].metadata.autoPlay;

          if (params[0].embedCode != currentEmbedCode) {
            lastEmbedCode = currentEmbedCode;
          } else {
            lastEmbedCode = "";
          }

          currentEmbedCode = params[0].embedCode;
        }

        break;

      case OO.Analytics.EVENTS.SSAI_AD_TIMELINE_RECEIVED:
        if (params && params[0] && params[0].timeline) {
          adTimeline = this.processAdTimeline(params[0].timeline);
        }

        this.updateAdOffset(currentPlayhead);
        break;

      case OO.Analytics.EVENTS.SSAI_PLAY_SINGLE_AD:
        var foundAd = false;

        for (var index = 0; index < adTimeline.length; index++) {
          if (adTimeline[index].adId === params[0].ad.adId) {
            foundAd = true;
          }
        }

        if (!foundAd) {
          var durationMillis = Math.floor(params[0].ad.duration * 1000);
          var adData = {
            "adId": params[0].ad.adId,
            "start": currentPlayhead,
            "end": currentPlayhead + durationMillis,
            "duration": durationMillis,
            "offset": 0
          };
          adTimeline.push(adData);
        }

        playingSsaiAd = true;
        break;

      case OO.Analytics.EVENTS.SSAI_SINGLE_AD_PLAYED:
        playingSsaiAd = false;
        ssaiAdTransition = true;
        break;
    } //OO.EVENTS.AUTHORAZATION_FETCHED -> OO.Analytics.EVENTS.STREAM_TYPE_UPDATED


    if (eventName === OO.Analytics.EVENTS.STREAM_TYPE_UPDATED) {
      //we don't need the auth data but we do need the geo data and that is the second param
      if (params && params[1]) {
        geoMetadata = params[1]; //we have to change country and dma to countryCode and geoVendor because
        //analytics.js throws errors if there are incorrect params in the object.

        geoMetadata.countryCode = geoMetadata.country;
        delete geoMetadata.country;
        geoMetadata.geoVendor = geoMetadata.dma;
        delete geoMetadata.dma;
        this.ooyalaReporter.setUserInfo(null, null, null, geoMetadata);
      }

      return;
    } //OO.EVENTS.AUTHORAZATION_FETCHED -> OO.Analytics.EVENTS.STREAM_TYPE_UPDATED


    if (eventName === OO.Analytics.EVENTS.STREAM_TYPE_UPDATED) {
      //we don't need the auth data but we do need the geo data and that is the second param
      if (params && params[1]) {
        geoMetadata = params[1]; //we have to change country and dma to countryCode and geoVendor because
        //analytics.js throws errors if there are incorrect params in the object.

        geoMetadata.countryCode = geoMetadata.country;
        delete geoMetadata.country;
        geoMetadata.geoVendor = geoMetadata.dma;
        delete geoMetadata.dma;
        this.ooyalaReporter.setUserInfo(null, null, null, geoMetadata);
      }

      return;
    }

    if (!iqEnabled) return; // Any other event requires analytics to be loaded, return otherwise

    if (!this.ooyalaReporter) {
      OO.log("Tried reporting event: " + eventName + " but ooyalaReporter is: " + this.ooyalaReporter);
      return;
    } // This switch is for IQ reporting events only


    switch (eventName) {
      //OO.EVENTS.CONTENT_TREE_FETCHED -> OO.Analytics.EVENTS.VIDEO_CONTENT_METADATA_UPDATED.
      case OO.Analytics.EVENTS.VIDEO_CONTENT_METADATA_UPDATED:
        if (params && params[0]) {
          ssaiAdTransition = false;
          playingSsaiAd = false;
          currentPlayhead = 0;
          lastReportedPlayhead = 0;
          adOffset = 0;
          adTimeline = [];
          var duration = params[0].duration;
          this.ooyalaReporter.initializeMedia(currentEmbedCode, contentType);
          OO.log("IQ: Reported: initializeMedia() with args: " + currentEmbedCode + ", " + contentType);
          this.ooyalaReporter.setMediaDuration(duration);
          OO.log("IQ: Reported: setMediaDuration() with args: " + duration);
        }

        break;
      //OO.EVENTS.PLAYER_CREATED -> OO.Analytics.EVENTS.VIDEO_PLAYER_CREATED

      case OO.Analytics.EVENTS.VIDEO_PLAYER_CREATED:
        if (params && params[0] && params[0].params) {
          var eventParams = params[0];
          pcode = eventParams.params.pcode;

          if (jsonPcode != null) {
            pcode = jsonPcode;
          }

          playerId = eventParams.params.playerBrandingId;
          eventMetadata = params[0];
          eventMetadata.qosEventName = eventName;
          this.ooyalaReporter._base.pcode = pcode;
          this.ooyalaReporter.reportCustomEvent(eventName, eventMetadata);
          OO.log("IQ: Reported: reportCustomEvent() for event: " + eventName + " with args:" + JSON.stringify(eventMetadata));

          if (!allowThrift || thriftPcode != null || jsonPcode != null) {
            this.ooyalaReporter.reportPlayerLoad();
            OO.log("IQ: Reported: reportPlayerLoad()");
          }
        }

        break;
      //OO.EVENTS.INITIAL_PLAY -> OO.Analytics.EVENTS.VIDEO_PLAY_REQUESTED.

      case OO.Analytics.EVENTS.INITIAL_PLAYBACK_REQUESTED:
        if (!allowThrift || thriftPcode != null || jsonPcode != null) {
          OO.log("IQ: Reported: reportPlayRequested() with args: " + autoPlay);
          this.ooyalaReporter.reportPlayRequested(autoPlay);
        }

        break;
      //OO.EVENTS.PLAYHEAD_TIME_CHANGED -> OO.Analytics.EVENTS.VIDEO_STREAM_POSITION_CHANGED.

      case OO.Analytics.EVENTS.VIDEO_STREAM_POSITION_CHANGED:
        if (params && params[0] && params[0].streamPosition > 0) {
          if (playingInstreamAd || playingSsaiAd) {
            if (playingInstreamAd) {
              this.reportAdPlaythrough(eventName, params[0].streamPosition, params[0].totalStreamDuration);
            }
          } else if (!allowThrift || thriftPcode != null || jsonPcode != null) {
            // When present, currentLiveTime should override currentTime for analytics purposes.
            var currentTime = params[0].streamPosition;

            if (OO._.isFinite(params[0].currentLiveTime) && params[0].currentLiveTime > 0) {
              currentTime = params[0].currentLiveTime;
              adOffset = 0;
            }

            var currentTimeMillis = Math.floor(currentTime * 1000);

            if (OO._.isFinite(currentTime) && currentTime > 0) {
              if (ssaiAdTransition) {
                if (this.isSSAIAdPlaying(currentTimeMillis)) {
                  break;
                } else {
                  // Update the ad offset as soon as the ad break is done to ensure correct offest
                  // for playhead reporting
                  this.updateAdOffset(currentTimeMillis);
                  ssaiAdTransition = false;
                }
              }

              currentPlayhead = currentTimeMillis;
              var offsetPlayhead = currentPlayhead - adOffset; // Fix for PLAYER-3592. Never report a playhead smaller than the previous reported playhead unless a seek event happens

              if (offsetPlayhead >= 0 && offsetPlayhead > lastReportedPlayhead) {
                lastReportedPlayhead = offsetPlayhead;
                this.ooyalaReporter.reportPlayHeadUpdate(offsetPlayhead);
                OO.log("IQ: Reported: reportPlayHeadUpdate() with args: " + offsetPlayhead);
              }
            }
          }
        }

        break;
      //OO.EVENTS.PAUSED -> OO.Analytics.EVENTS.VIDEO_PAUSED.

      case OO.Analytics.EVENTS.VIDEO_PAUSED:
        this.ooyalaReporter.reportPause();
        OO.log("IQ: Reported: reportPause()");
        break;
      //OO.EVENTS.PLAYING -> OO.Analytics.EVENTS.VIDEO_PLAYING.

      case OO.Analytics.EVENTS.VIDEO_PLAYING:
        if (!allowThrift || thriftPcode != null || jsonPcode != null) {
          if (!this.videoStartSent) {
            if (lastEmbedCode != currentEmbedCode) {
              this.ooyalaReporter.reportPlaybackStarted();
              OO.log("IQ: Reported: reportPlaybackStarted()");
            } else {
              this.ooyalaReporter.reportReplay();
              OO.log("IQ: Reported: reportReplay()");
            }

            lastEmbedCode = currentEmbedCode;
            this.videoStartSent = true;
          } else {
            this.ooyalaReporter.reportResume();
            OO.log("IQ: Reported: reportResume()");
          }
        }

        break;
      //OO.EVENTS.SEEKED -> OO.Analytics.EVENTS.VIDEO_SEEK_COMPLETED.

      case OO.Analytics.EVENTS.VIDEO_SEEK_COMPLETED:
        lastReportedPlayhead = 0;

        if (params && params[0]) {
          var newPlayhead = Math.floor(params[0].timeSeekedTo * 1000);
          playingSsaiAd = this.isSSAIAdPlaying(newPlayhead);
          this.updateAdOffset(newPlayhead);
          this.ooyalaReporter.reportSeek(currentPlayhead, newPlayhead);
          OO.log("IQ: Reported: reportSeek() with args: " + currentPlayhead + ", " + newPlayhead);
          currentPlayhead = newPlayhead;
        }

        break;
      //OO.EVENTS.PLAYED -> OO.Analytics.EVENTS.PLAYBACK_COMPLETED.

      case OO.Analytics.EVENTS.PLAYBACK_COMPLETED:
        this.ooyalaReporter.reportComplete();
        OO.log("IQ: Reported: reportComplete()");
        break;
      //OO.EVENTS.REPLAY -> OO.Analytics.EVENTS.VIDEO_REPLAY_REQUESTED.

      case OO.Analytics.EVENTS.VIDEO_REPLAY_REQUESTED:
        lastReportedPlayhead = 0; // SSAI: Check for preroll and update ad offset if present

        playingSsaiAd = this.isSSAIAdPlaying(0);
        this.updateAdOffset(0);
        break;

      case OO.EVENTS.WILL_PLAY_FROM_BEGINNING:
        this.videoStartSent = false;
        break;
      //OO.EVENTS.BUFFERING -> OO.Analytics.EVENTS.VIDEO_BUFFERING_STARTED.

      case OO.Analytics.EVENTS.VIDEO_BUFFERING_STARTED:
      case OO.Analytics.EVENTS.VIDEO_BUFFERING_ENDED:
      case OO.Analytics.EVENTS.INITIAL_PLAY_STARTING:
      case OO.Analytics.EVENTS.PLAYBACK_READY:
      case OO.Analytics.EVENTS.API_ERROR:
      case OO.Analytics.EVENTS.BITRATE_INITIAL:
      case OO.Analytics.EVENTS.BITRATE_FIVE_SEC:
      case OO.Analytics.EVENTS.BITRATE_STABLE:
      case OO.Analytics.EVENTS.PLAYBACK_START_ERROR:
      case OO.Analytics.EVENTS.PLAYBACK_MIDSTREAM_ERROR:
      case OO.Analytics.EVENTS.PLUGIN_LOADED:
        eventMetadata = params && params[0] ? params[0] : {};
        eventMetadata.qosEventName = eventName;
        OO.log("IQ: Reported: reportCustomEvent() for event: " + eventName + " with args:" + JSON.stringify(eventMetadata));
        this.ooyalaReporter.reportCustomEvent(eventName, eventMetadata);
        break;
      // OO.EVENTS.WILL_PLAY_ADS -> OO.Analytics.EVENTS.AD_BREAK_STARTED

      case OO.Analytics.EVENTS.AD_BREAK_STARTED:
        playingInstreamAd = true;
        this.ooyalaReporter.reportCustomEvent(eventName, {
          adEventName: eventName
        });
        break;
      // OO.EVENTS.ADS_PLAYED -> OO.Analytics.EVENTS.AD_BREAK_ENDED

      case OO.Analytics.EVENTS.AD_BREAK_ENDED:
        playingInstreamAd = false;
        this.ooyalaReporter.reportCustomEvent(eventName, {
          adEventName: eventName
        });
        break;

      case OO.Analytics.EVENTS.AD_STARTED:
        adFirstQuartile = false;
        adSecondQuartile = false;
        adThirdQuartile = false;
        adLastQuartile = false;

      case OO.Analytics.EVENTS.AD_REQUEST:
      case OO.Analytics.EVENTS.AD_REQUEST_SUCCESS:
      case OO.Analytics.EVENTS.AD_SDK_LOADED:
      case OO.Analytics.EVENTS.AD_SDK_LOAD_FAILURE:
      case OO.Analytics.EVENTS.AD_POD_STARTED:
      case OO.Analytics.EVENTS.AD_POD_ENDED:
      case OO.Analytics.EVENTS.AD_ENDED:
      case OO.Analytics.EVENTS.AD_SKIPPED:
      case OO.Analytics.EVENTS.AD_ERROR:
      case OO.Analytics.EVENTS.AD_REQUEST_EMPTY:
      case OO.Analytics.EVENTS.AD_REQUEST_ERROR:
      case OO.Analytics.EVENTS.AD_PLAYBACK_ERROR:
      case OO.Analytics.EVENTS.AD_IMPRESSION:
      case OO.Analytics.EVENTS.AD_SDK_IMPRESSION:
      case OO.Analytics.EVENTS.AD_COMPLETED:
      case OO.Analytics.EVENTS.AD_CLICKTHROUGH_OPENED:
      case OO.Analytics.EVENTS.AD_CLICKED:
      case OO.Analytics.EVENTS.SDK_AD_EVENT:
        if (!params || !params[0]) {
          params = [];
        }

        var eventMetadata = params[0];

        if (!eventMetadata) {
          eventMetadata = {};
        }

        if (eventMetadata.adEventName) {
          eventMetadata.adEventName = eventName + ":" + eventMetadata.adEventName;
        } else {
          eventMetadata.adEventName = eventName;
        }

        this.ooyalaReporter.reportCustomEvent(eventName, eventMetadata);
        OO.log("IQ: Reported: reportCustomEvent() for event: " + eventName + " with args:" + JSON.stringify(eventMetadata));
        break;

      case OO.Analytics.EVENTS.REPORT_DISCOVERY_IMPRESSION:
        if ((!allowThrift || thriftPcode != null || jsonPcode != null) && params && params[0] && params[0].metadata) {
          try {
            eventMetadata = params[0].metadata;
            OO.log("IQ: Reported: reportAssetImpression() with args: " + JSON.stringify(params[0]));
            this.ooyalaReporter.reportAssetImpression(eventMetadata.asset, eventMetadata.customData, eventMetadata.uiTag, eventMetadata.contentSource, eventMetadata.pageSize, eventMetadata.assetPosition);
          } catch (e) {
            OO.log("IQ: Tried reporting event: " + eventName + " but received error: " + e);
          }
        }

        break;

      case OO.Analytics.EVENTS.REPORT_DISCOVERY_CLICK:
        if ((!allowThrift || thriftPcode != null || jsonPcode != null) && params && params[0] && params[0].metadata) {
          try {
            eventMetadata = params[0].metadata;
            OO.log("IQ: Reported: reportAssetClick() with args: " + JSON.stringify(params[0]));
            this.ooyalaReporter.reportAssetClick(eventMetadata.asset, eventMetadata.customData, eventMetadata.uiTag, eventMetadata.contentSource, eventMetadata.pageSize, eventMetadata.assetPosition);
          } catch (e) {
            OO.log("IQ: Tried reporting event: " + eventName + " but received error: " + e);
          }
        }

        break;

      default:
        break;
    }
  };
  /**
   * [Required Function] Clean up this plugin so the garbage collector can clear it out.
   * @public
   * @method IqPlugin#destroy
   */


  this.destroy = function () {
    _framework = null;
  };
  /**
   * Called when the SDK fails to load.
   * @private
   * @method NielsenAnalyticsPlugin#sdkLoadError
   */


  var sdkLoadError = function () {
    //Destroy and unregister
    if (OO._.isString(id)) {
      framework.unregisterPlugin(id);
    }

    this.destroy();
  };

  var trySetupAnalytics = OO._.bind(function () {
    if (window.Ooyala) {
      this.ooyalaReporter = new Ooyala.Analytics.Reporter();
      var missedEvents; //if you need to process missed events, here is an example

      if (_framework && OO._.isFunction(_framework.getRecordedEvents)) {
        missedEvents = _framework.getRecordedEvents();

        for (var i = 0; i < missedEvents.length; i++) {
          recordedEvent = missedEvents[i];
          this.processEvent(recordedEvent.eventName, recordedEvent.params);
        }
      } // TODO: setup


      var deviceInfo = {};
      var playerName = "Ooyala Player";
      var playerVersion = OO.VERSION.core.releaseVersion; // TODO: need a mechanism in core to get this

      var doNotTrack = false;

      switch (OO.trackingLevel) {
        case OO.TRACKING_LEVEL.DISABLED:
        case OO.TRACKING_LEVEL.ANONYMOUS:
          doNotTrack = true;
          break;

        case OO.TRACKING_LEVEL.DEFAULT:
        default:
          break;
      }

      this.ooyalaReporter.setDeviceInfo(null, null, null, doNotTrack);
      this.ooyalaReporter.setPlayerInfo(playerId, playerName, playerVersion);
    } else {
      OO.log("IQ Plugin: Analytics SDK not loaded");
    }
  }, this);
}; //Add the template to the global list of factories for all new instances of the framework
//and register the template with all current instance of the framework.


OO.Analytics.RegisterPluginFactory(IqPlugin);
module.exports = IqPlugin;

},{"../../html5-common/js/utils/utils.js":3,"../framework/InitAnalyticsNamespace.js":6}],8:[function(require,module,exports){
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

module.exports = _arrayWithHoles;
},{}],9:[function(require,module,exports){
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

module.exports = _asyncToGenerator;
},{}],10:[function(require,module,exports){
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;
},{}],11:[function(require,module,exports){
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;
},{}],12:[function(require,module,exports){
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;
},{}],13:[function(require,module,exports){
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;
},{}],14:[function(require,module,exports){
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

module.exports = _iterableToArrayLimit;
},{}],15:[function(require,module,exports){
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

module.exports = _nonIterableRest;
},{}],16:[function(require,module,exports){
var defineProperty = require("./defineProperty");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

module.exports = _objectSpread;
},{"./defineProperty":12}],17:[function(require,module,exports){
var arrayWithHoles = require("./arrayWithHoles");

var iterableToArrayLimit = require("./iterableToArrayLimit");

var nonIterableRest = require("./nonIterableRest");

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

module.exports = _slicedToArray;
},{"./arrayWithHoles":8,"./iterableToArrayLimit":14,"./nonIterableRest":15}],18:[function(require,module,exports){
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
},{}],19:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],20:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":19}],21:[function(require,module,exports){
"use strict";

var utils = require("./utils");

module.exports = function batchProcessorMaker(options) {
    options             = options || {};
    var reporter        = options.reporter;
    var asyncProcess    = utils.getOption(options, "async", true);
    var autoProcess     = utils.getOption(options, "auto", true);

    if(autoProcess && !asyncProcess) {
        reporter && reporter.warn("Invalid options combination. auto=true and async=false is invalid. Setting async=true.");
        asyncProcess = true;
    }

    var batch = Batch();
    var asyncFrameHandler;
    var isProcessing = false;

    function addFunction(level, fn) {
        if(!isProcessing && autoProcess && asyncProcess && batch.size() === 0) {
            // Since this is async, it is guaranteed to be executed after that the fn is added to the batch.
            // This needs to be done before, since we're checking the size of the batch to be 0.
            processBatchAsync();
        }

        batch.add(level, fn);
    }

    function processBatch() {
        // Save the current batch, and create a new batch so that incoming functions are not added into the currently processing batch.
        // Continue processing until the top-level batch is empty (functions may be added to the new batch while processing, and so on).
        isProcessing = true;
        while (batch.size()) {
            var processingBatch = batch;
            batch = Batch();
            processingBatch.process();
        }
        isProcessing = false;
    }

    function forceProcessBatch(localAsyncProcess) {
        if (isProcessing) {
            return;
        }

        if(localAsyncProcess === undefined) {
            localAsyncProcess = asyncProcess;
        }

        if(asyncFrameHandler) {
            cancelFrame(asyncFrameHandler);
            asyncFrameHandler = null;
        }

        if(localAsyncProcess) {
            processBatchAsync();
        } else {
            processBatch();
        }
    }

    function processBatchAsync() {
        asyncFrameHandler = requestFrame(processBatch);
    }

    function clearBatch() {
        batch           = {};
        batchSize       = 0;
        topLevel        = 0;
        bottomLevel     = 0;
    }

    function cancelFrame(listener) {
        // var cancel = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.clearTimeout;
        var cancel = clearTimeout;
        return cancel(listener);
    }

    function requestFrame(callback) {
        // var raf = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || function(fn) { return window.setTimeout(fn, 20); };
        var raf = function(fn) { return setTimeout(fn, 0); };
        return raf(callback);
    }

    return {
        add: addFunction,
        force: forceProcessBatch
    };
};

function Batch() {
    var batch       = {};
    var size        = 0;
    var topLevel    = 0;
    var bottomLevel = 0;

    function add(level, fn) {
        if(!fn) {
            fn = level;
            level = 0;
        }

        if(level > topLevel) {
            topLevel = level;
        } else if(level < bottomLevel) {
            bottomLevel = level;
        }

        if(!batch[level]) {
            batch[level] = [];
        }

        batch[level].push(fn);
        size++;
    }

    function process() {
        for(var level = bottomLevel; level <= topLevel; level++) {
            var fns = batch[level];

            for(var i = 0; i < fns.length; i++) {
                var fn = fns[i];
                fn();
            }
        }
    }

    function getSize() {
        return size;
    }

    return {
        add: add,
        process: process,
        size: getSize
    };
}

},{"./utils":22}],22:[function(require,module,exports){
"use strict";

var utils = module.exports = {};

utils.getOption = getOption;

function getOption(options, name, defaultValue) {
    var value = options[name];

    if((value === undefined || value === null) && defaultValue !== undefined) {
        return defaultValue;
    }

    return value;
}

},{}],23:[function(require,module,exports){
"use strict";

var detector = module.exports = {};

detector.isIE = function(version) {
    function isAnyIeVersion() {
        var agent = navigator.userAgent.toLowerCase();
        return agent.indexOf("msie") !== -1 || agent.indexOf("trident") !== -1 || agent.indexOf(" edge/") !== -1;
    }

    if(!isAnyIeVersion()) {
        return false;
    }

    if(!version) {
        return true;
    }

    //Shamelessly stolen from https://gist.github.com/padolsey/527683
    var ieVersion = (function(){
        var undef,
            v = 3,
            div = document.createElement("div"),
            all = div.getElementsByTagName("i");

        do {
            div.innerHTML = "<!--[if gt IE " + (++v) + "]><i></i><![endif]-->";
        }
        while (all[0]);

        return v > 4 ? v : undef;
    }());

    return version === ieVersion;
};

detector.isLegacyOpera = function() {
    return !!window.opera;
};

},{}],24:[function(require,module,exports){
"use strict";

var utils = module.exports = {};

/**
 * Loops through the collection and calls the callback for each element. if the callback returns truthy, the loop is broken and returns the same value.
 * @public
 * @param {*} collection The collection to loop through. Needs to have a length property set and have indices set from 0 to length - 1.
 * @param {function} callback The callback to be called for each element. The element will be given as a parameter to the callback. If this callback returns truthy, the loop is broken and the same value is returned.
 * @returns {*} The value that a callback has returned (if truthy). Otherwise nothing.
 */
utils.forEach = function(collection, callback) {
    for(var i = 0; i < collection.length; i++) {
        var result = callback(collection[i]);
        if(result) {
            return result;
        }
    }
};

},{}],25:[function(require,module,exports){
/**
 * Resize detection strategy that injects objects to elements in order to detect resize events.
 * Heavily inspired by: http://www.backalleycoder.com/2013/03/18/cross-browser-event-based-element-resize-detection/
 */

"use strict";

var browserDetector = require("../browser-detector");

module.exports = function(options) {
    options             = options || {};
    var reporter        = options.reporter;
    var batchProcessor  = options.batchProcessor;
    var getState        = options.stateHandler.getState;

    if(!reporter) {
        throw new Error("Missing required dependency: reporter.");
    }

    /**
     * Adds a resize event listener to the element.
     * @public
     * @param {element} element The element that should have the listener added.
     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.
     */
    function addListener(element, listener) {
        if(!getObject(element)) {
            throw new Error("Element is not detectable by this strategy.");
        }

        function listenerProxy() {
            listener(element);
        }

        if(browserDetector.isIE(8)) {
            //IE 8 does not support object, but supports the resize event directly on elements.
            getState(element).object = {
                proxy: listenerProxy
            };
            element.attachEvent("onresize", listenerProxy);
        } else {
            var object = getObject(element);
            object.contentDocument.defaultView.addEventListener("resize", listenerProxy);
        }
    }

    /**
     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.
     * @private
     * @param {object} options Optional options object.
     * @param {element} element The element to make detectable
     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.
     */
    function makeDetectable(options, element, callback) {
        if (!callback) {
            callback = element;
            element = options;
            options = null;
        }

        options = options || {};
        var debug = options.debug;

        function injectObject(element, callback) {
            var OBJECT_STYLE = "display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: none; padding: 0; margin: 0; opacity: 0; z-index: -1000; pointer-events: none;";

            //The target element needs to be positioned (everything except static) so the absolute positioned object will be positioned relative to the target element.

            // Position altering may be performed directly or on object load, depending on if style resolution is possible directly or not.
            var positionCheckPerformed = false;

            // The element may not yet be attached to the DOM, and therefore the style object may be empty in some browsers.
            // Since the style object is a reference, it will be updated as soon as the element is attached to the DOM.
            var style = window.getComputedStyle(element);
            var width = element.offsetWidth;
            var height = element.offsetHeight;

            getState(element).startSize = {
                width: width,
                height: height
            };

            function mutateDom() {
                function alterPositionStyles() {
                    if(style.position === "static") {
                        element.style.position = "relative";

                        var removeRelativeStyles = function(reporter, element, style, property) {
                            function getNumericalValue(value) {
                                return value.replace(/[^-\d\.]/g, "");
                            }

                            var value = style[property];

                            if(value !== "auto" && getNumericalValue(value) !== "0") {
                                reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                                element.style[property] = 0;
                            }
                        };

                        //Check so that there are no accidental styles that will make the element styled differently now that is is relative.
                        //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).
                        removeRelativeStyles(reporter, element, style, "top");
                        removeRelativeStyles(reporter, element, style, "right");
                        removeRelativeStyles(reporter, element, style, "bottom");
                        removeRelativeStyles(reporter, element, style, "left");
                    }
                }

                function onObjectLoad() {
                    // The object has been loaded, which means that the element now is guaranteed to be attached to the DOM.
                    if (!positionCheckPerformed) {
                        alterPositionStyles();
                    }

                    /*jshint validthis: true */

                    function getDocument(element, callback) {
                        //Opera 12 seem to call the object.onload before the actual document has been created.
                        //So if it is not present, poll it with an timeout until it is present.
                        //TODO: Could maybe be handled better with object.onreadystatechange or similar.
                        if(!element.contentDocument) {
                            setTimeout(function checkForObjectDocument() {
                                getDocument(element, callback);
                            }, 100);

                            return;
                        }

                        callback(element.contentDocument);
                    }

                    //Mutating the object element here seems to fire another load event.
                    //Mutating the inner document of the object element is fine though.
                    var objectElement = this;

                    //Create the style element to be added to the object.
                    getDocument(objectElement, function onObjectDocumentReady(objectDocument) {
                        //Notify that the element is ready to be listened to.
                        callback(element);
                    });
                }

                // The element may be detached from the DOM, and some browsers does not support style resolving of detached elements.
                // The alterPositionStyles needs to be delayed until we know the element has been attached to the DOM (which we are sure of when the onObjectLoad has been fired), if style resolution is not possible.
                if (style.position !== "") {
                    alterPositionStyles(style);
                    positionCheckPerformed = true;
                }

                //Add an object element as a child to the target element that will be listened to for resize events.
                var object = document.createElement("object");
                object.style.cssText = OBJECT_STYLE;
                object.tabIndex = -1;
                object.type = "text/html";
                object.onload = onObjectLoad;

                //Safari: This must occur before adding the object to the DOM.
                //IE: Does not like that this happens before, even if it is also added after.
                if(!browserDetector.isIE()) {
                    object.data = "about:blank";
                }

                element.appendChild(object);
                getState(element).object = object;

                //IE: This must occur after adding the object to the DOM.
                if(browserDetector.isIE()) {
                    object.data = "about:blank";
                }
            }

            if(batchProcessor) {
                batchProcessor.add(mutateDom);
            } else {
                mutateDom();
            }
        }

        if(browserDetector.isIE(8)) {
            //IE 8 does not support objects properly. Luckily they do support the resize event.
            //So do not inject the object and notify that the element is already ready to be listened to.
            //The event handler for the resize event is attached in the utils.addListener instead.
            callback(element);
        } else {
            injectObject(element, callback);
        }
    }

    /**
     * Returns the child object of the target element.
     * @private
     * @param {element} element The target element.
     * @returns The object element of the target.
     */
    function getObject(element) {
        return getState(element).object;
    }

    function uninstall(element) {
        if(browserDetector.isIE(8)) {
            element.detachEvent("onresize", getState(element).object.proxy);
        } else {
            element.removeChild(getObject(element));
        }
        delete getState(element).object;
    }

    return {
        makeDetectable: makeDetectable,
        addListener: addListener,
        uninstall: uninstall
    };
};

},{"../browser-detector":23}],26:[function(require,module,exports){
/**
 * Resize detection strategy that injects divs to elements in order to detect resize events on scroll events.
 * Heavily inspired by: https://github.com/marcj/css-element-queries/blob/master/src/ResizeSensor.js
 */

"use strict";

var forEach = require("../collection-utils").forEach;

module.exports = function(options) {
    options             = options || {};
    var reporter        = options.reporter;
    var batchProcessor  = options.batchProcessor;
    var getState        = options.stateHandler.getState;
    var hasState        = options.stateHandler.hasState;
    var idHandler       = options.idHandler;

    if (!batchProcessor) {
        throw new Error("Missing required dependency: batchProcessor");
    }

    if (!reporter) {
        throw new Error("Missing required dependency: reporter.");
    }

    //TODO: Could this perhaps be done at installation time?
    var scrollbarSizes = getScrollbarSizes();

    // Inject the scrollbar styling that prevents them from appearing sometimes in Chrome.
    // The injected container needs to have a class, so that it may be styled with CSS (pseudo elements).
    var styleId = "erd_scroll_detection_scrollbar_style";
    var detectionContainerClass = "erd_scroll_detection_container";
    injectScrollStyle(styleId, detectionContainerClass);

    function getScrollbarSizes() {
        var width = 500;
        var height = 500;

        var child = document.createElement("div");
        child.style.cssText = "position: absolute; width: " + width*2 + "px; height: " + height*2 + "px; visibility: hidden; margin: 0; padding: 0;";

        var container = document.createElement("div");
        container.style.cssText = "position: absolute; width: " + width + "px; height: " + height + "px; overflow: scroll; visibility: none; top: " + -width*3 + "px; left: " + -height*3 + "px; visibility: hidden; margin: 0; padding: 0;";

        container.appendChild(child);

        document.body.insertBefore(container, document.body.firstChild);

        var widthSize = width - container.clientWidth;
        var heightSize = height - container.clientHeight;

        document.body.removeChild(container);

        return {
            width: widthSize,
            height: heightSize
        };
    }

    function injectScrollStyle(styleId, containerClass) {
        function injectStyle(style, method) {
            method = method || function (element) {
                document.head.appendChild(element);
            };

            var styleElement = document.createElement("style");
            styleElement.innerHTML = style;
            styleElement.id = styleId;
            method(styleElement);
            return styleElement;
        }

        if (!document.getElementById(styleId)) {
            var containerAnimationClass = containerClass + "_animation";
            var containerAnimationActiveClass = containerClass + "_animation_active";
            var style = "/* Created by the element-resize-detector library. */\n";
            style += "." + containerClass + " > div::-webkit-scrollbar { display: none; }\n\n";
            style += "." + containerAnimationActiveClass + " { -webkit-animation-duration: 0.1s; animation-duration: 0.1s; -webkit-animation-name: " + containerAnimationClass + "; animation-name: " + containerAnimationClass + "; }\n";
            style += "@-webkit-keyframes " + containerAnimationClass +  " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }\n";
            style += "@keyframes " + containerAnimationClass +          " { 0% { opacity: 1; } 50% { opacity: 0; } 100% { opacity: 1; } }";
            injectStyle(style);
        }
    }

    function addAnimationClass(element) {
        element.className += " " + detectionContainerClass + "_animation_active";
    }

    function addEvent(el, name, cb) {
        if (el.addEventListener) {
            el.addEventListener(name, cb);
        } else if(el.attachEvent) {
            el.attachEvent("on" + name, cb);
        } else {
            return reporter.error("[scroll] Don't know how to add event listeners.");
        }
    }

    function removeEvent(el, name, cb) {
        if (el.removeEventListener) {
            el.removeEventListener(name, cb);
        } else if(el.detachEvent) {
            el.detachEvent("on" + name, cb);
        } else {
            return reporter.error("[scroll] Don't know how to remove event listeners.");
        }
    }

    function getExpandElement(element) {
        return getState(element).container.childNodes[0].childNodes[0].childNodes[0];
    }

    function getShrinkElement(element) {
        return getState(element).container.childNodes[0].childNodes[0].childNodes[1];
    }

    /**
     * Adds a resize event listener to the element.
     * @public
     * @param {element} element The element that should have the listener added.
     * @param {function} listener The listener callback to be called for each resize event of the element. The element will be given as a parameter to the listener callback.
     */
    function addListener(element, listener) {
        var listeners = getState(element).listeners;

        if (!listeners.push) {
            throw new Error("Cannot add listener to an element that is not detectable.");
        }

        getState(element).listeners.push(listener);
    }

    /**
     * Makes an element detectable and ready to be listened for resize events. Will call the callback when the element is ready to be listened for resize changes.
     * @private
     * @param {object} options Optional options object.
     * @param {element} element The element to make detectable
     * @param {function} callback The callback to be called when the element is ready to be listened for resize changes. Will be called with the element as first parameter.
     */
    function makeDetectable(options, element, callback) {
        if (!callback) {
            callback = element;
            element = options;
            options = null;
        }

        options = options || {};

        function debug() {
            if (options.debug) {
                var args = Array.prototype.slice.call(arguments);
                args.unshift(idHandler.get(element), "Scroll: ");
                if (reporter.log.apply) {
                    reporter.log.apply(null, args);
                } else {
                    for (var i = 0; i < args.length; i++) {
                        reporter.log(args[i]);
                    }
                }
            }
        }

        function isDetached(element) {
            function isInDocument(element) {
                return element === element.ownerDocument.body || element.ownerDocument.body.contains(element);
            }

            if (!isInDocument(element)) {
                return true;
            }

            // FireFox returns null style in hidden iframes. See https://github.com/wnr/element-resize-detector/issues/68 and https://bugzilla.mozilla.org/show_bug.cgi?id=795520
            if (window.getComputedStyle(element) === null) {
                return true;
            }

            return false;
        }

        function isUnrendered(element) {
            // Check the absolute positioned container since the top level container is display: inline.
            var container = getState(element).container.childNodes[0];
            var style = window.getComputedStyle(container);
            return !style.width || style.width.indexOf("px") === -1; //Can only compute pixel value when rendered.
        }

        function getStyle() {
            // Some browsers only force layouts when actually reading the style properties of the style object, so make sure that they are all read here,
            // so that the user of the function can be sure that it will perform the layout here, instead of later (important for batching).
            var elementStyle            = window.getComputedStyle(element);
            var style                   = {};
            style.position              = elementStyle.position;
            style.width                 = element.offsetWidth;
            style.height                = element.offsetHeight;
            style.top                   = elementStyle.top;
            style.right                 = elementStyle.right;
            style.bottom                = elementStyle.bottom;
            style.left                  = elementStyle.left;
            style.widthCSS              = elementStyle.width;
            style.heightCSS             = elementStyle.height;
            return style;
        }

        function storeStartSize() {
            var style = getStyle();
            getState(element).startSize = {
                width: style.width,
                height: style.height
            };
            debug("Element start size", getState(element).startSize);
        }

        function initListeners() {
            getState(element).listeners = [];
        }

        function storeStyle() {
            debug("storeStyle invoked.");
            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            var style = getStyle();
            getState(element).style = style;
        }

        function storeCurrentSize(element, width, height) {
            getState(element).lastWidth = width;
            getState(element).lastHeight  = height;
        }

        function getExpandChildElement(element) {
            return getExpandElement(element).childNodes[0];
        }

        function getWidthOffset() {
            return 2 * scrollbarSizes.width + 1;
        }

        function getHeightOffset() {
            return 2 * scrollbarSizes.height + 1;
        }

        function getExpandWidth(width) {
            return width + 10 + getWidthOffset();
        }

        function getExpandHeight(height) {
            return height + 10 + getHeightOffset();
        }

        function getShrinkWidth(width) {
            return width * 2 + getWidthOffset();
        }

        function getShrinkHeight(height) {
            return height * 2 + getHeightOffset();
        }

        function positionScrollbars(element, width, height) {
            var expand          = getExpandElement(element);
            var shrink          = getShrinkElement(element);
            var expandWidth     = getExpandWidth(width);
            var expandHeight    = getExpandHeight(height);
            var shrinkWidth     = getShrinkWidth(width);
            var shrinkHeight    = getShrinkHeight(height);
            expand.scrollLeft   = expandWidth;
            expand.scrollTop    = expandHeight;
            shrink.scrollLeft   = shrinkWidth;
            shrink.scrollTop    = shrinkHeight;
        }

        function injectContainerElement() {
            var container = getState(element).container;

            if (!container) {
                container                   = document.createElement("div");
                container.className         = detectionContainerClass;
                container.style.cssText     = "visibility: hidden; display: inline; width: 0px; height: 0px; z-index: -1; overflow: hidden; margin: 0; padding: 0;";
                getState(element).container = container;
                addAnimationClass(container);
                element.appendChild(container);

                var onAnimationStart = function () {
                    getState(element).onRendered && getState(element).onRendered();
                };

                addEvent(container, "animationstart", onAnimationStart);

                // Store the event handler here so that they may be removed when uninstall is called.
                // See uninstall function for an explanation why it is needed.
                getState(element).onAnimationStart = onAnimationStart;
            }

            return container;
        }

        function injectScrollElements() {
            function alterPositionStyles() {
                var style = getState(element).style;

                if(style.position === "static") {
                    element.style.position = "relative";

                    var removeRelativeStyles = function(reporter, element, style, property) {
                        function getNumericalValue(value) {
                            return value.replace(/[^-\d\.]/g, "");
                        }

                        var value = style[property];

                        if(value !== "auto" && getNumericalValue(value) !== "0") {
                            reporter.warn("An element that is positioned static has style." + property + "=" + value + " which is ignored due to the static positioning. The element will need to be positioned relative, so the style." + property + " will be set to 0. Element: ", element);
                            element.style[property] = 0;
                        }
                    };

                    //Check so that there are no accidental styles that will make the element styled differently now that is is relative.
                    //If there are any, set them to 0 (this should be okay with the user since the style properties did nothing before [since the element was positioned static] anyway).
                    removeRelativeStyles(reporter, element, style, "top");
                    removeRelativeStyles(reporter, element, style, "right");
                    removeRelativeStyles(reporter, element, style, "bottom");
                    removeRelativeStyles(reporter, element, style, "left");
                }
            }

            function getLeftTopBottomRightCssText(left, top, bottom, right) {
                left = (!left ? "0" : (left + "px"));
                top = (!top ? "0" : (top + "px"));
                bottom = (!bottom ? "0" : (bottom + "px"));
                right = (!right ? "0" : (right + "px"));

                return "left: " + left + "; top: " + top + "; right: " + right + "; bottom: " + bottom + ";";
            }

            debug("Injecting elements");

            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            alterPositionStyles();

            var rootContainer = getState(element).container;

            if (!rootContainer) {
                rootContainer = injectContainerElement();
            }

            // Due to this WebKit bug https://bugs.webkit.org/show_bug.cgi?id=80808 (currently fixed in Blink, but still present in WebKit browsers such as Safari),
            // we need to inject two containers, one that is width/height 100% and another that is left/top -1px so that the final container always is 1x1 pixels bigger than
            // the targeted element.
            // When the bug is resolved, "containerContainer" may be removed.

            // The outer container can occasionally be less wide than the targeted when inside inline elements element in WebKit (see https://bugs.webkit.org/show_bug.cgi?id=152980).
            // This should be no problem since the inner container either way makes sure the injected scroll elements are at least 1x1 px.

            var scrollbarWidth          = scrollbarSizes.width;
            var scrollbarHeight         = scrollbarSizes.height;
            var containerContainerStyle = "position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; width: 100%; height: 100%; left: 0px; top: 0px;";
            var containerStyle          = "position: absolute; flex: none; overflow: hidden; z-index: -1; visibility: hidden; " + getLeftTopBottomRightCssText(-(1 + scrollbarWidth), -(1 + scrollbarHeight), -scrollbarHeight, -scrollbarWidth);
            var expandStyle             = "position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;";
            var shrinkStyle             = "position: absolute; flex: none; overflow: scroll; z-index: -1; visibility: hidden; width: 100%; height: 100%;";
            var expandChildStyle        = "position: absolute; left: 0; top: 0;";
            var shrinkChildStyle        = "position: absolute; width: 200%; height: 200%;";

            var containerContainer      = document.createElement("div");
            var container               = document.createElement("div");
            var expand                  = document.createElement("div");
            var expandChild             = document.createElement("div");
            var shrink                  = document.createElement("div");
            var shrinkChild             = document.createElement("div");

            // Some browsers choke on the resize system being rtl, so force it to ltr. https://github.com/wnr/element-resize-detector/issues/56
            // However, dir should not be set on the top level container as it alters the dimensions of the target element in some browsers.
            containerContainer.dir              = "ltr";

            containerContainer.style.cssText    = containerContainerStyle;
            containerContainer.className        = detectionContainerClass;
            container.className                 = detectionContainerClass;
            container.style.cssText             = containerStyle;
            expand.style.cssText                = expandStyle;
            expandChild.style.cssText           = expandChildStyle;
            shrink.style.cssText                = shrinkStyle;
            shrinkChild.style.cssText           = shrinkChildStyle;

            expand.appendChild(expandChild);
            shrink.appendChild(shrinkChild);
            container.appendChild(expand);
            container.appendChild(shrink);
            containerContainer.appendChild(container);
            rootContainer.appendChild(containerContainer);

            function onExpandScroll() {
                getState(element).onExpand && getState(element).onExpand();
            }

            function onShrinkScroll() {
                getState(element).onShrink && getState(element).onShrink();
            }

            addEvent(expand, "scroll", onExpandScroll);
            addEvent(shrink, "scroll", onShrinkScroll);

            // Store the event handlers here so that they may be removed when uninstall is called.
            // See uninstall function for an explanation why it is needed.
            getState(element).onExpandScroll = onExpandScroll;
            getState(element).onShrinkScroll = onShrinkScroll;
        }

        function registerListenersAndPositionElements() {
            function updateChildSizes(element, width, height) {
                var expandChild             = getExpandChildElement(element);
                var expandWidth             = getExpandWidth(width);
                var expandHeight            = getExpandHeight(height);
                expandChild.style.width     = expandWidth + "px";
                expandChild.style.height    = expandHeight + "px";
            }

            function updateDetectorElements(done) {
                var width           = element.offsetWidth;
                var height          = element.offsetHeight;

                debug("Storing current size", width, height);

                // Store the size of the element sync here, so that multiple scroll events may be ignored in the event listeners.
                // Otherwise the if-check in handleScroll is useless.
                storeCurrentSize(element, width, height);

                // Since we delay the processing of the batch, there is a risk that uninstall has been called before the batch gets to execute.
                // Since there is no way to cancel the fn executions, we need to add an uninstall guard to all fns of the batch.

                batchProcessor.add(0, function performUpdateChildSizes() {
                    if (!getState(element)) {
                        debug("Aborting because element has been uninstalled");
                        return;
                    }

                    if (!areElementsInjected()) {
                        debug("Aborting because element container has not been initialized");
                        return;
                    }

                    if (options.debug) {
                        var w = element.offsetWidth;
                        var h = element.offsetHeight;

                        if (w !== width || h !== height) {
                            reporter.warn(idHandler.get(element), "Scroll: Size changed before updating detector elements.");
                        }
                    }

                    updateChildSizes(element, width, height);
                });

                batchProcessor.add(1, function updateScrollbars() {
                    if (!getState(element)) {
                        debug("Aborting because element has been uninstalled");
                        return;
                    }

                    if (!areElementsInjected()) {
                        debug("Aborting because element container has not been initialized");
                        return;
                    }

                    positionScrollbars(element, width, height);
                });

                if (done) {
                    batchProcessor.add(2, function () {
                        if (!getState(element)) {
                            debug("Aborting because element has been uninstalled");
                            return;
                        }

                        if (!areElementsInjected()) {
                          debug("Aborting because element container has not been initialized");
                          return;
                        }

                        done();
                    });
                }
            }

            function areElementsInjected() {
                return !!getState(element).container;
            }

            function notifyListenersIfNeeded() {
                function isFirstNotify() {
                    return getState(element).lastNotifiedWidth === undefined;
                }

                debug("notifyListenersIfNeeded invoked");

                var state = getState(element);

                // Don't notify the if the current size is the start size, and this is the first notification.
                if (isFirstNotify() && state.lastWidth === state.startSize.width && state.lastHeight === state.startSize.height) {
                    return debug("Not notifying: Size is the same as the start size, and there has been no notification yet.");
                }

                // Don't notify if the size already has been notified.
                if (state.lastWidth === state.lastNotifiedWidth && state.lastHeight === state.lastNotifiedHeight) {
                    return debug("Not notifying: Size already notified");
                }


                debug("Current size not notified, notifying...");
                state.lastNotifiedWidth = state.lastWidth;
                state.lastNotifiedHeight = state.lastHeight;
                forEach(getState(element).listeners, function (listener) {
                    listener(element);
                });
            }

            function handleRender() {
                debug("startanimation triggered.");

                if (isUnrendered(element)) {
                    debug("Ignoring since element is still unrendered...");
                    return;
                }

                debug("Element rendered.");
                var expand = getExpandElement(element);
                var shrink = getShrinkElement(element);
                if (expand.scrollLeft === 0 || expand.scrollTop === 0 || shrink.scrollLeft === 0 || shrink.scrollTop === 0) {
                    debug("Scrollbars out of sync. Updating detector elements...");
                    updateDetectorElements(notifyListenersIfNeeded);
                }
            }

            function handleScroll() {
                debug("Scroll detected.");

                if (isUnrendered(element)) {
                    // Element is still unrendered. Skip this scroll event.
                    debug("Scroll event fired while unrendered. Ignoring...");
                    return;
                }

                var width = element.offsetWidth;
                var height = element.offsetHeight;

                if (width !== getState(element).lastWidth || height !== getState(element).lastHeight) {
                    debug("Element size changed.");
                    updateDetectorElements(notifyListenersIfNeeded);
                } else {
                    debug("Element size has not changed (" + width + "x" + height + ").");
                }
            }

            debug("registerListenersAndPositionElements invoked.");

            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            getState(element).onRendered = handleRender;
            getState(element).onExpand = handleScroll;
            getState(element).onShrink = handleScroll;

            var style = getState(element).style;
            updateChildSizes(element, style.width, style.height);
        }

        function finalizeDomMutation() {
            debug("finalizeDomMutation invoked.");

            if (!getState(element)) {
                debug("Aborting because element has been uninstalled");
                return;
            }

            var style = getState(element).style;
            storeCurrentSize(element, style.width, style.height);
            positionScrollbars(element, style.width, style.height);
        }

        function ready() {
            callback(element);
        }

        function install() {
            debug("Installing...");
            initListeners();
            storeStartSize();

            batchProcessor.add(0, storeStyle);
            batchProcessor.add(1, injectScrollElements);
            batchProcessor.add(2, registerListenersAndPositionElements);
            batchProcessor.add(3, finalizeDomMutation);
            batchProcessor.add(4, ready);
        }

        debug("Making detectable...");

        if (isDetached(element)) {
            debug("Element is detached");

            injectContainerElement();

            debug("Waiting until element is attached...");

            getState(element).onRendered = function () {
                debug("Element is now attached");
                install();
            };
        } else {
            install();
        }
    }

    function uninstall(element) {
        var state = getState(element);

        if (!state) {
            // Uninstall has been called on a non-erd element.
            return;
        }

        // Uninstall may have been called in the following scenarios:
        // (1) Right between the sync code and async batch (here state.busy = true, but nothing have been registered or injected).
        // (2) In the ready callback of the last level of the batch by another element (here, state.busy = true, but all the stuff has been injected).
        // (3) After the installation process (here, state.busy = false and all the stuff has been injected).
        // So to be on the safe side, let's check for each thing before removing.

        // We need to remove the event listeners, because otherwise the event might fire on an uninstall element which results in an error when trying to get the state of the element.
        state.onExpandScroll && removeEvent(getExpandElement(element), "scroll", state.onExpandScroll);
        state.onShrinkScroll && removeEvent(getShrinkElement(element), "scroll", state.onShrinkScroll);
        state.onAnimationStart && removeEvent(state.container, "animationstart", state.onAnimationStart);

        state.container && element.removeChild(state.container);
    }

    return {
        makeDetectable: makeDetectable,
        addListener: addListener,
        uninstall: uninstall
    };
};

},{"../collection-utils":24}],27:[function(require,module,exports){
"use strict";

var forEach                 = require("./collection-utils").forEach;
var elementUtilsMaker       = require("./element-utils");
var listenerHandlerMaker    = require("./listener-handler");
var idGeneratorMaker        = require("./id-generator");
var idHandlerMaker          = require("./id-handler");
var reporterMaker           = require("./reporter");
var browserDetector         = require("./browser-detector");
var batchProcessorMaker     = require("batch-processor");
var stateHandler            = require("./state-handler");

//Detection strategies.
var objectStrategyMaker     = require("./detection-strategy/object.js");
var scrollStrategyMaker     = require("./detection-strategy/scroll.js");

function isCollection(obj) {
    return Array.isArray(obj) || obj.length !== undefined;
}

function toArray(collection) {
    if (!Array.isArray(collection)) {
        var array = [];
        forEach(collection, function (obj) {
            array.push(obj);
        });
        return array;
    } else {
        return collection;
    }
}

function isElement(obj) {
    return obj && obj.nodeType === 1;
}

/**
 * @typedef idHandler
 * @type {object}
 * @property {function} get Gets the resize detector id of the element.
 * @property {function} set Generate and sets the resize detector id of the element.
 */

/**
 * @typedef Options
 * @type {object}
 * @property {boolean} callOnAdd    Determines if listeners should be called when they are getting added.
                                    Default is true. If true, the listener is guaranteed to be called when it has been added.
                                    If false, the listener will not be guarenteed to be called when it has been added (does not prevent it from being called).
 * @property {idHandler} idHandler  A custom id handler that is responsible for generating, setting and retrieving id's for elements.
                                    If not provided, a default id handler will be used.
 * @property {reporter} reporter    A custom reporter that handles reporting logs, warnings and errors.
                                    If not provided, a default id handler will be used.
                                    If set to false, then nothing will be reported.
 * @property {boolean} debug        If set to true, the the system will report debug messages as default for the listenTo method.
 */

/**
 * Creates an element resize detector instance.
 * @public
 * @param {Options?} options Optional global options object that will decide how this instance will work.
 */
module.exports = function(options) {
    options = options || {};

    //idHandler is currently not an option to the listenTo function, so it should not be added to globalOptions.
    var idHandler;

    if (options.idHandler) {
        // To maintain compatability with idHandler.get(element, readonly), make sure to wrap the given idHandler
        // so that readonly flag always is true when it's used here. This may be removed next major version bump.
        idHandler = {
            get: function (element) { return options.idHandler.get(element, true); },
            set: options.idHandler.set
        };
    } else {
        var idGenerator = idGeneratorMaker();
        var defaultIdHandler = idHandlerMaker({
            idGenerator: idGenerator,
            stateHandler: stateHandler
        });
        idHandler = defaultIdHandler;
    }

    //reporter is currently not an option to the listenTo function, so it should not be added to globalOptions.
    var reporter = options.reporter;

    if(!reporter) {
        //If options.reporter is false, then the reporter should be quiet.
        var quiet = reporter === false;
        reporter = reporterMaker(quiet);
    }

    //batchProcessor is currently not an option to the listenTo function, so it should not be added to globalOptions.
    var batchProcessor = getOption(options, "batchProcessor", batchProcessorMaker({ reporter: reporter }));

    //Options to be used as default for the listenTo function.
    var globalOptions = {};
    globalOptions.callOnAdd     = !!getOption(options, "callOnAdd", true);
    globalOptions.debug         = !!getOption(options, "debug", false);

    var eventListenerHandler    = listenerHandlerMaker(idHandler);
    var elementUtils            = elementUtilsMaker({
        stateHandler: stateHandler
    });

    //The detection strategy to be used.
    var detectionStrategy;
    var desiredStrategy = getOption(options, "strategy", "object");
    var strategyOptions = {
        reporter: reporter,
        batchProcessor: batchProcessor,
        stateHandler: stateHandler,
        idHandler: idHandler
    };

    if(desiredStrategy === "scroll") {
        if (browserDetector.isLegacyOpera()) {
            reporter.warn("Scroll strategy is not supported on legacy Opera. Changing to object strategy.");
            desiredStrategy = "object";
        } else if (browserDetector.isIE(9)) {
            reporter.warn("Scroll strategy is not supported on IE9. Changing to object strategy.");
            desiredStrategy = "object";
        }
    }

    if(desiredStrategy === "scroll") {
        detectionStrategy = scrollStrategyMaker(strategyOptions);
    } else if(desiredStrategy === "object") {
        detectionStrategy = objectStrategyMaker(strategyOptions);
    } else {
        throw new Error("Invalid strategy name: " + desiredStrategy);
    }

    //Calls can be made to listenTo with elements that are still being installed.
    //Also, same elements can occur in the elements list in the listenTo function.
    //With this map, the ready callbacks can be synchronized between the calls
    //so that the ready callback can always be called when an element is ready - even if
    //it wasn't installed from the function itself.
    var onReadyCallbacks = {};

    /**
     * Makes the given elements resize-detectable and starts listening to resize events on the elements. Calls the event callback for each event for each element.
     * @public
     * @param {Options?} options Optional options object. These options will override the global options. Some options may not be overriden, such as idHandler.
     * @param {element[]|element} elements The given array of elements to detect resize events of. Single element is also valid.
     * @param {function} listener The callback to be executed for each resize event for each element.
     */
    function listenTo(options, elements, listener) {
        function onResizeCallback(element) {
            var listeners = eventListenerHandler.get(element);
            forEach(listeners, function callListenerProxy(listener) {
                listener(element);
            });
        }

        function addListener(callOnAdd, element, listener) {
            eventListenerHandler.add(element, listener);

            if(callOnAdd) {
                listener(element);
            }
        }

        //Options object may be omitted.
        if(!listener) {
            listener = elements;
            elements = options;
            options = {};
        }

        if(!elements) {
            throw new Error("At least one element required.");
        }

        if(!listener) {
            throw new Error("Listener required.");
        }

        if (isElement(elements)) {
            // A single element has been passed in.
            elements = [elements];
        } else if (isCollection(elements)) {
            // Convert collection to array for plugins.
            // TODO: May want to check so that all the elements in the collection are valid elements.
            elements = toArray(elements);
        } else {
            return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }

        var elementsReady = 0;

        var callOnAdd = getOption(options, "callOnAdd", globalOptions.callOnAdd);
        var onReadyCallback = getOption(options, "onReady", function noop() {});
        var debug = getOption(options, "debug", globalOptions.debug);

        forEach(elements, function attachListenerToElement(element) {
            if (!stateHandler.getState(element)) {
                stateHandler.initState(element);
                idHandler.set(element);
            }

            var id = idHandler.get(element);

            debug && reporter.log("Attaching listener to element", id, element);

            if(!elementUtils.isDetectable(element)) {
                debug && reporter.log(id, "Not detectable.");
                if(elementUtils.isBusy(element)) {
                    debug && reporter.log(id, "System busy making it detectable");

                    //The element is being prepared to be detectable. Do not make it detectable.
                    //Just add the listener, because the element will soon be detectable.
                    addListener(callOnAdd, element, listener);
                    onReadyCallbacks[id] = onReadyCallbacks[id] || [];
                    onReadyCallbacks[id].push(function onReady() {
                        elementsReady++;

                        if(elementsReady === elements.length) {
                            onReadyCallback();
                        }
                    });
                    return;
                }

                debug && reporter.log(id, "Making detectable...");
                //The element is not prepared to be detectable, so do prepare it and add a listener to it.
                elementUtils.markBusy(element, true);
                return detectionStrategy.makeDetectable({ debug: debug }, element, function onElementDetectable(element) {
                    debug && reporter.log(id, "onElementDetectable");

                    if (stateHandler.getState(element)) {
                        elementUtils.markAsDetectable(element);
                        elementUtils.markBusy(element, false);
                        detectionStrategy.addListener(element, onResizeCallback);
                        addListener(callOnAdd, element, listener);

                        // Since the element size might have changed since the call to "listenTo", we need to check for this change,
                        // so that a resize event may be emitted.
                        // Having the startSize object is optional (since it does not make sense in some cases such as unrendered elements), so check for its existance before.
                        // Also, check the state existance before since the element may have been uninstalled in the installation process.
                        var state = stateHandler.getState(element);
                        if (state && state.startSize) {
                            var width = element.offsetWidth;
                            var height = element.offsetHeight;
                            if (state.startSize.width !== width || state.startSize.height !== height) {
                                onResizeCallback(element);
                            }
                        }

                        if(onReadyCallbacks[id]) {
                            forEach(onReadyCallbacks[id], function(callback) {
                                callback();
                            });
                        }
                    } else {
                        // The element has been unisntalled before being detectable.
                        debug && reporter.log(id, "Element uninstalled before being detectable.");
                    }

                    delete onReadyCallbacks[id];

                    elementsReady++;
                    if(elementsReady === elements.length) {
                        onReadyCallback();
                    }
                });
            }

            debug && reporter.log(id, "Already detecable, adding listener.");

            //The element has been prepared to be detectable and is ready to be listened to.
            addListener(callOnAdd, element, listener);
            elementsReady++;
        });

        if(elementsReady === elements.length) {
            onReadyCallback();
        }
    }

    function uninstall(elements) {
        if(!elements) {
            return reporter.error("At least one element is required.");
        }

        if (isElement(elements)) {
            // A single element has been passed in.
            elements = [elements];
        } else if (isCollection(elements)) {
            // Convert collection to array for plugins.
            // TODO: May want to check so that all the elements in the collection are valid elements.
            elements = toArray(elements);
        } else {
            return reporter.error("Invalid arguments. Must be a DOM element or a collection of DOM elements.");
        }

        forEach(elements, function (element) {
            eventListenerHandler.removeAllListeners(element);
            detectionStrategy.uninstall(element);
            stateHandler.cleanState(element);
        });
    }

    return {
        listenTo: listenTo,
        removeListener: eventListenerHandler.removeListener,
        removeAllListeners: eventListenerHandler.removeAllListeners,
        uninstall: uninstall
    };
};

function getOption(options, name, defaultValue) {
    var value = options[name];

    if((value === undefined || value === null) && defaultValue !== undefined) {
        return defaultValue;
    }

    return value;
}

},{"./browser-detector":23,"./collection-utils":24,"./detection-strategy/object.js":25,"./detection-strategy/scroll.js":26,"./element-utils":28,"./id-generator":29,"./id-handler":30,"./listener-handler":31,"./reporter":32,"./state-handler":33,"batch-processor":21}],28:[function(require,module,exports){
"use strict";

module.exports = function(options) {
    var getState = options.stateHandler.getState;

    /**
     * Tells if the element has been made detectable and ready to be listened for resize events.
     * @public
     * @param {element} The element to check.
     * @returns {boolean} True or false depending on if the element is detectable or not.
     */
    function isDetectable(element) {
        var state = getState(element);
        return state && !!state.isDetectable;
    }

    /**
     * Marks the element that it has been made detectable and ready to be listened for resize events.
     * @public
     * @param {element} The element to mark.
     */
    function markAsDetectable(element) {
        getState(element).isDetectable = true;
    }

    /**
     * Tells if the element is busy or not.
     * @public
     * @param {element} The element to check.
     * @returns {boolean} True or false depending on if the element is busy or not.
     */
    function isBusy(element) {
        return !!getState(element).busy;
    }

    /**
     * Marks the object is busy and should not be made detectable.
     * @public
     * @param {element} element The element to mark.
     * @param {boolean} busy If the element is busy or not.
     */
    function markBusy(element, busy) {
        getState(element).busy = !!busy;
    }

    return {
        isDetectable: isDetectable,
        markAsDetectable: markAsDetectable,
        isBusy: isBusy,
        markBusy: markBusy
    };
};

},{}],29:[function(require,module,exports){
"use strict";

module.exports = function() {
    var idCount = 1;

    /**
     * Generates a new unique id in the context.
     * @public
     * @returns {number} A unique id in the context.
     */
    function generate() {
        return idCount++;
    }

    return {
        generate: generate
    };
};

},{}],30:[function(require,module,exports){
"use strict";

module.exports = function(options) {
    var idGenerator     = options.idGenerator;
    var getState        = options.stateHandler.getState;

    /**
     * Gets the resize detector id of the element.
     * @public
     * @param {element} element The target element to get the id of.
     * @returns {string|number|null} The id of the element. Null if it has no id.
     */
    function getId(element) {
        var state = getState(element);

        if (state && state.id !== undefined) {
            return state.id;
        }

        return null;
    }

    /**
     * Sets the resize detector id of the element. Requires the element to have a resize detector state initialized.
     * @public
     * @param {element} element The target element to set the id of.
     * @returns {string|number|null} The id of the element.
     */
    function setId(element) {
        var state = getState(element);

        if (!state) {
            throw new Error("setId required the element to have a resize detection state.");
        }

        var id = idGenerator.generate();

        state.id = id;

        return id;
    }

    return {
        get: getId,
        set: setId
    };
};

},{}],31:[function(require,module,exports){
"use strict";

module.exports = function(idHandler) {
    var eventListeners = {};

    /**
     * Gets all listeners for the given element.
     * @public
     * @param {element} element The element to get all listeners for.
     * @returns All listeners for the given element.
     */
    function getListeners(element) {
        var id = idHandler.get(element);

        if (id === undefined) {
            return [];
        }

        return eventListeners[id] || [];
    }

    /**
     * Stores the given listener for the given element. Will not actually add the listener to the element.
     * @public
     * @param {element} element The element that should have the listener added.
     * @param {function} listener The callback that the element has added.
     */
    function addListener(element, listener) {
        var id = idHandler.get(element);

        if(!eventListeners[id]) {
            eventListeners[id] = [];
        }

        eventListeners[id].push(listener);
    }

    function removeListener(element, listener) {
        var listeners = getListeners(element);
        for (var i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              break;
            }
        }
    }

    function removeAllListeners(element) {
      var listeners = getListeners(element);
      if (!listeners) { return; }
      listeners.length = 0;
    }

    return {
        get: getListeners,
        add: addListener,
        removeListener: removeListener,
        removeAllListeners: removeAllListeners
    };
};

},{}],32:[function(require,module,exports){
"use strict";

/* global console: false */

/**
 * Reporter that handles the reporting of logs, warnings and errors.
 * @public
 * @param {boolean} quiet Tells if the reporter should be quiet or not.
 */
module.exports = function(quiet) {
    function noop() {
        //Does nothing.
    }

    var reporter = {
        log: noop,
        warn: noop,
        error: noop
    };

    if(!quiet && window.console) {
        var attachFunction = function(reporter, name) {
            //The proxy is needed to be able to call the method with the console context,
            //since we cannot use bind.
            reporter[name] = function reporterProxy() {
                var f = console[name];
                if (f.apply) { //IE9 does not support console.log.apply :)
                    f.apply(console, arguments);
                } else {
                    for (var i = 0; i < arguments.length; i++) {
                        f(arguments[i]);
                    }
                }
            };
        };

        attachFunction(reporter, "log");
        attachFunction(reporter, "warn");
        attachFunction(reporter, "error");
    }

    return reporter;
};
},{}],33:[function(require,module,exports){
"use strict";

var prop = "_erd";

function initState(element) {
    element[prop] = {};
    return getState(element);
}

function getState(element) {
    return element[prop];
}

function cleanState(element) {
    delete element[prop];
}

module.exports = {
    initState: initState,
    getState: getState,
    cleanState: cleanState
};

},{}],34:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v3.3.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2018-01-20T17:24Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		noModule: true
	};

	function DOMEval( code, doc, node ) {
		doc = doc || document;

		var i,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {
				if ( node[ i ] ) {
					script[ i ] = node[ i ];
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.3.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && Array.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {

		/* eslint-disable no-unused-vars */
		// See https://github.com/eslint/eslint/issues/6125
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		DOMEval( code );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	disabledAncestor = addCombinator(
		function( elem ) {
			return elem.disabled === true && ("form" in elem || "label" in elem);
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						disabledAncestor( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
        if ( nodeName( elem, "iframe" ) ) {
            return elem.contentDocument;
        }

        // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
        // Treat the template element as a regular one in browsers that
        // don't support it.
        if ( nodeName( elem, "template" ) ) {
            elem = elem.content || elem;
        }

        return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			jQuery.contains( elem.ownerDocument, elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]+)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();
var documentElement = document.documentElement;



var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 only
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), doc, node );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		div.style.position = "absolute";
		scrollboxSizeVal = div.offsetWidth === 36 || "absolute";

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a property mapped along what jQuery.cssProps suggests or to
// a vendor prefixed property.
function finalPropName( name ) {
	var ret = jQuery.cssProps[ name ];
	if ( !ret ) {
		ret = jQuery.cssProps[ name ] = vendorPropName( name ) || name;
	}
	return ret;
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5
		) );
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),
		val = curCSS( elem, dimension, styles ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox;

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}

	// Check for style in case a browser which returns unreliable values
	// for getComputedStyle silently falls back to the reliable elem.style
	valueIsBorderBox = valueIsBorderBox &&
		( support.boxSizingReliable() || val === elem.style[ dimension ] );

	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	if ( val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) {

		val = elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ];

		// offsetWidth/offsetHeight provide border-box values
		valueIsBorderBox = true;
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),
				isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra && boxModelAdjustment(
					elem,
					dimension,
					extra,
					isBorderBox,
					styles
				);

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && support.scrollboxSize() === styles.position ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{}],35:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],36:[function(require,module,exports){
(function (global){
//     Underscore.js 1.9.1
//     http://underscorejs.org
//     (c) 2009-2018 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` (`self`) in the browser, `global`
  // on the server, or `this` in some virtual machines. We use `self`
  // instead of `window` for `WebWorker` support.
  var root = typeof self == 'object' && self.self === self && self ||
            typeof global == 'object' && global.global === global && global ||
            this ||
            {};

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype;
  var SymbolProto = typeof Symbol !== 'undefined' ? Symbol.prototype : null;

  // Create quick reference variables for speed access to core prototypes.
  var push = ArrayProto.push,
      slice = ArrayProto.slice,
      toString = ObjProto.toString,
      hasOwnProperty = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var nativeIsArray = Array.isArray,
      nativeKeys = Object.keys,
      nativeCreate = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for their old module API. If we're in
  // the browser, add `_` as a global object.
  // (`nodeType` is checked to ensure that `module`
  // and `exports` are not HTML elements.)
  if (typeof exports != 'undefined' && !exports.nodeType) {
    if (typeof module != 'undefined' && !module.nodeType && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.9.1';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      // The 2-argument case is omitted because we’re not using it.
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  var builtinIteratee;

  // An internal function to generate callbacks that can be applied to each
  // element in a collection, returning the desired result — either `identity`,
  // an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (_.iteratee !== builtinIteratee) return _.iteratee(value, context);
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value) && !_.isArray(value)) return _.matcher(value);
    return _.property(value);
  };

  // External wrapper for our callback generator. Users may customize
  // `_.iteratee` if they want additional predicate/iteratee shorthand styles.
  // This abstraction hides the internal-only argCount argument.
  _.iteratee = builtinIteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // Some functions take a variable number of arguments, or a few expected
  // arguments at the beginning and then a variable number of values to operate
  // on. This helper accumulates all remaining arguments past the function’s
  // argument length (or an explicit `startIndex`), into an array that becomes
  // the last argument. Similar to ES6’s "rest parameter".
  var restArguments = function(func, startIndex) {
    startIndex = startIndex == null ? func.length - 1 : +startIndex;
    return function() {
      var length = Math.max(arguments.length - startIndex, 0),
          rest = Array(length),
          index = 0;
      for (; index < length; index++) {
        rest[index] = arguments[index + startIndex];
      }
      switch (startIndex) {
        case 0: return func.call(this, rest);
        case 1: return func.call(this, arguments[0], rest);
        case 2: return func.call(this, arguments[0], arguments[1], rest);
      }
      var args = Array(startIndex + 1);
      for (index = 0; index < startIndex; index++) {
        args[index] = arguments[index];
      }
      args[startIndex] = rest;
      return func.apply(this, args);
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var shallowProperty = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  var has = function(obj, path) {
    return obj != null && hasOwnProperty.call(obj, path);
  }

  var deepGet = function(obj, path) {
    var length = path.length;
    for (var i = 0; i < length; i++) {
      if (obj == null) return void 0;
      obj = obj[path[i]];
    }
    return length ? obj : void 0;
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object.
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = shallowProperty('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  var createReduce = function(dir) {
    // Wrap code that reassigns argument variables in a separate function than
    // the one that accesses `arguments.length` to avoid a perf hit. (#1991)
    var reducer = function(obj, iteratee, memo, initial) {
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      if (!initial) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    };

    return function(obj, iteratee, memo, context) {
      var initial = arguments.length >= 3;
      return reducer(obj, optimizeCb(iteratee, context, 4), memo, initial);
    };
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var keyFinder = isArrayLike(obj) ? _.findIndex : _.findKey;
    var key = keyFinder(obj, predicate, context);
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = restArguments(function(obj, path, args) {
    var contextPath, func;
    if (_.isFunction(path)) {
      func = path;
    } else if (_.isArray(path)) {
      contextPath = path.slice(0, -1);
      path = path[path.length - 1];
    }
    return _.map(obj, function(context) {
      var method = func;
      if (!method) {
        if (contextPath && contextPath.length) {
          context = deepGet(context, contextPath);
        }
        if (context == null) return void 0;
        method = context[path];
      }
      return method == null ? method : method.apply(context, args);
    });
  });

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null || typeof iteratee == 'number' && typeof obj[0] != 'object' && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value != null && value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(v, index, list) {
        computed = iteratee(v, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = v;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection.
  _.shuffle = function(obj) {
    return _.sample(obj, Infinity);
  };

  // Sample **n** random values from a collection using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    var sample = isArrayLike(obj) ? _.clone(obj) : _.values(obj);
    var length = getLength(sample);
    n = Math.max(Math.min(n, length), 0);
    var last = length - 1;
    for (var index = 0; index < n; index++) {
      var rand = _.random(index, last);
      var temp = sample[index];
      sample[index] = sample[rand];
      sample[rand] = temp;
    }
    return sample.slice(0, n);
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    var index = 0;
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, key, list) {
      return {
        value: value,
        index: index++,
        criteria: iteratee(value, key, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior, partition) {
    return function(obj, iteratee, context) {
      var result = partition ? [[], []] : {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (has(result, key)) result[key]++; else result[key] = 1;
  });

  var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (_.isString(obj)) {
      // Keep surrogate pair characters together
      return obj.match(reStrSymbol);
    }
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = group(function(result, value, pass) {
    result[pass ? 0 : 1].push(value);
  }, true);

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null || array.length < 1) return n == null ? void 0 : [];
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, Boolean);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, output) {
    output = output || [];
    var idx = output.length;
    for (var i = 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        // Flatten current level of array or arguments object.
        if (shallow) {
          var j = 0, len = value.length;
          while (j < len) output[idx++] = value[j++];
        } else {
          flatten(value, shallow, strict, output);
          idx = output.length;
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = restArguments(function(array, otherArrays) {
    return _.difference(array, otherArrays);
  });

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // The faster algorithm will not work with an iteratee if the iteratee
  // is not a one-to-one function, so providing an iteratee will disable
  // the faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted && !iteratee) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = restArguments(function(arrays) {
    return _.uniq(flatten(arrays, true, true));
  });

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      var j;
      for (j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = restArguments(function(array, rest) {
    rest = flatten(rest, true, true);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  });

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices.
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = restArguments(_.unzip);

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values. Passing by pairs is the reverse of _.pairs.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions.
  var createPredicateIndexFinder = function(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  };

  // Returns the first index on an array-like that passes a predicate test.
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions.
  var createIndexFinder = function(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
          i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
          length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  };

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    if (!step) {
      step = stop < start ? -1 : 1;
    }

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Chunk a single array into multiple arrays, each containing `count` or fewer
  // items.
  _.chunk = function(array, count) {
    if (count == null || count < 1) return [];
    var result = [];
    var i = 0, length = array.length;
    while (i < length) {
      result.push(slice.call(array, i, i += count));
    }
    return result;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments.
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = restArguments(function(func, context, args) {
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var bound = restArguments(function(callArgs) {
      return executeBound(func, bound, context, this, args.concat(callArgs));
    });
    return bound;
  });

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder by default, allowing any combination of arguments to be
  // pre-filled. Set `_.partial.placeholder` for a custom placeholder argument.
  _.partial = restArguments(function(func, boundArgs) {
    var placeholder = _.partial.placeholder;
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  });

  _.partial.placeholder = _;

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = restArguments(function(obj, keys) {
    keys = flatten(keys, false, false);
    var index = keys.length;
    if (index < 1) throw new Error('bindAll must be passed function names');
    while (index--) {
      var key = keys[index];
      obj[key] = _.bind(obj[key], obj);
    }
  });

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = restArguments(function(func, wait, args) {
    return setTimeout(function() {
      return func.apply(null, args);
    }, wait);
  });

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var timeout, context, args, result;
    var previous = 0;
    if (!options) options = {};

    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };

    var throttled = function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };

    throttled.cancel = function() {
      clearTimeout(timeout);
      previous = 0;
      timeout = context = args = null;
    };

    return throttled;
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;

    var later = function(context, args) {
      timeout = null;
      if (args) result = func.apply(context, args);
    };

    var debounced = restArguments(function(args) {
      if (timeout) clearTimeout(timeout);
      if (immediate) {
        var callNow = !timeout;
        timeout = setTimeout(later, wait);
        if (callNow) result = func.apply(this, args);
      } else {
        timeout = _.delay(later, wait, this, args);
      }

      return result;
    });

    debounced.cancel = function() {
      clearTimeout(timeout);
      timeout = null;
    };

    return debounced;
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  _.restArguments = restArguments;

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
    'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var collectNonEnumProps = function(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = _.isFunction(constructor) && constructor.prototype || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  };

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`.
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object.
  // In contrast to _.map it returns an object.
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = _.keys(obj),
        length = keys.length,
        results = {};
    for (var index = 0; index < length; index++) {
      var currentKey = keys[index];
      results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  // The opposite of _.object.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`.
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, defaults) {
    return function(obj) {
      var length = arguments.length;
      if (defaults) obj = Object(obj);
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!defaults || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s).
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test.
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Internal pick helper function to determine if `obj` has key `key`.
  var keyInObj = function(value, key, obj) {
    return key in obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = restArguments(function(obj, keys) {
    var result = {}, iteratee = keys[0];
    if (obj == null) return result;
    if (_.isFunction(iteratee)) {
      if (keys.length > 1) iteratee = optimizeCb(iteratee, keys[1]);
      keys = _.allKeys(obj);
    } else {
      iteratee = keyInObj;
      keys = flatten(keys, false, false);
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  });

  // Return a copy of the object without the blacklisted properties.
  _.omit = restArguments(function(obj, keys) {
    var iteratee = keys[0], context;
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
      if (keys.length > 1) context = keys[1];
    } else {
      keys = _.map(flatten(keys, false, false), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  });

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq, deepEq;
  eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // `null` or `undefined` only equal to itself (strict comparison).
    if (a == null || b == null) return false;
    // `NaN`s are equivalent, but non-reflexive.
    if (a !== a) return b !== b;
    // Exhaust primitive checks
    var type = typeof a;
    if (type !== 'function' && type !== 'object' && typeof b != 'object') return false;
    return deepEq(a, b, aStack, bStack);
  };

  // Internal recursive comparison function for `isEqual`.
  deepEq = function(a, b, aStack, bStack) {
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN.
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
      case '[object Symbol]':
        return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError, isMap, isWeakMap, isSet, isWeakSet.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error', 'Symbol', 'Map', 'WeakMap', 'Set', 'WeakSet'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), Safari 8 (#1929), and PhantomJS (#2236).
  var nodelist = root.document && root.document.childNodes;
  if (typeof /./ != 'function' && typeof Int8Array != 'object' && typeof nodelist != 'function') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return !_.isSymbol(obj) && isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`?
  _.isNaN = function(obj) {
    return _.isNumber(obj) && isNaN(obj);
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, path) {
    if (!_.isArray(path)) {
      return has(obj, path);
    }
    var length = path.length;
    for (var i = 0; i < length; i++) {
      var key = path[i];
      if (obj == null || !hasOwnProperty.call(obj, key)) {
        return false;
      }
      obj = obj[key];
    }
    return !!length;
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  // Creates a function that, when passed an object, will traverse that object’s
  // properties down the given `path`, specified as an array of keys or indexes.
  _.property = function(path) {
    if (!_.isArray(path)) {
      return shallowProperty(path);
    }
    return function(obj) {
      return deepGet(obj, path);
    };
  };

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    if (obj == null) {
      return function(){};
    }
    return function(path) {
      return !_.isArray(path) ? obj[path] : deepGet(obj, path);
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

  // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped.
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // Traverses the children of `obj` along `path`. If a child is a function, it
  // is invoked with its parent as context. Returns the value of the final
  // child, or `fallback` if any child is undefined.
  _.result = function(obj, path, fallback) {
    if (!_.isArray(path)) path = [path];
    var length = path.length;
    if (!length) {
      return _.isFunction(fallback) ? fallback.call(obj) : fallback;
    }
    for (var i = 0; i < length; i++) {
      var prop = obj == null ? void 0 : obj[path[i]];
      if (prop === void 0) {
        prop = fallback;
        i = length; // Ensure we don't continue iterating.
      }
      obj = _.isFunction(prop) ? prop.call(obj) : prop;
    }
    return obj;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'": "'",
    '\\': '\\',
    '\r': 'r',
    '\n': 'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offset.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    var render;
    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var chainResult = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return chainResult(this, func.apply(_, args));
      };
    });
    return _;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return chainResult(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return chainResult(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return String(this._wrapped);
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define == 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}());

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],37:[function(require,module,exports){
"use strict";

/* base64 encode/decode compatible with window.btoa/atob
 *
 * window.atob/btoa is a Firefox extension to convert binary data (the "b")
 * to base64 (ascii, the "a").
 *
 * It is also found in Safari and Chrome.  It is not available in IE.
 *
 * if (!window.btoa) window.btoa = base64.encode
 * if (!window.atob) window.atob = base64.decode
 *
 * The original spec's for atob/btoa are a bit lacking
 * https://developer.mozilla.org/en/DOM/window.atob
 * https://developer.mozilla.org/en/DOM/window.btoa
 *
 * window.btoa and base64.encode takes a string where charCodeAt is [0,255]
 * If any character is not [0,255], then an DOMException(5) is thrown.
 *
 * window.atob and base64.decode take a base64-encoded string
 * If the input length is not a multiple of 4, or contains invalid characters
 *   then an DOMException(5) is thrown.
 */

/* eslint-disable */
(function () {
  var base64 = {};
  base64.PADCHAR = '=';
  base64.ALPHA = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

  base64.makeDOMException = function () {
    // sadly in FF,Safari,Chrome you can't make a DOMException
    var e, tmp;

    try {
      return new DOMException(DOMException.INVALID_CHARACTER_ERR);
    } catch (tmp) {
      // not available, just passback a duck-typed equiv
      // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Error
      // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Error/prototype
      var ex = new Error('DOM Exception 5'); // ex.number and ex.description is IE-specific.

      ex.code = ex.number = 5;
      ex.name = ex.description = 'INVALID_CHARACTER_ERR'; // Safari/Chrome output format

      ex.toString = function () {
        return 'Error: ' + ex.name + ': ' + ex.message;
      };

      return ex;
    }
  };

  base64.getbyte64 = function (s, i) {
    // This is oddly fast, except on Chrome/V8.
    //  Minimal or no improvement in performance by using a
    //   object with properties mapping chars to value (eg. 'A': 0)
    var idx = base64.ALPHA.indexOf(s.charAt(i));

    if (idx === -1) {
      throw base64.makeDOMException();
    }

    return idx;
  };

  base64.decode = function (s) {
    // convert to string
    s = '' + s;
    var getbyte64 = base64.getbyte64;
    var pads, i, b10;
    var imax = s.length;

    if (imax === 0) {
      return s;
    }

    if (imax % 4 !== 0) {
      throw base64.makeDOMException();
    }

    pads = 0;

    if (s.charAt(imax - 1) === base64.PADCHAR) {
      pads = 1;

      if (s.charAt(imax - 2) === base64.PADCHAR) {
        pads = 2;
      } // either way, we want to ignore this last block


      imax -= 4;
    }

    var x = [];

    for (i = 0; i < imax; i += 4) {
      b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12 | getbyte64(s, i + 2) << 6 | getbyte64(s, i + 3);
      x.push(String.fromCharCode(b10 >> 16, b10 >> 8 & 0xff, b10 & 0xff));
    }

    switch (pads) {
      case 1:
        b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12 | getbyte64(s, i + 2) << 6;
        x.push(String.fromCharCode(b10 >> 16, b10 >> 8 & 0xff));
        break;

      case 2:
        b10 = getbyte64(s, i) << 18 | getbyte64(s, i + 1) << 12;
        x.push(String.fromCharCode(b10 >> 16));
        break;
    }

    return x.join('');
  };

  base64.getbyte = function (s, i) {
    var x = s.charCodeAt(i);

    if (x > 255) {
      throw base64.makeDOMException();
    }

    return x;
  };

  base64.encode = function (s) {
    if (arguments.length !== 1) {
      throw new SyntaxError('Not enough arguments');
    }

    var padchar = base64.PADCHAR;
    var alpha = base64.ALPHA;
    var getbyte = base64.getbyte;
    var i, b10;
    var x = []; // convert to string

    s = '' + s;
    var imax = s.length - s.length % 3;

    if (s.length === 0) {
      return s;
    }

    for (i = 0; i < imax; i += 3) {
      b10 = getbyte(s, i) << 16 | getbyte(s, i + 1) << 8 | getbyte(s, i + 2);
      x.push(alpha.charAt(b10 >> 18));
      x.push(alpha.charAt(b10 >> 12 & 0x3F));
      x.push(alpha.charAt(b10 >> 6 & 0x3f));
      x.push(alpha.charAt(b10 & 0x3f));
    }

    switch (s.length - imax) {
      case 1:
        b10 = getbyte(s, i) << 16;
        x.push(alpha.charAt(b10 >> 18) + alpha.charAt(b10 >> 12 & 0x3F) + padchar + padchar);
        break;

      case 2:
        b10 = getbyte(s, i) << 16 | getbyte(s, i + 1) << 8;
        x.push(alpha.charAt(b10 >> 18) + alpha.charAt(b10 >> 12 & 0x3F) + alpha.charAt(b10 >> 6 & 0x3f) + padchar);
        break;
    }

    return x.join('');
  };

  window.base64 = base64;
})();

},{}],38:[function(require,module,exports){
"use strict";

/* eslint-disable */
var HazmatBuilder = function HazmatBuilder(_, root) {
  // Actual Hazmat Code
  // top level module
  var Hazmat = function Hazmat(config) {
    this.config = config || {};

    if (!_.isObject(this.config)) {
      throw new Error('Hazmat is not initialized properly');
    }

    this.fail = _.isFunction(this.config.fail) ? this.config.fail : Hazmat.fail;
    this.warn = _.isFunction(this.config.warn) ? this.config.warn : Hazmat.warn;
    this.log = _.isFunction(this.config.log) ? this.config.log : Hazmat.log;
  };

  _.extend(Hazmat, {
    // constants
    ID_REGEX: /^[\_\-A-Za-z0-9]+$/,
    // factory
    create: function create(config) {
      return new Hazmat(config);
    },
    // noConflict
    noConflict: function noConflict() {
      root.Hazmat = Hazmat.original;
      return Hazmat;
    },
    // default log function
    log: function log() {
      if (window.console && _.isFunction(window.console.log)) {
        window.console.log.apply(window.console, arguments);
      }
    },
    // default fail function
    fail: function fail(_reason, _data) {
      var reason = _reason || '';
      var data = _data || {};
      Hazmat.log('Hazmat Failure::', reason, data);
      throw new Error('Hazmat Failure ' + reason.toString());
    },
    // default warn function
    warn: function warn(_reason, _data) {
      var reason = _reason || '';
      var data = _data || {};
      Hazmat.log('Hazmat Warning::', reason, data);
    },
    // global fixers
    fixDomId: function fixDomId(_value) {
      if (_.isString(_value) && _value.length > 0) {
        return _value.replace(/[^A-Za-z0-9\_]/g, '');
      } else {
        return null;
      }
    },
    // global testers
    isDomId: function isDomId(value) {
      return _.isString(value) && value.match(Hazmat.ID_REGEX);
    },
    __placeholder: true
  });

  _.extend(Hazmat.prototype, {
    _safeValue: function _safeValue(name, value, fallback, type) {
      // make fallback safe and eat exceptions
      var _fallback = fallback;

      if (_.isFunction(fallback)) {
        fallback = _.once(function () {
          try {
            return _fallback.apply(this, arguments);
          } catch (e) {}
        });
      }

      if (type.checker(value)) {
        return value;
      } else if (type.evalFallback && _.isFunction(fallback) && type.checker(fallback(value))) {
        this.warn('Expected valid ' + type.name + ' for ' + name + ' but was able to sanitize it:', [value, fallback(value)]);
        return fallback(value);
      } else if (type.checker(_fallback)) {
        this.warn('Expected valid ' + type.name + ' for ' + name + ' but was able to fallback to default value:', [value, _fallback]);
        return _fallback;
      } else {
        this.fail('Expected valid ' + type.name + ' for ' + name + ' but received:', value);
      }
    },
    safeString: function safeString(name, value, fallback) {
      return this._safeValue(name, value, fallback, {
        name: 'String',
        checker: _.isString,
        evalFallback: true
      });
    },
    safeStringOrNull: function safeStringOrNull(name, value, fallback) {
      if (value == null) {
        return value;
      } else {
        return this._safeValue(name, value, fallback, {
          name: 'String',
          checker: _.isString,
          evalFallback: true
        });
      }
    },
    safeDomId: function safeDomId(name, value, fallback) {
      return this._safeValue(name, value, fallback, {
        name: 'DOM ID',
        checker: Hazmat.isDomId,
        evalFallback: true
      });
    },
    safeFunction: function safeFunction(name, value, fallback) {
      return this._safeValue(name, value, fallback, {
        name: 'Function',
        checker: _.isFunction,
        evalFallback: false
      });
    },
    safeFunctionOrNull: function safeFunctionOrNull(name, value, fallback) {
      if (value == null) {
        return value;
      } else {
        return this._safeValue(name, value, fallback, {
          name: 'Function',
          checker: _.isFunction,
          evalFallback: false
        });
      }
    },
    safeObject: function safeObject(name, value, fallback) {
      return this._safeValue(name, value, fallback, {
        name: 'Object',
        checker: _.isObject,
        evalFallback: false
      });
    },
    safeObjectOrNull: function safeObjectOrNull(name, value, fallback) {
      if (value == null) {
        return value;
      } else {
        return this._safeValue(name, value, fallback, {
          name: 'Object',
          checker: _.isObject,
          evalFallback: false
        });
      }
    },
    safeArray: function safeArray(name, value, fallback) {
      return this._safeValue(name, value, fallback, {
        name: 'Array',
        checker: _.isArray,
        evalFallback: false
      });
    },
    safeArrayOfElements: function safeArrayOfElements(name, value, elementValidator, fallback) {
      var safeArray = this._safeValue(name, value, fallback, {
        name: 'Array',
        checker: _.isArray,
        evalFallback: false
      });

      return _.map(safeArray, elementValidator);
    },
    __placeholder: true
  });

  return Hazmat;
};

var _ = require('underscore'); // Integration with Node.js/Browser


if (typeof window !== 'undefined' && typeof _ !== 'undefined') {
  var hazmat = HazmatBuilder(_, window);
  hazmat.original = window.Hazmat;
  window.Hazmat = hazmat;
} else {
  var hazmat = HazmatBuilder(_);

  _.extend(exports, hazmat);
}

},{"underscore":36}],39:[function(require,module,exports){
"use strict";

/* eslint-disable */
(function (OO, $, _) {
  /*
   *  extend jquery lib
   */
  // add support for ie8/9 cross domain requests to jquery
  // see more here: http://bugs.jquery.com/ticket/8283
  // and here: https://github.com/jaubourg/ajaxHooks/blob/master/src/xdr.js
  if (window.XDomainRequest) {
    OO.$.ajaxTransport(function (s) {
      if (s.crossDomain && s.async) {
        if (s.timeout) {
          s.xdrTimeout = s.timeout;
          delete s.timeout;
        }

        var xdr;
        return {
          send: function send(_, complete) {
            function callback(status, statusText, responses, responseHeaders) {
              xdr.onload = xdr.onerror = xdr.ontimeout = OO.$.noop;
              xdr = undefined;
              complete(status, statusText, responses, responseHeaders);
            }

            xdr = new XDomainRequest();
            xdr.open(s.type, s.url);

            xdr.onload = function () {
              callback(200, 'OK', {
                text: xdr.responseText
              }, 'Content-Type: ' + xdr.contentType);
            };

            xdr.onerror = function () {
              callback(404, 'Not Found');
            };

            xdr.onprogress = function () {};

            if (s.xdrTimeout) {
              xdr.ontimeout = function () {
                callback(0, 'timeout');
              };

              xdr.timeout = s.xdrTimeout;
            }

            xdr.send(s.hasContent && s.data || null);
          },
          abort: function abort() {
            if (xdr) {
              xdr.onerror = OO.$.noop();
              xdr.abort();
            }
          }
        };
      }
    });
  }

  $.getScriptRetry = function (url, callback, options) {
    options = options || {};
    var errorCallBack = options.error;
    var removeOptions = ['error', 'dataType', 'success'];

    _.each(removeOptions, function (k) {
      delete options[k];
    }); // default settings; may be overridden by passing options


    var settings = {
      'url': url,
      'type': 'get',
      'dataType': 'script',
      'success': callback,
      'cache': true,
      'timeout': 5000,
      'tryCount': 0,
      'retryLimit': 1,
      'warning': false,
      'warningMessage': 'Can not load URL',
      'error': function error() {
        if (this.tryCount < this.retryLimit) {
          this.tryCount++;
          $.ajax(this);
        } else {
          if (this.warning) {
            alert(this.warningMessage);
          }

          if (errorCallBack) {
            errorCallBack.apply(null, arguments);
          }
        }
      }
    };

    _.extend(settings, options);

    $.ajax(settings);
  };
})(OO, OO.$, OO._);

},{}],40:[function(require,module,exports){
"use strict";

/* A JavaScript implementation of the SHA family of hashes, as defined in FIPS
 * PUB 180-2 as well as the corresponding HMAC implementation as defined in
 * FIPS PUB 198a
 *
 * Version 1.31 Copyright Brian Turek 2008-2012
 * Distributed under the BSD License
 * See http://caligatio.github.com/jsSHA/ for more information
 *
 * Several functions taken from Paul Johnson
 */

/* eslint-disable */
(function () {
  var charSize = 8;
  var b64pad = '';
  var hexCase = 0;

  var str2binb = function str2binb(str) {
    var bin = [];
    var mask = (1 << charSize) - 1;
    var length = str.length * charSize;
    var i;

    for (i = 0; i < length; i += charSize) {
      bin[i >> 5] |= (str.charCodeAt(i / charSize) & mask) << 32 - charSize - i % 32;
    }

    return bin;
  };

  var hex2binb = function hex2binb(str) {
    var bin = [];
    var length = str.length;
    var i;
    var num;

    for (i = 0; i < length; i += 2) {
      num = parseInt(str.substr(i, 2), 16);

      if (!isNaN(num)) {
        bin[i >> 3] |= num << 24 - 4 * (i % 8);
      } else {
        return 'INVALID HEX STRING';
      }
    }

    return bin;
  };

  var binb2hex = function binb2hex(binarray) {
    var hex_tab = hexCase ? '0123456789ABCDEF' : '0123456789abcdef';
    var str = '';
    var length = binarray.length * 4;
    var i;
    var srcByte;

    for (i = 0; i < length; i += 1) {
      srcByte = binarray[i >> 2] >> (3 - i % 4) * 8;
      str += hex_tab.charAt(srcByte >> 4 & 0xF) + hex_tab.charAt(srcByte & 0xF);
    }

    return str;
  };

  var binb2b64 = function binb2b64(binarray) {
    var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' + '0123456789+/';
    var str = '';
    var length = binarray.length * 4;
    var i;
    var j;
    var triplet;

    for (i = 0; i < length; i += 3) {
      triplet = (binarray[i >> 2] >> 8 * (3 - i % 4) & 0xFF) << 16 | (binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 0xFF) << 8 | binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 0xFF;

      for (j = 0; j < 4; j += 1) {
        if (i * 8 + j * 6 <= binarray.length * 32) {
          str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);
        } else {
          str += b64pad;
        }
      }
    }

    return str;
  };

  var rotr = function rotr(x, n) {
    return x >>> n | x << 32 - n;
  };

  var shr = function shr(x, n) {
    return x >>> n;
  };

  var ch = function ch(x, y, z) {
    return x & y ^ ~x & z;
  };

  var maj = function maj(x, y, z) {
    return x & y ^ x & z ^ y & z;
  };

  var sigma0 = function sigma0(x) {
    return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
  };

  var sigma1 = function sigma1(x) {
    return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
  };

  var gamma0 = function gamma0(x) {
    return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3);
  };

  var gamma1 = function gamma1(x) {
    return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10);
  };

  var safeAdd_2 = function safeAdd_2(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >>> 16) + (y >>> 16) + (lsw >>> 16);
    return (msw & 0xFFFF) << 16 | lsw & 0xFFFF;
  };

  var safeAdd_4 = function safeAdd_4(a, b, c, d) {
    var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF);
    var msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) + (lsw >>> 16);
    return (msw & 0xFFFF) << 16 | lsw & 0xFFFF;
  };

  var safeAdd_5 = function safeAdd_5(a, b, c, d, e) {
    var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) + (e & 0xFFFF);
    var msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) + (e >>> 16) + (lsw >>> 16);
    return (msw & 0xFFFF) << 16 | lsw & 0xFFFF;
  };

  var coreSHA2 = function coreSHA2(message, messageLen, variant) {
    var a;
    var b;
    var c;
    var d;
    var e;
    var f;
    var g;
    var h;
    var T1;
    var T2;
    var H;
    var lengthPosition;
    var i;
    var t;
    var K;
    var W = [];
    var appendedMessageLength;

    if (variant === 'SHA-224' || variant === 'SHA-256') {
      lengthPosition = (messageLen + 65 >> 9 << 4) + 15;
      K = [0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2];

      if (variant === 'SHA-224') {
        H = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
      } else {
        H = [0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19];
      }
    }

    message[messageLen >> 5] |= 0x80 << 24 - messageLen % 32;
    message[lengthPosition] = messageLen;
    appendedMessageLength = message.length;

    for (i = 0; i < appendedMessageLength; i += 16) {
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      f = H[5];
      g = H[6];
      h = H[7];

      for (t = 0; t < 64; t += 1) {
        if (t < 16) {
          W[t] = message[t + i];
        } else {
          W[t] = safeAdd_4(gamma1(W[t - 2]), W[t - 7], gamma0(W[t - 15]), W[t - 16]);
        }

        T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);
        T2 = safeAdd_2(sigma0(a), maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = safeAdd_2(d, T1);
        d = c;
        c = b;
        b = a;
        a = safeAdd_2(T1, T2);
      }

      H[0] = safeAdd_2(a, H[0]);
      H[1] = safeAdd_2(b, H[1]);
      H[2] = safeAdd_2(c, H[2]);
      H[3] = safeAdd_2(d, H[3]);
      H[4] = safeAdd_2(e, H[4]);
      H[5] = safeAdd_2(f, H[5]);
      H[6] = safeAdd_2(g, H[6]);
      H[7] = safeAdd_2(h, H[7]);
    }

    switch (variant) {
      case 'SHA-224':
        return [H[0], H[1], H[2], H[3], H[4], H[5], H[6]];

      case 'SHA-256':
        return H;

      default:
        return [];
    }
  };

  var jsSHA = function jsSHA(srcString, inputFormat) {
    this.sha224 = null;
    this.sha256 = null;
    this.strBinLen = null;
    this.strToHash = null;

    if (inputFormat === 'HEX') {
      if (srcString.length % 2 !== 0) {
        return 'TEXT MUST BE IN BYTE INCREMENTS';
      }

      this.strBinLen = srcString.length * 4;
      this.strToHash = hex2binb(srcString);
    } else if (inputFormat === 'ASCII' || typeof inputFormat === 'undefined') {
      this.strBinLen = srcString.length * charSize;
      this.strToHash = str2binb(srcString);
    } else {
      return 'UNKNOWN TEXT INPUT TYPE';
    }
  };

  jsSHA.prototype = {
    getHash: function getHash(variant, format) {
      var formatFunc = null;
      var message = this.strToHash.slice();

      switch (format) {
        case 'HEX':
          formatFunc = binb2hex;
          break;

        case 'B64':
          formatFunc = binb2b64;
          break;

        default:
          return 'FORMAT NOT RECOGNIZED';
      }

      switch (variant) {
        case 'SHA-224':
          if (this.sha224 === null) {
            this.sha224 = coreSHA2(message, this.strBinLen, variant);
          }

          return formatFunc(this.sha224);

        case 'SHA-256':
          if (this.sha256 === null) {
            this.sha256 = coreSHA2(message, this.strBinLen, variant);
          }

          return formatFunc(this.sha256);

        default:
          return 'HASH NOT RECOGNIZED';
      }
    },
    getHMAC: function getHMAC(key, inputFormat, variant, outputFormat) {
      var formatFunc;
      var keyToUse;
      var i;
      var retVal;
      var keyBinLen;
      var hashBitSize;
      var keyWithIPad = [];
      var keyWithOPad = [];

      switch (outputFormat) {
        case 'HEX':
          formatFunc = binb2hex;
          break;

        case 'B64':
          formatFunc = binb2b64;
          break;

        default:
          return 'FORMAT NOT RECOGNIZED';
      }

      switch (variant) {
        case 'SHA-224':
          hashBitSize = 224;
          break;

        case 'SHA-256':
          hashBitSize = 256;
          break;

        default:
          return 'HASH NOT RECOGNIZED';
      }

      if (inputFormat === 'HEX') {
        if (key.length % 2 !== 0) {
          return 'KEY MUST BE IN BYTE INCREMENTS';
        }

        keyToUse = hex2binb(key);
        keyBinLen = key.length * 4;
      } else if (inputFormat === 'ASCII') {
        keyToUse = str2binb(key);
        keyBinLen = key.length * charSize;
      } else {
        return 'UNKNOWN KEY INPUT TYPE';
      }

      if (keyBinLen / 8 > 64) {
        keyToUse = coreSHA2(keyToUse, keyBinLen, variant);
        keyToUse[15] &= 0xFFFFFF00;
      } else if (keyBinLen / 8 < 64) {
        keyToUse[15] &= 0xFFFFFF00;
      }

      for (i = 0; i <= 15; i += 1) {
        keyWithIPad[i] = keyToUse[i] ^ 0x36363636;
        keyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;
      }

      retVal = coreSHA2(keyWithIPad.concat(this.strToHash), 512 + this.strBinLen, variant);
      retVal = coreSHA2(keyWithOPad.concat(retVal), 512 + hashBitSize, variant);
      return formatFunc(retVal);
    }
  };
  window.jsSHA = jsSHA;
})();

},{}],41:[function(require,module,exports){
"use strict";

/* eslint-disable */
window.LZW = {
  // LZW-compress a string
  encode: function encode(s) {
    var dict = {};
    var data = (s + '').split('');
    var out = [];
    var currChar;
    var phrase = data[0];
    var code = 256;

    for (var i = 1; i < data.length; i++) {
      currChar = data[i];

      if (dict[phrase + currChar] != null) {
        phrase += currChar;
      } else {
        out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));
        dict[phrase + currChar] = code;
        code++;
        phrase = currChar;
      }
    }

    out.push(phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0));

    for (var i = 0; i < out.length; i++) {
      out[i] = String.fromCharCode(out[i]);
    }

    return out.join('');
  },
  // Decompress an LZW-encoded string
  decode: function decode(s) {
    var dict = {};
    var data = (s + '').split('');
    var currChar = data[0];
    var oldPhrase = currChar;
    var out = [currChar];
    var code = 256;
    var phrase;

    for (var i = 1; i < data.length; i++) {
      var currCode = data[i].charCodeAt(0);

      if (currCode < 256) {
        phrase = data[i];
      } else {
        phrase = dict[currCode] ? dict[currCode] : oldPhrase + currChar;
      }

      out.push(phrase);
      currChar = phrase.charAt(0);
      dict[code] = oldPhrase + currChar;
      code++;
      oldPhrase = phrase;
    }

    return out.join('');
  }
};

},{}],42:[function(require,module,exports){
(function (process,global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/* eslint-disable */
(function (OO, $, _) {
  // analtyics.js pulled from https://analytics.ooyala.com/static/v3/analytics.js on 2/21/19
  !function () {
    var e = function e(_e, t) {
      if ("undefined" != typeof WinJS) return void WinJS.Namespace.define(_e, {});
      var i = "undefined" != typeof process && process.versions && !!process.versions.node,
          a = i ? global : t;
      "undefined" != typeof window && (a = window), a || console.log(new Error().stack);

      for (var n = _e.split("."), s = a, r = 0; r < n.length; r++) {
        var o = n[r];

        if (s[o]) {
          var l = n.slice(0, r).join(".");
          if ("object" != (0, _typeof2.default)(s[o])) throw new Error("Namespace error: the name '" + l + "' already exists and is not a namespace.");
        } else s[o] = {};

        s = s[o];
      }
    };

    e("Ooyala.Util", this), Ooyala.Util.createNamespace = e;
  }(), function () {
    Ooyala.Util.createNamespace("Ooyala.Analytics", this), Ooyala.Analytics._GuidManager = function () {
      this._guid_key_name = "ooyala_guid";
    }, Ooyala.Analytics._GuidManager.prototype = {
      _isGuidInLocalStorage: function _isGuidInLocalStorage() {
        return "undefined" != typeof Storage && null !== localStorage.getItem(this._guid_key_name);
      },
      _getGuidFromLocalStorage: function _getGuidFromLocalStorage() {
        return "undefined" != typeof Storage ? localStorage.getItem(this._guid_key_name) : null;
      },
      _getRandomString: function _getRandomString() {
        return new Date().getTime() + Math.random().toString(16).split(".")[1];
      },
      _generateGuid: function _generateGuid() {
        return Ooyala.ThirdParty.SHA256.sha256ToBase64String(this._getRandomString());
      },
      _setGuid: function _setGuid(e) {
        return "undefined" != typeof Storage && (localStorage.setItem(this._guid_key_name, e), !0);
      },
      getOrGenerateGuid: function getOrGenerateGuid(e) {
        var t = this._generateGuid();

        return e || (this._isGuidInLocalStorage() ? t = this._getGuidFromLocalStorage() : this._setGuid(t)), t;
      }
    };
  }(), Ooyala.Util.createNamespace("Ooyala.ThirdParty.SHA256", this), function () {
    function e(e, t) {
      var i = (65535 & e) + (65535 & t),
          a = (e >> 16) + (t >> 16) + (i >> 16);
      return a << 16 | 65535 & i;
    }

    function t(e, t) {
      return e >>> t | e << 32 - t;
    }

    function i(e, t) {
      return e >>> t;
    }

    function a(e, t, i) {
      return e & t ^ ~e & i;
    }

    function n(e, t, i) {
      return e & t ^ e & i ^ t & i;
    }

    function s(e) {
      return t(e, 2) ^ t(e, 13) ^ t(e, 22);
    }

    function r(e) {
      return t(e, 6) ^ t(e, 11) ^ t(e, 25);
    }

    function o(e) {
      return t(e, 7) ^ t(e, 18) ^ i(e, 3);
    }

    function l(e) {
      return t(e, 17) ^ t(e, 19) ^ i(e, 10);
    }

    function u(t, i) {
      var u,
          c,
          h,
          _,
          d,
          f,
          y,
          m,
          T,
          E,
          p,
          g,
          I = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298),
          A = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225),
          S = new Array(64);

      t[i >> 5] |= 128 << 24 - i % 32, t[(i + 64 >> 9 << 4) + 15] = i;

      for (var T = 0; T < t.length; T += 16) {
        u = A[0], c = A[1], h = A[2], _ = A[3], d = A[4], f = A[5], y = A[6], m = A[7];

        for (var E = 0; E < 64; E++) {
          E < 16 ? S[E] = t[E + T] : S[E] = e(e(e(l(S[E - 2]), S[E - 7]), o(S[E - 15])), S[E - 16]), p = e(e(e(e(m, r(d)), a(d, f, y)), I[E]), S[E]), g = e(s(u), n(u, c, h)), m = y, y = f, f = d, d = e(_, p), _ = h, h = c, c = u, u = e(p, g);
        }

        A[0] = e(u, A[0]), A[1] = e(c, A[1]), A[2] = e(h, A[2]), A[3] = e(_, A[3]), A[4] = e(d, A[4]), A[5] = e(f, A[5]), A[6] = e(y, A[6]), A[7] = e(m, A[7]);
      }

      return A;
    }

    function c(e) {
      for (var t = Array(), i = (1 << f) - 1, a = 0; a < e.length * f; a += f) {
        t[a >> 5] |= (e.charCodeAt(a / f) & i) << 24 - a % 32;
      }

      return t;
    }

    function h(e) {
      for (var t = "", i = (1 << f) - 1, a = 0; a < 32 * e.length; a += f) {
        t += String.fromCharCode(e[a >> 5] >>> 24 - a % 32 & i);
      }

      return t;
    }

    function _(e) {
      for (var t = y ? "0123456789ABCDEF" : "0123456789abcdef", i = "", a = 0; a < 4 * e.length; a++) {
        i += t.charAt(e[a >> 2] >> 8 * (3 - a % 4) + 4 & 15) + t.charAt(e[a >> 2] >> 8 * (3 - a % 4) & 15);
      }

      return i;
    }

    function d(e) {
      for (var t = "", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = "", n = 0; n < 4 * e.length; n += 3) {
        for (var s = (e[n >> 2] >> 8 * (3 - n % 4) & 255) << 16 | (e[n + 1 >> 2] >> 8 * (3 - (n + 1) % 4) & 255) << 8 | e[n + 2 >> 2] >> 8 * (3 - (n + 2) % 4) & 255, r = 0; r < 4; r++) {
          a += 8 * n + 6 * r > 32 * e.length ? t : i.charAt(s >> 6 * (3 - r) & 63);
        }
      }

      return a;
    }

    var f = 8,
        y = 0;
    Ooyala.ThirdParty.SHA256.sha256ToHexString = function (e) {
      return _(u(c(e), e.length * f));
    }, Ooyala.ThirdParty.SHA256.sha256ToBase64String = function (e) {
      return d(u(c(e), e.length * f));
    }, Ooyala.ThirdParty.SHA256.sha256ToString = function (e) {
      return h(u(c(e), e.length * f));
    };
  }(), function (e) {
    "use strict";

    function t(e) {
      var e = {
        eventName: e.name,
        time: new Date().toISOString()
      };
      return e;
    }

    function i(e) {
      var t = Date.now() + this._priorityIntervals[e];

      t < this._flushTime && (this._flushTimeout && clearTimeout(this._flushTimeout), this._flushTimeout = setTimeout(function () {
        r.call(this);
      }.bind(this), this._priorityIntervals[e]), this._flushTime = Date.now() + this._priorityIntervals[e]);
    }

    function a(e) {
      new Ooyala.HttpRequester(e, this._iqEndpoint, this._base.disablePiiLogging);
    }

    function n(e) {
      if (e > 0) {
        var i = t(A.PLAYHEAD_UPDATE);
        i.playheadPositionMillis = Math.floor(e), v.call(this, i, A.PLAYHEAD_UPDATE.priority);
      }
    }

    function s(e) {
      if (e > 0) {
        var i = t(A.TIME_PLAYED);
        i.timePlayedMillis = e, v.call(this, i, A.TIME_PLAYED.priority), this._timePlayed = 0;
      }
    }

    function r() {
      var e = Date.now() / 1e3,
          t = new Date();
      this._base.clientTime = t.toISOString(), s.call(this, this._timePlayedMillis), n.call(this, this._playheadPositionMillis), this._base.events = this._pendingEvents, a.call(this, this._base), this._pendingEvents = [], this._flushTime = Number.MAX_VALUE, this._lastFlush = e;
    }

    function o(e) {
      for (; e / 10 > this._nextPlaythroughToReport || 100 == this._nextPlaythroughToReport && e / 10 > 95;) {
        var i = t(A.PLAYTHROUGH_PERCENT);
        i.percent = Math.floor(this._nextPlaythroughToReport), v.call(this, i, A.PLAYTHROUGH_PERCENT.priority), this._nextPlaythroughToReport += 25;
      }
    }

    function l(e) {
      for (var t = e / this._buckets.count, i = 0; i < this._buckets.count; i++) {
        this._buckets.startingTimes[i] = i * t;
      }
    }

    function u(e) {
      for (var t = !1, i = 0, a = 0; !t;) {
        i === this._buckets.count || this._buckets.startingTimes[i] > e ? (a = i - 1, t = !0) : i += 1;
      }

      return a;
    }

    function c(e) {
      this._buckets.watched[e] || (this._buckets.watched[e] = !0, h.call(this, e)), this._buckets.current !== e && (_.call(this, e), this._buckets.current = e);
    }

    function h(e) {
      var i = t(A.PERCENTAGE_WATCHED);
      i.startMille = 25 * e + 1, i.endMille = 25 * e + 25, v.call(this, i, A.PERCENTAGE_WATCHED.priority), this._buckets.watchedCount++, o.call(this, i.endMille);
    }

    function _(e) {
      var i = t(A.BUCKETS_WATCHED);
      i.startMille = 25 * e + 1, i.endMille = 25 * e + 25, v.call(this, i, A.BUCKETS_WATCHED.priority);
    }

    function d(e) {
      var i = t(e);
      v.call(this, i, e.priority);
    }

    function f(e) {
      var t = new Error(e.message);
      return t.name = e.name, t;
    }

    function y() {
      this._buckets = {
        watched: [],
        current: -1,
        startingTimes: [],
        count: 40,
        watchedCount: 0
      }, this._nextPlaythroughToReport = 25, this._playheadPositionMillis = 0, this._timePlayed = 0, this._lastTimePlayed = 0, this._timePlayedMillis = 0, this._base.source = {}, this._base.plugins = [], this._bufferingStartedTime = 0, this._bufferingTime = 0, this._adBreakStartedTime = 0, this._adBreakTime = 0, this._playRequestedTime = 0, this._joinTime = 0;
    }

    function m(e, t, i, a, n, s) {
      var r = {},
          o = {};
      if (r.uiTag = i, r.contentSource = a, e.hasOwnProperty("ooyalaDiscoveryContext")) o = e.ooyalaDiscoveryContext;else {
        if (!e.hasOwnProperty("bucket_info")) {
          var l = f(S.MISSING_DISCOVERY_CONTEXT);
          throw l.message = l.message.replace("{{asset}}", JSON.stringify(e)), l;
        }

        o.version = "1", o.data = T(e.bucket_info);
      }
      return t && (o.customData = t), r.ooyalaDiscoveryContext = JSON.stringify(o), r.pageSize = n, r.assetPosition = s, r;
    }

    function T(e) {
      if (e && e.length > 0 && "2" == e.charAt(0)) {
        var t = JSON.parse(e.substring(1));
        return window.atob(t.encoded);
      }

      var i = f(S.INVALID_BUCKET_INFO);
      throw i.message = i.message.replace("{{bucket_info}}", e), i;
    }

    function E(e) {
      var t = Ooyala.Analytics.MediaContentType.OOYALA_CONTENT,
          i = "";
      return e.hasOwnProperty("id_type") && (t = e.id_type), e.hasOwnProperty("embed_code") && (i = e.embed_code), {
        id: i,
        idType: t
      };
    }

    function p(e) {
      if (!e.hasOwnProperty("name") || !e.hasOwnProperty("active")) return f(S.PLUGIN_FIELDS_MISSING);

      for (var t in e) {
        if ("name" !== t && "active" !== t && "version" !== t) {
          var i = f(S.PLUGIN_FIELD_INVALID);
          return i.message = i.message.replace("{{field}}", t), i;
        }
      }

      return null;
    }

    function g() {
      function e() {
        return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
      }

      return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e();
    }

    var I = {
      LOW: 0,
      MEDIUM: 1,
      HIGH: 2
    },
        A = {
      PLAYER_LOAD: {
        name: "playerLoad",
        priority: I.HIGH
      },
      DISPLAY: {
        name: "display",
        priority: I.HIGH
      },
      PLAY_REQUESTED: {
        name: "playRequested",
        priority: I.HIGH
      },
      VIDEO_STARTED: {
        name: "videoStarted",
        priority: I.HIGH
      },
      PLAYTHROUGH_PERCENT: {
        name: "playthroughPercent",
        priority: I.HIGH
      },
      PERCENTAGE_WATCHED: {
        name: "percentageWatched",
        priority: I.MEDIUM
      },
      BUCKETS_WATCHED: {
        name: "bucketWatched",
        priority: I.MEDIUM
      },
      REPLAY: {
        name: "replay",
        priority: I.HIGH
      },
      SEEK: {
        name: "seek",
        priority: I.MEDIUM
      },
      PAUSE: {
        name: "pause",
        priority: I.MEDIUM
      },
      RESUME: {
        name: "resume",
        priority: I.MEDIUM
      },
      TIME_PLAYED: {
        name: "timePlayed",
        priority: I.LOW
      },
      PLAYHEAD_UPDATE: {
        name: "playheadUpdate",
        priority: I.LOW
      },
      CUSTOM: {
        name: "custom",
        priority: I.MEDIUM
      },
      OFFLINE_CONTENT_ACQUIRED: {
        name: "offlineContentAcquired",
        priority: I.HIGH
      },
      ASSET_IMPRESSION: {
        name: "assetImpression",
        priority: I.MEDIUM
      },
      ASSET_CLICK: {
        name: "assetClick",
        priority: I.HIGH
      }
    },
        S = {
      INVALID_DOWNLOAD_TYPE: {
        name: "InvalidDownloadType",
        message: "Not a valid download type for offline content, Download type should be own/rental."
      },
      MISSING_DISCOVERY_CONTEXT: {
        name: "MissingDiscoveryContext",
        message: "Missing ooyalaDiscoveryContext or bucket_info for {{asset}}."
      },
      INVALID_BUCKET_INFO: {
        name: "InvalidBucketInfo",
        message: "Not a version 2 bucket_info: {{bucket_info}}."
      },
      PLUGIN_FIELDS_MISSING: {
        name: "PluginFieldsMissing",
        message: "Plugin missing required fields - name and active."
      },
      PLUGIN_FIELD_INVALID: {
        name: "PluginFieldInvalid",
        message: "Plugin contains invalid field {{field}}."
      },
      PLUGINS_NOT_AN_ARRAY: {
        name: "PluginsNotAnArray",
        message: "Plugins must be an array."
      },
      INVALID_CUSTOM_DIMENSION: {
        name: "InvalidCustomObject",
        message: "The custom dimensions can only contain string, numerals or boolean values. They cannot contain complex objects."
      },
      GEO_FIELD_INVALID: {
        name: "GeoFieldInvalid",
        message: "Geo contains invalid field {{field}}."
      }
    },
        D = {
      VIDEO_BUFFERING_STARTED: "video_buffering_started",
      VIDEO_BUFFERING_ENDED: "video_buffering_ended",
      VIDEO_BUFFERING_TIME: "videoBufferingTime",
      AD_BREAK_STARTED: "ad_break_started",
      AD_BREAK_ENDED: "ad_break_ended",
      AD_BREAK_TIME: "adBreakTime",
      JOIN_TIME: "joinTime"
    },
        v = function v(e, t) {
      e.sequenceNum = this._currentSequenceNumber, i.call(this, t), this._pendingEvents.push(e), this._currentSequenceNumber++;
    };

    Ooyala.Util.createNamespace("Ooyala.Analytics", e), Ooyala.Analytics.Reporter = function (e, t, i) {
      this._base = {}, this._base.asset = {}, t ? this._base.sessionId = t : this._base.sessionId = g(), this._base.contentSessionId = "", this._base.pcode = e, this._base.disablePiiLogging = i || !1, this._base.sessionStartTime = new Date().toISOString(), this._base.analyticsSdkName = "ooyala-iq-analytics-js-sdk", this._base.analyticsSdkVersion = "1.0.21.3.0", this._base.player = {
        playerInfo: {}
      }, this._base.documentUrl = null, this._base.device = {
        deviceInfo: {}
      }, this._base.user = {}, this._lastFlush = 0, this._liveContent = !1, this._contentDuration = 0, this._date = new Date(), this._pendingEvents = [], this._currentSequenceNumber = 0, this._flushTime = Number.MAX_VALUE, this._priorityIntervals = [1e4, 5e3, 1e3], this._seek = {
        start: 0,
        end: 0
      }, this._hasContentStarted = !1, this._flushTimeout = null, this._lastClickedAsset = {};
      var a = "https:";
      this._iqEndpoint = a + "//l-staging.ooyala.com/v3/analytics/events", y.call(this);
    }, Ooyala.Analytics.Reporter.prototype = {
      setIQBackendURL: function setIQBackendURL(e) {
        this._iqEndpoint = e;
      },
      setDocumentURL: function setDocumentURL(e) {
        this._base.documentUrl = e;
      },
      setDeviceInfo: function setDeviceInfo(e, t, i, a) {
        if (!e) {
          var n = new Ooyala.Analytics._GuidManager();
          e = n.getOrGenerateGuid(a);
        }

        var s = {};

        for (var r in t) {
          s[r] = t[r];
        }

        this._base.device = {
          id: e,
          deviceInfo: s
        }, this._base.userAgent = i;
      },
      setUserInfo: function setUserInfo(e, t, i, a, n) {
        var s = {};

        for (var r in a) {
          if ("countryCode" !== r && "region" !== r && "state" !== r && "city" !== r && "latitude" !== r && "longitude" !== r && "geoVendor" !== r) {
            var o = f(S.GEO_FIELD_INVALID);
            throw o.message = o.message.replace("{{field}}", r), o;
          }

          s[r] = a[r];
        }

        this._base.user = {
          emailHashMD5: e,
          userId: t,
          gender: i,
          geo: s,
          isSubscriber: null != n && n
        };
      },
      setPlayerInfo: function setPlayerInfo(e, t, i) {
        this._base.player = {
          id: e,
          name: t,
          version: i
        };
      },
      setSessionId: function setSessionId(e) {
        this._base.sessionId = e;
      },
      reportPlayerLoad: function reportPlayerLoad() {
        d.call(this, A.PLAYER_LOAD);
      },
      initializeMedia: function initializeMedia(e, t, i) {
        y.call(this), this._base.asset.id = e, this._base.asset.idType = t, i ? this._base.contentSessionId = i : this._base.contentSessionId = g(), this._lastClickedAsset.hasOwnProperty("id") && (e === this._lastClickedAsset.id && t === this._lastClickedAsset.idType ? this.updateTopLevelSource(this._lastClickedAsset.source) : this._lastClickedAsset = {});
      },
      setMediaDuration: function setMediaDuration(e) {
        this._contentDuration = e, e <= 0 ? this._liveContent = !0 : l.call(this, e), d.call(this, A.DISPLAY);
      },
      reportPlayRequested: function reportPlayRequested(e) {
        var i = t(A.PLAY_REQUESTED);
        i.isAutoPlay = e || !1, this._playRequestedTime = new Date().getTime(), v.call(this, i, A.PLAY_REQUESTED.priority);
      },
      setPlugins: function setPlugins(e) {
        if (e) {
          if ("[object Array]" != Object.prototype.toString.call(e)) throw f(S.PLUGINS_NOT_AN_ARRAY);

          for (var t in e) {
            var i = p(e[t]);
            if (i) throw i;
          }

          this._base.plugins = e;
        }
      },
      reportOfflineContentAcquired: function reportOfflineContentAcquired(e) {
        if (e != Ooyala.Analytics.OfflineContentDownloadType.FOR_RENT && e != Ooyala.Analytics.OfflineContentDownloadType.TO_OWN) throw f(S.INVALID_DOWNLOAD_TYPE);
        var i = t(A.OFFLINE_CONTENT_ACQUIRED);
        i.downloadType = e, v.call(this, i, A.OFFLINE_CONTENT_ACQUIRED.priority);
      },
      reportReplay: function reportReplay() {
        var e = t(A.REPLAY);
        e.isAutoPlay = !1, v.call(this, e, A.REPLAY.priority);
      },
      reportPlaybackStarted: function reportPlaybackStarted() {
        0 !== this._playRequestedTime && (this._joinTime = 0 === this._adBreakTime ? new Date().getTime() - this._playRequestedTime : new Date().getTime() - this._playRequestedTime - this._adBreakTime, this.reportPrecalculatedEvent(D.JOIN_TIME), this._adBreakTime = 0, this._playRequestedTime = 0), d.call(this, A.VIDEO_STARTED);
      },
      reportPlayHeadUpdate: function reportPlayHeadUpdate(e) {
        if (this._timePlayed = this._timePlayed + (e - this._lastTimePlayed), (this._timePlayed > 2 * this._priorityIntervals[0] || this._timePlayed < 0) && (this._timePlayed = this._priorityIntervals[0]), this._lastTimePlayed = e, this._playheadPositionMillis = e, this._timePlayedMillis = Math.floor(this._timePlayed), i.call(this, A.PLAYHEAD_UPDATE.priority), i.call(this, A.TIME_PLAYED.priority), !this._liveContent) {
          var t = u.call(this, e);
          c.call(this, t);
        }
      },
      reportPause: function reportPause() {
        d.call(this, A.PAUSE);
      },
      reportResume: function reportResume() {
        d.call(this, A.RESUME);
      },
      reportSeek: function reportSeek(e, i) {
        var a = t(A.SEEK);
        a.fromMillis = e, a.toMillis = i, v.call(this, a, A.SEEK.priority);
      },
      reportComplete: function reportComplete() {
        r.call(this), this._flushTimeout && clearTimeout(this._flushTimeout);
      },
      reportCustomEvent: function reportCustomEvent(e, i) {
        var a = t(A.CUSTOM);

        switch (a.customEventName = e, e) {
          case D.VIDEO_BUFFERING_STARTED:
            this._bufferingStartedTime = new Date(a.time).getTime();
            break;

          case D.VIDEO_BUFFERING_ENDED:
            0 !== this._bufferingStartedTime && (this._bufferingTime = new Date(a.time).getTime() - this._bufferingStartedTime, this.reportPrecalculatedEvent(D.VIDEO_BUFFERING_TIME), this._bufferingStartedTime = 0);
            break;

          case D.AD_BREAK_STARTED:
            this._adBreakStartedTime = new Date(a.time).getTime();
            break;

          case D.AD_BREAK_ENDED:
            0 !== this._adBreakStartedTime && (this._adBreakTime = new Date(a.time).getTime() - this._adBreakStartedTime, this._adBreakStartedTime = 0);
        }

        for (var n in i) {
          a[n] = i[n];
        }

        v.call(this, a, A.CUSTOM.priority);
      },
      reportPrecalculatedEvent: function reportPrecalculatedEvent(e) {
        var i = t(A.CUSTOM);

        switch (i.customEventName = e, e) {
          case D.VIDEO_BUFFERING_TIME:
            i.bufferingTimeMillis = this._bufferingTime, this._bufferingTime = 0;
            break;

          case D.JOIN_TIME:
            i.joinTimeMillis = this._joinTime, this._joinTime = 0;
        }

        v.call(this, i, A.CUSTOM.priority);
      },
      updateTopLevelSource: function updateTopLevelSource(e) {
        this._base.source = e;
      },
      reportAssetImpression: function reportAssetImpression(e, i, a, n, s, r) {
        var o = t(A.ASSET_IMPRESSION);
        o.source = m(e, i, a, n, s, r), o.asset = E(e), v.call(this, o, A.ASSET_IMPRESSION.priority);
      },
      reportAssetClick: function reportAssetClick(e, i, a, n, s, r) {
        var o = t(A.ASSET_CLICK);
        this._lastClickedAsset.source = m(e, i, a, n, s, r), o.asset = E(e), this._lastClickedAsset.idType = o.asset.idType, this._lastClickedAsset.id = o.asset.id, o.source = this._lastClickedAsset.source;
        var l = !1;
        i && i.hasOwnProperty("autoplay") && (l = i.autoplay), o.isAutoPlay = l, v.call(this, o, A.ASSET_CLICK.priority);
      },
      setCustomDimensions: function setCustomDimensions(e) {
        if (e) for (var t in e) {
          if ("object" == (0, _typeof2.default)(e[t])) throw f(S.INVALID_CUSTOM_DIMENSION);
        }
        this._base.customDimensions = e;
      }
    }, Ooyala.Analytics.MediaContentType = {
      OOYALA_CONTENT: "ooyala",
      EXTERNAL_CONTENT: "external"
    }, Ooyala.Analytics.OfflineContentDownloadType = {
      TO_OWN: "own",
      FOR_RENT: "rental"
    };
  }(this), function (e) {
    Ooyala.HttpRequester = function (t, i, a) {
      if (this._iqEndpoint = i, this.object = t, this.disablePiiLogging = a || !1, e.XMLHttpRequest) {
        var n = new XMLHttpRequest();
        n.open("POST", this._iqEndpoint), n.setRequestHeader("Content-Type", "application/json;charset=UTF-8"), this.disablePiiLogging && n.setRequestHeader("OO-No-Follow", "true"), n.send(JSON.stringify(this.object));
      } else if (e.XDomainRequest) {
        var n = new e.XDomainRequest();
        n.onload = function () {
          onSuccess(n.responseText);
        }, n.onerror = function () {
          console.log("Error: " + httpErrorCodeTranslation.ieError);
        };

        try {
          n.open(method, uri), n.timeout = timeout, n.send();
        } catch (s) {
          console.log("Error: " + httpErrorCodeTranslation.ieError);
        }
      }
    };
  }(this);
})(OO, OO.$, OO._);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":18,"_process":35}],43:[function(require,module,exports){
"use strict";

(function (OO, $, _) {
  OO.AnalyticsBase = function (messageBus, id) {};

  _.extend(OO.AnalyticsBase.prototype, {
    loadSucceed: function loadSucceed() {},
    // Override this function to do additional setup.
    reportEvent: function reportEvent() {
      throw new Error('Please override this function');
    },
    // Private funciton:
    setup: function setup(messageBus, id, analyticsType) {
      this.mb = messageBus;
      this.elementId = id;
      this._loaded = false;
      this._bufferedEvents = [];
      this.mb.subscribe('*', analyticsType, _.bind(this._onAnalyticsEvent, this));
    },
    loadExternalAnalyticsJs: function loadExternalAnalyticsJs(url) {
      $.getScriptRetry(url, _.bind(this._onLoaded, this), {
        error: function error() {
          // TODO: report error to some log server.
          OO.log('can not load url', url);
        }
      });
    },
    _onLoaded: function _onLoaded() {
      this._loaded = true;
      this.loadSucceed();

      if (!this._bufferedEvents) {
        return;
      }

      _.each(this._bufferedEvents, function (event) {
        this._safeReportEvent.apply(this, event);
      }, this);
    },
    _onAnalyticsEvent: function _onAnalyticsEvent() {
      // TODO: white labeling here.
      if (this._loaded) {
        this._safeReportEvent.apply(this, arguments);
      } else {
        this._bufferedEvents.push(arguments);
      }
    },
    _safeReportEvent: function _safeReportEvent() {
      try {
        this.reportEvent.apply(this, arguments);
      } catch (error) {
        OO.log('can not log event');
      }
    },
    __place_holder: true
  });
})(OO, OO.$, OO._);

},{}],44:[function(require,module,exports){
"use strict";

/* global Ooyala */
(function (OO, $, _) {
  var OOYALA_ANALYTICS = 'ooyala_analytics';
  var OoyalaAnalytics = OO.inherit(OO.AnalyticsBase, function (messageBus, id) {
    if (!OO.requiredInEnvironment('html5-playback')) {
      return;
    }

    this.setup(messageBus, id, OOYALA_ANALYTICS);
    this.lastEmbedCode = '';
    this.currentEmbedcode = '';
    this.playingInstreamAd = false;
    this.playingSsaiAd = false;
    this.currentPlayhead = 0;
    this.lastReportedPlayhead = 0;
    this.guid = undefined;
    this.adOffset = 0;
    this.adTimeline = [];
    this.accountId = undefined;
    this.accountIdSet = false;
    this.guidSet = false;
    this.parameters = undefined;
    this.ssaiAdTransition = false;
    this.documentUrl = undefined;
    this.videoStartSent = false;
    this.isChromeCasting = false;
    this.enableThrift = true;
    this.enableIQ = false;
    this.thriftPcode = null;
    this.jsonPcode = null;
    this.analyticsParams = null; // Note: we load the external JS analytics after the SAS response comes back, so we can propagate the
    // accountId parameter into Reporter if there is one. However, we also need to listen for error events,
    // in case the SAS Authorization fails. If that happens, we also load external JS analytics and
    // instantiate Reporter without an accountId. In either case, we unsubscribe from future authorization
    // fetched or error events.
    // TODO(playback-team): are you guys sure there's no race with SAS authorization request here?

    messageBus.subscribe(OO.EVENTS.AUTHORIZATION_FETCHED, OOYALA_ANALYTICS, _.bind(this._onAuthorizationFetched, this));
    messageBus.subscribe(OO.EVENTS.ERROR, OOYALA_ANALYTICS, _.bind(this._onErrorEvent, this));
    messageBus.subscribe(OO.EVENTS.GUID_SET, OOYALA_ANALYTICS, _.bind(this._onGuidSet, this));
    messageBus.subscribe(OO.EVENTS.REPORT_DISCOVERY_IMPRESSION, OOYALA_ANALYTICS, _.bind(this._onReportDiscoveryImpression, this));
    messageBus.subscribe(OO.EVENTS.REPORT_DISCOVERY_CLICK, OOYALA_ANALYTICS, _.bind(this._onReportDiscoveryClick, this));
    messageBus.subscribe(OO.EVENTS.PLAYER_CREATED, OOYALA_ANALYTICS, _.bind(this._onPlayerCreated, this));
    messageBus.subscribe(OO.EVENTS.METADATA_FETCHED, OOYALA_ANALYTICS, _.bind(this._onMetadataFetched, this));
    messageBus.subscribe(OO.EVENTS.ASSET_CHANGED, OOYALA_ANALYTICS, _.bind(this._onFirstAssetChanged, this));
    messageBus.subscribe(OO.EVENTS.CHROMECAST_START_CAST, OOYALA_ANALYTICS, _.bind(this._onChromecastStartCast, this));
    messageBus.subscribe(OO.EVENTS.CHROMECAST_END_CAST, OOYALA_ANALYTICS, _.bind(this._onChromecastEndCast, this));
  });

  _.extend(OoyalaAnalytics.prototype, {
    _onGuidSet: function _onGuidSet(event, guid) {
      this.guid = guid;
      this.guidSet = true;

      this._onGuidAndAccountIdSet();
    },
    _onPlayerCreated: function _onPlayerCreated(event, elementId, params) {
      this.parameters = params;

      if (this.parameters && this.parameters.docUrl) {
        this.documentUrl = this.parameters.docUrl;
      } else if (this.parameters && this.parameters['flashParams'] && this.parameters['flashParams']['docUrl']) {
        this.documentUrl = this.parameters['flashParams']['docUrl'];
      }

      if (params && params.modules && params.modules.iq) {
        this._setMetadata(params.modules.iq);
      }

      OO.log('OO.OoyalaAnalytics: Player Created');
    },
    _onMetadataFetched: function _onMetadataFetched(event, params) {
      if (params && params.modules && params.modules.iq && params.modules.iq.metadata) {
        this._setMetadata(params.modules.iq.metadata);
      } // Check if iq is enabled in page params and override received metadata


      if (this.parameters && this.parameters.iq && this.parameters.iq.metadata) {
        this._setMetadata(this.parameters.iq.metadata);
      }
    },
    _onAuthorizationFetched: function _onAuthorizationFetched(event, tree) {
      if (tree.user_info && tree.user_info.account_id) {
        this.accountId = tree.user_info.account_id;
      } else if (tree.debug_data && tree.debug_data.user_info && tree.debug_data.user_info.account_id) {
        this.accountId = tree.debug_data.user_info.account_id;
      }

      this.mb.unsubscribe(OO.EVENTS.ERROR, OOYALA_ANALYTICS);
      this.mb.unsubscribe(OO.EVENTS.AUTHORIZATION_FETCHED, OOYALA_ANALYTICS);

      if (_.isNumber(this.accountId)) {
        // Convert numeric id to a string, since reporter.js does a strict type check for strings
        this.accountId = this.accountId.toString();
      }

      if (!_.isString(this.accountId)) {
        this.accountId = undefined;
        OO.d('OO.OoyalaAnalytics: SAS authorization fetched without an accountId');
      } else {
        OO.d('OO.OoyalaAnalytics: SAS authorization fetched with accountId == ' + this.accountId);
      }

      this.accountIdSet = true;

      this._onGuidAndAccountIdSet();
    },

    /**
     * Updates the ad offset for calculating the correct playhead for videos
     * with SSAI ads embedded after a seek has been performed.
     * @private
     * @method _updateAdOffset
     * @param {number} playhead The raw playhead returned by the video plugin (in seconds)
     */
    _updateAdOffset: function _updateAdOffset(playhead) {
      if (this.adTimeline !== null) {
        this.adOffset = 0;

        for (var index = 0; index < this.adTimeline.length; index++) {
          if (this.adTimeline[index].start <= playhead) {
            this.adOffset += this.adTimeline[index].duration;
          }
        }
      }
    },

    /**
     * Processes the timeline of ads received by the SSAI server metadata call.
     * Converts an array of ads to have an end time and offset, and cleans up unused values
     * @private
     * @method _processAdTimeline
     * @param {array} timeline The raw array of ads returned by the SSAI server
     * @returns {array} timeline
     */
    _processAdTimeline: function _processAdTimeline(timeline) {
      if (timeline === null) {
        return [];
      }

      var processedTimeline = [];
      var totalOffset = 0;

      for (var index = 0; index < timeline.length; index++) {
        var milliseconds = 1000;
        var durationMillis = Math.floor(timeline[index].duration * milliseconds);
        var startTimeMillis = Math.floor(timeline[index].start * milliseconds);
        totalOffset += durationMillis;
        var adData = {
          'adId': timeline[index].id,
          'start': startTimeMillis,
          'end': startTimeMillis + durationMillis,
          'duration': durationMillis,
          'offset': totalOffset
        };
        processedTimeline.push(adData);
      }

      return processedTimeline;
    },

    /**
     * Checks the player is inside an SSAI ad block.
     * Checks the passed playhead against the ad timeline and returns true
     * if it is inside an SSAI ad block, false otherwise
     * @private
     * @method _isSSAIAdPlaying
     * @param {number} playhead the playhead time to check (in seconds)
     * @returns {boolean} result
     */
    _isSSAIAdPlaying: function _isSSAIAdPlaying(playhead) {
      for (var index = 0; index < this.adTimeline.length; index++) {
        if (playhead >= this.adTimeline[index].start && playhead < this.adTimeline[index].end) {
          return true;
        }
      }

      return false;
    },
    _onGuidAndAccountIdSet: function _onGuidAndAccountIdSet() {
      if (!this.guidSet || !this.accountIdSet) {
        return;
      }

      OO.d('Loading Analytics Module...');

      this._loadAnalytics();
    },
    _onErrorEvent: function _onErrorEvent(event, params) {
      if (!params || !params['code']) {
        return;
      }

      var code = params['code'];
      var isAuthError = false; // Check if it's a SAS API error. If yes, call _onAuthorizationError, otherwise ignore.

      _.each(OO.ERROR.API.SAS, function (value, key) {
        if (value === code) {
          isAuthError = true;
        }
      });

      if (isAuthError) {
        this._onAuthorizationError(event, code);
      }
    },
    _onAuthorizationError: function _onAuthorizationError(event, errorCode) {
      this.mb.unsubscribe(OO.EVENTS.ERROR, OOYALA_ANALYTICS);
      this.mb.unsubscribe(OO.EVENTS.AUTHORIZATION_FETCHED, OOYALA_ANALYTICS);
      OO.d('OO.OoyalaAnalytics: SAS authorization failed, loading external analytics module ...');

      this._loadAnalytics();
    },
    _onReportDiscoveryImpression: function _onReportDiscoveryImpression(event, params) {
      if (!this.reporter) {
        return;
      }

      try {
        OO.log('Reporting a discovery event: ' + event + ' with params: ' + JSON.stringify(params.custom) + ' and relatedVideos: ' + JSON.stringify(params.relatedVideos));
        this.reporter.reportDiscoveryImpression(params.relatedVideos, params.custom);
        OO.log('OO.OoyalaAnalytics: Reported event: reportDiscoveryImpression with params: ' + JSON.stringify(params.custom) + ' and relatedVideos: ' + JSON.stringify(params.relatedVideos));
      } catch (error) {
        OO.log('Failed to report a discovery impression event with params ' + JSON.stringify(params) + ': ' + error);
      }
    },
    _onReportDiscoveryClick: function _onReportDiscoveryClick(event, params) {
      if (!this.reporter) {
        return;
      }

      try {
        OO.log('Reporting a discovery event: ' + event + 'with params: ' + JSON.stringify(params.custom) + ' for clickedVideo: ' + JSON.stringify(params.clickedVideo));
        this.reporter.reportDiscoveryClick(params.clickedVideo, params.custom);
        OO.log('OO.OoyalaAnalytics: Reported event: reportDiscoveryClick with params: ' + JSON.stringify(params.custom) + ' for clickedVideo: ' + JSON.stringify(params.clickedVideo));
      } catch (error) {
        OO.log('Failed to report a discovery click event with params ' + JSON.stringify(params) + ': ' + error);
      }
    },
    _loadAnalytics: function _loadAnalytics() {
      // PLAYER-970: Bundling the payload of reporter.js into this file
      // Because of this, we will be calling the _onLoaded callback immediately
      // The below line is the old code to fetch analytics.js
      // this.loadExternalAnalyticsJs(OO.URLS.ANALYTICS({ server: OO.SERVER.ANALYTICS }));
      _.bind(this._onLoaded, this)();
    },
    _setMetadata: function _setMetadata(metadata) {
      if (metadata.jsonPcode != null) {
        this.jsonPcode = metadata.jsonPcode;
      }

      if (metadata.thriftPcode != null) {
        this.thriftPcode = metadata.thriftPcode;
      }

      if (metadata.enabled != null) {
        this.enableIQ = metadata.enabled === true || metadata.enabled === 'true';
      }

      if (metadata.allowThrift != null) {
        this.enableThrift = metadata.allowThrift === true || metadata.allowThrift === 'true';
      }

      this._initializeReporter();
    },
    _canReportDisplay: function _canReportDisplay() {
      return !this.enableIQ || this.thriftPcode != null || this.jsonPcode != null;
    },
    _initializeReporter: function _initializeReporter(params) {
      if (!this.enableIQ || this.enableThrift || this.thriftPcode != null || this.jsonPcode != null) {
        var reporterPcode = OO.playerParams.pcode;

        if (this.thriftPcode != null) {
          reporterPcode = this.thriftPcode;
        }

        if (OoyalaAnalytics && OoyalaAnalytics.Reporter) {
          this.reporter = new OoyalaAnalytics.Reporter(reporterPcode, this.analyticsParams);
        }
      } else {
        this.reporter = null;
      }
    },
    _onFirstAssetChanged: function _onFirstAssetChanged(event, asset) {
      if (!asset.ooyalaAsset) {
        return;
      }

      this.mb.unsubscribe(OO.EVENTS.ASSET_CHANGED, OOYALA_ANALYTICS, this._onFirstAssetChanged);
      this.accountId = undefined;
      this.accountIdSet = true;

      this._onGuidAndAccountIdSet();
    },
    _onChromecastStartCast: function _onChromecastStartCast(event) {
      this.isChromeCasting = true;
    },
    _onChromecastEndCast: function _onChromecastEndCast(event) {
      this.isChromeCasting = false;
    },
    loadSucceed: function loadSucceed() {
      // todo this should not be possible
      if (!window.Ooyala || !window.Ooyala.Reporter) {
        return;
      }

      OoyalaAnalytics.Reporter = Ooyala.Reporter;
      OoyalaAnalytics.Pinger = Ooyala.Pinger; // this.guid = OoyalaAnalytics.Pinger.getOrCreateGuid();
      // this.mb.publish(OO.EVENTS.GUID_SET, this.guid);

      this.reporter = null; // TODO: if pcode is not set, we may have an error.

      if (!OO.playerParams.pcode) {
        return;
      }

      this.analyticsParams = {
        accountId: this.accountId,
        guid: this.guid,
        playerBrandingId: OO.playerParams.playerBrandingId
      };

      switch (OO.trackingLevel) {
        case OO.TRACKING_LEVEL.DISABLED:
        case OO.TRACKING_LEVEL.ANONYMOUS:
          this.analyticsParams.doNotTrack = true;
          break;

        case OO.TRACKING_LEVEL.DEFAULT:
        default:
          break;
      }

      if (this.documentUrl) {
        this.analyticsParams = _.extend(this.analyticsParams, {
          documentUrl: this.documentUrl
        });
      }

      this._initializeReporter();
    },
    reportEvent: function reportEvent(eventName, arg1, arg2) {
      if (!this.reporter) {
        // If thrift is disabled then it is expected that this.reporter is null and all
        // analytics reporting will be handled by the JSON pipeline
        if (this.enableThrift) {
          OO.log('Error: trying to report event but reporter does not exist yet.');
        }

        return;
      }

      if (this.isChromeCasting) {
        // we need to stop reporting while we are chromecasting, to avoid double reporting.
        return;
      }

      OO.log('OO.OoyalaAnalytics: Received event: ' + eventName + ', args: ' + arg1 + ', ' + arg2);
      var milliseconds = 1000;

      switch (eventName) {
        case OO.EVENTS.PLAYER_CREATED:
          this.reporter.reportPlayerLoad();
          OO.log('OO.OoyalaAnalytics: Reported event: reportPlayerLoad');
          break;

        case OO.EVENTS.EMBED_CODE_CHANGED:
        case OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD:
          // TODO: get the right duration for the video.
          // When setEmbedCode is called on the same asset it is NOT treated as a replay
          if (arg1 !== this.currentEmbedcode) {
            this.lastEmbedCode = this.currentEmbedcode;
          } else {
            this.lastEmbedCode = '';
          }

          this.currentEmbedcode = arg1;
          break;

        case OO.EVENTS.CONTENT_TREE_FETCHED:
          this.ssaiAdTransition = false;
          this.playingSsaiAd = false;
          this.currentPlayhead = 0;
          this.lastReportedPlayhead = 0;
          this.adOffset = 0;
          this.adTimeline = []; // TODO: get the right duration for the video.

          this.reporter.initializeVideo(this.currentEmbedcode, arg1.duration);
          OO.log('OO.OoyalaAnalytics: Reported event: initializeVideo with embedCode: ' + this.currentEmbedcode + ' and duration: ' + arg1.duration);

          if (this._canReportDisplay()) {
            this.reporter.reportDisplay();
            OO.log('OO.OoyalaAnalytics: Reported event: reportDisplay');
          }

          break;

        case OO.EVENTS.ASSET_CHANGED:
          if (!arg1) {
            break;
          }

          if (arg1.id !== this.currentEmbedcode) {
            this.lastEmbedCode = this.currentEmbedcode;
          } else {
            this.lastEmbedCode = '';
          }

          break;

        case OO.EVENTS.WILL_PLAY_FROM_BEGINNING:
          this.videoStartSent = false;
          break;

        case OO.EVENTS.PLAYING:
          if (!this.videoStartSent) {
            if (this.lastEmbedCode === this.currentEmbedcode) {
              this.reporter.reportReplay();
              OO.log('OO.OoyalaAnalytics: Reported event: reportReplay');
            } else {
              this.reporter.reportVideoStarted();
              OO.log('OO.OoyalaAnalytics: Reported event: reportVideoStarted');
              this.lastEmbedCode = this.currentEmbedcode;
            }

            this.videoStartSent = true;
          }

          break;
        // TODO: reportAdRequest, reportAdClickToSite, reportAdPlayFailure
        // TODO: Add ad metadata

        case OO.EVENTS.SSAI_PLAY_SINGLE_AD:
          var foundAd = false;

          for (var index = 0; index < this.adTimeline.length; index++) {
            if (this.adTimeline[index].adId === arg1.adId) {
              foundAd = true;
            }
          }

          if (!foundAd) {
            var durationMillis = Math.floor(arg1.duration * milliseconds);
            var adData = {
              'adId': arg1.adId,
              'start': this.currentPlayhead,
              'end': this.currentPlayhead + durationMillis,
              'duration': durationMillis,
              'offset': 0
            };
            this.adTimeline.push(adData);
          }

          this.playingSsaiAd = true;
          break;

        case OO.EVENTS.SSAI_SINGLE_AD_PLAYED:
          this.playingSsaiAd = false;
          this.ssaiAdTransition = true;
          break;

        case OO.EVENTS.REPLAY:
          this.lastReportedPlayhead = 0; // SSAI: Check for preroll and update ad offset if present

          this.playingSsaiAd = this._isSSAIAdPlaying(0);

          this._updateAdOffset(0);

          break;

        case OO.EVENTS.SEEKED:
          this.lastReportedPlayhead = 0;
          var newPlayheadMillis = Math.floor(arg1 * milliseconds);
          this.playingSsaiAd = this._isSSAIAdPlaying(newPlayheadMillis);

          this._updateAdOffset(newPlayheadMillis);

          break;

        case OO.EVENTS.WILL_PLAY_ADS:
          this.playingInstreamAd = true;
          var adSource = Ooyala.Reporter.AdSource.UNKNOWN;

          if (arg1 && arg1.type && typeof arg1.type === 'string') {
            adSource = Ooyala.Reporter.AdSource[arg1.type.toUpperCase()];
          }

          this.reporter.setAdSource(adSource, this.currentEmbedcode, arg1 && arg1.click_url);
          this.reporter.reportAdImpression();
          OO.log('OO.OoyalaAnalytics: Reported event: reportAdImpression');
          break;

        case OO.EVENTS.ADS_PLAYED:
          this.playingInstreamAd = false; // TODO, report ads end.

          break;

        case OO.EVENTS.ADS_CLICKED:
          this.reporter.reportAdClickToVideo();
          OO.log('OO.OoyalaAnalytics: Reported event: reportAdClickToVideo');
          break;

        case OO.EVENTS.PLAYHEAD_TIME_CHANGED:
          if (this.playingInstreamAd || this.playingSsaiAd) {
            this.reporter.reportAdPlaythrough(arg1, arg2);
            OO.log('OO.OoyalaAnalytics: Reported event: reportAdPlaythrough with playheadTime: ' + arg1 + ' and totalTime: ' + arg2);
          } else {
            // [PBW-5863] currentTime for live videos is used only for display
            // purposes, the actual playhead is the currentLiveTime parameter (arg6).
            // When present, currentLiveTime should override currentTime for a87yunalytics purposes.
            var currentTime = arg1;
            var offsetIndex = 6;

            if (typeof arguments[offsetIndex] !== 'undefined') {
              currentTime = arguments[offsetIndex];
              this.adOffset = 0;
            }

            var currentTimeMillis = Math.floor(currentTime * milliseconds);

            if (_.isFinite(currentTime) && currentTime > 0) {
              if (this.ssaiAdTransition) {
                if (this._isSSAIAdPlaying(currentTimeMillis)) {
                  break;
                } else {
                  // Update the ad offset as soon as the ad break is done to ensure correct offest
                  // for playhead reporting
                  this._updateAdOffset(currentTimeMillis);

                  this.ssaiAdTransition = false;
                }
              }

              this.currentPlayhead = currentTimeMillis;
              var playheadPosition = this.currentPlayhead - this.adOffset;

              if (playheadPosition < 0) {
                break;
              } // Fix for PLAYER-3592. Never report a playhead smaller than the previous reported playhead unless a seek event happens


              if (playheadPosition > this.lastReportedPlayhead) {
                this.lastReportedPlayhead = playheadPosition;
                this.reporter.reportPlayheadUpdate(playheadPosition);
                OO.log('OO.OoyalaAnalytics: Reported event: reportPlayheadUpdate with playheadPosition: ' + playheadPosition);
              }
            }
          }

          break;

        case OO.EVENTS.REPORT_EXPERIMENT_VARIATIONS:
          OO.log('OO.OoyalaAnalytics: Reported event: reportExperimentVariation with variationIds: ' + JSON.stringify(arg1));
          this.reporter.reportExperimentVariation(arg1.variationIds);
          OO.log('OO.OoyalaAnalytics: Reported event: reportExperimentVariation with variationIds: ' + JSON.stringify(arg1.variationIds));
          break;

        case OO.EVENTS.INITIAL_PLAY:
          this.reporter.reportPlayRequested();
          OO.log('OO.OoyalaAnalytics: Reported event: reportPlayRequested');
          break;

        case OO.EVENTS.SSAI_AD_TIMELINE_RECEIVED:
          this.playingSsaiAd = true;
          this.adTimeline = this._processAdTimeline(arg1['ads']);

          this._updateAdOffset(this.currentPlayhead);

          break;

        default:
        /** do nothing */

      }
    },
    __place_holder: true
  });

  OO.registerModule(OO.MODULE_NAMES.OOYALA_ANALYTICS, function (messageBus, id) {
    return new OoyalaAnalytics(messageBus, id);
  });
})(OO, OO.$, OO._);

},{}],45:[function(require,module,exports){
"use strict";

(function (OO) {
  OO.get_css = function (cssName) {
    if (!OO.stylus_css || !cssName) {
      return null;
    }

    return OO.stylus_css[cssName + '.styl'];
  };
})(OO);

},{}],46:[function(require,module,exports){
"use strict";

OO.VERSION.core.rev = '7ad40ebfdfd0bdd9540fb991d429e36d962a2be7';

},{}],47:[function(require,module,exports){
"use strict";

(function (OO) {
  OO.stylus_css = {
    'root.styl': '#<%= elementId %>>div{width:0;height:0;position:relative;z-index:10000;overflow:hidden}' + '#<%= elementId %> .innerWrapper{background:#000;text-align:left}#<%= elementId %> ' + '.innerWrapper:-webkit-full-screen{width:100%;height:100%}#<%= elementId %> ' + '.innerWrapper:-webkit-full-screen video{width:100%}#<%= elementId %> ' + '.innerWrapper.fullscreen{position:fixed;top:0;left:0;width:100%;height:100%;background:#fff}' + '#<%= elementId %> .oo_playhead{-ms-touch-action:none}',
    __end_marker: 1
  };
})(OO);

},{}],48:[function(require,module,exports){
"use strict";

(function (OO) {
  require('../3rdparty/hazmat-0.1.4.js');

  require('../3rdparty/base64.js');

  require('../3rdparty/jquery_plugins.js');

  require('../3rdparty/jsSHA-1.31.js');

  require('../3rdparty/lzw.js');

  var hazmatConfig = {}; // 'debugHazmat' flag needs to be set before plugins are loaded. If we added
  // this flag to the OO namespace, it would be overriden during plugin initalization,
  // so we need to use a global var instead

  if (!window.debugHazmat) {
    hazmatConfig = {
      warn: function warn() {}
    };
  }

  OO.HM = window.Hazmat.noConflict().create(hazmatConfig);
  OO.jsSHA = window.jsSHA;
  OO.LZW = window.LZW;

  if (!window.console || !window.console.log) {
    window.console = window.console || {};

    window.console.log = function () {};
  }
})(OO);

},{"../3rdparty/base64.js":37,"../3rdparty/hazmat-0.1.4.js":38,"../3rdparty/jquery_plugins.js":39,"../3rdparty/jsSHA-1.31.js":40,"../3rdparty/lzw.js":41}],49:[function(require,module,exports){
"use strict";

(function (OO, _) {
  OO.Emitter = function (messageBus) {
    this.mb = messageBus;
    this._subscribers = {};
  };

  _.extend(OO.Emitter.prototype, {
    on: function on(eventName, subscriber, callback) {
      this._subscribers[eventName] = this._subscribers[eventName] || [];

      this._subscribers[eventName].push({
        callback: callback,
        subscriber: subscriber
      });
    },
    off: function off(eventName, subscriber, callback) {
      this._subscribers[eventName] = _.reject(this._subscribers[eventName] || [], function (elem) {
        return (elem.callback === callback || callback === undefined) && elem.subscriber === subscriber;
      });
    },
    trigger: function trigger(eventName
    /* , args... */
    ) {
      _.each(this._subscribers[eventName] || [], _.bind(this._triggerSubscriber, this, eventName, arguments));

      _.each(this._subscribers['*'] || [], _.bind(this._triggerSubscriber, this, eventName, arguments));
    },
    _triggerSubscriber: function _triggerSubscriber(eventName, params, subscriber) {
      try {
        subscriber.callback.apply(this, params);
      } catch (error) {
        var stack = error.stack || 'unavailable';
        OO.log('Uncaught exception', error, 'Stack', stack, 'triggering subscriber', subscriber, 'with event', eventName, 'Parameters: ', params);
      }
    },
    __placeholder: true
  });
})(OO, OO._);

},{}],50:[function(require,module,exports){
"use strict";

(function (OO, _, HM) {
  // Ensure playerParams exists
  OO.playerParams = HM.safeObject('environment.playerParams', OO.playerParams, {}); // Init publisher's OO.playerParams via player parameter object

  OO.configurePublisher = function (parameters) {
    OO.playerParams.pcode = parameters.pcode || OO.playerParams.pcode || '';
    OO.playerParams.playerBrandingId = parameters.playerBrandingId || OO.playerParams.playerBrandingId || '';
    OO.playerParams.playerType = parameters.playerType || OO.playerParams.playerType || OO.CONSTANTS.PLAYER_TYPE.VIDEO;
    OO.playerParams.debug = parameters.debug || OO.playerParams.debug || '';
  };

  OO.isPublisherConfigured = function () {
    return !!(OO.playerParams.pcode && OO.playerParams.playerBrandingId);
  }; // Set API end point environment


  OO.setServerHost = function (parameters) {
    OO.playerParams.api_ssl_server = parameters.api_ssl_server || OO.playerParams.api_ssl_server || null;
    OO.playerParams.api_server = parameters.api_server || OO.playerParams.api_server || null;
    OO.playerParams.auth_ssl_server = parameters.auth_ssl_server || OO.playerParams.auth_ssl_server || null;
    OO.playerParams.auth_server = parameters.auth_server || OO.playerParams.auth_server || null;
    OO.playerParams.analytics_ssl_server = parameters.analytics_ssl_server || OO.playerParams.analytics_ssl_server || null;
    OO.playerParams.analytics_server = parameters.analytics_server || OO.playerParams.analytics_server || null;
    updateServerHost();
  };

  var updateServerHost = function updateServerHost() {
    OO.SERVER = {
      API: OO.isSSL ? OO.playerParams.api_ssl_server || 'https://player.ooyala.com' : OO.playerParams.api_server || 'http://player.ooyala.com',
      AUTH: OO.isSSL ? OO.playerParams.auth_ssl_server || 'https://player.ooyala.com/sas' : OO.playerParams.auth_server || 'http://player.ooyala.com/sas',
      ANALYTICS: OO.isSSL ? OO.playerParams.analytics_ssl_server || 'https://player.ooyala.com' : OO.playerParams.analytics_server || 'http://player.ooyala.com'
    };
  }; // process tweaks
  // tweaks is optional. Hazmat takes care of this but throws an undesirable warning.


  OO.playerParams.tweaks = OO.playerParams.tweaks || '';
  OO.playerParams.tweaks = HM.safeString('environment.playerParams.tweaks', OO.playerParams.tweaks, '');
  OO.playerParams.tweaks = OO.playerParams.tweaks.split(','); // explicit list of supported tweaks

  OO.tweaks = {};
  OO.tweaks['android-enable-hls'] = _.contains(OO.playerParams.tweaks, 'android-enable-hls');
  OO.tweaks['html5-force-mp4'] = _.contains(OO.playerParams.tweaks, 'html5-force-mp4'); // Max timeout for fetching ads metadata, default to 3 seconds.

  var defaultMaxTimeOut = 5;
  var defaultMaxVastWrapperDepth = 3;
  var defaultMinLiveSeekWindow = 10;
  OO.playerParams.maxAdsTimeout = OO.playerParams.maxAdsTimeout || defaultMaxTimeOut; // max wrapper ads depth we look, we will only look up to 3 level until we get vast inline ads

  OO.playerParams.maxVastWrapperDepth = OO.playerParams.maxVastWrapperDepth || defaultMaxVastWrapperDepth;
  OO.playerParams.minLiveSeekWindow = OO.playerParams.minLiveSeekWindow || defaultMinLiveSeekWindow; // Ripped from: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript

  OO.guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (cipher) {
    var bytes = 16;
    var random = Math.random() * bytes | 0;
    var digits3 = 0x3;
    var digits8 = 0x8;
    var vector = cipher.toLowerCase() === 'x' ? random : random & digits3 | digits8;
    return vector.toString(bytes);
  });
  OO.playerCount = 0; // Check environment to see if this is prod

  OO.isProd = !!(OO.playerParams.environment && OO.playerParams.environment.match(/^prod/i)); // Environment invariant.

  OO.platform = window.navigator.platform;
  OO.os = window.navigator.appVersion;
  OO.supportsVideo = !!document.createElement('video').canPlayType;

  OO.browserSupportsCors = function () {
    try {
      return _.has(new window.XMLHttpRequest(), 'withCredentials') || _.has(window.XMLHttpRequest.prototype, 'withCredentials');
    } catch (error) {
      return false;
    }
  }();

  OO.isWindows = function () {
    return !!OO.platform.match(/Win/);
  }();

  OO.isWindows7 = function () {
    return OO.isWindows && window.navigator.userAgent.match(/Windows NT [\d.]*/)[0].trim() === 'Windows NT 6.1';
  }();

  OO.isIos = function () {
    return !!OO.platform.match(/iPhone|iPad|iPod/);
  }();

  OO.isIphone = function () {
    return !!OO.platform.match(/iPhone|iPod/);
  }();

  OO.isIpad = function () {
    return !!OO.platform.match(/iPad/);
  }();

  OO.iosMajorVersion = function () {
    try {
      if (OO.isIos) {
        return parseInt(window.navigator.userAgent.match(/OS (\d+)/)[1], 10);
      } else {
        return null;
      }
    } catch (err) {
      return null;
    }
  }();

  OO.isAndroid = function () {
    return !!(OO.os.match(/Android/) && !OO.os.match(/Windows Phone/));
  }();

  OO.isAndroid4Plus = function () {
    var version = OO.os.match(/Android [\d\.]*;/); // eslint-disable-line no-useless-escape

    var androidFour = 4;

    if (version && version.length > 0) {
      version = parseInt(version[0].substring(version[0].indexOf(' ') + 1, version[0].search('[\.\;]'))); // eslint-disable-line no-useless-escape
    }

    return OO.isAndroid && version >= androidFour;
  }();
  /**
     * Check if Android version > 4.3
     * @returns {boolean} true if OS is not Android or Android version > 4.3 otherwise false
     */


  OO.isAndroid4_4Plus = function () {
    var isAndroid44Plus = false;

    if (OO.isAndroid) {
      var userAgent = OO.os.match(/Android [\d\.]*;/); // eslint-disable-line no-useless-escape

      if (userAgent && userAgent.length) {
        var userAgentLowerCase = userAgent[0].toLowerCase();
        var version = userAgentLowerCase.match(/android\s([0-9\.]*)/)[1]; // eslint-disable-line no-useless-escape

        var android43 = 4.3;
        isAndroid44Plus = parseFloat(version) > android43;
      }
    }

    return isAndroid44Plus;
  }();

  OO.isRimDevice = function () {
    return !!(OO.os.match(/BlackBerry/) || OO.os.match(/PlayBook/));
  }();

  OO.isFirefox = function () {
    return !!window.navigator.userAgent.match(/Firefox/);
  }();

  OO.isSamsungBrowser = function () {
    return !!window.navigator.userAgent.match(/SamsungBrowser/);
  }();

  OO.isChrome = function () {
    return !!window.navigator.userAgent.match(/Chrome/) && !window.navigator.userAgent.match(/Edge/);
  }();

  OO.isSafari = function () {
    return !!window.navigator.userAgent.match(/AppleWebKit/) && !window.navigator.userAgent.match(/Chrome/) && !window.navigator.userAgent.match(/CriOS/) && // check Chrome/Chromium on iPhone
    // more info is here https://chromium.googlesource.com/chromium/src/+/master/docs/ios/user_agent.md
    !window.navigator.userAgent.match(/like iPhone/);
  }();

  OO.chromeMajorVersion = function () {
    try {
      return parseInt(window.navigator.userAgent.match(/Chrome.([0-9]*)/)[1], 10);
    } catch (err) {
      return null;
    }
  }();

  OO.isIE = function () {
    return !!window.navigator.userAgent.match(/MSIE/) || !!window.navigator.userAgent.match(/Trident/);
  }();

  OO.isEdge = function () {
    return !!window.navigator.userAgent.match(/Edge/);
  }();

  OO.isIE11Plus = function () {
    // check if IE
    if (!window.navigator.userAgent.match(/Trident/)) {
      return false;
    } // extract version number


    var ieVersionMatch = window.navigator.userAgent.match(/rv:(\d*)/);
    var ieVersion = ieVersionMatch && ieVersionMatch[1];
    var ie11 = 11;
    return ieVersion >= ie11;
  }();

  OO.isWinPhone = function () {
    return !!OO.os.match(/Windows Phone/) || !!OO.os.match(/ZuneWP/) || !!OO.os.match(/XBLWP/);
  }();

  OO.isSmartTV = function () {
    return !!window.navigator.userAgent.match(/SmartTV/) || !!window.navigator.userAgent.match(/NetCast/);
  }();

  OO.ismatches = function () {
    return !OO.isIos && !!OO.os.match(/Mac/) && !window.navigator.userAgent.match(/like iPhone/);
  }();

  OO.ismatchesLionOrLater = function () {
    var matches = OO.os.match(/Mac OS X ([0-9]+)_([0-9]+)/);
    var minMatchesLength = 3;

    if (matches == null || matches.length < minMatchesLength) {
      return false;
    }

    var minMajorVersion = 10;
    var minCurrentVersion = 7;
    var currentVersionIndex = 2;
    return parseInt(matches[1], 10) >= minMajorVersion && parseInt(matches[currentVersionIndex], 10) >= minCurrentVersion;
  }();

  OO.matchesSafariVersion = function () {
    try {
      if (OO.ismatches && OO.isSafari) {
        return parseInt(window.navigator.userAgent.match(/Version\/(\d+)/)[1], 10);
      } else {
        return null;
      }
    } catch (err) {
      return null;
    }
  }();

  OO.isKindleHD = function () {
    return !!OO.os.match(/Silk\/2/);
  }();

  OO.supportMSE = function () {
    return 'MediaSource' in window || 'WebKitMediaSource' in window || 'mozMediaSource' in window || 'msMediaSource' in window;
  }();

  OO.supportAds = function () {
    // We are disabling ads for Android 2/3 device, the reason is that main video is not resuming after
    // ads finish. Util we can figure out a work around, we will keep ads disabled.
    return !OO.isWinPhone && !OO.os.match(/Android [23]/);
  }();

  OO.allowGesture = function () {
    return OO.isIos;
  }();

  OO.allowAutoPlay = function () {
    return !OO.isIos && !OO.isAndroid;
  }();

  OO.supportTouch = function () {
    // IE8- doesn't support JS functions on DOM elements
    return document.documentElement.hasOwnProperty && document.documentElement.hasOwnProperty('ontouchstart');
  }();

  OO.docDomain = function () {
    var domain = null;

    try {
      domain = document.domain;
    } catch (error) {}

    if (!OO._.isEmpty(domain)) {
      return domain;
    }

    if (OO.isSmartTV) {
      return 'SmartTV';
    }

    return 'unknown';
  }();

  OO.uiParadigm = function () {
    var paradigm = 'tablet'; // The below code attempts to decide whether or not we are running in 'mobile' mode
    // Meaning that no controls are displayed, chrome is minimized and only fullscreen playback is allowed
    // Unfortunately there is no clean way to figure out whether the device is tablet or phone
    // or even to properly detect device screen size http://tripleodeon.com/2011/12/first-understand-your-screen/
    // So there is a bunch of heuristics for doing just that
    // Anything that is not explicitly detected as mobile defaults to desktop
    // so worst case they get ugly chrome instead of unworking player

    if (OO.isAndroid4Plus && OO.tweaks['android-enable-hls']) {
      // special case for Android 4+ running HLS
      paradigm = 'tablet';
    } else if (OO.isIphone) {
      paradigm = 'mobile-native';
    } else if (OO.os.match(/BlackBerry/)) {
      paradigm = 'mobile-native';
    } else if (OO.os.match(/iPad/)) {
      paradigm = 'tablet';
    } else if (OO.isKindleHD) {
      // Kindle Fire HD
      paradigm = 'mobile-native';
    } else if (OO.os.match(/Silk/)) {
      // Kindle Fire
      paradigm = 'mobile';
    } else if (OO.os.match(/Android 2/)) {
      // On Android 2+ only window.outerWidth is reliable, so we are using that and window.orientation
      var halfCircle = 180;
      var widthInPx480 = 480;
      var widthInPx560 = 560;

      if (window.orientation % halfCircle === 0 && window.outerWidth / window.devicePixelRatio <= widthInPx480) {
        // portrait mode
        paradigm = 'mobile';
      } else if (window.outerWidth / window.devicePixelRatio <= widthInPx560) {
        // landscape mode
        paradigm = 'mobile';
      }
    } else if (OO.os.match(/Android/)) {
      paradigm = 'tablet';
    } else if (OO.isWinPhone) {
      // Windows Phone is mobile only for now, tablets not yet released
      paradigm = 'mobile';
    } else if (!!OO.platform.match(/Mac/) || // Macs
    !!OO.platform.match(/Win/) || // Winboxes
    !!OO.platform.match(/Linux/)) {
      // Linux
      paradigm = 'desktop';
    }

    return paradigm;
  }();
  /**
     * Determines if a single video element should be used.<br/>
     * <ul><li>Use single video element on iOS, all versions</li>
     *     <li>Use single video element on Android, all versions</li></ul>
     * 01/11/17 Previous JSDoc for Android - to be removed once fix is confirmed and there is no regression:<br />
     * <ul><li>Use single video element on Android < v4.0</li>
     *     <li>Use single video element on Android with Chrome < v40<br/>
     *       (note, it might work on earlier versions but don't know which ones! Does not work on v18)</li></ul>
     *
     * @private
     * @returns {boolean} True if a single video element is required
     */


  OO.requiresSingleVideoElement = function () {
    // 01/11/17 - commenting out, but not removing three lines below pending QA, we may need to restore this logic
    // PLAYER-2454 - Commenting back in, since current Android environments support multiple video elements.
    // On IMA, we cannot force a single video element so we need to make sure this function is proper
    var iosRequireSingleElement = OO.isIos;
    var chromeVersion = 40;
    var androidRequireSingleElement = OO.isAndroid && (!OO.isAndroid4Plus || OO.chromeMajorVersion < chromeVersion);
    return iosRequireSingleElement || androidRequireSingleElement;
  }(); // TODO(jj): need to make this more comprehensive
  // Note(jj): only applies to mp4 videos for now


  OO.supportedVideoProfiles = function () {
    // iOS only supports baseline profile
    if (OO.isIos || OO.isAndroid) {
      return 'baseline';
    }

    return null;
  }(); // TODO(bz): add flash for device when we decide to use stream data from sas
  // TODO(jj): add AppleTV and other devices as necessary


  OO.device = function () {
    var device = 'html5';

    if (OO.isIphone) {
      device = 'iphone-html5';
    } else if (OO.isIpad) {
      device = 'ipad-html5';
    } else if (OO.isAndroid) {
      device = 'android-html5';
    } else if (OO.isRimDevice) {
      device = 'rim-html5';
    } else if (OO.isWinPhone) {
      device = 'winphone-html5';
    } else if (OO.isSmartTV) {
      device = 'smarttv-html5';
    }

    return device;
  }(); // list of environment-specific modules needed by the environment or empty to include all
  // Note: should never be empty because of html5


  OO.environmentRequiredFeatures = function () {
    var features = [];

    if (OO.os.match(/Android 2/)) {
      // safari android
      features.push('html5-playback');
    } else {
      // normal html5
      features.push('html5-playback');

      if (OO.supportAds) {
        features.push('ads');
      }
    }

    return _.reduce(features, function (memo, feature) {
      return memo + feature + ' ';
    }, '');
  }();

  OO.supportMidRollAds = function () {
    return OO.uiParadigm === 'desktop' && !OO.isIos && !OO.isRimDevice;
  }();

  OO.supportCookies = function () {
    document.cookie = 'ooyala_cookie_test=true';
    var cookiesSupported = document.cookie.indexOf('ooyala_cookie_test=true') >= 0;
    document.cookie = 'ooyala_cookie_test=; expires=Thu, 01 Jan 1970 00:00:00 GMT';
    return cookiesSupported;
  }();

  OO.isSSL = document.location.protocol === 'https:';
  updateServerHost(); // returns true iff environment-specific feature is required to run in current environment

  OO.requiredInEnvironment = OO.featureEnabled = function (feature) {
    return !!OO.environmentRequiredFeatures.match(new RegExp(feature));
  }; // Detect Chrome Extension. We will recieve an acknowledgement from the content script, which will prompt us to start sending logs


  OO.chromeExtensionEnabled = !!document.getElementById('ooyala-extension-installed'); // Locale Getter and Setter

  OO.locale = '';

  OO.setLocale = function (locale) {
    OO.locale = locale.toUpperCase();
  };

  OO.getLocale = function () {
    var localeStrLength = 2;
    return (OO.locale || document.documentElement.lang || navigator.language || navigator.userLanguage || 'en').substr(0, localeStrLength).toUpperCase();
  };
})(OO, OO._, OO.HM);

},{}],51:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

(function (OO, _) {
  /**
   * @class MessageBus
   * @classdesc Represents the Ooyala V4 Player Message Bus. Use message bus events to subscribe to or publish player events from video to ad playback.
   * <p>When you create an {@link OO.Player} object (for example, <code>myplayer = OO.Player.create(...)</code> ), that object contains a Message Bus object named <code>mb</code>.
   * For example, you would access the <code><a href="#publish">publish()</a></code> method by calling <code>myplayer.mb.publish(...)</code>.</p>
   * @public
   */
  OO.MessageBus = function () {
    this._emitter = new OO.Emitter(this);
    this._dependentEmitter = new OO.Emitter(this);
    this._interceptEmitter = new OO.Emitter(this);
    this._interceptArgs = {};
    this._dependentList = {};
    this._blockList = {};
    this._readyEventList = {};
    this._dispatching = false; // whether message bus is currently dispatching published events

    this._publishingQueue = [];
    this.blockedEvent = {};
    this.blockedParams = {}; // public properties

    this._messageHistory = [];
    this._tracer = _.bind(this._internalTracer, this); // default internal tracer
    // add a random ID for debug

    this.MbId = OO.getRandomString();
    this.debug = false;
  };

  _.extend(OO.MessageBus.prototype, {
    // Adds a tracer function, which will be fired for each published/executed event
    addTracer: function addTracer(newTracer) {
      if (newTracer && _.isFunction(newTracer)) {
        if (this._tracer) {
          this._tracer = _.wrap(this._tracer, function () {
            newTracer.apply(this, _.rest(arguments));
          });
        } else {
          this._tracer = newTracer;
        }
      }
    },
    _internalTracer: function _internalTracer() {
      this._messageHistory.push(_.toArray(arguments));
    },
    messageTraceSnapshot: function messageTraceSnapshot() {
      return _.toArray(this._messageHistory);
    },

    /*
     * addDependent blocks eventName until dependentEvent fires, at which point onMergeParams will be
     * called.  This means that eventName MUST be fired before dependentEvent.
     */

    /**
     * Enables you to send a publish or subscribe message that is dependent on a condition or event.
     * For example, you might want to change the UI based on the location or time of day.
     * This method blocks the event (<code>eventName</code>) until the dependent event (<code>dependentEvent</code>) fires.
     * For more information and examples of usage, see
     * <a href="http://support.ooyala.com/developers/documentation/reference/player_v3_dev_listenevent.html" target="target">Listening to a Message Bus Event</a>.
     *
     * @method addDependent
     * @memberOf OO.MessageBus.prototype
     * @param {String} eventName The name of the event.
     * @param {String} dependentEvent The name of the event that triggers the specified event name.
     * @param {String} subscriber The name of the subscriber to which the message bus will publish the event.
     * @param {function} onMergeParams (Optional) A function used to pass data to the handler for the dependent event.
     * This function is only necessary if need to complete a computation before passing data to the dependent event handler.
     * This function can take up to four arguments and returns an array of arguments to be passed into the dependent event listener.
     * @example
     *        //  This blocks the PAUSED event from firing until
     *        // the 'user_allowed_pause' event has fired
     *        player.mb.addDependent(
     *          OO.EVENTS.PAUSED,
     *          'user_allowed_pause',
     *          'example',
     *          function(){}
     *        );
     * @public
     */
    addDependent: function addDependent(eventName, dependentEvent, subscriber, onMergeParams) {
      // TODO, add a circular detectecion here.
      if (!eventName || eventName === '' || !dependentEvent || dependentEvent === '') {
        console.error('MB: addDependent called on message bus from subscriber ' + subscriber + ' with no event name given.');
        return;
      }

      if (this.debug) {
        OO.log('MB DEBUG: "' + eventName + '" depends on "' + dependentEvent + '". Added by "' + subscriber + '"');
      }

      this._dependentList[eventName] = this._dependentList[eventName] || [];

      this._dependentList[eventName].push(dependentEvent);

      this._blockList[dependentEvent] = this._blockList[dependentEvent] || [];

      this._blockList[dependentEvent].push(eventName);

      this.blockedParams[eventName] = [];

      var onSourceReady = OO._.bind(function (error) {
        if (this.blockedEvent[error] !== 1) {
          return;
        }

        var args = OO.safeClone(_.flatten(arguments));
        var origParams = OO.safeClone(this.blockedParams[eventName]);
        args.shift();
        origParams.shift();
        var newArgs = onMergeParams && onMergeParams.apply(this, [eventName, dependentEvent, origParams, args]) || origParams;
        newArgs = [error].concat(newArgs);
        delete this.blockedEvent[error];
        this.blockedParams[error] = [];

        if (this.debug) {
          OO.log('MB DEBUG: unblocking "' + error + '" because of "' + dependentEvent + '" with args ', newArgs);
        }

        this._publish.apply(this, newArgs);
      }, this);

      this._dependentEmitter.on(eventName, subscriber, onSourceReady);
    },

    /**
     * Removes all dependencies on event 'source' by event 'target'
     * @memberOf OO.MessageBus.prototype
     * @param {string} source The depending event that is blocked
     * @param {string} target The dependent event that is blocking
     * @public
     */
    removeDependent: function removeDependent(source, target) {
      if (!source || source === '' || !target || target === '') {
        console.warn('MB: removeDependent called on message bus with no event name given.');
        return;
      }

      if (this.debug) {
        OO.log('MB DEBUG: "' + source + '" no longer depends on "' + target + '"');
      }

      this._clearDependent(source, target);
    },

    /**
     * Enables you to publish events to the message bus.<br/>
     *
     * @method publish
     * @memberOf OO.MessageBus.prototype
     * @param {String} eventName The name of the event. Comma-separated arguments for the event may follow the event name as needed.
     * @example myplayer.mb.publish(OO.EVENTS.PLAY);
     * @example myplayer.mb.publish(OO.EVENTS.WILL_CHANGE_FULLSCREEN,true);
     * @public
     */
    publish: function publish() {
      if (!arguments || !arguments[0] || arguments[0] === '') {
        console.error('MB: publish called on message bus with no event name given.');
        return;
      }

      var args = OO.safeClone(_.flatten(arguments));

      this._publishingQueue.push(args);

      if (this.debug) {
        OO.log('MB DEBUG: queueing "' + arguments[0] + '" args', args);
      }

      if (!this._dispatching) {
        this._dispatching = true;

        var ev = this._publishingQueue.shift();

        while (ev) {
          this._publish.apply(this, ev);

          ev = this._publishingQueue.shift();
        }

        this._dispatching = false;
      }
    },
    _publish: function _publish(eventName) {
      // queue event here untill all dependency is cleared.
      // also trigger queued event if there are blocked by this event.
      this._readyEventList[eventName] = 1;
      var args = OO.safeClone(_.flatten(arguments));

      this._interceptEmitter.trigger.apply(this._interceptEmitter, args);

      if (this._interceptArgs[eventName] === false) {
        this._interceptArgs[eventName] = true;
        return;
      }

      if (this._interceptArgs[eventName]) {
        args = _.flatten([eventName, this._interceptArgs[eventName]]);
      }

      if (this._tracer && _.isFunction(this._tracer)) {
        var params = _.flatten(['publish'].concat(args));

        this._tracer.apply(this._tracer, params);
      }

      if (this._noDependency(eventName)) {
        if (this.debug) {
          OO.log('MB DEBUG: publishing "' + eventName + '"args ', args);
        } // Intercept setEmbedCode, prevent emptyString to be set


        if (eventName === OO.EVENTS.SET_EMBED_CODE) {
          // if we did not get the value of embedCode (args [1]),
          // then we look whether it is a playlist.
          // If there is playlist plugin and the value of useFistVideoFromPlaylist is true,
          // then continue, if not, exit the function
          var argIndex1 = 1;

          if (!args[argIndex1] || args[argIndex1].length === 0 || !args[argIndex1].trim()) {
            var argIndex2 = 2;
            var playerParams = args[argIndex2];

            if (!(OO.isPlaylistsPluginIncluded() && playerParams && playerParams !== null && (0, _typeof2.default)(playerParams) === 'object' && typeof playerParams[OO.PLUGINS.PLAYLISTS_PLUGIN] !== 'undefined' && playerParams[OO.PAGE_LEVEL_PARAMS.USE_FIRST_VIDEO_FROM_PLAYLIST])) {
              console.error('MB: no embed code and/or playlist plugin');
              return;
            }
          }
        }

        this._emitter.trigger.apply(this._emitter, args);

        _.each(this._blockList[eventName], function (event) {
          this._clearDependent(event, eventName);

          args[0] = event;

          this._dependentEmitter.trigger.apply(this._dependentEmitter, args);
        }, this);

        delete this._blockList[eventName];
      } else {
        if (this.debug) {
          OO.log('MB DEBUG: blocking "' + eventName + '" because of "' + this._dependentList ? this._dependentList[eventName] : '[null]' + '"');
        }

        this.blockedEvent[eventName] = 1;
        this.blockedParams[eventName] = args;
      }
    },

    /*
     * eventName is the event to intercept
     * subscriber is the subscriber
     * callback returns a list of arguments, not including the eventName
     */

    /**
     * Enables you to subscribe to events to the message bus using a callback function that
     * allows you to manipulate the event payload and name. The returned list of arguments
     * from the callback can be used in subsequent event triggers. For more information and examples of usage, see
     * <a href="http://support.ooyala.com/developers/documentation/reference/player_v3_dev_listenevent.html" target="target">Listening to a Message Bus Event</a>.<br/>
     *
     * @method intercept
     * @memberOf OO.MessageBus.prototype
     * @param {String} eventName The name of the event to intercept.
     * @param {String} subscriber The name of the subscriber to which the message bus will publish the event.
     * @param {function} callback A function that returns a list of arguments used in subsequent event triggers.
     * This allows you to manipulate the event payload and name. To cancel propagation of an event using an intercepter,
     * return <code>false</code> instead of an array.
     * @example In the following example we subscribe to the published message bus PLAY event,
     * specify 'test-plugin' as the subscriber and specify a payload of 'hello'.
     *
     * We also include an intercept that swaps the string 'goodbye' into the payload
     * so that when the message bus publishes the PLAY event, the console outputs 'goodbye' instead of 'hello':
     *
     * mb.subscribe(OO.EVENTS.PLAY, "test-plugin", function(eventName, payload) {
     *    console.log(eventName+": "+payload);
     * });
     *
     * mb.publish(OO.EVENTS.PLAY, "hello");
     *
     * // Console displays "play: hello"
     *
     * mb.intercept(OO.EVENTS.PLAY, "test-plugin", function(eventName, payload) {
     *     return ["goodbye"];
     * });
     *
     * //   Console displays "play: goodbye"
     * @private
     */
    intercept: function intercept(eventName, subscriber, callback) {
      this._interceptEmitter.on(eventName, subscriber, _.bind(function () {
        if (!eventName || eventName === '') {
          console.error('MB: intercept called on message bus from subscriber ' + subscriber + ' with no event name given.');
          return;
        }

        var args = OO.safeClone(_.flatten(arguments));

        if (this._interceptArgs[eventName] !== false) {
          this._interceptArgs[eventName] = callback.apply(this, args);
        }
      }, this));

      this._interceptArgs[eventName] = [eventName];
    },

    /**
     * Subscribe to an event published to the message bus.
     *
     * @method subscribe
     * @memberOf OO.MessageBus.prototype
     * @param {String} eventName The name of the event.
     * @param {String} subscriber The name of the subscriber to which the message bus will publish the event.
     * @param {Function} callback The function that will execute when the subscriber receives the event notification.
     * @example myplayer.mb.subscribe(OO.EVENTS.METADATA_FETCHED, 'example', function(eventName) {});
     * @example // Subscribes to all events published by the Message Bus
     * messageBus.subscribe("*", 'example', function(eventName) {});
     * @public
     */
    subscribe: function subscribe(eventName, subscriber, callback) {
      // TODO check if it is on the dependent queue, should not allow this action if a event is blocking
      // other event.
      if (!eventName || eventName === '') {
        console.error('MB: subscribe called on message bus from subscriber ' + subscriber + ' with no event name given.');
        return;
      }

      this._emitter.on(eventName, subscriber, callback);
    },

    /**
     * Unsubscribes from an event published to the message bus.
     *
     * @method unsubscribe
     * @memberOf OO.MessageBus.prototype
     * @param {String} eventName The name of the event.
     * @param {String} subscriber The name of the subscriber to which the message bus will unsubscribe from the event.
     * @param {Function} callback The function that normally executes when the subscriber receives the event notification.
     * @example messageBus.unsubscribe(OO.EVENTS.METADATA_FETCHED, 'example', function(eventName) {});
     * @example // Unsubscribes from all events published by the Message Bus
     * messageBus.unsubscribe("*", 'example', function(eventName) {});
     * @public
     */
    unsubscribe: function unsubscribe(eventName, subscriber, callback) {
      if (!eventName || eventName === '') {
        console.error('MB: unsubscribe called on message bus from subscriber ' + subscriber + ' with no event name given.');
        return;
      }

      this._emitter.off(eventName, subscriber, callback);
    },
    // Start of the private member function, all internal used func will prefix with _
    _noDependency: function _noDependency(eventName) {
      if (!this._dependentList[eventName]) {
        return true;
      }

      return this._dependentList[eventName].length === 0;
    },
    _clearDependent: function _clearDependent(source, target) {
      var depEvents = this._dependentList[source];
      this._dependentList[source] = OO._.filter(depEvents, function (event) {
        return event !== target;
      }, this);
    },
    /// //////////////////
    /// / DEBUG TOOLS ////
    /// //////////////////

    /**
     * Start debugging the message bus messages. It will display when dependents are added,
     * when they are removed, when messages get blocked, when messages are queued
     * and when they actually get published.
     *
     * This is mainly intended to be used in the console when debugging.
     * @private
     * @returns {string} Message that states debugging has started. (Mostly for console output)
     */
    startDebug: function startDebug() {
      this.debug = true;
      return 'MB DEBUGGING STARTED';
    },

    /**
     * Stop debugging the message bus messages.
     *
     * This is mainly intended to be used in the console when debugging.
     * @private
     * @returns {string} Message that states debugging has stopped. (Mostly for console output)
     */
    stopDebug: function stopDebug() {
      this.debug = false;
      return 'MB DEBUGGING STOPPED';
    },

    /**
     * Return a test formatted string of the dependent messages and which ones are
     * currently blocked.
     * @private
     * @returns {string} Formatted string of dependent messages and which ones are blocked.
     */
    listDependencies: function listDependencies() {
      var output = '------------------------------------\n' + '[blocked] Message --> Dependency\n' + '------------------------------------\n';
      var index;

      if (this._dependentList) {
        for (var eventName in this._dependentList) {
          if (this._dependentList[eventName]) {
            for (index = 0; index < this._dependentList[eventName].length; index++) {
              if (this.blockedEvent[eventName] === 1) {
                output += '[blocked]';
              }

              output += eventName + ' --> ' + this._dependentList[eventName] + '\n';
            }
          }
        }
      }

      output += '------------------------------------';
      return output;
    }
  });
})(OO, OO._);

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":18}],52:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

(function (OO, _, $) {
  OO.players = {};
  /**
   * @class OO.Player
   * @classdesc Creates and destroys an instance of the Ooyala V4 Player.
   * @public
   * @param {string} _elementId The DOM id of the element that wraps the player
   * @param {string|object} _asset The asset's Ooyala id or metadata
   * @param {object} _parameters The session parameters
   */

  OO.Player = function (_elementId, _asset, _parameters) {
    // validate params
    // _parameters is optional. Hazmat takes care of this but throws an undesirable warning.
    _parameters = _parameters || {}; // eslint-disable-line no-param-reassign

    var elementId = OO.HM.safeDomId('Player.create.elementId', _elementId);
    var parameters = OO.HM.safeObject('Player.create.parameters', _parameters, {});
    var persistentSettings = {
      'closedCaptionOptions': {}
    };
    parameters.onCreate = OO.HM.safeFunctionOrNull('Player.create.parameters.onCreate', parameters.onCreate); // instance variables

    var mb = new OO.MessageBus();

    if (parameters.debug && parameters.enableDebugTools && parameters.enableDebugTools.startDebugMB === true) {
      mb.debug = true;
    }

    $('#' + elementId).html(''); // clear the container for player rendering.
    // Module initialziation

    var modules = OO._.map(OO.modules, function (moduleDefinition) {
      var id = moduleDefinition.name + '-' + OO.getRandomString();
      var module = {
        name: moduleDefinition.name,
        moduleId: id,
        // a random id to help debug
        instance: moduleDefinition.factory(mb, id, parameters) // Modules Only See MB directly, not the player

      };
      OO.log('Loaded plugin', module.moduleId, module);
      return module;
    }); // init persistent player settings from local storage


    var localSettings = OO.localStorage.getItem(OO.CONSTANTS.OOYALA_PLAYER_SETTINGS_KEY);

    if (localSettings) {
      persistentSettings = JSON.parse(localSettings);
    } // Api setup


    var playerApi = new OO.PlayerApi(mb, _elementId, modules, parameters, persistentSettings); // Destroyal

    mb.subscribe(OO.EVENTS.DESTROY, 'player', _.bind(function (event, embedCode) {
      $('#' + elementId).empty();
      delete OO.players[elementId];
      OO.removeStyles(elementId); // [PBW-459] Call optional destory() callback after DESTROY is complete.

      playerApi.triggerDestroyCallback();
    }, this)); // give the creator a chance to initalize itself

    if (_.isFunction(parameters.onCreate)) {
      parameters.onCreate(playerApi);
    } // announce player instance was created


    var createTime = new Date().valueOf();
    var playerUrl = '';

    if (OO.$.ajaxSettings != null) {
      playerUrl = OO.$.ajaxSettings.url;
    }

    mb.publish(OO.EVENTS.PLAYER_CREATED, elementId, parameters, persistentSettings, _asset, createTime, playerUrl);
    /*
    PARTITION THE FLOW TO CMS-LESS PLAYER. Prevent any setEmbedCode action to execute
    */

    if ((0, _typeof2.default)(_asset) === 'object') {
      _asset = OO.HM.safeObject('assetObject', _asset); // eslint-disable-line no-param-reassign

      playerApi.setAsset(_asset, parameters);
    } else if (typeof _asset === 'string') {
      // Normal CMS workflow. Initiate content loading
      _asset = OO.HM.safeStringOrNull('assetString', _asset); // eslint-disable-line no-param-reassign

      if (OO.isHevcEnabled(parameters)) {
        OO.checkHevcAvailability(function (result, codec) {
          var resultParams = {};
          resultParams[codec] = result.result;

          if (result.error) {
            mb.publish(OO.EVENTS.HEVC_CHECKED, resultParams, codec, result.error);
          } else {
            mb.publish(OO.EVENTS.HEVC_CHECKED, resultParams, codec);
          }
        });
      }

      playerApi.setEmbedCode(_asset, parameters);
    }

    return playerApi;
  }; // Public Player API Class Methods


  OO.exposeStaticApi('Player', {
    /**
     * Creates a player object and attaches it to the specified element.
     * This is an asynchronous method and will return before the player is completely initialized.
     * Listen for the <code>PLAYBACK_READY</code> event to determine whether the player is completely initialized.
     *
     * @public
     * @method create
     * @memberOf OO.Player
     * @param {Number} elementId The ID of the element to which to attach the player object.
     * @param {Number} asset The asset. The player will load the asset. Only a single video is supported.
     * @param {Object} parameters The player parameters. These can be used to customize player ads and behavior, and can determine player styles.
     * For more information, see <a href="http://support.ooyala.com/developers/documentation/api/player_v3_api_embedparams.html" target="target">Embedded Parameters</a>.
     * @returns {Object} The created player object.
     */
    create: function create(elementId, asset, parameters) {
      parameters = parameters || {}; // eslint-disable-line no-param-reassign
      // Check and see if correct routing is with correct player version

      var lastCoreVersionString = '4';
      var lastCoreVersionNumber = 4;

      if (!OO.playerParams['core_version'] || OO.playerParams['core_version'] !== lastCoreVersionString && OO.playerParams['core_version'] !== lastCoreVersionNumber) {
        // wrong routing with v4 player, so throw an error since v4 player doesn't accept non-v4 routing
        console.error('Error: A v4 player has been specified using a mismatch route. ' + 'v4 players can only be used with a v4 route.');
        return null;
      } // Some parts of the code obtain the pcode and playerBrandingId values directly
      // from the page-level parameters, so we make sure that the internal values set
      // by Valhalla are available at the page-level as well.
      // Page-level params will have precedence over Valhalla values in order to accommodate sub-accounts.


      var playerParams = _.extend({}, OO.playerParams, parameters); // extend Pcode, playerBrandingId and debug to playerParams


      OO.configurePublisher(playerParams);

      if (!OO.isPublisherConfigured()) {
        console.error('Error: pcode and playerBrandingId must be provided');
        return null;
      } // Set player environment if provided in parameters


      OO.setServerHost(playerParams); // will not allow OO.players create twice for the same embedding element.

      if (!OO.players[elementId]) {
        OO.playerCount++;
        OO.players[elementId] = OO.Player(elementId, asset, playerParams);
      }

      if (OO.DEBUG !== false && OO.DEBUG !== true) {
        OO.DEBUG = playerParams.debug === true;

        if (OO.DEBUG === true) {
          this.exposeDebugApi(elementId, OO.players[elementId]); // activate tools from the player params

          this.enableDebugTools(elementId, playerParams['enableDebugTools']);
        }
      }

      return OO.players[elementId];
    },

    /**
     * Isolates the specified player for debugging. <code>debug.ooyala.com</code> automatically generates a valid V3 embedded player.
     * When you call this on a player it automatically generates the corresponding <code>debug.ooyala.com</code> test page.
     *
     * @public
     * @method isolate
     * @memberOf OO.Player.prototype
     * @param {String} targetPlayer The name of the <code>div</code> container in which to load the player.
     * @returns {String} url The link to the isolated player.
     */
    isolate: function isolate(targetPlayer) {
      var url = 'http://debug.ooyala.com/?';
      var pbid = OO.playerParams.playerBrandingId;

      if (pbid) {
        url += 'pbid=' + pbid + '&';
      } // find the player


      var player;

      if (targetPlayer) {
        player = OO.players[targetPlayer];
      } else if (OO.playerCount > 1) {
        console.log('More than one player to choose.' + 'Please specify the target div of the intended player as a parameter');
        console.log('Available players are: ', _.keys(OO.players));
        return _.keys(OO.players);
      } else if (OO.playerCount < 1) {
        console.log('There are no players on the page to isolate');
        return '';
      } else {
        // Get the only player available in the list
        player = _.values(OO.players)[0];
      }

      var params = JSON.stringify(player.parameters);
      var ec = player.embedCode;

      if (params) {
        url += 'options=' + encodeURIComponent(params) + '&';
      }

      if (ec) {
        url += 'ec=' + ec + '&';
      } // If this isn't local development or default, then there is a version specified


      if (OO.playerParams.environment !== 'local-dev' && OO.playerParams.v3_version_source !== 'default') {
        url += 'version=' + OO.playerParams.v3_version + '&';
      } // We need to check if it is suppose to play a html5 player or not, so we check if the platform doesn't have flash in the string
      // and that if it doesn't then it is also not html5-fallback which would need to play the flash player.


      var environmentRF = OO.environmentRequiredFeatures;

      if (environmentRF.indexOf('html5-playback') > -1) {
        url += 'useHtml5=true' + '&';
      }

      console.log("If you are copying this link, do not highlight. Right click and press 'copy link address'");
      return url;
    },

    /**
     * Private function that exposes the debug api to the public version of OO.
     * @private
     * @method player#exposeDebugApi
     * @param {String} playerName - the player name
     * @param {Object} player - current player object
     */
    exposeDebugApi: function exposeDebugApi(playerName, player) {
      if (!OO.publicApi) {
        return;
      }

      if (!OO.publicApi.DEBUG) {
        OO.publicApi.DEBUG = {};
      }
      /* CONSOLE OUTPUT TOOLS */

      /**
       * Refer to OO.consoleOutput
       * @method OO#DEBUG#consoleOutput
       */


      OO.publicApi.DEBUG.consoleOutput = OO.consoleOutput;
      /**
       * Refer to OO.startRecordingConsoleOutput.
       * @method OO#DEBUG#startRecordingConsoleOutput
       */

      OO.publicApi.DEBUG.startRecordingConsoleOutput = OO.startRecordingConsoleOutput;
      /**
       * Refer to OO.stopRecordingConsoleOutput.
       * @method OO#DEBUG#stopRecordingConsoleOutput
       */

      OO.publicApi.DEBUG.stopRecordingConsoleOutput = OO.stopRecordingConsoleOutput;
      /**
       * Refer to OO.clearRecordedConsoleOutput
       * @method OO#DEBUG#clearRecordedConsoleOutput
       */

      OO.publicApi.DEBUG.clearRecordedConsoleOutput = OO.clearRecordedConsoleOutput;
      /**
       * Refer to OO.setMaxConsoleOutputLines
       * @method OO#DEBUG#setMaxConsoleOutputLines
       */

      OO.publicApi.DEBUG.setMaxConsoleOutputLines = OO.setMaxConsoleOutputLines;
      /* STATE MACHINE TOOLS */

      /**
       * Refer to StateMachine.getActiveList
       * @method OO#DEBUG#listStateMachines
       */

      OO.publicApi.DEBUG.listStateMachines = OO._.bind(OO.StateMachine.getActiveList, OO.StateMachine);
      /**
       * Refer to StateMachine.startDebugTransitionsFor
       * @method OO#DEBUG#startDebugStateMachine
       */

      OO.publicApi.DEBUG.startDebugStateMachine = OO._.bind(OO.StateMachine.startDebugTransitionsFor, OO.StateMachine);
      /**
       * Refer to StateMachine.stopDebugTransitionsFor
       * @method OO#DEBUG#stopDebugStateMachine
       */

      OO.publicApi.DEBUG.stopDebugStateMachine = OO._.bind(OO.StateMachine.stopDebugTransitionsFor, OO.StateMachine);
      /* MESSAGE BUS TOOLS */

      OO.publicApi.DEBUG[playerName] = OO.publicApi.DEBUG[playerName] || {};
      /**
       * Refer to MessageBus.startDebug
       * @method OO#DEBUG#[playerName]#startDebugMB
       */

      OO.publicApi.DEBUG[playerName].startDebugMB = OO._.bind(player.mb.startDebug, player.mb);
      /**
       * Refer to MessageBus.stopDebug
       * @method OO#DEBUG#[playerName]#stopDebugMB
       */

      OO.publicApi.DEBUG[playerName].stopDebugMB = OO._.bind(player.mb.stopDebug, player.mb);
      /**
       * Refer to MessageBus.listDependencies
       * @method OO#DEBUG#[playerName]#listMBDependencies
       */

      OO.publicApi.DEBUG[playerName].listMBDependencies = OO._.bind(player.mb.listDependencies, player.mb); // Extend debug player apis with all debug tools defined within modules

      $.extend(OO.publicApi.DEBUG[playerName], OO.debug_tools[playerName]);
    },

    /**
     * Private function that enables debug tools specified in the player creation parameters.
     * The tools can only be enabled if debug is set to true. Here is an example playerparam
     * usage of each possible command, with documentation for each:
     * {
     *   "debug":true,
     *   "enableDebugTools":{
     *   "startRecordingConsoleOutput":"OldState.*Init",                 //this turns on recording console output. You can pass in a regex to filter out what output you actually want to record. You don't need the initial and ending '/'. Look up RegExp in javascript for more info.
     *   "setMaxConsoleOutputLines":100,                                 //set the max number of lines to record. It's FIFO so it dumps the oldest message when full.
     *   "startDebugStateMachine":"adManagerController,Api,something",   //specify which statemachines you care about recording. Use  "all" to turn it on for all statemachines
     *   "startDebugMB":true                                             //this turns on the detailed message bus debugging. You will know when a message is queue up to be sent out and when it actually gets propogated to listeners. You also see when messages create/remove dependents. Super verbose.
     *   }
     * }
     *
     * Two important things to note:
     * 1. These features get turned on after the player is created. So this will not capture messages and debug output while the player is initializing.
     * 2. If the console message isn't sent through OO.log, it won't get recorded.
     * @private
     * @method player#enableDebugTools
     * @param {string} elementId The div in which the player lives
     * @param {object} options The value of "enableDebugTools" inside the player params
     */
    enableDebugTools: function enableDebugTools(elementId, options) {
      if (!OO.publicApi || !OO.publicApi.DEBUG || !options || !elementId) {
        return;
      }

      if (options.hasOwnProperty('startRecordingConsoleOutput')) {
        var filter = options['startRecordingConsoleOutput'];
        OO.publicApi.DEBUG.startRecordingConsoleOutput(filter);
      }

      if (OO._.isFinite(options['setMaxConsoleOutputLines'])) {
        OO.publicApi.DEBUG.setMaxConsoleOutputLines(options['setMaxConsoleOutputLines']);
      }

      if (options.hasOwnProperty('startDebugStateMachine') && OO._.isString(options['startDebugStateMachine'])) {
        var smList = [];

        if (options['startDebugStateMachine'] === 'all') {
          smList = OO.publicApi.DEBUG.listStateMachines();

          for (var smName in smList) {
            if (smList.hasOwnProperty(smName)) {
              OO.publicApi.DEBUG.startDebugStateMachine(smName);
            }
          }
        } else {
          smList = options['startDebugStateMachine'].split(',');

          for (var index in smList) {
            if (smList.hasOwnProperty(index)) {
              var _smName = smList[index].trim();

              OO.publicApi.DEBUG.startDebugStateMachine(_smName);
            }
          }
        }
      }

      if (options['startDebugMB'] === true) {
        OO.publicApi.DEBUG[elementId].startDebugMB();
      }
    },
    __placeholder: 0
  });
})(OO, OO._, OO.$);

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":18}],53:[function(require,module,exports){
"use strict";

(function (OO, _, $) {
  /**
   * @class OO.PlayerApi
   * @classdesc API layer for the Ooyala Player.  This class takes no direct action on the player.  It stores
   *   player properties and provides an API layer for the player that interacts with the message bus.
   * @public
   * @param {object} _mb The message bus instance for the player
   * @param {string} _elementId The DOM id of the root player element
   * @param {string} _modules The module instances for the player
   * @param {string} _parameters The parameters for the first playback session
   * @param {object} _persistentSettings The persistent settings for the player
   */
  OO.PlayerApi = function (_mb, _elementId, _modules, _parameters, _persistentSettings) {
    var _this2 = this;

    // player properties
    this.mb = _mb;
    this.modules = _modules;
    this.parameters = _parameters;
    this.hvcChecked = false;
    this.hevChecked = false;
    this.persistentSettings = _persistentSettings;
    var elementId = _elementId;
    var IS_EXTERNAL_API_CALL = true; // video state

    var playbackReady = false;
    var isAdPlaying = false;
    var isPlaying = false;
    var playheadTime = -1;
    var isLive = false;
    var duration = -1;
    var adDuration = -1;
    var bufferLength = -1;
    var item = null;
    var authStartTime = -1;
    var closedCaptionsLanguages = {};
    var closedCaptionOptions = {};
    var bitratesInfo = {};
    var error = null;
    var currentBitrate = null;
    var _playedOnce = false;
    var startTime = null; // session state

    var state = OO.STATE.LOADING;
    var clockOffset = 0;
    var fullscreen = false;
    var volume = 1;
    var _playQueued = false;
    var _atEndScreen = false;
    var destroyCallback = null;
    var _embedCode = null;
    var _playerOptions = null;
    /*
     * Helpers
     */

    var updateStateOnPlay = function updateStateOnPlay() {
      _playedOnce = true;
      _playQueued = false;
      _atEndScreen = false;
    };

    var resetPlayState = function resetPlayState() {
      playbackReady = false;
      isAdPlaying = false;
      isPlaying = false;
      state = OO.STATE.LOADING;
      playheadTime = -1;
      isLive = false;
      duration = -1;
      adDuration = -1;
      bufferLength = -1;
      item = null;
      authStartTime = -1;
      closedCaptionsLanguages = {};
      closedCaptionOptions = {};
      bitratesInfo = {};
      error = null;
      currentBitrate = null;
      _playedOnce = false;
      _atEndScreen = false;
    };
    /*
     * State Tracking
     */


    this.mb.subscribe(OO.EVENTS.PLAYBACK_READY, 'player', _.bind(function () {
      state = OO.STATE.READY;
      playbackReady = true;
      closedCaptionOptions = Object.assign({}, _persistentSettings.closedCaptionOptions);

      if (_playQueued) {
        this.play();
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.REPLAY, 'player', _.bind(function () {
      updateStateOnPlay();
    }, this));
    this.mb.subscribe(OO.EVENTS.PLAY, 'player', _.bind(function () {
      updateStateOnPlay();
    }, this));
    this.mb.subscribe(OO.EVENTS.INITIAL_PLAY, 'player', _.bind(function () {
      updateStateOnPlay();
    }, this));
    this.mb.subscribe(OO.EVENTS.PLAYING, 'player', _.bind(function () {
      // initial time:
      // TODO, w3c has introduced a new attribute for HTML 5 tag: initialTime
      // http://www.w3.org/TR/2011/WD-html5-20110113/video.html#dom-media-initialtime
      // Once it is widely supported, we can directly set this attribute instead.
      if (state !== OO.STATE.ERROR) {
        state = OO.STATE.PLAYING;
        _playedOnce = true;
        isPlaying = true;
      }

      _atEndScreen = false;
    }, this));
    this.mb.subscribe(OO.EVENTS.HEVC_CHECKED, 'player', _.bind(function (event, response, codec, error) {
      _.extend(_playerOptions, response);

      if (error) {
        if (error.code && !error.message) {
          error.message = OO.getMediaElementErrorFromCode(error.code);
        }

        OO.log('HEVC check returned error for codec ' + codec + ': code: ' + error.code + ' message: ' + error.message);
      }

      if (codec === OO.CONSTANTS.HEVC_CODEC.HVC1) {
        this.hvcChecked = true;
      }

      if (codec === OO.CONSTANTS.HEVC_CODEC.HEV1) {
        this.hevChecked = true;
      }

      if (this.hvcChecked && this.hevChecked) {
        this.mb.publish(OO.EVENTS.SET_EMBED_CODE, _embedCode, _playerOptions || {});
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.PAUSED, 'player', _.bind(function () {
      if (state !== OO.STATE.ERROR) {
        state = OO.STATE.PAUSED;
      }

      isPlaying = false;
    }, this));
    this.mb.subscribe(OO.EVENTS.BUFFERING, 'player', _.bind(function () {
      if (state !== OO.STATE.ERROR) {
        state = OO.STATE.BUFFERING;
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.BUFFERED, 'player', _.bind(function () {
      // If the video is still in a buffering state after we've finished buffering,
      // Change it to either a playing or paused state
      if (state === OO.STATE.BUFFERING) {
        state = isPlaying ? OO.STATE.PLAYING : OO.STATE.PAUSED;
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.PLAYED, 'player', _.bind(function () {
      state = OO.STATE.READY;
      _atEndScreen = true;
      isPlaying = false;
    }, this));
    this.mb.subscribe(OO.EVENTS.WILL_PLAY_ADS, 'player', _.bind(function (event, newAdDuration) {
      adDuration = newAdDuration;
      _playedOnce = true;
      isAdPlaying = true;
      _atEndScreen = false;
    }, this));
    this.mb.subscribe(OO.EVENTS.AD_POD_STARTED, 'player', _.bind(function (event, numberOfAds) {
      isAdPlaying = true;
    }, this));
    this.mb.subscribe(OO.EVENTS.ADS_PLAYED, 'player', _.bind(function () {
      adDuration = -1;
      isAdPlaying = false;
    }, this));
    this.mb.subscribe(OO.EVENTS.AD_POD_ENDED, 'player', _.bind(function () {
      adDuration = -1;
      isAdPlaying = false;
    }, this)); // listen for some events to keep a copy of metadata for APIs

    this.mb.subscribe(OO.EVENTS.CONTENT_TREE_FETCHED, 'player', _.bind(function (event, tree) {
      // NOTE[jigish]: we do not support channels yet, so currentItem *is* the root item
      item = tree;
      var ms = 1000;

      if (!tree) {
        return;
      } // Preset duration to what contentTree thinks it is. This will get updated once
      // real duration is known


      var treeDuration = Number(tree.duration);

      if (!isNaN(treeDuration)) {
        // Content tree duration is in milliseconds, convert to seconds
        duration = treeDuration / ms;
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.WILL_FETCH_AUTHORIZATION, 'player', _.bind(function (event) {
      authStartTime = new Date().getTime();
    }, this));
    this.mb.subscribe(OO.EVENTS.AUTHORIZATION_FETCHED, 'player', _.bind(function (event, tree) {
      if (!tree.debug_data || !tree.debug_data.user_info) {
        return;
      }

      var currentTime = new Date().getTime();
      var half = 2;
      var ms = 1000;
      var latency = (currentTime - authStartTime - tree.debug_data.server_latency) / half;
      clockOffset = tree.debug_data.user_info.request_timestamp * ms + latency - currentTime;
    }, this));
    this.mb.subscribe(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, 'player', _.bind(function (event, videoId, streams, parentContainer, params) {
      if (videoId === OO.VIDEO.MAIN) {
        isLive = streams ? streams.isLive : false;
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, 'player', _.bind(function (event, time, newDuration, buffer) {
      playheadTime = time;

      if (newDuration) {
        duration = newDuration;
      }

      bufferLength = buffer;

      if (!startTime) {
        startTime = new Date().getTime();
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.DOWNLOADING, 'player', _.bind(function (event, time, newDuration, buffer) {
      playheadTime = time;

      if (newDuration) {
        duration = newDuration;
      }

      bufferLength = buffer;
    }, this));
    this.mb.subscribe(OO.EVENTS.FULLSCREEN_CHANGED, 'player', _.bind(function (event, state) {
      fullscreen = state;
    }, this));
    this.mb.subscribe(OO.EVENTS.ERROR, 'player', _.bind(function (event, err) {
      error = err;
      state = OO.STATE.ERROR;
      isPlaying = false;
    }, this));
    this.mb.subscribe(OO.EVENTS.VOLUME_CHANGED, 'player', _.bind(function (event, newVolume) {
      volume = newVolume;
    }, this)); // Copies player settings from skin UI (source) to current settings (destination).
    // Source settings will override properties of destination settings.
    // Mutated destination settings are then saved to local storage.

    this.mb.subscribe(OO.EVENTS.SAVE_PLAYER_SETTINGS, 'player', _.bind(function (event, sourceSettings) {
      _.extend(this.persistentSettings.closedCaptionOptions, sourceSettings.closedCaptionOptions);

      var newSettings = JSON.stringify(this.persistentSettings); // save new settings to local storage

      OO.setItem(OO.CONSTANTS.OOYALA_PLAYER_SETTINGS_KEY, newSettings);
    }, this));
    this.mb.subscribe(OO.EVENTS.SET_EMBED_CODE, 'player', _.bind(function (event, embedCode, options) {
      // TODO: Should this be a replacement rather than an extend?  Some parameters do not live past the
      // session, such as autoplay.
      this.parameters = _.extend(this.parameters, options); // PLAYER-2796 - isAd is only used for Ooyala Ad manager ads (MyAds).
      // The ad itself will send a SET_EMBED_CODE change event for MyAds, as the ad is an Ooyala Asset
      // The isAd value prevents resetPlayState from being called for this event so that
      // isAdPlaying remains true

      if (!options.isAd) {
        resetPlayState();
      }
    }, this));
    this.mb.subscribe(OO.EVENTS.SET_ASSET, 'player', _.bind(function (event, asset, options) {
      // TODO: Should this be a replacement rather than an extend?  Some parameters do not live past the
      // session, such as autoplay.
      this.parameters = _.extend(this.parameters, options);
      resetPlayState();
    }, this));
    this.mb.subscribe(OO.EVENTS.ASSET_CHANGED, 'player', _.bind(function (event, asset) {
      item = asset.content;
      duration = item.duration;
    }, this));
    this.mb.subscribe(OO.EVENTS.DESTROY, 'player', _.bind(function (event, embedCode) {
      state = OO.STATE.DESTROYED;
    }, this));
    this.mb.subscribe(OO.EVENTS.BITRATE_INFO_AVAILABLE, 'player', _.bind(function (event, info) {
      bitratesInfo = info.bitrates;
    }, this));
    this.mb.subscribe(OO.EVENTS.BITRATE_CHANGED, 'player', _.bind(function (event, info) {
      currentBitrate = info;
    }, this));
    this.mb.subscribe(OO.EVENTS.CLOSED_CAPTIONS_INFO_AVAILABLE, 'player', _.bind(function (event, info) {
      closedCaptionsLanguages = info;
    }, this));
    this.mb.subscribe(OO.EVENTS.SET_CLOSED_CAPTIONS_LANGUAGE, 'player', function (event, lang) {
      closedCaptionOptions.enabled = Boolean(lang);

      if (closedCaptionOptions.enabled) {
        closedCaptionOptions.language = lang;
      }
    });
    /*
     * Public Player API Instance Methods
     *
     * NOTE[jigish]: Some functions are aliased to maintain compatibility with the flash player. Others are
     * aliased because they are Channel APIs and Channels are not supported yet.
     *
     * TODO[jigish]:
     * setQueryStringParameters
     */

    /**
     * Sets the embed code for the current player. You may optionally specify an <code>options</code> object
     * that enables you to dynamically assign an ad set or other asset-level options to the embed code.
     * For example, you can set the initial position from which the player will start.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @public
     * @method setEmbedCode
     * @memberOf OO.Player.prototype
     * @param {String} embedCode An embed code belonging to the same provider as the ad set code.
     * @param {Object} options <b>(Optional)</b> An object containing a hash of key-value pairs representing the unique ad set code.
     */

    this.setEmbedCode = function (embedCode, options) {
      // If the window and player was just created and hevc is preferred, we need to wait for
      // The HEVC compatability check to complete before sending the first SET_EMBED_CODE event
      if (!this.hevcChecked && OO.isHevcEnabled(options)) {
        _embedCode = embedCode;
        _playerOptions = options;
      } else {
        this.mb.publish(OO.EVENTS.SET_EMBED_CODE, embedCode, options || {}, IS_EXTERNAL_API_CALL);
      }
    };
    /**
     * Sets the asset streams for the current player. You may optionally specify an <code>options</code> object
     * that enables you to dynamically assign an ad set or other asset-level options to the asset.
     * For example, you can set the initial position from which the player will start.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @method setAsset
     * @memberOf OO.Player.prototype
     * @param {String} asset An object of content metadata
     * @param {Object} options <b>(Optional)</b> An object containing a hash of key-value pairs representing playback configuration
     */


    this.setAsset = function (asset, options) {
      this.mb.publish(OO.EVENTS.SET_ASSET, asset, options || {}, IS_EXTERNAL_API_CALL);
    };
    /**
     * Sets the mute state of all player elements to muted programmatically.
     *
     * @public
     * @method mute
     * @memberOf OO.Player.prototype
     */


    this.mute = function () {
      this.mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, true, null, false);
    };
    /**
     * Sets the mute state of all player elements to unmute programmatically.
     *
     * @public
     * @method unmute
     * @memberOf OO.Player.prototype
     * @param {Boolean} fromUser True if the unmute was from a user click, false otherwise
     */


    this.unmute = function (fromUser) {
      var unmuteWasSetByUser = false;

      if (typeof fromUser === 'boolean') {
        unmuteWasSetByUser = fromUser;
      }

      this.mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, false, null, unmuteWasSetByUser);
    };
    /**
     * Plays the current video and the entire asset including ads, or queues it for playback if the video is not ready.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @public
     * @method play
     * @memberOf OO.Player.prototype
     */


    this.play = function () {
      if (state === OO.STATE.ERROR) {
        return;
      } else if (!playbackReady) {
        _playQueued = true;
        return;
      }

      if (_atEndScreen) {
        this.mb.publish(OO.EVENTS.REPLAY);
      } else {
        if (_playedOnce) {
          this.mb.publish(OO.EVENTS.PLAY);
        } else {
          this.mb.publish(OO.EVENTS.INITIAL_PLAY, Date.now(), false);
        }
      }
    };
    /**
     * Pauses the current video playback.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @public
     * @method pause
     * @memberOf OO.Player.prototype
     */


    this.pause = function () {
      this.mb.publish(OO.EVENTS.PAUSE);
    };
    /**
     * Set the speed of playback for the main video element. Must be >= 0.5
     * and <= 2.0.  This will return true if you pass in a valid number. Altering
     * playback speed does not work with Live or VR360 video and the setting will be
     * ignored but it will still return true if the speed is a valid speed.
     * @public
     * @method setPlaybackSpeed
     * @memberOf OO.Player.prototype
     * @param  {Number} speed The desired playbackrate. Must be more than 0.5 and less than 2.
     * @returns {Boolean}  True if the speed is a valid number
     */


    this.setPlaybackSpeed = function (speed) {
      if (OO.isValidPlaybackSpeed(speed)) {
        this.mb.publish(OO.EVENTS.SET_PLAYBACK_SPEED, speed);
        return true;
      }

      return false;
    };
    /**
     * Seeks to the specified number of seconds from the beginning for VOD assets.
     * For live assets sets the playhead to a specified number of seconds starting from
     * the beginning of DVR window, if exists. Beginning of the DVR window is the opposite to live edge.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the <code>BUFFERED</code> event.
     *
     * @public
     * @method seek
     * @memberOf OO.Player.prototype
     * @param {Number} seconds The number of seconds from the beginning at which to begin playing the video.
     */


    this.seek = function (seconds) {
      if (_atEndScreen) {
        this.mb.publish(OO.EVENTS.REPLAY, seconds);
      } else {
        this.mb.publish(OO.EVENTS.SEEK, seconds);
      }
    };
    /**
     * Sets the current volume on a best-effort basis according to the underlying device limitations.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @public
     * @method setVolume
     * @memberOf OO.Player.prototype
     * @param {Number} volume The volume. Specify a value between 0 and 1, inclusive.
     */


    this.setVolume = function (volume) {
      this.mb.publish(OO.EVENTS.CHANGE_VOLUME, volume);
    };
    /**
     * Destroys the item. When this method is called, the player is removed, all activity is stopped, and any video is unloaded.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @public
     * @method destroy
     * @memberOf OO.Player.prototype
     * @param {function} callback (<b>Optional</b>) A function callback used to notify a web page
     * that the <code>destroy</code> method has completed destroying the HTML5 player.
     */


    this.destroy = _.bind(function (callback) {
      // [PBW-459] Save optional callback to be called after DESTROY event is unblocked.
      if (callback && typeof callback === 'function') {
        destroyCallback = callback;
      }

      this.mb.publish(OO.EVENTS.DESTROY);
    }, this);

    this.triggerDestroyCallback = function () {
      if (destroyCallback) {
        destroyCallback();
        destroyCallback = null;
      }
    };
    /**
     * Set related media for unbundled player.
     *
     * @public
     * @method updateAsset
     * @memberOf OO.Player.prototype
     * @param {Object} updatedAsset with asset structure where id field should not be empty.
     * Other fields will be updated if populated.
     */


    this.updateAsset = function (updatedAsset) {
      this.mb.publish(OO.EVENTS.UPDATE_ASSET, updatedAsset);
    };
    /* Getters */

    /**
     * Retrieves the playhead position in seconds.
     *
     * @public
     * @method getPlayheadTime
     * @memberOf OO.Player.prototype
     * @returns {Number} The playhead position, in seconds.
     */


    this.getPlayheadTime = function () {
      return playheadTime;
    };

    this.getLiveTime = function () {
      var ms = 1000;
      return new Date(startTime + playheadTime * ms + clockOffset);
    };
    /**
     * Retrieves the total duration, in seconds, of the video.
     * This method should not be called before the player fires the <code>PLAYBACK_READY</code> event.
     * The duration is not guaranteed to be known before that point.
     *
     * @public
     * @method getDuration
     * @memberOf OO.Player.prototype
     * @returns {Number} The total duration of the video in seconds.  The method returns a value of <code>Infinity</code> for all live assets, including assets that feature DVR functionality.
     */


    this.getDuration = function () {
      if (isLive) {
        return Infinity;
      } else {
        return duration;
      }
    };
    /**
     * Method that checks whether a video can autoplay with sound in a given browser
     * @fires OO.EVENTS.AUTOPLAY_STATE_CHECKED
     * @fires OO.EVENTS.AUTOPLAY_CHECK_COMPLETE
     *
     * @returns {Promise} promise with value of autoplayState.
     * Possible values of autoplayState:
     * - All_Unblocked
     * - All_Blocked
     * - Unblocked_without_Audio
     *
     * NOTICE: to use the result of autoplayState on iOS param "iosPlayMode" should be set to "inline"
     * NOTICE2: it checks regardless of whether the option "autoplay" is in users video properties
     * or delayForPreroll is enabled.
     * @TODO: Maybe it need to be changed to check the prop.
     */


    this.isAutoplayBlocked = function () {
      var _this = this;

      return new Promise(function (resolve) {
        try {
          OO.checkAutoplay.runTest(function (results, autoplayState) {
            OO.log('Autoplay state checked', autoplayState);

            _this.mb.publish(OO.EVENTS.AUTOPLAY_STATE_CHECKED, autoplayState);

            resolve(autoplayState);
          });
        } catch (error) {
          var autoplayState = OO.CONSTANTS.AUTOPLAY_STATE.ALL_BLOCKED;
          OO.log('Autoplay state check failed with', error);

          _this.mb.publish(OO.EVENTS.AUTOPLAY_STATE_CHECKED, autoplayState);

          resolve(autoplayState);
        }
      });
    };
    /**
     * Retrieves the total duration, in milliseconds, of the videos.
     *
     * @public
     * @method getAdDuration
     * @memberOf OO.Player.prototype
     * @returns {Number} The total duration of the ad videos in milliseconds.
     */


    this.getAdDuration = function () {
      return adDuration;
    };
    /**
     * Retrieves the current size of the buffer in seconds.<br/>
     *
     * @public
     * @method getBufferLength
     * @memberOf OO.Player.prototype
     * @returns {Number} The current size of the buffer in seconds when buffer length is supported; returns 0 otherwise.
     */


    this.getBufferLength = function () {
      return bufferLength;
    };
    /**
     * Retrieves an object describing the current video.
     *
     * @public
     * @method getItem
     * @memberOf OO.Player.prototype
     * @returns {Object} The current video, described in an object containing the following attributes:
     * <ul>
     *    <li><code>embedCode</code></li>
     *    <li><code>title</code></li>
     *    <li><code>description</code></li>
     *    <li><code>time</code> (play length in seconds)</li>
     *    <li><code>lineup</code></li>
     *    <li><code>promo</code></li>
     *    <li><code>hostedAtURL</code></li>
     * </ul>
     */


    this.getItem = function () {
      return item;
    };
    /**
     * Retrieves the description of the current video. This function retrieves the description that was set
     * in the the <b>Backlot Manage Details</b> tab or the equivalent manual setting.
     *
     * @public
     * @method getDescription
     * @memberOf OO.Player.prototype
     * @returns {String} The description of the current video. For example, <code>Season 22 Opening Game</code>.
     */


    this.getDescription = function () {
      if (!item) {
        return null;
      }

      return item.description;
    };
    /**
     * Retrieves the embed code for the current player.
     *
     * @public
     * @method getEmbedCode
     * @memberOf OO.Player.prototype
     * @returns {String} The embed code for the current player.
     */


    this.getEmbedCode = function () {
      if (!item) {
        return null;
      }

      return item.embedCode || item.embed_code || ''; // it could be one or the other
    };
    /**
     * Retrieves the title of the current video.
     *
     * @public
     * @method getTitle
     * @memberOf OO.Player.prototype
     * @returns {String} The title of the current video. For example, <code>My Snowboarding Channel</code>.
     */


    this.getTitle = function () {
      if (!item) {
        return null;
      }

      return item.title;
    };
    /**
     * Determines whether the player is in full screen mode.
     *
     * @public
     * @method isFullscreen
     * @memberOf OO.Player.prototype
     * @returns {Boolean} <code>true</code> if the player is in full screen mode, <code>false</code> otherwise.
     */


    this.isFullscreen = function () {
      return fullscreen;
    };
    /**
     * Retrieves the current error code if it exists.
     *
     * @public
     * @method getErrorCode
     * @memberOf OO.Player.prototype
     * @returns {String} The error code, if it exists.
     */


    this.getErrorCode = function () {
      return error != null ? error.code : null;
    };
    /**
     * Retrieves the current player state. See {@link OO.STATE} for descriptions of the states.
     *
     * @public
     * @method getState
     * @memberOf OO.Player.prototype
     * @returns {String} One of the following values:
     * <ul>
     *   <li><code>LOADING</code></li>
     *   <li><code>READY</code></li>
     *   <li><code>PLAYING</code></li>
     *   <li><code>PAUSED</code></li>
     *   <li><code>BUFFERING</code></li>
     *   <li><code>ERROR</code></li>
     *   <li><code>DESTROYED</code></li>
     * </ul>
     */


    this.getState = function () {
      return state;
    };
    /**
     * Retrieves the current volume on a best-effort basis according to underlying device limitations.
     *
     * @public
     * @method getVolume
     * @memberOf OO.Player.prototype
     * @returns {Number} The volume, whose value is between 0 and 1, inclusive.
     */


    this.getVolume = function () {
      return volume;
    };

    this.skipAd = function () {
      this.mb.publish(OO.EVENTS.SKIP_AD);
    };
    /**
     * Retrieves an array of available bitrate information object.
     *
     * @public
     * @method getBitratesAvailable
     * @memberOf OO.Player.prototype
     * @returns {Array} An array of available bitrate information object. The handler is called with an array containing the available bitrates, each object includes:
     *   <ul>
     *     <li>bitrate: The bitrate in bits per second. (number)</li>
     *     <li>height: The vertical resolution of the stream. (number)</li>
     *     <li>width: The horizontal resolution of the stream. (number)</li>
     *     <li>id: A unique identifier for the stream. (string)</li>
     *   </ul>
     * The bitrates will be sorted in descending order by resolution and then by bitrate.
     * If the video plugin supports automatic ABR, one stream will have an ID of "auto" and a bitrate of 0.
     *
     * @see getCurrentBitrate
     * @see setTargetBitrate
     */


    this.getBitratesAvailable = function () {
      return bitratesInfo;
    };
    /**
     * Retrieves the current bitrate information object.
     *
     * @public
     * @method getCurrentBitrate
     * @memberOf OO.Player.prototype
     * @returns {Object} The current bitrate information object. Each object includes:
     *   <ul>
     *     <li>bitrate: The bitrate in bits per second. (number|string)</li>
     *     <li>height: The vertical resolution of the stream. (number)</li>
     *     <li>width: The horizontal resolution of the stream. (number)</li>
     *     <li>id: A unique identifier for the stream. (string)</li>
     *   </ul>
     * @see getBitratesAvailable
     */


    this.getCurrentBitrate = function () {
      return currentBitrate;
    };
    /**
     * Sets the target bitrate. You must specify the ID of an available bitrate information object.
     * To determine which bitrates are available, call <code>{@link getBitratesAvailable}()</code>.<br/><br/>
     * <p><b><font color="red">NOTE: </font></b>This setting does not carry over to new asset.
     * This is an asynchronous method and may return before having completed the operation.
     * If your logic depends on the completion of this operation, listen to the corresponding event.
     *
     * @public
     * @method setTargetBitrate
     * @memberOf OO.Player.prototype
     * @param {String} id ID of the stream to switch to. ID should correspond to an ID property from
     *   one of the available bitrates.
     * @see getBitratesAvailable
     */


    this.setTargetBitrate = function (id) {
      this.mb.publish(OO.EVENTS.SEND_QUALITY_CHANGE, id);
      this.mb.publish(OO.EVENTS.SET_TARGET_BITRATE, id);
    };
    /**
     * Retrieves a list of supported closed captions languages for the currently playing item.
     * This list is derived from the closed captions XML (DFXP [now TTML]) file for this content, uploaded via Backlot.
     * For more information about this file see
     * <a href"http://support.ooyala.com/developers/documentation/tasks/api_closed_captions_upload.html" target="target">Uploading and Viewing a Closed Captions File</a>.
     * If there is no DFXP (now TTML) file in place, this method returns an empty list. In live streaming mode,
     * the closed caption languages are derived from the stream itself.
     *
     * @public
     * @method getCurrentItemClosedCaptionsLanguages
     * @memberOf OO.Player.prototype
     * @returns {Array} A list of supported closed captions languages for the currently playing item.
     */


    this.getCurrentItemClosedCaptionsLanguages = function () {
      return closedCaptionsLanguages;
    };
    /**
     * Sets the language of the closed captions (CC) that will be shown in the player. If you do not upload the Closed Captions file,
     * the content will play back without closed captions. In Live streaming mode, the closed caption languages are derived
     * from the stream itself. Note that because of the way that closed captions are supported in iOS,
     * we are not able to add closed caption data for IOS web for remote assets.<br/><br/>
     * <p><b><font color="red">NOTE: </font></b> Because of the way that closed captions are supported in iOS,
     * closed caption data cannot be added for IOS web for remote assets.</p><br/>
     *
     * @public
     * @method setClosedCaptionsLanguage
     * @memberOf OO.Player.prototype
     * @param {String} language Specify the ISO 639-1 language code. For example, specify <code>"en"</code>, <code>"de"</code>, or <code>"ja"</code>
     * for English, German, or Japanese.
     * Use <code>"zh-hans"</code> for Simplified Chinese and <code>"zh-hant"</code> for Traditional Chinese.
     * To show no closed captions, set the language to <code>"none"</code>.
     */


    this.setClosedCaptionsLanguage = function (language) {
      if (language) {
        var params = {
          forceEnabled: !closedCaptionOptions.enabled
        };
        this.mb.publish(OO.EVENTS.CHANGE_CLOSED_CAPTION_LANGUAGE, language, params);
      }
    };
    /**
     * Get closed captions options for current video
     *
     * @typedef  {Object} ClosedCaptionOptions
     * @property {Boolean} closedCaptionsEnabled flag indicating whether closedCaptions are enabled
     * @property {String} availableLanguages list of all available languages
     * @property {String} currentCCLanguage selected language
     *
     * @public
     * @method getClosedCaptionOptions
     * @memberOf OO.Player.prototype
     * @returns {ClosedCaptionOptions} closed captions options
     */


    this.getClosedCaptionOptions = function () {
      return {
        closedCaptionsEnabled: closedCaptionOptions.enabled,
        availableLanguages: closedCaptionsLanguages.languages,
        currentCCLanguage: closedCaptionOptions.language
      };
    };
    /**
     * Turn on/off closed captions
     *
     * @public
     * @method toggleClosedCaptions
     * @memberOf OO.Player.prototype
     */


    this.toggleClosedCaptions = function () {
      _this2.mb.publish(OO.EVENTS.TOGGLE_CLOSED_CAPTIONS);
    };
    /**
     * Subscribe to a specified event.
     *
     * @public
     * @method subscribe
     * @memberOf OO.Player.prototype
     * @param {String} eventName The name of the event.
     * @param {String} subscriber The name of the subscriber to which the message bus will publish the event.
     * @param {Function} callback The function that will execute when the subscriber receives the event notification.
     */


    this.subscribe = function (eventName, subscriber, callback) {
      this.mb.subscribe(eventName, subscriber, function () {
        var argsArray = _.toArray(arguments);

        argsArray.unshift(callback);

        _.defer.apply(this, argsArray);
      });
    };
    /**
     * Retrieves the core player version.
     *
     * @public
     * @method getVersion
     * @memberOf OO.Player.prototype
     * @returns {String} The core player version.
     */


    this.getVersion = function () {
      return OO.VERSION.version;
    };
    /**
     * Retrieves the ID of the DOM element the player was created inside.
     *
     * @public
     * @method getElementId
     * @memberOf OO.Player.prototype
     * @returns {String} The ID of the DOM element the player was created inside.
     */


    this.getElementId = function () {
      return elementId;
    };
    /**
     * Determine if main content is currently playing
     *
     * @public
     * @method isPlaying
     * @memberOf OO.Player.prototype
     * @returns {Boolean} Whether or not the player is currently playing.
     */


    this.isPlaying = function () {
      return isPlaying;
    };
    /**
     * Determine if an ad is currently playing
     *
     * @public
     * @method isAdPlaying
     * @memberOf OO.Player.prototype
     * @returns {Boolean} Whether or not the player is currently playing.
     */


    this.isAdPlaying = function () {
      return isAdPlaying;
    };
  };
})(OO, OO._, OO.$);

},{}],54:[function(require,module,exports){
"use strict";

(function (OO, _, $) {
  /**
   * An array of all registered modules.
   * @field OO#modules
   * @public
   */
  OO.modules = [];
  /**
   * Registers a module to be instantiated with each player.
   * @method OO#registerModule
   * @public
   * @param {String} _moduleName The name of the module
   * @param {Object} _moduleFactoryMethod A factory for creating an instance of the module
   */

  OO.registerModule = function (_moduleName, _moduleFactoryMethod) {
    // Prevent tracking modules from registering when user tracking has been
    // explicitly disabled
    if (OO.trackingLevel === OO.TRACKING_LEVEL.DISABLED && OO.TRACKING_MODULES.indexOf(_moduleName) > -1) {
      OO.log('Core: Registration was aborted for module ' + _moduleName + ' due to tracking restrictions.');
      return;
    } // validate params


    var moduleName = OO.HM.safeDomId('moduleName', _moduleName, OO.HM.fixDomId);
    var moduleFactoryMethod = OO.HM.safeFunction('moduleFactoryMethod', _moduleFactoryMethod);
    OO.modules.push({
      name: moduleName,
      factory: moduleFactoryMethod
    });
  };
  /**
   * Registers a plugin to be instantiated with each player.
   * @method OO#plugin
   * @public
   * @param {string} moduleName The name of the module
   * @param {Object} moduleClassFactory A factory for creating an instance of the module
   */


  OO.plugin = function (moduleName, moduleClassFactory) {
    OO.log('Registered optional plugin: ', moduleName);
    OO.registerModule(moduleName, function (messageBus, id) {
      // TODO, check if we need to catch any exception here.
      var ModuleClass = moduleClassFactory.apply({}, [OO, OO._, OO.$, window]);
      var plugin = new ModuleClass(messageBus, id);
      return plugin;
    });
  };
  /**
   * Exposes an API object to the public scope.
   * @method OO#exposeStatieApi
   * @public
   * @param {string} _apiModule The route of the api module
   * @param {object} _apiObject The api object to expose
   */


  OO.exposeStaticApi = function (_apiModule, _apiObject) {
    // validate params
    var apiModule = OO.HM.safeDomId('apiModule', _apiModule);
    var apiObject = OO.HM.safeObject('apiObject', _apiObject);
    OO.publicApi[apiModule] = OO.publicApi[apiModule] || {};

    OO._.extend(OO.publicApi[apiModule], apiObject);
  };
})(OO, OO._, OO.$);

},{}],55:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/* eslint no-magic-numbers: "off" */
(function (OO, _) {
  OO.StateMachine = {
    // Based on https://github.com/jakesgordon/javascript-state-machine
    create: function create(_cfg) {
      // validate parameters
      var cfg = OO.HM.safeObject('statemachine.create.cfg', _cfg);
      var initial = OO.HM.safeDomId('statemachine.create.cfg.initial', cfg.initial);
      var fsm = OO.HM.safeObject('statemachine.create.cfg.target', cfg.target, {});
      var events = OO.HM.safeArrayOfElements('statemachine.create.cfg.events', cfg.events, function (element) {
        return OO.HM.safeObject('statemachine.create.cfg.events[]', element);
      }, []);
      var moduleName = OO.HM.safeString('statemachine.create.cfg.moduleName', cfg.moduleName, '');
      var mb = OO.HM.safeObject('statemachine.create.cfg.messageBus', cfg.messageBus);
      var map = {};
      var eventIndex;
      fsm.debugTransitions = false;
      var lastEvent = '';
      OO.StateMachine.addToActiveList(cfg.moduleName, fsm);

      var doCallback = function doCallback(name) {
        var stateMethod = null; // transform xxx/abc into ['abc','a','bc']

        var shortEventName = name.replace(/[^\/]*\//, '').match(/^(.)(.*)/); // eslint-disable-line no-useless-escape

        var shortMethodName = 'on' + shortEventName[1].toUpperCase() + shortEventName[2];

        if (fsm[shortMethodName]) {
          stateMethod = fsm[shortMethodName];
        } else {
          var fullEventName = name.replace(/\/.*/, '').match(/^(.)(.*)/); // transform xyz/abc into ['xyz','x','yz']

          var fullMethodName = 'on' + fullEventName[1].toUpperCase() + fullEventName[2] + shortEventName[1].toUpperCase() + shortEventName[2];

          if (fsm[fullMethodName]) {
            stateMethod = fsm[fullMethodName];
          }
        }

        if (stateMethod) {
          try {
            var result = stateMethod.apply(fsm, arguments);
            return result !== false ? 'ok' : 'fail';
          } catch (error) {
            OO.log(error);

            if (OO.TEST_TEST_TEST) {
              throw error; // rethrow in test environment
            }

            return 'fail';
          }
        } // callback not found


        return 'not_found';
      };

      var add = function add(element) {
        var from = element.from instanceof Array ? element.from : element.from ? [element.from] : ['*']; // allow 'wildcard' transition if 'from' is not specified

        var num;
        map[element.name] = map[element.name] || {};

        for (num = 0; num < from.length; num++) {
          map[element.name][from[num]] = element.to || from[num]; // allow no-op transition if 'to' is not specified
        }
      };

      fsm.removeEvent = function (eventname) {
        if (map[eventname]) map[eventname] = null;
      };

      fsm.destroyFsm = function () {
        OO.StateMachine.removeFromActiveList(this.moduleName, this);

        for (eventIndex in map) {
          mb.unsubscribe(eventIndex.toString(), moduleName, fsm.receive);
        }

        cfg = null;
        initial = null;
        fsm = null;
        events = null;
        moduleName = null;
        mb = null;
        map = {};
      };

      var updateState = function updateState(fsm, state) {
        if (!fsm || state === '*') {
          return;
        } // no op  for * state


        if (fsm.debugTransitions) {
          OO.log('Transition ' + (moduleName || '') + '\n  OldState: ' + (fsm.currentState ? fsm.currentState : '') + '\n  NewState: ' + (state || '') + '\n  CausedBy: ' + (lastEvent || ''));
        }

        fsm.currentState = state;
      };

      fsm.canReceive = function (event) {
        return map[event] && (map[event].hasOwnProperty(fsm.currentState) || map[event].hasOwnProperty('*'));
      };

      fsm.receive = function (event
      /* ....arguments */
      ) {
        // drop events not valid in current state
        if (!fsm) {
          return;
        }

        if (!fsm.canReceive(event)) {
          // using arguments[0] instead of event because safari and iOS don't display this nicely in the console.
          OO.log('dropped event \'' + arguments[0] + '\' for \'' + moduleName + '\' while in state \'' + fsm.currentState + '\' with map:', map);
          return;
        }

        lastEvent = arguments[0];
        var from = fsm.currentState;
        var to = map[event][from] || map[event]['*'] || from; // handle transition to same state

        if (from === to) {
          doCallback.apply(fsm, arguments);
          return;
        }

        updateState(fsm, to);
        var callbackResult = 'not_found';

        if (to !== '*') {
          callbackResult = doCallback.apply(fsm, _.union([to], _.rest(arguments)));
        }

        if (callbackResult === 'not_found') {
          callbackResult = doCallback.apply(fsm, arguments);
        }

        switch (callbackResult) {
          case 'not_found':
            OO.log('Module \'' + moduleName + '\' does not handle state \'' + to + '\' or event \'' + arguments[0] + '\'');
            updateState(fsm, from);
            break;

          case 'fail':
            updateState(fsm, from);
            break;

          case 'ok':
            break;

          default:
            break;
        }
      };

      for (eventIndex = 0; eventIndex < events.length; eventIndex++) {
        if ((0, _typeof2.default)(events[eventIndex]) === 'object') {
          add(events[eventIndex]);
        }
      }

      updateState(fsm, initial);

      if (mb !== undefined) {
        for (eventIndex in map) {
          mb.subscribe(eventIndex.toString(), moduleName, fsm.receive);
        }
      }

      return fsm;
    },
    activeStateMachines: {},

    /**
     * Adds a StateMachine to the list of currently active state machines.
     * @public
     * @param {String} smName - name of the statemachine you want to debug
     * @param {String} sm - comparing name
     * @method StateMachine#addToActiveList
     */
    addToActiveList: function addToActiveList(smName, sm) {
      if (!this.activeStateMachines[smName]) {
        this.activeStateMachines[smName] = [];
      }

      this.activeStateMachines[smName].push(sm);
    },

    /**
     * Remove the StateMachine from the list of curently active state machines.
     * @public
     * @param {String} smName - name of the statemachine you want to debug
     * @param {String} sm - comparing name
     * @method StateMachine#removeFromActiveList
     */
    removeFromActiveList: function removeFromActiveList(smName, sm) {
      var list = this.activeStateMachines[smName];

      if (!list) {
        return;
      }

      for (var index = 0; index < list.length; index++) {
        if (list[index] === sm) {
          list.splice(index, 1);
          break;
        }
      }
    },

    /**
     * Enable debugging state transitions for a particular state machine. If
     * multiple of the same state machine are active, all of them have debugging
     * enabled.
     * @public
     * @method StateMachine#startDebugTransitionsFor
     * @param {String} smName - name of the statemachine you want to debug
     * @returns {String} Message stating whether debugging was succesfully started
     *           (Mostly for debugging in the console)
     */
    startDebugTransitionsFor: function startDebugTransitionsFor(smName) {
      var result = this.debugTransitionsHelper(smName, true);
      var msg;

      if (result) {
        msg = "STATEMACHINE '" + smName + "' DEBUGGING STARTED";
      } else {
        msg = "Couldn't find '" + smName + "'";
      }

      return msg;
    },

    /**
     * Disable debugging state transitions for a particular state machine. If
     * multiple of the same state machine are active, all of them have debugging
     * disabled.
     * @public
     * @method StateMachine#stopDebugTransitionsFor
     * @param {String} smName - name of the statemachine you want to debug
     * @returns {String} Message stating whether debugging was succesfully stopped
     *           (Mostly for debugging in the console)
     */
    stopDebugTransitionsFor: function stopDebugTransitionsFor(smName) {
      var result = this.debugTransitionsHelper(smName, false);
      var msg;

      if (result) {
        msg = "STATEMACHINE '" + smName + "' DEBUGGING STOPPED";
      } else {
        msg = "Couldn't find '" + smName + "'";
      }

      return msg;
    },

    /**
     * Helper function to enable/disable all statemachines with the specified name.
     * @private
     * @method StateMachine#debugTransitionsHelper
     * @param {String} smName - name of the statemachine you want to debug
     * @param {Boolean} enable - whether to turn debugging on or off.
     * @returns {Boolean} True if successfully at least 1 state machine found to enable/disable
     */
    debugTransitionsHelper: function debugTransitionsHelper(smName, enable) {
      var list = this.activeStateMachines[smName];

      if (!list) {
        return false;
      }

      for (var index = 0; index < list.length; index++) {
        list[index].debugTransitions = enable;
      }

      return true;
    },

    /**
     * Returns a list of active state machines by name along with a count of
     * how many instances are each state machine are active.
     * @public
     * @method StateMachine#getActiveList
     * @returns {Object} An object who's keys are the names of the statemachines and
     *           the value is the number of active instances of that statemachine.
     */
    getActiveList: function getActiveList() {
      var list = {};

      for (var smName in this.activeStateMachines) {
        list[smName] = this.activeStateMachines[smName].length;
      }

      return list;
    },
    __end_marker: true
  };
})(OO, OO._);

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":18}],56:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

(function (OO, _, $) {
  /** ************************** BEGIN can-autoplay.js ****************************************/

  /* source: https://github.com/video-dev/can-autoplay
        MIT License
       Copyright (c) 2017 video-dev
       Permission is hereby granted, free of charge, to any person obtaining a copy
      of this software and associated documentation files (the "Software"), to deal
      in the Software without restriction, including without limitation the rights
      to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
      copies of the Software, and to permit persons to whom the Software is
      furnished to do so, subject to the following conditions:
       The above copyright notice and this permission notice shall be included in all
      copies or substantial portions of the Software.
       THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
      OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
      SOFTWARE.
    */
  OO.canAutoplay = function () {
    'use strict';
    /**
       * Small HEVC(hvc1) file with audio.
       *
       * @constant
       * @default
       * @type {String}
       */

    var HEV1 = 'data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAALl21kYXQAAAMRJg' + 'GvHYCh+rRXrzsdF9OQ5sh6IUZVTbyUH1TYc9eQ5kYBqfbDfH2M5v71r9vJSjxNUUON5TCnZyZh+hxfdR9bgRVQkfi8f9fXf0Jgl' + 'IlP6t46usUo9ioTIvqfewozMNadUuHkUisjCSA0FXb9FBpztGmCtQqeIsvh7yfEYBOEzNm1c1FrOrc2UduY1ZJv8Ij2xWZoIGQc' + 'RgA2bPr7ykA0aQu2eXLGvLrF8ZSdktns6UXrvYY00LIOodKhFrsz6YYTjWwzDetgzC3KPCEnOYuxbu2xm43OhS/pHAlf9tlSSRo' + 'Jx8TTwBpgTcQbrtaqVTSQAu+7FHXB2HkZG4bEZg8Gm4zkjMLCo47TPJ/CfAy4zWXLsZAZr0jGDydkNewLwRikhLIuel01AZH+lW' + '3kO+YYP409hXSCu90OCly97bSYqbBYpa72JOvFhmKebViOP080hLrQ/lGzHOV7CW1TrXY5JAQrfz2cdpmH/pcFLr+VwvRPJzhDo' + '6LM0GWELCApILayF4ag6eOncqhSW1+gVp2iNjOlx8tUFmCL8ZfdOG6FsekMj9nkSmhRuuZaOCeLB/fqc/gKoDVIO3EjK9ErHs1X' + 'QOqeNxVwFsB7rz1h9TTV6t3/3qLNnBxIjl2E3v24Gmy5bZncjU7CmMl8o5nfaYy23B0BDqvRBwI2RGnV21dunF7CyZRxTHQVe0u' + 'uwes2ePGVdfBl2U/Bt3ntG2z21MFiXkN0MwpiZYsR6maapbTXTxGEiVa9O3NcpjATS0AFVHzcDBO5k6DTVPn6llDGr1xGe9zyfb' + '1VaJfWYiK0CSGRiGfkpSe3w4yddULOTLYS+7t6KttCXuZIxNg9MWBekV6iAeYHgQNhZiMY++tRNois/cEixZVMTtaJqafcubkHl' + 'LqO1Qdk4V0rCxS8VI/Yrwu9cb6u6XIN8emW92YkyRXZlOzZ7vDptz8ZqxlTtkNistfCcIB5+ECLhUbZ+MIqiyju61wHPKatY6rZ' + 'EiH/TFY/c2JWYgmJPcVJSYbhzh1ictew8YhBv5w+3B/9zA3cD4Y87dwAAAB7AgHQKUvBDCDknQwMwyznK16ybbK58f4zdJvWIpT' + 'xMEBYlESWfEba4x/4AZwvXFJvYaXeYeyziD6qyFesKwEuL3SDHdh1AIoYosdbXUl4UZWhi3f1iILFuCghJnYZz1SRJhJK0VUxpu' + 'E8ztSA4uQXXYw8SmSc3DXMiTD4AAAAEAIB4GSdcCBB4IBoGMwFrsAAAAAQAAHgJPVZokCm5L7EAt3HIAAAAAwAAeBE11miQKLu5' + '3QAAAAMAAHghrflQgUwk1KAAAAA4QIB0FCS1fXEMAg5q1JHiGvrjLlBWFggBq1i3Wv3WeiiPbWpyxS2KOx/Qg+W8RAsAHbwyOhE' + 'TI9aYEHbRtZ0GCC/NbFtmnfGMGGn6VdWj7bsDTnuTZirVKRUcChflUHyaLhVc54GO7OvhQLb8NGFxR+p6GsvCoGhzi+ZLKA9sc+' + 'm0Yt1azhLkPyOT8f4PRDTLg0FuGuCYBodg3uBCxH12aMVTgHF8CxR2jc1mvlXbu0RRJQzCXWc7hy2xKqVg6bDNzu75TX01l2csQ' + 'lrm3SuoJRoGjE2rn7NbLYXmOqIMqw8jwAAABICAeECJ1ddcIEE3yEq1A5k84AAAAAOAAHgwj1dVlokCmCTUoAAAAASAAHg4jVX1' + 'lokCiBDybePM1twAAAADQAB4SKt1flwgUyTUoAAAAAaAgHQWN1dX1xDAIOwluVtntqoufg+5WPtikwAAABqAgHQeNJ1ddcQwCDk' + '/lFkKk/qlPlZlN6NiV7m/ymkHztxrqFqf3OWPOMC3pKHbGh+5gIvudQTTXndRwDnk8AxB+/PhgCHrzBiEv5T9Zd7A48wXaOrBQm' + 'oq1hgyR7wMCJQbD+T+dVycQy6WAAAABICAeGipdS1lwgQQPOajw3cSlAAAAAQAAHhgj9dZaJAojw09gjewAAAAA0AAeHCrXXlwg' + 'Uw7ud0AAAAHAIB0JDXVddcQwCDsGkyL7oLlRzAVpH5qSX05FQAAAAOAgHiIqVVf1wgQ+mpmsIAAAANAAHiAj1X5aJAou7ndAAAA' + 'GsCAdC40vVV1z4GiDmvPRMMtWfoNTXZjOkbl89TTlTtZFDiv1YrxLoy4Neym5M0VFiUTRa0yLPo2ZzXMJ3pmmLLbcfq2HjuGErG' + 'pB1cO6Pts588MYZSJmNs5A+V4N7is7C+TcCBcdMEBF3hywAAABMCAeKip9VXXCBB/sTrh7xmOjAFAAAAEAAB4mI/JVdaJApgL26' + '65CcAAAAQAAHigjXJ11okCiAvbrVgkwAAACIAAeLCrfJ9cIFM9+IaT1CP4IgkFrEODfmTIqc//sF6kUNHAAADOioBrGBsjRHGYL' + 'DH3TXdmAexNEEI/lFVpm37he9h94H4YPgoZYwdOPFHPl7pMMOwiVwOuiRl86GtfkysComKlEYKV2zlHElYJaEgnYia4zEqG3RiQ' + 'eY+CZsOoKJV9Gv9sdh2ZKtZ+nS0vwMWHgW8j/J5I6vQlsh3n8IoXMvR7m9SdfwbSqalOgPkx2XX/aLFVTOBjpV0YazzwgraqgW8' + 'MCSBKnbYYaipCdlU/naAHns1rh4uTXHuCZo4+2IeA5vYJbfKWq963KMapbAo1MWiKSW1SVM6nnoJzijuw+WoOXn9N+5mfnbAKaD' + 'xV/U7tlMAORiFd45QqtjfmX3QO+wA1AOvtsK2b2i1btFBQE+jp0bgIdatIecG+UBr5I/EPch+6s+S6rQ942uGLYbCl6ivSaoPt+' + '2NKYLEETqlHlUlGuc9efZj4GpPpN5DveT/N+Iybtv05pmk0JDNj65MldO8gpqiVQIHz+gRkp6iMfERioai6AdmjGRtxV4oX6gUY' + 'vKNJSBc0AQX5l1cqKBlpQHxdjAzr936nyiETd5NRHkneidrJyxVj2H7wr/ymFvx2mRCL5wKOz9UmT/mxRteWEVRYCzKLOudsDNQ' + '8bvCK/ETACopuhaxxAC76nx9/49pTNLlRKWp0twGGSOmlIt/WugcEtwNt4TgNFMk3/fEZSeGHVrHXv3GnrvZ05VQznR8pnc9v5M' + 'F+4KPcaHTUPTdM7eQx6fdL/TL24nTvnE3idhSNx3vvcD6W0WBDNSoc/fZgDZ/PqadsQez6sFotbmwWHEnlVn9x0Ae21IU3MYhcB' + 'Fh/dCQICxL/NWieTD/D/w2RV78lMfSTZ/gNDEx9fGLf0g9E000QUc+UZ92JE+hvF3WPHO7bamxh2Vp6lAogMVhwQ8XLYR8mbL8r' + 'qcxlugvAvi6IhGw7T6SN4jJiZ4sfF2ArEx6d5qbLxQjdgxPuc6V1I0s18fK3mhVpC9JLGUHOWo3kaeCwuJ5bSoETClOF3SLcQgn' + 'XEr3gZJ7BhYdb7XAkMqIdoUsT8CcCIz6DX1vWtad2PeSmUejWGK/2gmentwIIo0R1syHR+DSNS3rTS8FPMucOqPd+AdTueg/m4A' + 'AAADCAgHQ6UvhDCDkrDUmT1MeQXkhvW7sPKLELfLhpA6HdslJsP7R6x6/I7bb3c1dRChK55f9Qjj7GVMJdkyC0s59awYPGguErC' + '15TAAMTMLnsmxTB2kwShgrGZ0sODar3kxY9jOzjraQLjCPC+UGQFhjXqEIcxk12j+CD0kx2ySUCKsadNeR32WKhr2a0J05wh6Rb' + 'VzZ1PDlrHEzSuM2TNJrnP7HUVo/+aLbABVaAYQfYoIRdvOQE5fZxByfZ5n1eKAb78AAAABbAgHjZJ1wIEP+jqco37lyuyi9BWTm' + '5gY+vnx4mocxOuHP1QwmtevSxuPsy16LhMrJngT4pEg3knXILN+P48ngp+hGhnGWuVBhd3YeUCrbReOBk7jlRV2e2i5LbwAAAA8' + 'AAeMk9V2iQKbg57h1QoAAAAAUAAHjRNddokCm4RHV8ktW2o70/WsAAAAPAAHjhrf1QgUw4R74nbNgAAAIcW1vb3YAAABsbXZoZA' + 'AAAAAAAAAAAAAAAAAAA+gAAATiAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAebdHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAQAAAAAAAATiAAAAAAAAAAAA' + 'AAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAABCAAAAQgAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAA' + 'BAAAE4gAABAAAAQAAAAAHE21kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAAMAAAADwAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAA' + 'AAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAABr5taW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAA' + 'AEAAAAMdXJsIAAAAAEAAAZ+c3RibAAABKpzdHNkAAAAAAAAAAEAAASaaGV2MQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAABCAEIA' + 'SAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAABDpodmNDAQFgAAAAkAAAAAAAHvAA/P3' + '4+AAADwQgAAEAGEABDAH//wFgAAADAJAAAAMAAAMAHpmYCSEAAQApQgEBAWAAAAMAkAAAAwAAAwAeoCSBJySZZmaSTK4BAAADAA' + 'EAAAMAGAgiAAEAB0QBwXK0IkAnAAEDv04BBf///7osot4JtRdH27tVpP5/wvxOeDI2NSAoYnVpbGQgODApIC0gMS45KzctZGM2M' + 'mI0N2RkMGQ5OltNYWMgT1MgWF1bY2xhbmcgNC4yLjBdWzY0IGJpdF0gOGJpdCAtIEguMjY1L0hFVkMgY29kZWMgLSBDb3B5cmln' + 'aHQgMjAxMy0yMDE1IChjKSBNdWx0aWNvcmV3YXJlIEluYyAtIGh0dHA6Ly94MjY1Lm9yZyAtIG9wdGlvbnM6IDcyeDcyIGZwcz0' + 'yNC8xIGJpdGRlcHRoPTggbm8td3BwIGN0dT02NCBtaW4tY3Utc2l6ZT04IG1heC10dS1zaXplPTMyIHR1LWludHJhLWRlcHRoPT' + 'EgdHUtaW50ZXItZGVwdGg9MSBtZT0xIHN1Ym1lPTIgbWVyYW5nZT01NyBuby1yZWN0IG5vLWFtcCBtYXgtbWVyZ2U9MiB0ZW1wb' + '3JhbC1tdnAgbm8tZWFybHktc2tpcCByZHBlbmFsdHk9MCBuby10c2tpcCBuby10c2tpcC1mYXN0IHN0cm9uZy1pbnRyYS1zbW9v' + 'dGhpbmcgbm8tbG9zc2xlc3Mgbm8tY3UtbG9zc2xlc3Mgbm8tY29uc3RyYWluZWQtaW50cmEgbm8tZmFzdC1pbnRyYSBvcGVuLWd' + 'vcCBuby10ZW1wb3JhbC1sYXllcnMgaW50ZXJsYWNlPTAga2V5aW50PTI1MCBtaW4ta2V5aW50PTI0IHNjZW5lY3V0PTQwIHJjLW' + 'xvb2thaGVhZD0yMCBsb29rYWhlYWQtc2xpY2VzPTAgYmZyYW1lcz00IGJmcmFtZS1iaWFzPTAgYi1hZGFwdD0yIHJlZj0zIGxpb' + 'Wl0LXJlZnM9MyBuby1saW1pdC1tb2RlcyB3ZWlnaHRwIG5vLXdlaWdodGIgYXEtbW9kZT0xIHFnLXNpemU9MzIgYXEtc3RyZW5n' + 'dGg9MS4wMCBjYnFwb2Zmcz0wIGNycXBvZmZzPTAgcmQ9MyBwc3ktcmQ9Mi4wMCByZG9xLWxldmVsPTAgcHN5LXJkb3E9MC4wMCB' + 'uby1yZC1yZWZpbmUgc2lnbmhpZGUgZGVibG9jayBzYW8gbm8tc2FvLW5vbi1kZWJsb2NrIGItcHlyYW1pZCBjdXRyZWUgbm8taW' + '50cmEtcmVmcmVzaCByYz1jcmYgY3JmPTI4LjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTUxIHFwc3RlcD00IGlwcmF0aW89M' + 'S40MCBwYnJhdGlvPTEuMzCAAAAACmZpZWwBAAAAABhzdHRzAAAAAAAAAAEAAAAeAAACAAAAABhzdHNzAAAAAAAAAAIAAAABAAAA' + 'GQAAAOBjdHRzAAAAAAAAABoAAAABAAAEAAAAAAEAAAwAAAAAAQAABgAAAAACAAAAAAAAAAEAAAIAAAAAAQAADAAAAAABAAAGAAA' + 'AAAIAAAAAAAAAAQAAAgAAAAABAAAEAAAAAAEAAAoAAAAAAQAABAAAAAABAAAAAAAAAAEAAAIAAAAAAQAACAAAAAABAAAEAAAAAA' + 'EAAAAAAAAAAQAADAAAAAABAAAGAAAAAAIAAAAAAAAAAQAAAgAAAAABAAAEAAAAAAEAAAwAAAAAAQAABgAAAAACAAAAAAAAAAEAA' + 'AIAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAAeAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADFQAAAH8AAAAUAAAAFAAAABAAAAAQ' + 'AAAA5QAAABYAAAASAAAAFgAAABEAAAAeAAAAbgAAABYAAAAUAAAAEQAAACAAAAASAAAAEQAAAG8AAAAXAAAAFAAAABQAAAAmAAA' + 'DPgAAAMYAAABfAAAAEwAAABgAAAATAAAAFHN0Y28AAAAAAAAAAQAAACwAAABidWR0YQAAAFptZXRhAAAAAAAAACFoZGxyAAAAAA' + 'AAAABtZGlyYXBwbAAAAAAAAAAAAAAAAC1pbHN0AAAAJal0b28AAAAdZGF0YQAAAAEAAAAATGF2ZjU2LjQwLjEwMQ==';
    /**
       * Small HEVC(hvc1) file with audio.
       *
       * @constant
       * @default
       * @type {String}
       */

    var HVC1 = 'data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAALl21kYXQAAAMRJg' + 'GvHYCh+rRXrzsdF9OQ5sh6IUZVTbyUH1TYc9eQ5kYBqfbDfH2M5v71r9vJSjxNUUON5TCnZyZh+hxfdR9bgRVQkfi8f9fXf0Jgl' + 'IlP6t46usUo9ioTIvqfewozMNadUuHkUisjCSA0FXb9FBpztGmCtQqeIsvh7yfEYBOEzNm1c1FrOrc2UduY1ZJv8Ij2xWZoIGQc' + 'RgA2bPr7ykA0aQu2eXLGvLrF8ZSdktns6UXrvYY00LIOodKhFrsz6YYTjWwzDetgzC3KPCEnOYuxbu2xm43OhS/pHAlf9tlSSRo' + 'Jx8TTwBpgTcQbrtaqVTSQAu+7FHXB2HkZG4bEZg8Gm4zkjMLCo47TPJ/CfAy4zWXLsZAZr0jGDydkNewLwRikhLIuel01AZH+lW' + '3kO+YYP409hXSCu90OCly97bSYqbBYpa72JOvFhmKebViOP080hLrQ/lGzHOV7CW1TrXY5JAQrfz2cdpmH/pcFLr+VwvRPJzhDo' + '6LM0GWELCApILayF4ag6eOncqhSW1+gVp2iNjOlx8tUFmCL8ZfdOG6FsekMj9nkSmhRuuZaOCeLB/fqc/gKoDVIO3EjK9ErHs1X' + 'QOqeNxVwFsB7rz1h9TTV6t3/3qLNnBxIjl2E3v24Gmy5bZncjU7CmMl8o5nfaYy23B0BDqvRBwI2RGnV21dunF7CyZRxTHQVe0u' + 'uwes2ePGVdfBl2U/Bt3ntG2z21MFiXkN0MwpiZYsR6maapbTXTxGEiVa9O3NcpjATS0AFVHzcDBO5k6DTVPn6llDGr1xGe9zyfb' + '1VaJfWYiK0CSGRiGfkpSe3w4yddULOTLYS+7t6KttCXuZIxNg9MWBekV6iAeYHgQNhZiMY++tRNois/cEixZVMTtaJqafcubkHl' + 'LqO1Qdk4V0rCxS8VI/Yrwu9cb6u6XIN8emW92YkyRXZlOzZ7vDptz8ZqxlTtkNistfCcIB5+ECLhUbZ+MIqiyju61wHPKatY6rZ' + 'EiH/TFY/c2JWYgmJPcVJSYbhzh1ictew8YhBv5w+3B/9zA3cD4Y87dwAAAB7AgHQKUvBDCDknQwMwyznK16ybbK58f4zdJvWIpT' + 'xMEBYlESWfEba4x/4AZwvXFJvYaXeYeyziD6qyFesKwEuL3SDHdh1AIoYosdbXUl4UZWhi3f1iILFuCghJnYZz1SRJhJK0VUxpu' + 'E8ztSA4uQXXYw8SmSc3DXMiTD4AAAAEAIB4GSdcCBB4IBoGMwFrsAAAAAQAAHgJPVZokCm5L7EAt3HIAAAAAwAAeBE11miQKLu5' + '3QAAAAMAAHghrflQgUwk1KAAAAA4QIB0FCS1fXEMAg5q1JHiGvrjLlBWFggBq1i3Wv3WeiiPbWpyxS2KOx/Qg+W8RAsAHbwyOhE' + 'TI9aYEHbRtZ0GCC/NbFtmnfGMGGn6VdWj7bsDTnuTZirVKRUcChflUHyaLhVc54GO7OvhQLb8NGFxR+p6GsvCoGhzi+ZLKA9sc+' + 'm0Yt1azhLkPyOT8f4PRDTLg0FuGuCYBodg3uBCxH12aMVTgHF8CxR2jc1mvlXbu0RRJQzCXWc7hy2xKqVg6bDNzu75TX01l2csQ' + 'lrm3SuoJRoGjE2rn7NbLYXmOqIMqw8jwAAABICAeECJ1ddcIEE3yEq1A5k84AAAAAOAAHgwj1dVlokCmCTUoAAAAASAAHg4jVX1' + 'lokCiBDybePM1twAAAADQAB4SKt1flwgUyTUoAAAAAaAgHQWN1dX1xDAIOwluVtntqoufg+5WPtikwAAABqAgHQeNJ1ddcQwCDk' + '/lFkKk/qlPlZlN6NiV7m/ymkHztxrqFqf3OWPOMC3pKHbGh+5gIvudQTTXndRwDnk8AxB+/PhgCHrzBiEv5T9Zd7A48wXaOrBQm' + 'oq1hgyR7wMCJQbD+T+dVycQy6WAAAABICAeGipdS1lwgQQPOajw3cSlAAAAAQAAHhgj9dZaJAojw09gjewAAAAA0AAeHCrXXlwg' + 'Uw7ud0AAAAHAIB0JDXVddcQwCDsGkyL7oLlRzAVpH5qSX05FQAAAAOAgHiIqVVf1wgQ+mpmsIAAAANAAHiAj1X5aJAou7ndAAAA' + 'GsCAdC40vVV1z4GiDmvPRMMtWfoNTXZjOkbl89TTlTtZFDiv1YrxLoy4Neym5M0VFiUTRa0yLPo2ZzXMJ3pmmLLbcfq2HjuGErG' + 'pB1cO6Pts588MYZSJmNs5A+V4N7is7C+TcCBcdMEBF3hywAAABMCAeKip9VXXCBB/sTrh7xmOjAFAAAAEAAB4mI/JVdaJApgL26' + '65CcAAAAQAAHigjXJ11okCiAvbrVgkwAAACIAAeLCrfJ9cIFM9+IaT1CP4IgkFrEODfmTIqc//sF6kUNHAAADOioBrGBsjRHGYL' + 'DH3TXdmAexNEEI/lFVpm37he9h94H4YPgoZYwdOPFHPl7pMMOwiVwOuiRl86GtfkysComKlEYKV2zlHElYJaEgnYia4zEqG3RiQ' + 'eY+CZsOoKJV9Gv9sdh2ZKtZ+nS0vwMWHgW8j/J5I6vQlsh3n8IoXMvR7m9SdfwbSqalOgPkx2XX/aLFVTOBjpV0YazzwgraqgW8' + 'MCSBKnbYYaipCdlU/naAHns1rh4uTXHuCZo4+2IeA5vYJbfKWq963KMapbAo1MWiKSW1SVM6nnoJzijuw+WoOXn9N+5mfnbAKaD' + 'xV/U7tlMAORiFd45QqtjfmX3QO+wA1AOvtsK2b2i1btFBQE+jp0bgIdatIecG+UBr5I/EPch+6s+S6rQ942uGLYbCl6ivSaoPt+' + '2NKYLEETqlHlUlGuc9efZj4GpPpN5DveT/N+Iybtv05pmk0JDNj65MldO8gpqiVQIHz+gRkp6iMfERioai6AdmjGRtxV4oX6gUY' + 'vKNJSBc0AQX5l1cqKBlpQHxdjAzr936nyiETd5NRHkneidrJyxVj2H7wr/ymFvx2mRCL5wKOz9UmT/mxRteWEVRYCzKLOudsDNQ' + '8bvCK/ETACopuhaxxAC76nx9/49pTNLlRKWp0twGGSOmlIt/WugcEtwNt4TgNFMk3/fEZSeGHVrHXv3GnrvZ05VQznR8pnc9v5M' + 'F+4KPcaHTUPTdM7eQx6fdL/TL24nTvnE3idhSNx3vvcD6W0WBDNSoc/fZgDZ/PqadsQez6sFotbmwWHEnlVn9x0Ae21IU3MYhcB' + 'Fh/dCQICxL/NWieTD/D/w2RV78lMfSTZ/gNDEx9fGLf0g9E000QUc+UZ92JE+hvF3WPHO7bamxh2Vp6lAogMVhwQ8XLYR8mbL8r' + 'qcxlugvAvi6IhGw7T6SN4jJiZ4sfF2ArEx6d5qbLxQjdgxPuc6V1I0s18fK3mhVpC9JLGUHOWo3kaeCwuJ5bSoETClOF3SLcQgn' + 'XEr3gZJ7BhYdb7XAkMqIdoUsT8CcCIz6DX1vWtad2PeSmUejWGK/2gmentwIIo0R1syHR+DSNS3rTS8FPMucOqPd+AdTueg/m4A' + 'AAADCAgHQ6UvhDCDkrDUmT1MeQXkhvW7sPKLELfLhpA6HdslJsP7R6x6/I7bb3c1dRChK55f9Qjj7GVMJdkyC0s59awYPGguErC' + '15TAAMTMLnsmxTB2kwShgrGZ0sODar3kxY9jOzjraQLjCPC+UGQFhjXqEIcxk12j+CD0kx2ySUCKsadNeR32WKhr2a0J05wh6Rb' + 'VzZ1PDlrHEzSuM2TNJrnP7HUVo/+aLbABVaAYQfYoIRdvOQE5fZxByfZ5n1eKAb78AAAABbAgHjZJ1wIEP+jqco37lyuyi9BWTm' + '5gY+vnx4mocxOuHP1QwmtevSxuPsy16LhMrJngT4pEg3knXILN+P48ngp+hGhnGWuVBhd3YeUCrbReOBk7jlRV2e2i5LbwAAAA8' + 'AAeMk9V2iQKbg57h1QoAAAAAUAAHjRNddokCm4RHV8ktW2o70/WsAAAAPAAHjhrf1QgUw4R74nbNgAAAIcW1vb3YAAABsbXZoZA' + 'AAAAAAAAAAAAAAAAAAA+gAAATiAAEAAAEAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAebdHJhawAAAFx0a2hkAAAAAwAAAAAAAAAAAAAAAQAAAAAAAATiAAAAAAAAAAAA' + 'AAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAABCAAAAQgAAAAAAJGVkdHMAAAAcZWxzdAAAAAAAAAA' + 'BAAAE4gAABAAAAQAAAAAHE21kaWEAAAAgbWRoZAAAAAAAAAAAAAAAAAAAMAAAADwAVcQAAAAAAC1oZGxyAAAAAAAAAAB2aWRlAA' + 'AAAAAAAAAAAAAAVmlkZW9IYW5kbGVyAAAABr5taW5mAAAAFHZtaGQAAAABAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAA' + 'AEAAAAMdXJsIAAAAAEAAAZ+c3RibAAABKpzdHNkAAAAAAAAAAEAAASaaHZjMQAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAABCAEIA' + 'SAAAAEgAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj//wAABDpodmNDAQFgAAAAkAAAAAAAHvAA/P3' + '4+AAADwQgAAEAGEABDAH//wFgAAADAJAAAAMAAAMAHpmYCSEAAQApQgEBAWAAAAMAkAAAAwAAAwAeoCSBJySZZmaSTK4BAAADAA' + 'EAAAMAGAgiAAEAB0QBwXK0IkAnAAEDv04BBf///7osot4JtRdH27tVpP5/wvxOeDI2NSAoYnVpbGQgODApIC0gMS45KzctZGM2M' + 'mI0N2RkMGQ5OltNYWMgT1MgWF1bY2xhbmcgNC4yLjBdWzY0IGJpdF0gOGJpdCAtIEguMjY1L0hFVkMgY29kZWMgLSBDb3B5cmln' + 'aHQgMjAxMy0yMDE1IChjKSBNdWx0aWNvcmV3YXJlIEluYyAtIGh0dHA6Ly94MjY1Lm9yZyAtIG9wdGlvbnM6IDcyeDcyIGZwcz0' + 'yNC8xIGJpdGRlcHRoPTggbm8td3BwIGN0dT02NCBtaW4tY3Utc2l6ZT04IG1heC10dS1zaXplPTMyIHR1LWludHJhLWRlcHRoPT' + 'EgdHUtaW50ZXItZGVwdGg9MSBtZT0xIHN1Ym1lPTIgbWVyYW5nZT01NyBuby1yZWN0IG5vLWFtcCBtYXgtbWVyZ2U9MiB0ZW1wb' + '3JhbC1tdnAgbm8tZWFybHktc2tpcCByZHBlbmFsdHk9MCBuby10c2tpcCBuby10c2tpcC1mYXN0IHN0cm9uZy1pbnRyYS1zbW9v' + 'dGhpbmcgbm8tbG9zc2xlc3Mgbm8tY3UtbG9zc2xlc3Mgbm8tY29uc3RyYWluZWQtaW50cmEgbm8tZmFzdC1pbnRyYSBvcGVuLWd' + 'vcCBuby10ZW1wb3JhbC1sYXllcnMgaW50ZXJsYWNlPTAga2V5aW50PTI1MCBtaW4ta2V5aW50PTI0IHNjZW5lY3V0PTQwIHJjLW' + 'xvb2thaGVhZD0yMCBsb29rYWhlYWQtc2xpY2VzPTAgYmZyYW1lcz00IGJmcmFtZS1iaWFzPTAgYi1hZGFwdD0yIHJlZj0zIGxpb' + 'Wl0LXJlZnM9MyBuby1saW1pdC1tb2RlcyB3ZWlnaHRwIG5vLXdlaWdodGIgYXEtbW9kZT0xIHFnLXNpemU9MzIgYXEtc3RyZW5n' + 'dGg9MS4wMCBjYnFwb2Zmcz0wIGNycXBvZmZzPTAgcmQ9MyBwc3ktcmQ9Mi4wMCByZG9xLWxldmVsPTAgcHN5LXJkb3E9MC4wMCB' + 'uby1yZC1yZWZpbmUgc2lnbmhpZGUgZGVibG9jayBzYW8gbm8tc2FvLW5vbi1kZWJsb2NrIGItcHlyYW1pZCBjdXRyZWUgbm8taW' + '50cmEtcmVmcmVzaCByYz1jcmYgY3JmPTI4LjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTUxIHFwc3RlcD00IGlwcmF0aW89M' + 'S40MCBwYnJhdGlvPTEuMzCAAAAACmZpZWwBAAAAABhzdHRzAAAAAAAAAAEAAAAeAAACAAAAABhzdHNzAAAAAAAAAAIAAAABAAAA' + 'GQAAAOBjdHRzAAAAAAAAABoAAAABAAAEAAAAAAEAAAwAAAAAAQAABgAAAAACAAAAAAAAAAEAAAIAAAAAAQAADAAAAAABAAAGAAA' + 'AAAIAAAAAAAAAAQAAAgAAAAABAAAEAAAAAAEAAAoAAAAAAQAABAAAAAABAAAAAAAAAAEAAAIAAAAAAQAACAAAAAABAAAEAAAAAA' + 'EAAAAAAAAAAQAADAAAAAABAAAGAAAAAAIAAAAAAAAAAQAAAgAAAAABAAAEAAAAAAEAAAwAAAAAAQAABgAAAAACAAAAAAAAAAEAA' + 'AIAAAAAHHN0c2MAAAAAAAAAAQAAAAEAAAAeAAAAAQAAAIxzdHN6AAAAAAAAAAAAAAAeAAADFQAAAH8AAAAUAAAAFAAAABAAAAAQ' + 'AAAA5QAAABYAAAASAAAAFgAAABEAAAAeAAAAbgAAABYAAAAUAAAAEQAAACAAAAASAAAAEQAAAG8AAAAXAAAAFAAAABQAAAAmAAA' + 'DPgAAAMYAAABfAAAAEwAAABgAAAATAAAAFHN0Y28AAAAAAAAAAQAAACwAAABidWR0YQAAAFptZXRhAAAAAAAAACFoZGxyAAAAAA' + 'AAAABtZGlyYXBwbAAAAAAAAAAAAAAAAC1pbHN0AAAAJal0b28AAAAdZGF0YQAAAAEAAAAATGF2ZjU3LjgzLjEwMA==';
    /**
     * Small video file with audio.
     * Source: https://github.com/mathiasbynens/small
     *
     * @constant
     * @default
     * @type {String}
     */

    var VIDEO = 'data:video/mp4;base64,AAAAHGZ0eXBpc29tAAACAGlzb21pc28ybXA0MQAAAAhmcmVlAAAC721kYXQhEAUgpB' + 'v/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3pwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcCEQBSCkG//AAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADengAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAAAsJtb292AAAAbG' + '12aGQAAAAAAAAAAAAAAAAAAAPoAAAALwABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAA' + 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAB7HRyYWsAAABcdGtoZAAAAAMAAAAAAAAAAAAAAAIAAAAAAAAALwAAAAAAAA' + 'AAAAAAAQEAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAACRlZHRzAAAAHGVsc3QAAAAAAA' + 'AAAQAAAC8AAAAAAAEAAAAAAWRtZGlhAAAAIG1kaGQAAAAAAAAAAAAAAAAAAKxEAAAIAFXEAAAAAAAtaGRscgAAAAAAAAAAc291bg' + 'AAAAAAAAAAAAAAAFNvdW5kSGFuZGxlcgAAAAEPbWluZgAAABBzbWhkAAAAAAAAAAAAAAAkZGluZgAAABxkcmVmAAAAAAAAAAEAAA' + 'AMdXJsIAAAAAEAAADTc3RibAAAAGdzdHNkAAAAAAAAAAEAAABXbXA0YQAAAAAAAAABAAAAAAAAAAAAAgAQAAAAAKxEAAAAAAAzZX' + 'NkcwAAAAADgICAIgACAASAgIAUQBUAAAAAAfQAAAHz+QWAgIACEhAGgICAAQIAAAAYc3R0cwAAAAAAAAABAAAAAgAABAAAAAAcc3' + 'RzYwAAAAAAAAABAAAAAQAAAAIAAAABAAAAHHN0c3oAAAAAAAAAAAAAAAIAAAFzAAABdAAAABRzdGNvAAAAAAAAAAEAAAAsAAAAYn' + 'VkdGEAAABabWV0YQAAAAAAAAAhaGRscgAAAAAAAAAAbWRpcmFwcGwAAAAAAAAAAAAAAAAtaWxzdAAAACWpdG9vAAAAHWRhdGEAAA' + 'ABAAAAAExhdmY1Ni40MC4xMDE=';
    /**
     * Try to play HEV1 video
     * @param {Object} options to play
     * @param {Function} resultCallback to be called with result
     * @returns {Object} playing video
     */

    function playHev1(options, resultCallback) {
      return startPlayback(setupDefaultValues(options), resultCallback, function () {
        return {
          element: document.createElement('video'),
          source: HEV1,
          type: OO.CONSTANTS.HEVC_CODEC.HEV1
        };
      });
    }
    /**
     * Try to play HVC1 video
     * @param {Object} options to play
     * @param {Function} resultCallback to be called with result
     * @returns {Object} playing video
     */


    function playHvc1(options, resultCallback) {
      return startPlayback(setupDefaultValues(options), resultCallback, function () {
        return {
          element: document.createElement('video'),
          source: HVC1,
          type: OO.CONSTANTS.HEVC_CODEC.HVC1
        };
      });
    }
    /**
     * Try to play video
     * @param {Object} options to play
     * @param {Function} resultCallback to be called with result
     * @returns {Object} playing video
     */


    function playVideo(options, resultCallback) {
      return startPlayback(setupDefaultValues(options), resultCallback, function () {
        return {
          element: document.createElement('video'),
          source: VIDEO
        };
      });
    }
    /**
     * Extend with specific params
     * @param {Object} options to extend
     * @returns {Object} extended object
     */


    function setupDefaultValues(options) {
      return OO._.extend({
        muted: false,
        timeout: 250,
        inline: false,
        usePromise: false
      }, options);
    }
    /**
     * Try to play video
     * @param {Object} _ref - options to play
     * @param {Function} resultCallback to be called with result
     * @param {Function} elementCallback to be called to get element
     */


    function startPlayback(_ref, resultCallback, elementCallback) {
      if (_ref === null || typeof _ref === 'undefined') {
        _ref = setupDefaultValues({}); // eslint-disable-line no-param-reassign
      }

      var muted = _ref.muted;
      var timeout = _ref.timeout;
      var inline = _ref.inline;
      var usePromise = _ref.usePromise && !OO.isIE && !OO.isEdge;

      var _elementCallback = elementCallback();

      var element = _elementCallback.element;
      var source = _elementCallback.source;
      var playResult;
      var timeoutId;
      var timedOut = false;
      element.muted = muted;

      if (muted === true) {
        element.setAttribute('muted', 'muted');
      } // indicates that the video is to be played "inline",
      // that is within the element's playback area.


      if (inline === true) {
        element.setAttribute('playsinline', 'playsinline');
      }

      var resultCallbackWrap = function resultCallbackWrap() {
        if (element.pause) {
          element.pause();
        }

        element.src = '';

        if (element.querySelectorAll) {
          Array.prototype.forEach.call(element.querySelectorAll('source') || [], function (item) {
            if (item.remove) {
              item.remove();
            }
          });
        }

        if (element.remove) {
          element.remove();
        }

        if (resultCallback) {
          resultCallback.apply(this, arguments);
        }
      };

      var errorCallback = function errorCallback() {
        clearTimeout(timeoutId);
        resultCallbackWrap({
          result: false,
          error: element.error
        }, _elementCallback.type);
        element.removeEventListener('playing', successCallback, true);
        element.removeEventListener('error', errorCallback, true);
      };

      var successCallback = function successCallback() {
        clearTimeout(timeoutId);
        resultCallbackWrap({
          result: true
        }, _elementCallback.type);
        element.removeEventListener('playing', successCallback, true);
        element.removeEventListener('error', errorCallback, true);
      };

      element.src = source;
      timeoutId = setTimeout(function () {
        timedOut = true;
        clearTimeout(timeoutId);
        resultCallbackWrap({
          result: false,
          error: new Error('Timeout ' + timeout + ' ms has been reached'),
          timedOut: true
        }, _elementCallback.type);
        element.removeEventListener('playing', successCallback, true);
        element.removeEventListener('error', errorCallback, true);
      }, timeout);

      if (!usePromise) {
        element.addEventListener('playing', successCallback, true);
        element.addEventListener('error', errorCallback, true);
      } // Browser may return a promise for play() and will print an exception
      // on the console if rejection is not handled. The following is only to
      // handle and ignore the promise since we refactored this library to
      // use callbacks instead
      // Our unit test framework doesn't have the play function defined for
      // the mocked DOM video element, so this check is mainly for our unit tests


      if (typeof element.play === 'function') {
        playResult = element.play();

        if (playResult !== undefined) {
          playResult.then(function (response) {
            if (usePromise && !timedOut) {
              successCallback();
            }
          }, function () {
            if (usePromise && !timedOut) {
              errorCallback();
            }
          });
        }
      } else {
        errorCallback();
      }
    }

    return {
      playHev1: playHev1,
      playHvc1: playHvc1,
      playVideo: playVideo
    };
  }();
  /** ************************** END can-autoplay.js ****************************************/


  OO.checkAutoplay = function () {
    /**
     * Returns an object with muted and unmuted autoplay capabilities of the browser.
     * If the a test was not conclusive, such as when the test times out, the corresponding
     * muted or unmuted value will remain undefined.
     * @param {Function} callback - function called if result is not sent
     */
    function runTest(callback) {
      if (typeof callback === 'function') {
        var autoplayability = {};
        var autoplayState = OO.CONSTANTS.AUTOPLAY_STATE.ALL_BLOCKED;
        var unmutedChecked = false;
        var mutedChecked = false;
        var sentResult = false;

        var trySendResult = function trySendResult() {
          if (!sentResult) {
            sentResult = true;
            callback(autoplayability, autoplayState);
          }
        }; // We are no longer storing the result because browsers such
        // as Chrome can have video autoplay capabilities change
        // midway during a browser session
        // See https://developers.google.com/web/updates/2017/09/autoplay-policy-changes
        // We have to wait for both tests to finish before sending the result.
        // However, if we receive the unmuted result and we can autoplay unmuted,
        // immediately send out the result.


        var options = {
          timeout: 750,
          usePromise: true
        }; // ios requires inline play

        if (OO.isIos) {
          options.inline = true;
        }

        var mutedOptions = _.clone(options);

        mutedOptions.muted = true;
        OO.canAutoplay.playVideo(options, function (unmutedResult) {
          unmutedChecked = true;

          if (!unmutedResult.timedOut) {
            autoplayability.unmuted = unmutedResult.result;
          }

          if (unmutedResult.result) {
            // We assume that if we can autoplay unmuted, we can
            // autoplay muted. Send the result now as there is
            // no need to wait for the muted test
            autoplayability.muted = true;
            autoplayState = OO.CONSTANTS.AUTOPLAY_STATE.ALL_UNBLOCKED;
            trySendResult();
          } else if (mutedChecked) {
            if (autoplayability.muted) {
              autoplayState = OO.CONSTANTS.AUTOPLAY_STATE.UNBLOCKED_WITHOUT_AUDIO;
            }

            trySendResult();
          }
        });
        OO.canAutoplay.playVideo(mutedOptions, function (mutedResult) {
          mutedChecked = true;

          if (!mutedResult.timedOut) {
            autoplayability.muted = mutedResult.result;
          }

          if (unmutedChecked) {
            if (mutedResult.result) {
              autoplayState = OO.CONSTANTS.AUTOPLAY_STATE.UNBLOCKED_WITHOUT_AUDIO;
            }

            trySendResult();
          }
        });
      }
    }

    return {
      runTest: runTest
    };
  }();

  OO.getRandomString = function () {
    var strLength = 36;
    var shiftLength = 7;
    return Math.random().toString(strLength).substring(shiftLength);
  };

  OO.safeClone = function (source) {
    if (_.isNumber(source) || _.isString(source) || _.isBoolean(source) || _.isFunction(source) || _.isNull(source) || _.isUndefined(source)) {
      return source;
    }

    var result = source instanceof Array ? [] : {};

    try {
      $.extend(true, result, source);
    } catch (error) {
      OO.log('deep clone error', error);
    }

    return result;
  };

  OO.debug = function () {
    if (OO.isDebug) {
      OO.log.apply(OO, arguments);
    }

    OO.$('#OOYALA_DEBUG_CONSOLE').append(JSON.stringify(OO.safeClone(arguments)) + '<br>');
  }; // Note: This inherit only for simple inheritance simulation, the Parennt class still has a this binding
  // to the parent class. so any variable initiated in the Parent Constructor, will not be available to the
  // Child Class, you need to copy paste constructor to Child Class to make it work.
  // coffeescript is doing a better job here by binding the this context to child in the constructor.
  // Until we switch to CoffeeScript, we need to be careful using this simplified inherit lib.


  OO.inherit = function (ParentClass, myConstructor) {
    if (typeof ParentClass !== 'function') {
      OO.log('invalid inherit, ParentClass need to be a class', ParentClass);
      return null;
    }

    var SubClass = function SubClass() {
      ParentClass.apply(this, arguments);

      if (typeof myConstructor === 'function') {
        myConstructor.apply(this, arguments);
      }
    };

    var parentClass = new ParentClass();

    OO._.extend(SubClass.prototype, parentClass);

    SubClass.prototype.parentClass = parentClass;
    return SubClass;
  };

  var styles = {}; // keep track of all styles added so we can remove them later if destroy is called

  OO.attachStyle = function (styleContent, playerId) {
    var style = $('<style type="text/css">' + styleContent + '</style>').appendTo('head');
    styles[playerId] = styles[playerId] || [];
    styles[playerId].push(style);
  };

  OO.removeStyles = function (playerId) {
    OO._.each(styles[playerId], function (style) {
      style.remove();
    });
  }; // object: object to get the inner property for, ex. {"mod":{"fw":{"data":{"key":"val"}}}}
  // keylist: list of keys to find, ex. ["mod", "fw", "data"]
  // example output: {"key":"val"}


  OO.getInnerProperty = function (object, keylist) {
    var innerObject = object;
    var list = keylist;

    while (list.length > 0) {
      var key = list.shift(); // Note that function and arrays are objects

      if (_.isNull(innerObject) || !_.isObject(innerObject) || _.isFunction(innerObject) || _.isArray(innerObject)) {
        return null;
      }

      innerObject = innerObject[key];
    }

    return innerObject;
  };

  OO.checkHevcAvailability = function (callback) {
    var options = {
      timeout: 300,
      muted: true
    }; // ios requires inline play

    if (OO.isIos) {
      options.inline = true;
    }

    OO.canAutoplay.playHev1(options, callback);
    OO.canAutoplay.playHvc1(options, callback);
  };

  OO.stripNonMp4Streams = function (streams) {
    var returnStreams = [];

    for (var index = 0; index < streams.length; index++) {
      if (streams[index].delivery_type === 'mp4') {
        returnStreams.push(streams[index]);
      }
    }

    return returnStreams;
  };

  OO.formatSeconds = function (timeInSeconds) {
    var secondsInMinute = 60;
    var secondsInHour = 3600;
    var oneDigitNumberThreshold = 10;
    var seconds = parseInt(timeInSeconds, 10) % secondsInMinute;
    var hours = parseInt(timeInSeconds / secondsInHour, 10);
    var minutes = parseInt((timeInSeconds - hours * secondsInHour) / secondsInMinute, 10);

    if (hours < oneDigitNumberThreshold) {
      hours = '0' + hours;
    }

    if (minutes < oneDigitNumberThreshold) {
      minutes = '0' + minutes;
    }

    if (seconds < oneDigitNumberThreshold) {
      seconds = '0' + seconds;
    }

    return parseInt(hours, 10) > 0 ? hours + ':' + minutes + ':' + seconds : minutes + ':' + seconds;
  };

  OO.getMediaElementErrorFromCode = function (code) {
    var map = {
      1: OO.ERROR.MEDIA.MEDIA_ERR_ABORTED,
      2: OO.ERROR.MEDIA.MEDIA_ERR_NETWORK,
      3: OO.ERROR.MEDIA.MEDIA_ERR_DECODE,
      4: OO.ERROR.MEDIA.MEDIA_ERR_SRC_NOT_SUPPORTED
    };
    return map[code];
  };

  OO.timeStringToSeconds = function (timeString) {
    var timeArray = (timeString || '').split(':');
    var secondsInMinute = 60;
    return _.reduce(timeArray, function (minute, second) {
      return minute * secondsInMinute + parseInt(second, 10);
    }, 0);
  };

  OO.leftPadding = function (num, totalChars) {
    var pad = '0';
    var numString = num ? num.toString() : '';

    while (numString.length < totalChars) {
      numString = pad + numString;
    }

    return numString;
  };

  OO.getColorString = function (color) {
    var bits = 16;
    var shift = 6;
    return '#' + OO.leftPadding(color.toString(bits), shift).toUpperCase();
  };

  OO.isHevcEnabled = function (parameters) {
    return parameters && (parameters.preferHevc === true || parameters.preferHevc === 'true');
  };

  OO.hexToRgb = function (hex) {
    var redBitMask = 0xFF0000;
    var redBits = 16;
    var red = (hex & redBitMask) >> redBits;
    var greenBitMask = 0xFF00;
    var greenBits = 8;
    var green = (hex & greenBitMask) >> greenBits;
    var blueBitMask = 0xFF;
    var blue = hex & blueBitMask;
    return [red, green, blue];
  };

  OO.changeColor = function (color, ratio, darker) {
    var max = 255;
    var bits = 16;
    var minmax = darker ? Math.max : Math.min;
    var boundary = darker ? 0 : max;
    var difference = Math.round(ratio * max) * (darker ? -1 : 1);

    var _OO$hexToRgb = OO.hexToRgb(color),
        _OO$hexToRgb2 = (0, _slicedToArray2.default)(_OO$hexToRgb, 3),
        red = _OO$hexToRgb2[0],
        green = _OO$hexToRgb2[1],
        blue = _OO$hexToRgb2[2];

    var shift = 2;
    return [OO.leftPadding(minmax(red + difference, boundary).toString(bits), shift), OO.leftPadding(minmax(green + difference, boundary).toString(bits), shift), OO.leftPadding(minmax(blue + difference, boundary).toString(bits), shift)].join('');
  };

  OO.decode64 = function (string) {
    var sanitizedStr = string.replace(/\n/g, '');
    var results = '';
    var length;
    var index = 0;
    var enc = [];
    var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; // shortcut for browsers with atob

    if (window.atob) {
      return window.atob(sanitizedStr);
    }

    var limit = 4;

    do {
      for (length = 0; length < limit; length++) {
        enc[length] = b64.indexOf(sanitizedStr.charAt(index++));
      }

      results += String.fromCharCode(enc[0] << 2 | enc[1] >> 4, // eslint-disable-line no-magic-numbers
      enc[2] === 64 ? 0 : (enc[1] & 15) << 4 | enc[2] >> 2, // eslint-disable-line no-magic-numbers
      enc[3] === 64 ? 0 : (enc[2] & 3) << 6 | enc[3]); // eslint-disable-line no-magic-numbers
    } while (index < sanitizedStr.length); // trim tailing null characters


    return results.replace(/\0/g, '');
  };

  OO.pixelPing = function (url) {
    var img = new window.Image();

    img.onerror = img.onabort = function () {
      OO.debug('onerror:', url);
    };

    img.src = OO.getNormalizedTagUrl(url);
  }; // ping array of urls.


  OO.pixelPings = function (urls) {
    if (_.isEmpty(urls)) {
      return;
    }

    _.each(urls, function (url) {
      OO.pixelPing(url);
    }, this);
  }; // helper function to convert types to boolean
  // the (!!) trick only works to verify if a string isn't the empty string
  // therefore, we must use a special case for that


  OO.stringToBoolean = function (value) {
    if (typeof value === 'string') {
      return value.toLowerCase().indexOf('true') > -1 || value.toLowerCase().indexOf('yes') > -1;
    }

    return !!value;
  };

  OO.regexEscape = function (value) {
    var specials = /[<>()\[\]{}]/g; // eslint-disable-line 

    return value.replace(specials, '\\$&');
  };

  OO.getNormalizedTagUrl = function (url, embedCode) {
    var ts = new Date().getTime();
    var pageUrl = escape(document.URL);
    var normalizedUrl = url;

    var placeHolderReplace = function placeHolderReplace(placeholders, replaceValue) {
      placeholders.forEach(function (placeholder) {
        var regexp = new RegExp("(".concat(OO.regexEscape(placeholder), ")"), 'gi');
        normalizedUrl = normalizedUrl.replace(regexp, replaceValue);
      });
    }; // replace the timestamp and referrer_url placeholders


    placeHolderReplace(OO.TEMPLATES.RANDOM_PLACE_HOLDER, ts);
    placeHolderReplace(OO.TEMPLATES.REFERAK_PLACE_HOLDER, pageUrl); // first make sure that the embedCode exists, then replace the
    // oo_embedcode placeholder

    if (embedCode) {
      placeHolderReplace(OO.TEMPLATES.EMBED_CODE_PLACE_HOLDER, embedCode);
    }

    return normalizedUrl;
  };

  OO.safeSeekRange = function (seekRange) {
    return {
      start: seekRange.length > 0 ? seekRange.start(0) : 0,
      end: seekRange.length > 0 ? seekRange.end(0) : 0
    };
  };

  OO.loadedJS = OO.loadedJS || {};
  OO.jsOnSuccessList = OO.jsOnSuccessList || {};

  OO.safeFuncCall = function (fn) {
    if (typeof fn !== 'function') {
      return;
    }

    try {
      fn.apply();
    } catch (error) {
      OO.log('Can not invoke function!', error);
    }
  };

  OO.loadScriptOnce = function (jsSrc, successCallBack, errorCallBack, timeoutInMillis) {
    OO.jsOnSuccessList[jsSrc] = OO.jsOnSuccessList[jsSrc] || [];

    if (OO.loadedJS[jsSrc]) {
      // invoke call back directly if loaded.
      if (OO.loadedJS[jsSrc] === 'loaded') {
        OO.safeFuncCall(successCallBack);
      } else if (OO.loadedJS[jsSrc] === 'loading') {
        OO.jsOnSuccessList[jsSrc].unshift(successCallBack);
      }

      return false;
    }

    OO.loadedJS[jsSrc] = 'loading';
    var defaultTimeout = 15000;
    $.ajax({
      url: jsSrc,
      type: 'GET',
      cache: true,
      dataType: 'script',
      timeout: timeoutInMillis || defaultTimeout,
      success: function success() {
        OO.loadedJS[jsSrc] = 'loaded';
        OO.jsOnSuccessList[jsSrc].unshift(successCallBack);

        OO._.each(OO.jsOnSuccessList[jsSrc], function (fn) {
          OO.safeFuncCall(fn);
        }, this);

        OO.jsOnSuccessList[jsSrc] = [];
      },
      error: function error() {
        OO.safeFuncCall(errorCallBack);
      }
    });
    return true;
  };

  try {
    OO.localStorage = window.localStorage;
  } catch (err) {
    OO.log(err);
  }

  if (!OO.localStorage) {
    OO.localStorage = {
      getItem: function getItem(sKey) {
        if (!sKey || !this.hasOwnProperty(sKey)) {
          return null;
        }

        return unescape(document.cookie.replace(new RegExp('(?:^|.*;\\s*)' + escape(sKey).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=\\s*((?:[^;](?!;))*[^;]?).*'), // eslint-disable-line no-useless-escape
        '$1'));
      },
      key: function key(nKeyId) {
        return unescape(document.cookie.replace(/\s*\=(?:.(?!;))*$/, '').split(/\s*\=(?:[^;](?!;))*[^;]?;\s*/)[nKeyId]); // eslint-disable-line no-useless-escape
      },
      setItem: function setItem(sKey, sValue) {
        if (!sKey) {
          return;
        }

        document.cookie = escape(sKey) + '=' + escape(sValue) + '; expires=Tue, 19 Jan 2038 03:14:07 GMT; path=/';
        this.length = document.cookie.match(/\=/g).length; // eslint-disable-line no-useless-escape
      },
      length: 0,
      removeItem: function removeItem(sKey) {
        if (!sKey || !this.hasOwnProperty(sKey)) {
          return;
        }

        document.cookie = escape(sKey) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
        this.length--;
      },
      hasOwnProperty: function hasOwnProperty(sKey) {
        return new RegExp('(?:^|;\\s*)' + escape(sKey).replace(/[\-\.\+\*]/g, '\\$&') + '\\s*\\=').test(document.cookie); // eslint-disable-line no-useless-escape
      }
    };
    OO.localStorage.length = (document.cookie.match(/\=/g) || OO.localStorage).length; // eslint-disable-line no-useless-escape
  } // A container to properly request OO.localStorage.setItem


  OO.setItem = function (sKey, sValue) {
    try {
      OO.localStorage.setItem(sKey, sValue);
    } catch (err) {
      OO.log(err);
    }
  };
  /**
     * Converts a value to a number or returns null if it can't be converted or is not a finite value.
     * @public
     * @method OO#ensureNumber
     * @param {*} dirtyValue The value to convert.
     * @param {*} defaultValue A default value to return when the input is not a valid number.
     * @returns {Number} The Number equivalent of value if it can be converted and is finite.
     * When value doesn't meet the criteria the function will return either defaultValue (if provided) or null.
     */


  OO.ensureNumber = function (dirtyValue, defaultValue) {
    var number;
    var value;

    if (dirtyValue === null || _.isArray(dirtyValue)) {
      value = NaN;
    } else {
      value = dirtyValue;
    }

    if (_.isNumber(value)) {
      number = value;
    } else {
      number = Number(value);
    }

    if (!isFinite(number)) {
      return typeof defaultValue === 'undefined' ? null : defaultValue;
    }

    return number;
  };

  OO.JSON = window.JSON;
  /**
     * Factory function to create language normalization function
     * @param {Object[]} languageList - list of languages to go through
     * @returns {Function} function that accepts languageCode and
     * returns normalized version of that code - e.g. ISO-639-2B
     */

  OO.normalizeLanguage = function (languageList) {
    return function (languageCode) {
      if (languageList && languageList.length && languageCode && typeof languageCode === 'string') {
        // normalize the code here
        var normalizedLanguage = _.find(languageList, function (lang) {
          var standards = ['1', '2T', '2B', '3']; // check if list of standards contains language code

          var standardsContain = _.some(standards, function (standard) {
            return lang[standard] === languageCode;
          });

          return standardsContain;
        }); // if we can normalize the language - return normalized version


        return normalizedLanguage ? normalizedLanguage['2B'] : null;
      } else {
        return null;
      }
    };
  };
  /**
     * Function that returns normalized version of language code - ISO-639-2B version
     * @param {String} languageCode
     * @returns {String || null} either languageCode in ISO-639-2B or null
     */


  OO.normalizeLanguageCode = OO.normalizeLanguage(OO.LANGUAGE_LIST);
  /**
   * Get language from page level params
   * @param {Object} pageLevelParams - object with user skin settings (pageLevelParams)
   * @returns {Object} defaultTrack
   */

  OO.getLanguageFromPageLevelParams = function (pageLevelParams) {
    // check default language from settings
    // check default language from inline overrides for skin json
    var possibleLanguage = null;
    var defaultTrack = null;

    if (pageLevelParams) {
      // check top level default language
      if (pageLevelParams.audioLanguage) {
        possibleLanguage = pageLevelParams.audioLanguage; // check inline skin config default language
      } else if (pageLevelParams.skinConfig && pageLevelParams.skinConfig.inline && pageLevelParams.skinConfig.inline.audio && pageLevelParams.skinConfig.inline.audio.audioLanguage) {
        possibleLanguage = pageLevelParams.skinConfig.inline.audio.audioLanguage;
      }
    }

    if (possibleLanguage) {
      defaultTrack = OO.normalizeLanguageCode(possibleLanguage);
    }

    return defaultTrack ? {
      issuer: 'pageLevelParams',
      defaultTrack: defaultTrack
    } : null;
  };
  /**
     * Gets language from browser if there's one
     * @param {Object} navigator - user browser navigator
     * @returns {Object} defaultTrack
     */


  OO.getLanguageFromBrowser = function (navigator) {
    // get browser language somehow
    var browserLanguage = navigator && (navigator.language || navigator.userLanguage);
    var possibleLanguage = browserLanguage && browserLanguage.split('-')[0];
    var defaultTrack = null;

    if (possibleLanguage) {
      defaultTrack = OO.normalizeLanguageCode(possibleLanguage);
    }

    return defaultTrack ? {
      issuer: 'browser',
      defaultTrack: defaultTrack
    } : null;
  };
  /**
     * Get language from skinConfig
     * @param {SkinConfig} skinConfig - object with values for skin configuration (default or/and user settings)
     * @returns {Object} defaultTrack
     */


  OO.getLanguageFromSkinConfig = function (skinConfig) {
    // should get from this.skin.props.skinConfig.audio.audioLanguage
    var possibleLanguage = null;
    var defaultTrack = null;

    if (skinConfig && skinConfig.audio && skinConfig.audio.audioLanguage) {
      possibleLanguage = skinConfig.audio.audioLanguage;
    }

    if (possibleLanguage) {
      defaultTrack = OO.normalizeLanguageCode(possibleLanguage);
    }

    return defaultTrack ? {
      issuer: 'skinConfig',
      defaultTrack: defaultTrack
    } : null;
  };
  /**
   * Get track from content tree if its present
   * @param {Object} contentTree - object from server with main info about a video file
   * @returns {Object} defaultLanguage
   */


  OO.getLanguageFromContentTree = function (contentTree) {
    // item.defaultLanguage; item is contentTree
    var possibleLanguage = null;
    var defaultTrack = null;

    if (contentTree && contentTree.movie_attributes && contentTree.movie_attributes.default_language && contentTree.movie_attributes.default_language.length) {
      possibleLanguage = contentTree.movie_attributes.default_language;
    }

    if (possibleLanguage) {
      defaultTrack = OO.normalizeLanguageCode(possibleLanguage);
    }

    return defaultTrack ? {
      issuer: 'contentTree',
      defaultTrack: defaultTrack
    } : null;
  };
  /**
     * Gets track from localstorage is there's one
     * @param {Object} storage - localStorage
     * @returns {Object} defaultTrack
     */


  OO.getTrackFromLocalStorage = function (storage) {
    var track = null;

    if (storage && typeof storage.getItem === 'function') {
      track = storage.getItem(OO.CONSTANTS.SELECTED_AUDIO);
    }

    var defaultTrack = track ? JSON.parse(track) : null;
    return defaultTrack;
  };
  /**
   * Get possible default track and list of current tracks and try
   * to find matching track by
   * 1. matching both lang and label attributes
   * 2. matching only lang attribute
   *
   * @param {Object} possibleDefaultTrack - object with info about possibleDefaultTrack
   * @param {String} possibleDefaultTrack.lang - language of a possible default track
   * @param {String} possibleDefaultTrack.label - label of a possible default track
   *
   * @param {Object[]} tracksList - list of available tracks
   * @returns {Object} defaultTrack
   */


  OO.restoreDefaultTrack = function (possibleDefaultTrack, tracksList) {
    // first we have to explicitly check BOTH label and lang attributes
    var defaultTrack = _.find(tracksList, function (track) {
      return track.label === possibleDefaultTrack.label && track.lang === OO.normalizeLanguageCode(possibleDefaultTrack.lang);
    }); // otherwise we have to check ONLY lang attribute


    if (!defaultTrack) {
      defaultTrack = _.find(tracksList, function (track) {
        return track.lang === OO.normalizeLanguageCode(possibleDefaultTrack.lang);
      });
    }

    return defaultTrack || null;
  };
  /**
     * Get first track in the list
     * @param {Object[]} tracksList - list of tracks
     * @returns {Object} defaultTrack
     */


  OO.getFirstTrack = function (tracksList) {
    return {
      issuer: 'firstTrack',
      defaultTrack: _.head(tracksList)
    };
  };
  /**
   * Find exact default track by going throught the list of
   * found default languages in all places and
   * match them against the list of all available languages
   * number of iterations depends on foundDefaultLanguages length
   * the flow can be desribed as:
   * foundDefaultLanguages -> ['en', 'de', 'spa']
   * tracksList -> [{ lang: 'de' }, { lang: 'en' }, { lang: 'spa' }]
   * starting value for determinedDefaultTrack -> null
   * first iteration - determinedDefaultTrack -> { lang: 'en' }
   * second iteration - determinedDefaultTrack -> { lang: 'en' }
   * third iteration - determinedDefaultTrack -> { lang: 'en' }
   * @param {Array} foundDefaultLanguages - list of default languages
   * @param {Array} tracksList - list of tracks
   * @returns {Array} determine default track
   */


  OO.determineDefaultTrack = function (foundDefaultLanguages, tracksList) {
    // get first and exact match from the list
    // go over found default languages, e.g. ['en', 'es', 'de']
    // and save found result to determinedDefaultTrack
    // initial reduction is null
    var exactDefaultTrack = foundDefaultLanguages.reduce(function (determinedDefaultTrack, possibleDefaultLanguage) {
      // try to find default language in the track list
      var defaultLanguageCandidate = _.find(tracksList, function (track) {
        // if one of the found default languages matches track that we have available in a list
        return track.lang === possibleDefaultLanguage.defaultTrack;
      }); // if one was found - set it as determinedDefaultTrack
      // if not - go to the next language in the list
      // don't change determined default track if it was found once
      // since we only need first and exact match


      return determinedDefaultTrack || defaultLanguageCandidate;
    }, null);
    return exactDefaultTrack;
  };
  /**
   * Go through list of available tracks and assign default track
   * Basically we have two branches here -
   * If default track was already set once then we need to try and
   * match current default track against array of existing tracks
   * and if we've never run through the code then
   * we need to try to select a track based on multiple criteria -
   * if default track can be set from page level parameters
   * if default track can be set from skinConfig
   * if default track can be set from browser settings
   * if all of the above fail - select first track
   * @param {Array} tracksList - list of tracks
   * @param {string} tracksList[].id - language code
   * @param {string} tracksList[].lang - language code
   * @param {string} tracksList[].label - decorating label
   * @param {Array} providers - list of providers
   * @returns {(Object|null)} defaultTrack
   */


  OO.getDefaultTrack = function (tracksList, providers) {
    // first we try and check whether we have some language selected and saved in localStorage
    var defaultLanguage = null;
    var defaultTrack = null;

    if (providers) {
      if (providers.localStorage) {
        defaultLanguage = OO.getTrackFromLocalStorage(providers.localStorage);

        if (defaultLanguage) {
          // if default language is set in local storage we have a completely different flow
          defaultTrack = OO.restoreDefaultTrack(defaultLanguage, tracksList);
        }
      }

      if (!defaultTrack) {
        /*
          * if we still were not able to find a matching language
          * or if no language was selected before e.g. it's our first run
          *
          * we run in sequence all checks that include -
          * checking for language in page level parameters
          * checking for language in skinConfig
          * checking for language in browser settings
          * checking for language in contentTree
          */
        var pageLevelLanguage = OO.getLanguageFromPageLevelParams(providers.pageLevelParams);
        var skinConfigLanguage = OO.getLanguageFromSkinConfig(providers.skinConfig);
        var contentTreeLanguage = OO.getLanguageFromContentTree(providers.contentTree); // get all possible default language candidates and save them in seq
        // we really have to keep them in this order

        var defaultLanguageCandidates = [pageLevelLanguage, skinConfigLanguage, contentTreeLanguage]; // filter default languages to only have active ones
        // because one of the methods can return either null or undefined

        var foundDefaultLanguages = defaultLanguageCandidates.filter(function (language) {
          return language;
        }); // if some languages are left after filtering all undefined and nulls

        if (foundDefaultLanguages.length) {
          defaultTrack = OO.determineDefaultTrack(foundDefaultLanguages, tracksList);
        }
      }
    } // if all of the above fail - we just select the first track


    if (!defaultTrack) {
      defaultTrack = OO.getFirstTrack(tracksList).defaultTrack;
    }

    return defaultTrack;
  };
  /**
     * Check if the speed is a support playback speed.
     * @param  {number} speed The speed multiple to be checked.
     * @returns {boolean}      True if valid, false if not.
     */


  OO.isValidPlaybackSpeed = function (speed) {
    if (typeof speed === 'number' && speed >= OO.CONSTANTS.PLAYBACK_SPEED.MIN && speed <= OO.CONSTANTS.PLAYBACK_SPEED.MAX) {
      return true;
    }

    return false;
  };
  /**
  * Check if the provided encoding is audio only or not
  * @param  {string} encoding The provided encoding format.
  * @returns {boolean}      True if audio only, false if not.
  */


  OO.isAudioOnlyStream = function (encoding) {
    if (encoding === OO.VIDEO.ENCODING.AUDIO_HLS || encoding === OO.VIDEO.ENCODING.AUDIO || encoding === OO.VIDEO.ENCODING.AUDIO_OGG || encoding === OO.VIDEO.ENCODING.AUDIO_M4A) {
      return true;
    } else {
      return false;
    }
  };
  /**
  * Check if playlistPlugin is in a list of plugins
  * @returns {boolean} True if playlistPlugin is in the list of plugins, false otherwise
  */


  OO.isPlaylistsPluginIncluded = function () {
    if (OO.modules && OO.modules.length) {
      for (var index = OO.modules.length - 1; index >= 0; index--) {
        var plugin = OO.modules[index];

        if (plugin !== null && (0, _typeof2.default)(plugin) === 'object' && plugin.name === OO.PLUGINS.PLAYLISTS_PLUGIN) {
          return true;
        }
      }
    }

    return false;
  };
})(OO, OO._, OO.$);

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/slicedToArray":17,"@babel/runtime/helpers/typeof":18}],57:[function(require,module,exports){
"use strict";

/**
 * @public
 * @namespace OO
 */
(function (OO, _) {
  // External States

  /**
   * @public
   * @description The Ooyala Player run-time states apply to an Ooyala player while it is running. These states apply equally to both HTML5 and Flash players.
   * State changes occur either through user interaction (for example, the user clickes the PLAY button), or programmatically via API calls. For more information,
   * see <a href='http://support.ooyala.com/developers/documentation/api/pbv4_api_events.html' target='target'>Player Message Bus Events</a>.
   * @summary Represents the Ooyala Player run-time states.
   * @namespace OO.STATE
   */
  OO.STATE = {
    /**
     * The embed code has been set. The movie and its metadata is currently being loaded into the player.
     * @public
     */
    LOADING: 'loading',

    /**
     * One of the following applies:
     * <ul>
     *   <li>All of the necessary data is loaded in the player. Playback of the movie can begin.</li>
     *   <li>Playback of the asset has finished and is ready to restart from the beginning.</li>
     * </ul>
     * @public
     */
    READY: 'ready',

    /**
     * The player is currently playing video content.
     * @public
     */
    PLAYING: 'playing',

    /**
     * The player has currently paused after playback had begun.
     * @public
     */
    PAUSED: 'paused',

    /**
     * Playback has currently stopped because it doesn't have enough movie data to continue and is downloading more.
     * @public
     */
    BUFFERING: 'buffering',

    /** The player has encountered an error that prevents playback of the asset. The error could be due to many reasons,
     * such as video format, syndication rules, or the asset being disabled. Refer to the list of errors for details.
     * The error code for the root cause of the error is available from the [OO.Player.getErrorCode()]{@link OO.Player#getErrorCode} method.
     * @public
     */
    ERROR: 'error',

    /**
     * The player has been destroyed via its [OO.Player.destroy(<i>callback</i>)]{@link OO.Player#destroy} method.
     * @public
     */
    DESTROYED: 'destroyed',
    __end_marker: true
  }; // All Events Constants

  /**
   * @description The Ooyala Player events are default events that are published by the event bus.Your modules can subscribe to any and all of these events.
   * Use message bus events to subscribe to or publish player events from video to ad playback. For more information,
   * see <a href='http://support.ooyala.com/developers/documentation/api/pbv4_api_events.html' target='target'>Player Message Bus Events</a>.
   * @summary Represents the Ooyala Player events.
   * @namespace OO.EVENTS
   * @public
   */

  OO.EVENTS = {
    /**
    * A player was created. This is the first event that is sent after player creation.
    * This event provides the opportunity for any other modules to perform their own initialization.
    * The handler is called with the query string parameters.
    * The DOM has been created at this point, and plugins may make changes or additions to the DOM.<br/><br/>
    * <ul>
    *   <li>The element id.</li>
    *   <li>The object containing the player page level parameters.</li>
    *   <li>The object containing the player persistent settings.</li>
    *   <li>The embed code.</li>
    *   <li>The timestamp when the player was created.</li>
    *   <li>The player url.</li>
    * </ul>
    *
    * @event OO.EVENTS#PLAYER_CREATED
    * @public
    */
    PLAYER_CREATED: 'playerCreated',
    PLAYER_EMBEDDED: 'playerEmbedded',

    /**
     * An attempt has been made to set the embed code.
     * If you are developing a plugin, reset the internal state since the player is switching to a new asset.
     * Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The ID (embed code) of the asset.</li>
     *     <li>{
     *       The object containing options for the asset:
     *       <ul>
     *         <li> [optional] isAd: (boolean) true if this asset is an Ooyala Ad.</li>
     *       </ul>
     *     }</li>
     *   </ul>
     *
     * @event OO.EVENTS#SET_EMBED_CODE
     * @public
     */
    SET_EMBED_CODE: 'setEmbedCode',

    /**
     * HEVC playback availablility has been checked
     * The handler is called with:
     *   <ul>
     *     <li>canPlayHevc (boolean) If HEVC can be played in the current environment.</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#HEVC_CHECKED
     * @private
     */
    HEVC_CHECKED: 'hevcChecked',

    /**
     * An attempt has been made to set the embed code by Ooyala Ads.
     * If you are developing a plugin, reset the internal state since the player is switching to a new asset.
     * Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The ID (embed code) of the asset.</li>
     *     <li>The ID (embed code) of the asset, with options.</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#SET_EMBED_CODE_AFTER_OOYALA_AD
     * @private
     */
    SET_EMBED_CODE_AFTER_OOYALA_AD: 'setEmbedCodeAfterOoyalaAd',

    /**
     * An attempt has been made to set a new asset.
     * If you are developing a plugin, reset the internal state since the player is switching to a new asset.
     * Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The asset Object</li>
     *     <li>The asset Object, with options.</li>
     *   </ul>
     *
     * <h5>Compatibility: </h5>
     * <p style='text-indent: 1em;'>HTML5, Flash</p>
     *
     * @event OO.EVENTS#SET_ASSET
     */
    SET_ASSET: 'setAsset',

    /**
     * A new asset has been specified to for playback and has basic passed validation.
     * The handler will be called with an object representing the new asset.
     * The object will have the following structure:
     *   <ul>
     *     <li>{
     *           Content:
     *           <ul>
     *                 <li>title: String,</li>
     *                 <li>description: String,</li>
     *                 <li>duration: Number,</li>
     *                 <li>posterImages: Array,</li>
     *                 <li>streams: Array,</li>
     *                 <li>captions: Array</li>
     *           </ul>
     *     }</li>
     *
     *   </ul>
     *
     * <h5>Compatibility: </h5>
     * <p style='text-indent: 1em;'>HTML5, Flash</p>
     *
     * @event OO.EVENTS#ASSET_CHANGED
     */
    ASSET_CHANGED: 'assetChanged',

    /**
     * The player's embed code has changed. The handler is called with two parameters:
     * <ul>
     *    <li>The ID (embed code) of the asset.</li>
     *    <li>The options JSON object.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#EMBED_CODE_CHANGED
     * @public
     */
    EMBED_CODE_CHANGED: 'embedCodeChanged',

    /**
     * The player's embed code has been changed by an Ooyala Ad. The handler is called with two parameters:
     * <ul>
     *    <li>The ID (embed code) of the asset.</li>
     *    <li>The options JSON object.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#EMBED_CODE_CHANGED_AFTER_OOYALA_AD
     * @private
     */
    EMBED_CODE_CHANGED_AFTER_OOYALA_AD: 'embedCodeChangedAfterOoyalaAd',

    /**
     * An <code>AUTH_TOKEN_CHANGED</code> event is triggered when an authorization token is issued by the Player Authorization API.<br/>
     * For example, in device registration, an authorization token is issued, as described in
     * <a href='http://support.ooyala.com/developers/documentation/concepts/device_registration.html' target='target'>Device Registration</a>.
     * The handler is called with a new value for the authorization token.<br/><br/>
     *
     *
     * @event OO.EVENTS#AUTH_TOKEN_CHANGED
     * @public
     */
    AUTH_TOKEN_CHANGED: 'authTokenChanged',

    /**
     * The GUID has been set. The handler is called with the GUID.
     * <p>This event notifies plugin or page developers that a unique ID has been either generated or loaded for the current user's browser.
     * This is useful for analytics.</p>
     * <p>In HTML5, Flash, and Chromecast environments, a unique user is identified by local storage or a cookie. </p>
     * <p>To generate the GUID, Flash players use the timestamp indicating when the GUID is generated, and append random data to it.
     * The string is then converted to base64.</p>
     * <p>To generate the GUID, HTML5 players use the current time, browser
     * information, and random data and hash it and convert it to base64.</p>
     * <p>Within the same browser on the desktop, once a GUID is set by one platform
     * it is used for both platforms for the user. If a user clears their browser cache, that user's (device's) ID will be regenerated the next time
     * they watch video. Incognito modes will track a user for a single session, but once the browser is closed the GUID is erased.</p>
     * <p>For more information, see <b>unique user</b> <a href='http://support.ooyala.com/users/users/documentation/reference/glossary.html' target='target'>Glossary</a>.</p>
     *
     *
     * @event OO.EVENTS#GUID_SET
     * @public
     */
    GUID_SET: 'guidSet',
    WILL_FETCH_PLAYER_XML: 'willFetchPlayerXml',
    PLAYER_XML_FETCHED: 'playerXmlFetched',
    WILL_FETCH_CONTENT_TREE: 'willFetchContentTree',
    SAVE_PLAYER_SETTINGS: 'savePlayerSettings',

    /**
     * A content tree was fetched. The handler is called with a JSON object that represents the content data for the current asset.<br/><br/>
     *
     *
     * <h5>Analytics:</h5>
     * <p style='text-indent: 1em;'>Records a <code>display</code> event. For more information see
     * <a href='http://support.ooyala.com/developers/documentation/concepts/analytics_plays-and-displays.html' target='target'>Displays, Plays, and Play Starts</a>.</p>
     *
     * @event OO.EVENTS#CONTENT_TREE_FETCHED
     * @public
     */
    CONTENT_TREE_FETCHED: 'contentTreeFetched',

    /**
     * This event is published when embed code metadata is required.
     *
     *
     * @event OO.EVENTS#WILL_REQUIRE_EMBED_CODE_METADATA
     * @public
     */
    WILL_REQUIRE_EMBED_CODE_METADATA: 'willRequireEmbedCodeMetadata',

    /**
     * This event is published when embed code metadata will be fetched.
     *
     *
     * @event OO.EVENTS#WILL_FETCH_EMBED_CODE_METADATA
     * @public
     */
    WILL_FETCH_EMBED_CODE_METADATA: 'willFetchEmbedCodeMetadata',

    /**
     * The embed code provider metadata, has been retrieved.
     *
     *
     * @event OO.EVENTS#EMBED_CODE_METADATA_FETCHED
     * @public
     */
    EMBED_CODE_METADATA_FETCHED: 'embedCodeMetadataFetched',
    WILL_FETCH_METADATA: 'willFetchMetadata',

    /**
     * The metadata, which is typically set in Backlot, has been retrieved.
     * The handler is called with the JSON object containing all metadata associated with the current asset.
     * The metadata includes page-level, asset-level, player-level, and account-level metadata, in addition to
     * metadata specific to 3rd party plugins. This is typically used for ad and anlytics plugins, but can be used
     * wherever you need specific logic based on the asset type.<br/><br/>
     *
     *
     * @event OO.EVENTS#METADATA_FETCHED
     * @public
     */
    METADATA_FETCHED: 'metadataFetched',

    /**
     * The skin metadata, which is set in Backlot, has been retrieved.
     * The handler is called with the JSON object containing metadata set in Backlot for the current asset.
     * This is used by the skin plug-in to deep merge with the embedded skin config.<br/><br/>
     *
     * @event OO.EVENTS#SKIN_METADATA_FETCHED
     */
    SKIN_METADATA_FETCHED: 'skinMetadataFetched',

    /**
     * The attributes from the metadata API call have been retrieved.
     * The handler is called with the JSON object containing metadata for the current asset.
     * This is used by the skin plug-in to apply logic based on attribute values.<br/><br/>
     *
     * @event OO.EVENTS#ATTRIBUTES_FETCHED
     */
    ATTRIBUTES_FETCHED: 'attributesFetched',

    /**
     * The thumbnail metadata needed for thumbnail previews while seeking has been fetched and will be
     * passed through to the event handlers subscribing to this event.
     * Thumbnail metadata will have the following structure:
     * {
        data: {
          available_time_slices: [10],  //times that have thumbnails available
          available_widths: [100],       //widths of thumbnails available
          thumbnails: {
                10: {100: {url: http://test.com, height: 100, width: 100}}
          }
        }
      }
      * <br/><br/>
      *
      *
      * @event OO.EVENTS#THUMBNAILS_FETCHED
      * @public
      */
    THUMBNAILS_FETCHED: 'thumbnailsFetched',
    WILL_FETCH_AUTHORIZATION: 'willFetchAuthorization',

    /**
     * Playback was authorized. The handler is called with an object containing the entire SAS response, and includes the value of <code>video_bitrate</code>.
     * <p>For more information see
     * <a href='http://support.ooyala.com/developers/documentation/concepts/encodingsettings_videobitrate.html' target='target'>Video Bit Rate</a>.</p>
     *
     *
     * @event OO.EVENTS#AUTHORIZATION_FETCHED
     * @public
     */
    AUTHORIZATION_FETCHED: 'authorizationFetched',
    WILL_FETCH_AD_AUTHORIZATION: 'willFetchAdAuthorization',
    AD_AUTHORIZATION_FETCHED: 'adAuthorizationFetched',

    /**
     * An attempt has been made to update current asset for cms-less player.
     * The handler is called with:
     *   <ul>
     *     <li>The asset Object, with optional fields populated</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#UPDATE_ASSET
     * @public
     */
    UPDATE_ASSET: 'updateAsset',

    /**
     * New asset parameters were specified for playback and have passed basic validation.
     * The handler will be called with an object representing the new parameters.
     * The object will have the following structure:
     *   <ul> {
     *     <li> id: String </li>
     *     <li> content:
     *           <ul>
     *                 <li>title: String,</li>
     *                 <li>description: String,</li>
     *                 <li>duration: Number,</li>
     *                 <li>posterImages: Array,</li>
     *                 <li>streams: Array,</li>
     *                 <li>captions: Array</li>
     *           </ul>
     *     </li>
     *     <li> relatedVideos:
     *           <ul>
     *                 <li>title: String,</li>
     *                 <li>description: String,</li>
     *                 <li>thumbnailUrl: String,</li>
     *                 <li>asset: Object</li>
     *           </ul>
     *     </li>
     *   }</ul>
     *
     * <h5>Compatibility: </h5>
     * <p style='text-indent: 1em;'>HTML5, Flash</p>
     *
     * @event OO.EVENTS#ASSET_UPDATED
     */
    ASSET_UPDATED: 'assetUpdated',
    CAN_SEEK: 'canSeek',
    WILL_RESUME_MAIN_VIDEO: 'willResumeMainVideo',

    /**
     * The player has indicated that it is in a playback-ready state.
     * All preparations are complete, and the player is ready to receive playback commands
     * such as play, seek, and so on. The default UI shows the <b>Play</b> button,
     * displaying the non-clickable spinner before this point. <br/><br/>
     * <ul>
     *   <li>The time from player creation to when it is in the playback ready state.</li>
     * </ul>
     *
     * @event OO.EVENTS#PLAYBACK_READY
     * @public
     */
    PLAYBACK_READY: 'playbackReady',

    /**
     * Play has been called for the first time. <br/><br/>
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The unix timestamp of the initial playtime</li>
     *   <li>True if the playback request was the result of an autoplay, false or undefined otherwise</li>
     * </ul>
     *
     * @event OO.EVENTS#INITIAL_PLAY
     * @public
     */
    INITIAL_PLAY: 'initialPlay',
    // when play is called for the very first time ( in start screen )

    /**
     * Indicates that the video framework is ready to accept play commands
     *
     *
     * @event OO.EVENTS#CAN_PLAY
     */
    CAN_PLAY: 'canPlay',
    WILL_PLAY: 'willPlay',

    /**
     * The user has restarted the playback after the playback finished.
     * The handler is called with the following optional argument:
     * <ul>
     *   <li>[optional] The time to restart video from, in seconds. </li>
     * </ul>
     *
     * If no argument is provided, playback restarts from the beginning.
     *
     * @event OO.EVENTS#REPLAY
     */
    REPLAY: 'replay',

    /**
     * The user is trying to set the playbackspeed of the main content.
     * <ul>
     *   <li>The desired speed</li>
     * </ul>
     * @event OO.EVENTS#SET_PLAYBACK_SPEED
     */
    SET_PLAYBACK_SPEED: 'setPlaybackSpeed',

    /**
     * The playback speed changed. The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video whose playback speed changed.</li>
     *   <li>The new playback speed that was set.</li>
     * </ul>
     * @event OO.EVENTS#PLAYBACK_SPEED_CHANGED
     */
    PLAYBACK_SPEED_CHANGED: 'playbackSpeedChanged',

    /**
     * The playhead time changed. The handler is called with the following arguments:
     * <ul>
     *   <li>The current time.</li>
     *   <li>The duration.</li>
     *   <li>The name of the buffer.</li>
     *   <li>The seek range.</li>
     *   <li>The id of the video (as defined by the module that controls it).</li>
     * </ul>
     *
     *
     * <h5>Analytics:</h5>
     * <p style='text-indent: 1em;'>The first event is <code>video start</code>. Other instances of the event feed the <code>% completed data points</code>.</p>
     * <p style='text-indent: 1em;'>For more information, see <a href='http://support.ooyala.com/developers/documentation/concepts/analytics_plays-and-displays.html'>Displays, Plays, and Play Starts</a>.</p>
     *
     * @event OO.EVENTS#PLAYHEAD_TIME_CHANGED
     * @public
     */
    PLAYHEAD_TIME_CHANGED: 'playheadTimeChanged',

    /**
     * The player is buffering the data stream.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The url of the video that is buffering.</li>
     *   <li>The playhead position.</li>
     *   <li>The id of the video that is buffering (as defined by the module that controls it).</li>
     * </ul><br/><br/>
     *
     *
     * @event OO.EVENTS#BUFFERING
     * @public
     */
    BUFFERING: 'buffering',
    // playing stops because player is buffering

    /**
     * Play resumes because the player has completed buffering. The handler is called with the URL of the stream.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The url of the video that has buffered.</li>
     *   <li>The id of the video that has buffered (as defined by the module that controls it).</li>
     * </ul><br/><br/>
     *
     *
     * @event OO.EVENTS#BUFFERED
     * @public
     */
    BUFFERED: 'buffered',

    /**
     * The player is downloading content (it can play while downloading).
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The current time.</li>
     *   <li>The duration.</li>
     *   <li>The name of the buffer.</li>
     *   <li>The seek range.</li>
     *   <li>The id of the video (as defined by the module that controls it).</li>
     * </ul>
     * <br/><br/>
     *
     *
     * @event OO.EVENTS#DOWNLOADING
     * @public
     */
    DOWNLOADING: 'downloading',
    // player is downloading content (could be playing while downloading)

    /**
     * The content is stalling or could not be fetched.
     * Currently only published by the main_html5 plugin and used by HA to determine
     * if failover is needed.
     * @event OO.EVENTS#STALLED
     * @public
     */
    STALLED: 'stalled',

    /**
     * Lists the available bitrate information. The handler is called with an array containing the available streams,
     * each object must include the following and only the following:
     *   <ul>
     *     <li>bitrate: The bitrate in bits per second. (number)</li>
     *     <li>height: The vertical resolution of the stream. (number)</li>
     *     <li>width: The horizontal resolution of the stream. (number)</li>
     *     <li>id: A unique identifier for the stream. (string)</li>
     *   </ul>
     * If The video plugin supports automatic ABR, one stream will have an ID of 'auto' and a bitrate of 0.
     *
     * <p>For more information see
     * <a href='http://support.ooyala.com/developers/documentation/concepts/encodingsettings_videobitrate.html' target='target'>Video Bit Rate</a>.</p>
     * @event OO.EVENTS#BITRATE_INFO_AVAILABLE
     * @public
     */
    BITRATE_INFO_AVAILABLE: 'bitrateInfoAvailable',

    /**
     * A request to set a specific stream bitrate has occurred.
     * The event is published with parameter containing a string ID of the bitrate to change to.
     * This will be an ID from one of the stream objects published in BITRATE_INFO_AVAILABLE.
     * To use automatic ABR, the ID will be 'auto'.
     *
     * @event OO.EVENTS#SET_TARGET_BITRATE
     */
    SET_TARGET_BITRATE: 'setTargetBitrate',

    /**
     * The current playing bitrate has changed. The handler is called with the stream object
     * which includes the following and only the following:
     *   <ul>
     *     <li>bitrate: The bitrate in bits per second. (number)</li>
     *     <li>height: The vertical resolution of the stream. (number)</li>
     *     <li>width: The horizontal resolution of the stream. (number)</li>
     *     <li>id: A unique identifier for the stream. (string).</li>
     *   </ul>
     * If the player is using automatic ABR, it should publish a stream object with an ID of 'auto' and bitrate set to 0.
     *
     * <p>For more information see
     * <a href='http://support.ooyala.com/developers/documentation/concepts/encodingsettings_videobitrate.html' target='target'>Video Bit Rate</a>.</p>
     * @event OO.EVENTS#BITRATE_CHANGED
     * @public
     */
    BITRATE_CHANGED: 'bitrateChanged',

    /**
     * The current playing bitrate has changed. The handler is called with the stream object
     *
     * <p>For more information see
     * <a href='http://support.ooyala.com/developers/documentation/concepts/encodingsettings_videobitrate.html' target='target'>Video Bit Rate</a>.</p>
     * @event OO.EVENTS#SEND_QUALITY_CHANGE
     * @public
     */
    SEND_QUALITY_CHANGE: 'receiveVideoQualityChangeEvent',

    /**
     * Lists the available closed caption information including languages and locale.
     *
     * Provide the following arguments:
     * <ul>
     *   <li>object containing:
     *     <ul>
     *       <li><code>languages</code>: (array) a list of available languages.</li>
     *       <li><code>locale</code>: (object) contains language names by id. For example, <code>{en: 'English', fr: 'Français', sp: 'Español'}</code>.</li>
     *     </ul>
     *   </li>
     * </ul>
     *
     * @event OO.EVENTS#CLOSED_CAPTIONS_INFO_AVAILABLE
     * @public
     */
    CLOSED_CAPTIONS_INFO_AVAILABLE: 'closedCaptionsInfoAvailable',

    /**
     * Sets the closed captions language to use.  To remove captions, specify <code>'none'</code> as the language.
     *
     * Provide the following arguments:
     * <ul>
     *   <li>string specifying the language in which the captions appear.
     *   </li>
     * </ul>
     *
     * @event OO.EVENTS#SET_CLOSED_CAPTIONS_LANGUAGE
     * @public
     */
    SET_CLOSED_CAPTIONS_LANGUAGE: 'setClosedCaptionsLanguage',

    /**
     * Enable/Disable closed captions
     *
     * @event OO.EVENT#TOGGLE_CLOSED_CAPTIONS
     * @public
     */
    TOGGLE_CLOSED_CAPTIONS: 'toggleCLosedCaptions',

    /**
     * Sent when the skin has chosen the language for the UI.
     *
     * Provide the following arguments:
     * <ul>
     *   <li>string specifying the language code of the UI.
     *   </li>
     * </ul>
     * @event OO.EVENTS#SKIN_UI_LANGUAGE
     * @private
     */
    SKIN_UI_LANGUAGE: 'skinUiLanguage',

    /**
     * Raised when closed caption text is changed at a point in time.
     *
     * Provide the following arguments:
     * <ul>
     *   <li>TBD
     *   </li>
     * </ul>
     *
     * @event OO.EVENTS#CLOSED_CAPTION_CUE_CHANGED
     * @private
     */
    CLOSED_CAPTION_CUE_CHANGED: 'closedCaptionCueChanged',

    /**
     * Fires when a list of tracks is available and ready to be displayed.
     * Provide the following arguments:
     * <ul>
     *   <li>list of multiaudio data with 'multiAudio' as a key</li>
     * </ul>
     *
     * @event OO.EVENTS#MULTI_AUDIO_FETCHED
     * @public
     */
    MULTI_AUDIO_FETCHED: 'multiAudioFetched',

    /**
     * Fires when the current track has been changed.
     * Provide the following arguments:
     * <ul>
     *   <li>list of multiaudio data with 'multiAudio' as a key</li>
     * </ul>
     *
     * @event OO.EVENTS#MULTI_AUDIO_CHANGED
     * @public
     */
    MULTI_AUDIO_CHANGED: 'multiAudioChanged',

    /**
     * Fires when need to set new audio as current
     * @event OO.EVENTS#SET_CURRENT_AUDIO
     * @public
     * Provide the following arguments:
     * <ul>
     *   <li>Video id of the video to change the audio for</li>
     *   <li>Audio track information</li>
     * </ul>
     */
    SET_CURRENT_AUDIO: 'setCurrentAudio',

    /**
     *
     * This stream type is not supported for multiaudio.
     * @event OO.EVENTS#MULTIAUDIO_ERROR
     * @public
     */
    MULTIAUDIO_ERROR: 'multiAudioError',

    /**
     * Raised when asset dimensions become available.
     *
     * Provide the following arguments in an object:
     * <ul>
     *   <li>width: the width of the asset (number)
     *   </li>
     *   <li>height: the height of the asset (number)
     *   </li>
     *   <li>videoId: the id of the video (string)
     *   </li>
     * </ul>
     *
     * @event OO.EVENTS#ASSET_DIMENSION
     * @public
     */
    ASSET_DIMENSION: 'assetDimension',
    SCRUBBING: 'scrubbing',
    SCRUBBED: 'scrubbed',

    /**
     * A request to perform a seek has occurred. The playhead is requested to move to
     * a specific location, specified in milliseconds. The handler is called with the position to which to seek.<br/><br/>
     *
     *
     * @event OO.EVENTS#SEEK
     * @public
     */
    SEEK: 'seek',

    /**
     * The player has finished seeking the main video to the requested position.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The current time of the video after seeking.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#SEEKED
     * @public
     */
    SEEKED: 'seeked',

    /**
     * A request to perform a seek to the live point has occurred. The playhead is requested to move to
     * the live point location. The handler is called as a seek with the position to seek equal to the video duration.<br/><br/>
     *
     *
     * @event OO.EVENTS#LIVE_BUTTON_CLICKED
     * @public
     */
    LIVE_BUTTON_CLICKED: 'liveButtonClicked',

    /**
     * A playback request has been made. This event is called anytime the video plays, including at the video's initial play, as well as when a user resumes playback after a pause. <br/><br/>
     *
     *
     * @event OO.EVENTS#PLAY
     * @public
     */
    PLAY: 'play',
    PLAYING: 'playing',
    PLAY_FAILED: 'playFailed',

    /**
     * A player pause has been requested. <br/><br/>
     *
     *
     * @event OO.EVENTS#PAUSE
     * @public
     */
    PAUSE: 'pause',

    /**
     * The player was paused. If a PAUSE event is fired by the Ad Manager,
     * the <code>'pauseForAdPlayback'</code> parameter is included as an argument.<br/><br/>
     *
     *
     * @event OO.EVENTS#PAUSED
     * @public
     */
    PAUSED: 'paused',

    /**
     * The video and asset were played. The handler is called with the arguments that were passed.<br/><br/>
     *
     *
     * @event OO.EVENTS#PLAYED
     * @public
     */
    PLAYED: 'played',
    SHOULD_DISPLAY_CUE_POINTS: 'shouldDisplayCuePoints',
    INSERT_CUE_POINT: 'insertCuePoint',
    RESET_CUE_POINTS: 'resetCuePoints',

    /**
     * This event is triggered before a change is made to the full screen setting of the player.
     * The handler is called with <code>true</code> if the full screen setting will be enabled,
     * and is called with <code>false</code> if the full screen setting will be disabled.
     *
     *
     * @event OO.EVENTS#WILL_CHANGE_FULLSCREEN
     * @public
     */
    WILL_CHANGE_FULLSCREEN: 'willChangeFullscreen',

    /**
     * The fullscreen state has changed. Depending on the context, the handler is called with:
     * <ul>
     *   <li><code>isFullscreen</code> and <code>paused</code>:</li>
     *     <ul>
     *       <li><code>isFullscreen</code> is set to <code>true</code> or <code>false</code>.</li>
     *       <li><code>isFullscreen</code> and <code>paused</code> are each set to <code>true</code> or <code>false</code>.</li>
     *     </ul>
     *   </li>
     *   <li>The id of the video that has entered fullscreen (as defined by the module that controls it).
     * </ul>
     *
     *
     * @event OO.EVENTS#FULLSCREEN_CHANGED
     * @public
     */
    FULLSCREEN_CHANGED: 'fullscreenChanged',

    /**
     * The screen size has changed. This event can also be triggered by a screen orientation change for handheld devices.
     * Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The width of the player.</li>
     *     <li>The height of the player.</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#SIZE_CHANGED
     * @public
     */
    SIZE_CHANGED: 'sizeChanged',

    /**
     * A request to change volume has been made.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The desired volume of the video element.</li>
     *   <li>The id of the video on which to change the volume (as defined by the module that controls it).
     *        If null or undefined, all video elements volume will be changed</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#CHANGE_VOLUME
     * @public
     */
    CHANGE_VOLUME: 'changeVolume',

    /**
     * The volume has changed. The handler is called with the current volume, which has a value between 0 and 1, inclusive.<br/><br/>
     *
     *
     * @event OO.EVENTS#VOLUME_CHANGED
     * @public
     */
    VOLUME_CHANGED: 'volumeChanged',

    /**
     * A request to change the mute state has been made.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The desired mute state of the video element.</li>
     *   <li>The id of the video on which to mute (as defined by the module that controls it).
     *        If null or undefined, all video elements volume will be changed</li>
     *   <li>Whether or not the request was from a user action. True if it was from a user action,
     *        false otherwise.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#CHANGE_MUTE_STATE
     * @public
     */
    CHANGE_MUTE_STATE: 'changeMuteState',

    /**
     * The mute state has changed.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The current mute state of the video element.</li>
     *   <li>The id of the video that was muted (as defined by the module that controls it).</li>
     *   <li>Whether or not the mute state was changed for muted autoplay. True if it was
     *        done for muted autoplay, false or undefined otherwise.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#MUTE_STATE_CHANGED
     * @public
     */
    MUTE_STATE_CHANGED: 'muteStateChanged',

    /**
     * The stereo parameter has been changed. The handler is called with a new parameter, the value of the parameter can be
     * true or false.
     * @event OO.EVENTS#TOGGLE_STEREO
     * @public
     */
    TOGGLE_STEREO_VR: 'toggleStereoVr',

    /**
     * Switch to full screen mode and back to vr360 with ios
     * @event OO.EVENTS#TOGGLE_FULLSCREEN_VR
     * @public
     */
    TOGGLE_FULLSCREEN_VR: 'toggleFullscreenVr',

    /**
     * The camera (the visible part of video360) can be shifted when you press the keyboard keys or a special control
     * on the screen. This event is called when events 'mousestart' or 'mouseend' triggered
     * @event OO.EVENTS#MOVE_VR_TO_DIRECTION
     * @public
     */
    MOVE_VR_TO_DIRECTION: 'moveVrToDirection',

    /**
     * @event OO.EVENTS#VIDEO_VR
     * @private
     */
    VIDEO_VR: 'videoVr',

    /**
     * Used to say skins to clear interface for vr
     * @event OO.EVENTS#CLEAR_VIDEO_TYPE
     * @public
     */
    CLEAR_VIDEO_TYPE: 'clearVideoType',

    /**
     * To re-create skins
     * @event OO.EVENTS#RECREATING_UI
     * @public
     */
    RECREATING_UI: 'recreatingUI',

    /**
     * Controls are shown.<br/><br/>
     *
     *
     * @event OO.EVENTS#CONTROLS_SHOWN
     * @private
     */
    CONTROLS_SHOWN: 'controlsShown',
    // Set to private temporarily.
    // Set these to public when they are working.

    /**
     * Controls are hidden.<br/><br/>
     *
     * @event OO.EVENTS#CONTROLS_HIDDEN
     * @private
     */
    CONTROLS_HIDDEN: 'controlsHidden',
    END_SCREEN_SHOWN: 'endScreenShown',

    /**
     * Request change to closed caption language.<br/><br/>
     *
     *
     * @event OO.EVENTS#CHANGE_CLOSED_CAPTION_LANGUAGE
     * @public
     */
    CHANGE_CLOSED_CAPTION_LANGUAGE: 'changeClosedCaptionLanguage',

    /**
     * An error has occurred. The handler is called with a JSON object that always includes an error code field,
     * and may also include other error-specific fields.<br/><br/>
     *
     *
     * @event OO.EVENTS#ERROR
     * @public
     */
    ERROR: 'error',

    /**
     * An api related error has occurred. The handler is called with the following arguments:
     * <ul>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     *   <li>The url requested.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#API_ERROR
     * @public
     */
    API_ERROR: 'apiError',

    /**
     * Event containing the bitrate used at the start of playback. The handler is called with the following arguments:
     * <ul>
     *   <li>The bitrate in kbps.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#BITRATE_INITIAL
     * @public
     */
    BITRATE_INITIAL: 'bitrateInitial',

    /**
     * Event containing the bitrate used five seconds into playback. The handler is called with the following arguments:
     * <ul>
     *   <li>The bitrate in kbps.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#BITRATE_FIVE_SEC
     * @public
     */
    BITRATE_FIVE_SEC: 'bitrateFiveSec',

    /**
     * Event containing the bitrate used thirty seconds into playback. The handler is called with the following arguments:
     * <ul>
     *   <li>The bitrate in kbps.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#BITRATE_STABLE
     * @public
     */
    BITRATE_STABLE: 'bitrateStable',

    /**
     * A playback error has occurred before the video start. The handler is called with the following arguments:
     * <ul>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     *   <li>The la url if DRM used.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#PLAYBACK_START_ERROR
     * @public
     */
    PLAYBACK_START_ERROR: 'playbackStartError',

    /**
     * A playback error has occurred midstream. The handler is called with the following arguments:
     * <ul>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     *   <li>The playhead position.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#PLAYBACK_MIDSTREAM_ERROR
     * @public
     */
    PLAYBACK_MIDSTREAM_ERROR: 'playbackMidstreamError',

    /**
     * A plugin has been loaded successfully. The handler is called with the following arguments:
     * <ul>
     *   <li>The player core version.</li>
     *   <li>The plugin type: ad, video, analytics, playtest, skin.</li>
     *   <li>The plugin name.</li>
     *   <li>The time it took to load the plugin.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#PLAYBACK_MIDSTREAM_ERROR
     * @public
     */
    PLUGIN_LOADED: 'pluginLoaded',

    /**
     * A skin config has been loaded successfully. The handler is called with the following arguments:
     * <ul>
     *   <li>The player skin config.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#SKIN_CONFIG_LOADED
     * @public
     */
    SKIN_CONFIG_LOADED: 'skinConfigLoaded',

    /**
     * The autoplay capabilities of the browser have been determined.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>Object containing
     *     <ul> <code>unmuted</code> is set to true if we can autoplay unmuted, false otherwise
     *     <ul> <code>muted</code> is set to true if we can autoplay muted, false otherwise
     *   </li>
     * </ul>
     */
    AUTOPLAY_CHECK_COMPLETE: 'autoplayCheckComplete',

    /**
     * The video plugin has sent an error message. The handler is called with the following arguments:
     * <ul>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     * </ul>
     *
     *
     * @event OO.EVENTS#VC_PLUGIN_ERROR
     * @public
     */

    /**
     * Notifies the player that the initial playback of content has started.
     * <ul>
     *   <li>The time since the initial play request was made (number)</li>
     *   <li>Boolean parameter. True if video was autoplayed, false otherwise (boolean)</li>
     *   <li>Boolean parameter. True if the video had an ad play before it started.
     *       This includes midrolls that play before content due to an initial playhead time > 0.
     *       False otherwise  (number)</li>(boolean)</li>
     *   <li>The initial position of the playhead upon playback start. (number)</li>
     *   <li>The video plugin used for playback (string)</li>
     *   <li>The browser technology used - HTML5, Flash, Mixed, or Other (string)</li>
     *   <li>The stream encoding type, i.e. MP4, HLS, Dash, etc. (string)</li>
     *   <li>The URL of the content being played (string)</li>
     *   <li>The DRM being used, none if there is no DRM (string)</li>
     *   <li>Boolean parameter. True if a live stream is playing. False if VOD.(boolean)</li>
     * </ul>
     * @event OO.EVENTS#INITIAL_PLAY_STARTING
     * @public
     */
    INITIAL_PLAY_STARTING: 'initialPlayStarting',

    /**
     * Notifies the player that the user has requested to play the previous video.
     * Depending on the plugin being used, this could either be the previous video in
     * a playlist, or the previously played Discovery video recommendation.
     *
     * @event OO.EVENTS#REQUEST_PREVIOUS_VIDEO
     * @public
     */
    REQUEST_PREVIOUS_VIDEO: 'requestPreviousVideo',

    /**
     * Notifies the player that the user has requested to play the next video.
     * Depending on the plugin being used, this could either be the next video in
     * a playlist, or the next Discovery video recommendation.
     *
     * @event OO.EVENTS#REQUEST_NEXT_VIDEO
     * @public
     */
    REQUEST_NEXT_VIDEO: 'requestNextVideo',

    /**
     * Fired by either the Playlist or Discovery plugins after the position of the
     * current video, relative to its siblings, has been determined. The main purpose
     * of this event is to let the UI know whether or not there are previous or next
     * videos that the user can navigate towards.<br/><br/>
     *
     * The handler is called with the following arguments:
     * <ul>
     *   <li>An object which contains the following properties:
     *     <ul>
     *       <li><code>hasPreviousVideos</code>: (boolean) True if there are videos before the current one, false otherwise</li>
     *       <li><code>hasNextVideos</code>: (boolean) True if there are videos after the current one, false otherwise</li>
     *     </ul>
     *   </li>
     * </ul>
     *
     * @event OO.EVENTS#POSITION_IN_PLAYLIST_DETERMINED
     * @private
     */
    POSITION_IN_PLAYLIST_DETERMINED: 'positionInPlaylistDetermined',
    VC_PLUGIN_ERROR: 'videoPluginError',

    /**
     * The player is currently being destroyed, and anything created by your module must also be deleted.
     * After the destruction is complete, there is nothing left to send an event.
     * Any plugin that creates or has initialized any long-living logic should listen to this event and clean up that logic.
     * <br/><br/>
     *
     *
     * @event OO.EVENTS#DESTROY
     * @public
     */
    DESTROY: 'destroy',
    WILL_PLAY_FROM_BEGINNING: 'willPlayFromBeginning',
    DISABLE_PLAYBACK_CONTROLS: 'disablePlaybackControls',
    ENABLE_PLAYBACK_CONTROLS: 'enablePlaybackControls',
    // Video Controller action events

    /**
     * Denotes that the video controller is ready for playback to be triggered.
     * @event OO.EVENTS#VC_READY
     * @public
     */
    VC_READY: 'videoControllerReady',

    /**
     * Commands the video controller to create a video element.
     * Provide the following arguments:
     * <ul>
     *   <li><code>videoId (string)</code>
     *   </li>
     *   <li>streams (object) containing:
     *     <ul>
     *       <li>Encoding type (string) as key defined in OO.VIDEO.ENCODINGS
     *       </li>
     *       <li>Key-value pair (object) as value containing:
     *         <ul>
     *           <li>url (string): Url of the stream</li>
     *           <li>drm (object): Denoted by type of DRM with data as value object containing:
     *             <ul>
     *               <li>Type of DRM (string) as key (ex. 'widevine', 'fairplay', 'playready')</li>
     *               <li>DRM specific data (object) as value</li>
     *             </ul>
     *           </li>
     *         </ul>
     *       </li>
     *     </ul>
     *   </li>
     *   <li>parentContainer of the element. This is a jquery element. (object)
     *   </li>
     *   <li>optional params object (object) containing:
     *     <ul>
     *       <li><code>closedCaptions</code>: (object) The possible closed captions available on this video. Permitted values: <code>null (default), closedCaptions</code>.</li>
     *       <li><code>crossorigin</code>: The crossorigin attribute value to set on the video. Permitted values: <code>null (default), 'anonymous'</code>.</li>
     *       <li><code>technology</code>: The core video technology required (string) (ex. OO.VIDEO.TECHNOLOGY.HTML5)</li>
     *       <li><code>features</code>: The video plugin features required (string) (ex. OO.VIDEO.FEATURE.CLOSED_CAPTIONS)</li>
     *     </ul>
     *   </li>
     * </ul>
     * @event OO.EVENTS#VC_CREATE_VIDEO_ELEMENT
     * @public
     */
    VC_CREATE_VIDEO_ELEMENT: 'videoControllerCreateVideoElement',

    /**
     * A message to be interpreted by the Video Controller to update the URL of the stream for an element.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The name of the element who's URL is being altered</li>
     *   <li>The new url to be used</li>
     * </ul>
     * @event OO.EVENTS#VC_UPDATE_ELEMENT_STREAM
     * @public
     */
    VC_UPDATE_ELEMENT_STREAM: 'videoControllerUpdateElementStream',

    /**
     * The Video Controller has created the desired video element, as denoted by id (string).
     * The handler is called with the following arguments:
     * <ul>
     *   <li>Object containing:
     *     <ul>
     *       <li><code>videoId</code>: The id of the video as defined by the module that controls it.</li>
     *       <li><code>encodings</code>: The encoding types supported by the new video element.</li>
     *       <li><code>parent</code>: The parent element of the video element.</li>
     *       <li><code>domId</code>: The DOM id of the video element.</li>
     *       <li><code>videoElement</code>: The video element or its wrapper as created by the video plugin.</li>
     *     </ul>
     *   </li>
     * </ul>
     * @event OO.EVENTS#VC_VIDEO_ELEMENT_CREATED
     * @public
     */
    VC_VIDEO_ELEMENT_CREATED: 'videoControllerVideoElementCreated',

    /**
     * Commands the Video Controller to bring a video element into the visible range given the video element id (string).
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video to focus (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_FOCUS_VIDEO_ELEMENT
     * @public
     */
    VC_FOCUS_VIDEO_ELEMENT: 'videoControllerFocusVideoElement',

    /**
     * The Video Controller has moved a video element (string) into focus.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that is in focus (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_VIDEO_ELEMENT_IN_FOCUS
     * @public
     */
    VC_VIDEO_ELEMENT_IN_FOCUS: 'videoControllerVideoElementInFocus',

    /**
     * The Video Controller has removed a video element (string) from focus.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that lost focus (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_VIDEO_ELEMENT_LOST_FOCUS
     * @public
     */
    VC_VIDEO_ELEMENT_LOST_FOCUS: 'videoControllerVideoElementLostFocus',

    /**
     * Commands the Video Controller to dispose a video element given the video element id (string).
     * @event OO.EVENTS#VC_DISPOSE_VIDEO_ELEMENT
     * @public
     */
    VC_DISPOSE_VIDEO_ELEMENT: 'videoControllerDisposeVideoElement',

    /**
     * The Video Controller has disposed the denoted video element (string).
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that was disposed (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_VIDEO_ELEMENT_DISPOSED
     * @public
     */
    VC_VIDEO_ELEMENT_DISPOSED: 'videoControllerVideoElementDisposed',

    /**
     * Commands the video controller to set the stream for a video element.
     * It should be given the video element name (string) and an object of streams denoted by encoding type (object).
     * @event OO.EVENTS#VC_SET_VIDEO_STREAMS
     * @public
     */
    VC_SET_VIDEO_STREAMS: 'videoControllerSetVideoStreams',

    /**
     * The Video Controller has encountered an error attempting to configure video elements.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that encountered the error (as defined by the module that controls it).</li>
     *   <li>The error details (object) containing an error code.</li>
     *   <li>The playhead position (number)</li>
     * @event OO.EVENTS#VC_ERROR
     * @public
     */
    VC_ERROR: 'videoControllerError',
    // Video Player action events

    /**
     * Sets the video element's initial playback time.
     * @event OO.EVENTS#VC_SET_INITIAL_TIME
     * @public
     */
    VC_SET_INITIAL_TIME: 'videoSetInitialTime',

    /**
     * Commands the video element to play.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video to play (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_PLAY
     * @public
     */
    VC_PLAY: 'videoPlay',

    /**
     * Notifies the video element to play.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video to play (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#PLAY_VIDEO_ELEMENT
     * @private
     */
    PLAY_VIDEO_ELEMENT: 'playVideoElement',

    /**
     * The video element has been initialized and deferred command to play is unblocked
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that is will be played (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_CAN_PLAY
     * @public
     */
    VC_CAN_PLAY: 'videoCanPlay',

    /**
     * The video element has detected a command to play and will begin playback.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video to seek (as defined by the module that controls it).</li>
     *   <li>The url of the video that will play.</li>
     * </ul>
     * @event OO.EVENTS#VC_WILL_PLAY
     * @public
     */
    VC_WILL_PLAY: 'videoWillPlay',

    /**
     * The video element has detected playback in progress.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that is playing (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_PLAYING
     * @public
     */
    VC_PLAYING: 'videoPlaying',

    /**
     * The video element has detected playback completion.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that has played (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_PLAYED
     * @public
     */
    VC_PLAYED: 'videoPlayed',

    /**
     * The video element has detected playback failure.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that has played (as defined by the module that controls it).</li>
     *   <li>The error code of the failure (string).</li>
     * </ul>
     * @event OO.EVENTS#VC_PLAY_FAILED
     * @public
     */
    VC_PLAY_FAILED: 'videoPlayFailed',

    /**
     * Commands the video element to pause.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video to pause (as defined by the module that controls it).</li>
     *   <li>Optional string indicating the reason for the pause.  Supported values include:
     *     <ul>
     *       <li>'transition' indicates that a pause was triggered because a video is going into or out of focus.</li>
     *       <li>null or undefined for all other cases.</li>
     *     </ul>
     *   </li>
     * </ul>
     * @event OO.EVENTS#VC_PAUSE
     * @public
     */
    VC_PAUSE: 'videoPause',

    /**
     * The video element has detected video state change to paused.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that has paused (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_PAUSED
     * @public
     */
    VC_PAUSED: 'videoPaused',

    /**
     * Commands the video element to seek.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video to seek (as defined by the module that controls it).</li>
     *   <li>The time position to seek to (in seconds).</li>
     * </ul>
     * @event OO.EVENTS#VC_SEEK
     * @public
     */
    VC_SEEK: 'videoSeek',

    /**
     * The video element has detected seeking.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that is seeking (as defined by the module that controls it).</li>
     * </ul>
     * @event OO.EVENTS#VC_SEEKING
     * @public
     */
    VC_SEEKING: 'videoSeeking',

    /**
     * The video element has detected seeked.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that has seeked (as defined by the module that controls it).</li>
     *   <li>The current time of the video after seeking.</li>
     * </ul>
     * @event OO.EVENTS#VC_SEEKED
     * @public
     */
    VC_SEEKED: 'videoSeeked',

    /**
     * Commands the video element to preload.
     * @event OO.EVENTS#VC_PRELOAD
     * @public
     */
    VC_PRELOAD: 'videoPreload',

    /**
     * Commands the video element to reload.
     * @event OO.EVENTS#VC_RELOAD
     * @public
     */
    VC_RELOAD: 'videoReload',

    /**
     * Notifies the player of tags (such as ID3) encountered during video playback.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The id of the video that has paused (as defined by the module that controls it). (string)</li>
     *   <li>The type of metadata tag found, such as ID3. (string)</li>
     *   <li>The metadata. (string|object)</li>
     * </ul>
     * @event OO.EVENTS#VC_TAG_FOUND
     * @public
     */
    VC_TAG_FOUND: 'videoTagFound',

    /**
     * Initiate reload of manifest.
     * When reload will be completed
     * OO.EVENTS.PLAY will be fired.
     * @event OO.EVENTS#VC_RELOAD_AND_PLAY
     * @public
     */
    VC_RELOAD_AND_PLAY: 'vcReloadAndPlay',

    /**
     * Triggered right before reloading of manifest
     * @event OO.EVENTS#VC_WILL_RELOAD_AND_PLAY
     * @public
     */
    VC_WILL_RELOAD_AND_PLAY: 'vcWillReloadAndPlay',

    /**
     * Triggered right after reload of manifest completed.
     * @event OO.EVENTS#VC_RELOADED
     * @public
     */
    VC_RELOADED: 'vcReloaded',

    /**
     * This event is triggered when an ad sdk has been loaded successfully. the handler is called with:
     * <ul>
     *   <li>The ad plugin loaded.</li>
     * </ul>
     * @event OO.EVENTS#AD_SDK_LOADED
     */
    AD_SDK_LOADED: 'adSdkLoaded',

    /**
     * This event is triggered when there is an failure to load the ad sdk.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin that failed to load.</li>
     *   <li>The player core version.</li>
     *   <li>The error message associated with the load failure.</li>
     * </ul>
     * @event OO.EVENTS#AD_SDK_LOAD_FAILED
    */
    AD_SDK_LOAD_FAILED: 'adSdkLoadFailed',

    /**
     * This event is triggered whenever an ad is requested.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time the ad was scheduled to play.</li>
     * </ul>
     * @event OO.EVENTS#AD_REQUEST
     */
    AD_REQUEST: 'adRequest',

    /**
     * This event is triggered upon receiving a successful response for an ad request.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time the ad was scheduled to play.</li>
     *   <li>The ad request response time.</li>
     *   <li>Time from initial play to ad request success</li>
     * </ul>
     * @event OO.EVENTS#AD_REQUEST_SUCCESS
     */
    AD_REQUEST_SUCCESS: 'adRequestSuccess',

    /**
     * This event is triggered upon receiving an error for an ad request.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time the ad was scheduled to play.</li>
     *   <li>The final ad tag after macro substitution</li>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     *   <li>If there was a request timeout or not.</li>
     * </ul>
     * @event OO.EVENTS#AD_REQUEST_ERROR
     */
    AD_REQUEST_ERROR: 'adRequestError',

    /**
     * This event is triggered upon receiving an empty response for an ad request.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time the ad was scheduled to play.</li>
     *   <li>The final ad tag after macro substitution</li>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     * </ul>
     * @event OO.EVENTS#AD_REQUEST_EMPTY
     */
    AD_REQUEST_EMPTY: 'adRequestEmpty',

    /**
     * This event is triggered upon when an error occurs trying to play an ad.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time/position the ad was scheduled to play.</li>
     *   <li>The final ad tag url after macro substitution</li>
     *   <li>The error code.</li>
     *   <li>The error message.</li>
     *   <li>The list of all video plugins.</li>
     *   <li>The media file URL.</li>
     * </ul>
     * @event OO.EVENTS#AD_PLAYBACK_ERROR
     */
    AD_PLAYBACK_ERROR: 'adPlaybackError',

    /**
     * This event is triggered when the ad plugin sdk records an impression event.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time the ad was scheduled to play.</li>
     *   <li>The ad load time - time between ad request success and first frame started.</li>
     *   <li>The ad protocol: VAST or VPAID.</li>
     *   <li>The ad type: linearVideo, linearOverlay, nonLinearVideo, nonLinearOverlay.</li>
     * </ul>
     * @event OO.EVENTS#AD_SDK_IMPRESSION
     */
    AD_SDK_IMPRESSION: 'adSdkImpression',

    /**
     * This event is triggered when an ad has completed playback.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad plugin.</li>
     *   <li>The time passed since the ad impression.</li>
     *   <li>If the ad was skipped or not.</li>
     * </ul>
     * @event OO.EVENTS#AD_COMPLETED
     */
    AD_COMPLETED: 'adCompleted',

    /**
     * This event is triggered when the ad manager has received an ad timeline for SSAI ads.
     * The handler is called with the following arguments:
     * <ul>
     *   <li>The ad timeline.</li>
     * </ul>
     * @event OO.EVENTS#SSAI_AD_TIMELINE_RECEIVED
     */
    SSAI_AD_TIMELINE_RECEIVED: 'adTimelineReceived',

    /**
     * This event is triggered if the ad manager controller has been notified that
     * an ssai ad break has started
     * @event OO.EVENTS#SSAI_PLAY_SINGLE_AD
     * @public
     */
    SSAI_PLAY_SINGLE_AD: 'ssaiPlaySingleAd',

    /**
     * This event is triggered if the ad manager controller has been notified that
     * an ssai ad break has ended
     * @event OO.EVENTS#SSAI_SINGLE_AD_PLAYED
     * @public
     */
    SSAI_SINGLE_AD_PLAYED: 'ssaiSingleAdPlayed',
    WILL_FETCH_ADS: 'willFetchAds',
    DISABLE_SEEKING: 'disableSeeking',
    ENABLE_SEEKING: 'enableSeeking',

    /**
     * This event is triggered before an ad is played. Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The duration of the ad.</li>
     *     <li>The ID of the ad.</li>
     *   </ul>
     *
     *
     * <h5>Analytics:</h5>
     * <p style='text-indent: 1em;'Triggers an <b>Ad Analytics</b> <code>AD_IMPRESSION</code> event.</p>
     *
     * @event OO.EVENTS#WILL_PLAY_ADS
     * @public
     */
    WILL_PLAY_ADS: 'willPlayAds',
    WILL_PLAY_SINGLE_AD: 'willPlaySingleAd',
    WILL_PAUSE_ADS: 'willPauseAds',
    WILL_RESUME_ADS: 'willResumeAds',

    /**
     * This event is triggered to indicate that a non-linear ad will be played.  The handler is called with:
     *   <ul>
     *     <li>An object representing the ad.  For a definition, see class 'Ad' from the ad manager framework.</li>
     *   </ul>
     *
     * @event OO.EVENTS#WILL_PLAY_NONLINEAR_AD
     */
    WILL_PLAY_NONLINEAR_AD: 'willPlayNonlinearAd',

    /**
     * A non-linear ad will play now.  The handler is called with:
     *   <ul>
     *     <li>An object containing the following fields:</li>
     *     <ul>
     *       <li>ad: An object representing the ad.  For a definition, see class 'Ad' from the ad manager framework.</li>
     *       <li>url: [optional] The url of the nonlinear ad.</li>
     *     </ul>
     *   </ul>
     *
     * @event OO.EVENTS#PLAY_NONLINEAR_AD
     */
    PLAY_NONLINEAR_AD: 'playNonlinearAd',

    /**
     * A set of ads have been played. Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The duration of the ad.</li>
     *     <li>The ID of the item to play.</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#ADS_PLAYED
     * @public
     */
    ADS_PLAYED: 'adsPlayed',
    SINGLE_AD_PLAYED: 'singleAdPlayed',

    /**
     * This event is triggered when an error has occurred with an ad. <br/><br/>
     *
     *
     * @event OO.EVENTS#ADS_ERROR
     * @public
     */
    ADS_ERROR: 'adsError',

    /**
     * This event is triggered when an ad has been clicked. <br/><br/>
     *
     *
     * @event OO.EVENTS#ADS_CLICKED
     * @public
     */
    ADS_CLICKED: 'adsClicked',
    FIRST_AD_FETCHED: 'firstAdFetched',
    AD_CONFIG_READY: 'adConfigReady',

    /**
     * This event is triggered before the companion ads are shown.
     * Companion ads are displayed on a customer page and are not displayed in the player.
     * This event notifies the page handler to display the specified ad, and is the only means by which companion ads can appear.
     * If the page does not handle this event, companion ads will not appear.
     * Depending on the context, the handler is called with:
     *   <ul>
     *     <li>The ID of all companion ads.</li>
     *     <li>The ID of a single companion ad.</li>
     *   </ul>
     *
     *
     * <h5>Analytics:</h5>
     * <p style='text-indent: 1em;'Triggers an <b>Ad Analytics</b> <code>AD_IMPRESSION</code> event.</p>
     *
     * @event OO.EVENTS#WILL_SHOW_COMPANION_ADS
     * @public
     */
    WILL_SHOW_COMPANION_ADS: 'willShowCompanionAds',
    AD_FETCH_FAILED: 'adFetchFailed',
    MIDROLL_PLAY_FAILED: 'midrollPlayFailed',
    SKIP_AD: 'skipAd',
    UPDATE_AD_COUNTDOWN: 'updateAdCountdown',
    // this player is part of these experimental variations
    REPORT_EXPERIMENT_VARIATIONS: 'reportExperimentVariations',
    FETCH_STYLE: 'fetchStyle',
    STYLE_FETCHED: 'styleFetched',
    SET_STYLE: 'setStyle',
    USE_SERVER_SIDE_HLS_ADS: 'useServerSideHlsAds',
    LOAD_ALL_VAST_ADS: 'loadAllVastAds',
    ADS_FILTERED: 'adsFiltered',
    ADS_MANAGER_HANDLING_ADS: 'adsManagerHandlingAds',
    ADS_MANAGER_FINISHED_ADS: 'adsManagerFinishedAds',
    // This event contains the information AMC need to know to place the overlay in the correct position.
    OVERLAY_RENDERING: 'overlayRendering',

    /**
     * Event for signaling Ad Marquee rendering:
     *   <ul>
     *     <li>Boolean parameter, 'false' to not show ad marquee, 'true' to show ad marquee based on skin config</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#SHOW_AD_MARQUEE
     */
    SHOW_AD_MARQUEE: 'showAdMarquee',

    /**
     * An ad plugin will publish this event whenever the ad SDK throws an ad event. Typical ad events are
     * impressions, clicks, quartiles, etc. <br/><br/>
     *
     * @event OO.EVENTS#SDK_AD_EVENT
     * @private
     */
    SDK_AD_EVENT: 'sdkAdEvent',
    // Window published beforeUnload event. It's still user cancellable.

    /**
     * The window, document, and associated resources are being unloaded.
     * The handler is called with <code>true</code> if a page unload has been requested, <code>false</code> otherwise.
     * This event may be required since some browsers perform asynchronous page loading while the current page is still active,
     * meaning that the end user loads a page with the Ooyala player, plays an asset, then redirects the page to a new URL they have specified.
     * Some browsers will start loading the new data while still displaying the player, which will result in an error since the networking has already been reset.
     * To prevent such false errors, listen to this event and ignore any errors raised after such actions have occurred.
     * <br/><br/>
     *
     *
     * @event OO.EVENTS#PAGE_UNLOAD_REQUESTED
     * @public
     */
    PAGE_UNLOAD_REQUESTED: 'pageUnloadRequested',
    // Either 1) The page is refreshing (almost certain) or 2) The user tried to refresh
    // the page, the embedding page had an 'Are you sure?' prompt, the user clicked
    // on 'stay', and a real error was produced due to another reason during the
    // following few seconds. The real error, if any, will be received in some seconds.
    // If we are certain it has unloaded, it's too late to be useful.
    PAGE_PROBABLY_UNLOADING: 'pageProbablyUnloading',
    // DiscoveryApi publishes these, OoyalaAnalytics listens for them and propagates to reporter.js
    REPORT_DISCOVERY_IMPRESSION: 'reportDiscoveryImpression',
    REPORT_DISCOVERY_CLICK: 'reportDiscoveryClick',
    // These discovery events are propagated to the iq plugin
    DISCOVERY_API: {
      /**
       * Represents the discovery display event
       * @event OO.EVENTS.DISCOVERY_API#SEND_DISPLAY_EVENT
       * @public
      */
      SEND_DISPLAY_EVENT: 'sendDisplayEvent',

      /**
       * Represents the discovery click event
       * @event OO.EVENTS.DISCOVERY_API#SEND_CLICK_EVENT
       * @public
      */
      SEND_CLICK_EVENT: 'sendClickEvent'
    },

    /**
     * Denotes that the playlist plugin is ready and has configured the playlist Pod(s).
     * @event OO.EVENTS#PLAYLISTS_READY
     * @public
     */
    PLAYLISTS_READY: 'playlistReady',

    /**
     * The UI layer has finished its initial render. The handler is called with an object
     * of the following structure:
     *
     * <ul>
     *   <li>videoWrapperClass: The class name of the element containing the UI layer</li>
     *   <li>pluginsClass: The class name of the element into which the plugins content should be inserted</li>
     * </ul>
     *
     * If the UI layer doesn't require any special handling, the values for these two keys will be null.
     *
     * @event OO.EVENTS#UI_READY
     */
    UI_READY: 'uiReady',

    /**
     * Represents the mousemove event
     * @event OO.EVENTS#TOUCH_MOVE
     * @public
     */
    TOUCH_MOVE: 'touchMove',

    /**
     * Represents the endVrMove event
     * @event OO.EVENTS#END_VR_MOVE
     * @public
     */
    END_VR_MOVE: 'endVrMove',

    /**
     * Represents the mouseUp event
     * @event OO.EVENTS#CHECK_VR_DIRECTION
     * @public
     */
    CHECK_VR_DIRECTION: 'checkVrDirection',

    /**
     * Represents a change in the direction of movement of the camera
     * @event OO.EVENTS#VR_DIRECTION_CHANGED
     * @public
     */
    VR_DIRECTION_CHANGED: 'vrDirectionChanged',

    /**
     * Says that a video type in playlist was updated
     * @event OO.EVENTS#VIDEO_TYPE_CHANGED
     * @public
     */
    VIDEO_TYPE_CHANGED: 'videoTypeChanged',

    /**
     * Says that the ability to autoplay in a browser has been verified
     * @event OO.EVENTS#SET_AUTOPLAY_STATE
     * @public
     */
    AUTOPLAY_STATE_CHECKED: 'autoplayStateChecked',

    /**
     * Triggers if asset movie attributes has ha_enabled set to 'true'(string)
     * @event OO.EVENTS#HA_ENABLED
     * @public
     */
    HA_ENABLED: 'haEnabled',

    /**
     * Triggers manual failover. As result player should reload manifest and start playing
     * @event OO.EVENTS#HA_FAILOVER_NOW
     * @public
     */
    HA_FAILOVER_NOW: 'haFailoverNow',

    /**
     * Triggers update of the config for HA Failover plugin. Takes new config as parameter
     * @event OO.EVENTS#HA_CONFIG_UPDATE
     * @private
     */
    HA_CONFIG_UPDATE: 'haConfigUpdate',

    /**
     * Use it to submit any new information about segments loading or requests.
     * Ha Plugin gathers data and based on provided data taking actions.
     * @event OO.EVENTS#HA_NOTIFY
     * @private
     */
    HA_NOTIFY: 'haNotify',

    /**
     * This events is triggered right after HA plugin got notified and processed data
     * handler parameter will be boolean, true if data valid and accepted
     * used by unit tests.
     * @event OO.EVENTS#HA_NOTIFY
     * @private
     */
    HA_NOTIFIED: 'haNotified',

    /**
     * This events is triggered right after HA config updated. Returns updated config
     * @event OO.EVENTS#HA_CONFIG_UPDATED
     * @private
     */
    HA_CONFIG_UPDATED: 'haConfigUpdated',

    /**
     * This events is triggered right before initiating failover
     * @event OO.EVENTS#HA_WILL_FAILOVER
     * @public
     */
    HA_WILL_FAILOVER: 'haWillFailover',

    /**
     * This events is triggered after failover completed successfully.
     * Usually right after OO.EVENTS.VC_WILL_PLAY
     * @event OO.EVENTS#HA_FAILOVER_COMPLETE
     * @public
     */
    HA_FAILOVER_COMPLETE: 'haFailoverComplete',

    /**
     * This events is triggered if some error happens during attempt of failover.
     * Usually right after OO.EVENTS.VC_WILL_PLAY
     * @event OO.EVENTS#HA_FAILOVER_ERROR
     * @public
     */
    HA_FAILOVER_ERROR: 'haFailoverError',

    /**
     * This event is triggered if you want to uncheck the geoblock.
     * It can be called after locks by locating or in the event of a player error
     * or the end of playback
     * @event OO.EVENTS#CANCEL_GEO_CHECKING
     * @public
     */
    CANCEL_GEO_CHECKING: 'cancelGeoChecking',

    /**
     * This event is triggered if the chromecast sdk has been downloaded and
     * set up
     * @event OO.EVENT#CHROMECAST_AVAILABLE
     * @public
     */
    CHROMECAST_AVAILABLE: 'chromecastAvailable',

    /**
     * This event is triggered if the chromecast icon has been clicked
     * @event OO.EVENT#CHROMECAST_CLICKED
     * @public
     */
    CHROMECAST_CLICKED: 'chromecastClicked',

    /**
     * This event is triggered if the player is now connected to a chromecast
     * receiver
     * @event OO.EVENT#CHROMECAST_START_CAST
     * @public
     */
    CHROMECAST_START_CAST: 'chromecastStartCast',

    /**
     * This event is triggered if the player has disconnected from a chromecast
     * receiver
     * @event OO.EVENT#CHROMECAST_END_CAST
     * @public
     */
    CHROMECAST_END_CAST: 'chromecastEndCast',

    /**
     * This event contains informaton about possible markers on the asset. The handler will be called with:
     *   <ul>
     *     <li>A JSON object that represents a series or markers</li>
     *   </ul>
     *
     *
     * @event OO.EVENTS#MARKER_DATA_AVAILABLE
     * @public
     */
    MARKER_DATA_AVAILABLE: 'markerDataAvailable',

    /**
     * Airplay related events
     */
    AIRPLAY: {
      /**
       * This event is triggered if airplay button has been clicked
       * Could be published to display airplay target picker
       * @event OO.EVENTS.AIRPLAY#BUTTON_CLICKED
       * @public
       */
      BUTTON_CLICKED: 'airplayButtonClicked',

      /**
       * This event is triggered if page was reloaded during airplay casting
       * @event OO.EVENTS.AIRPLAY#SESSION_RESUMED
       * @public
       */
      SESSION_RESUMED: 'airplaySessionResumed',

      /**
       * This event is triggered if Airplay availability changes
       * @event OO.EVENT.AIRPLAY#AVAILABILITY_CHANGED
       * @public
       */
      AVAILABILITY_CHANGED: 'airplayAvailabilityChanged',

      /**
       * This event is triggered when a media element starts or stops AirPlay playback
       * @event OO.EVENT.AIRPLAY#CONNECTED_CHANGED
       * @public
       */
      CONNECTION_CHANGED: 'airplayPlaybackTargetChanged'
    },
    __end_marker: true
  };
  /**
   * @description Represents the Ooyala V4 Player Errors. Use message bus events to handle errors by subscribing to the <code>OO.EVENTS.ERROR</code> event.
   * For more information, see <a href='http://support.ooyala.com/developers/documentation/concepts/errors_overview.html' target='target'>Errors and Error Handling Overview</a>.
   * @summary Represents the Ooyala V4 Player Errors.
   * @namespace OO.ERROR
   * @public
   */

  OO.ERROR = {
    /**
    * @description Represents the <code>OO.ERROR.API</code> Ooyala V4 Player Errors. Use message bus events to handle errors by subscribing to the <code>OO.EVENTS.ERROR</code> event.
    * For more information, see <a href='http://support.ooyala.com/developers/documentation/concepts/errors_overview.html' target='target'>Errors and Error Handling Overview</a>.
    * @summary Represents the <code>OO.ERROR.API</code> Ooyala V4 Player Errors.
    * @namespace OO.ERROR.API
    * @public
    */
    API: {
      /**
      * @description <code>OO.ERROR.API.NETWORK ('network')</code>: Cannot contact the server.
      * @constant OO.ERROR.API.NETWORK
      * @type {string}
      * @public
      */
      NETWORK: 'network',

      /**
       * @description Represents the <code>OO.ERROR.API.SAS</code> Ooyala V4 Player Errors for the Stream Authorization Server.
       * Use message bus events to handle errors by subscribing to the <code>OO.EVENTS.ERROR</code> event.
       * For more information, see <a href='http://support.ooyala.com/developers/documentation/concepts/errors_overview.html' target='target'>Errors and Error Handling Overview</a>.
       * @summary Represents the <code>OO.ERROR.API.SAS</code> Ooyala V4 Player Errors.
       * @namespace OO.ERROR.API.SAS
       * @public
       */
      SAS: {
        /**
        * @description <code>OO.ERROR.API.SAS.GENERIC ('sas')</code>: Invalid authorization response.
        * @constant OO.ERROR.API.SAS.GENERIC
        * @type {string}
        * @public
        */
        GENERIC: 'sas',

        /**
         * @description <code>OO.ERROR.API.SAS.GEO ('geo')</code>: This video is not authorized for your location.
         * @constant OO.ERROR.API.SAS.GEO
         * @type {string}
         * @public
         */
        GEO: 'geo',

        /**
         * @description <code>OO.ERROR.API.SAS.DOMAIN ('domain')</code>: This video is not authorized for your domain.
         * @constant OO.ERROR.API.SAS.DOMAIN
         * @type {string}
         * @public
         */
        DOMAIN: 'domain',

        /**
         * @description <code>OO.ERROR.API.SAS.FUTURE ('future')</code>: This video will be available soon.
         * @constant OO.ERROR.API.SAS.FUTURE
         * @type {string}
         * @public
         */
        FUTURE: 'future',

        /**
         * @description <code>OO.ERROR.API.SAS.PAST ('past')</code>: This video is no longer available.
         * @constant OO.ERROR.API.SAS.PAST
         * @type {string}
         * @public
         */
        PAST: 'past',

        /**
         * @description <code>OO.ERROR.API.SAS.DEVICE ('device')</code>: This video is not authorized for playback on this device.
         * @constant OO.ERROR.API.SAS.DEVICE
         * @type {string}
         * @public
         */
        DEVICE: 'device',

        /**
         * @description <code>OO.ERROR.API.SAS.PROXY ('proxy')</code>: An anonymous proxy was detected. Please disable the proxy and retry.
         * @constant OO.ERROR.API.SAS.PROXY
         * @type {string}
         * @public
         */
        PROXY: 'proxy',

        /**
         * @description <code>OO.ERROR.API.SAS.CONCURRENT_STREAM ('concurrent_streams')S</code>: You have exceeded the maximum number of concurrent streams.
         * @constant OO.ERROR.API.SAS.CONCURRENT_STREAMS
         * @type {string}
         * @public
         */
        CONCURRENT_STREAMS: 'concurrent_streams',

        /**
         * @description <code>OO.ERROR.API.SAS.INVALID_HEARTBEAT ('invalid_heartbeat')</code>: Invalid heartbeat response.
         * @constant OO.ERROR.API.SAS.INVALID_HEARTBEAT
         * @type {string}
         * @public
         */
        INVALID_HEARTBEAT: 'invalid_heartbeat',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_DEVICE_INVALID_AUTH_TOKEN ('device_invalid_auth_token')</code>: Invalid Ooyala Player token.
         * @constant OO.ERROR.API.SAS.ERROR_DEVICE_INVALID_AUTH_TOKEN
         * @type {string}
         * @public
         */
        ERROR_DEVICE_INVALID_AUTH_TOKEN: 'device_invalid_auth_token',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_DEVICE_LIMIT_REACHED ('device_limit_reached')</code>: The device limit has been reached.
         * The device limit is the maximum number of devices that can be registered with the viewer.
         * When the maximum number of devices for an entitlement has been reached this error is displayed
         * @constant OO.ERROR.API.SAS.ERROR_DEVICE_LIMIT_REACHED
         * @type {string}
         * @public
         */
        ERROR_DEVICE_LIMIT_REACHED: 'device_limit_reached',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_NON_REGISTERED_DEVICE ('non_registered_device')</code>:
         * The device limit is the maximum number of devices that can be registered with the viewer.
         * when the device not registered to viewer account this error is displayed
         * The account_id has reached its maximum number of devices.
         * @constant OO.ERROR.API.SAS.ERROR_NON_REGISTERED_DEVICE
         * @type {string}
         * @public
         */
        ERROR_NON_REGISTERED_DEVICE: 'non_registered_device',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_DEVICE_BINDING_FAILED ('device_binding_failed')</code>: Device binding failed.
         * If the number of devices registered is already equal to the number of devices that may be bound for the account,
         * attempting to register a new device will result in this error.
         * @constant OO.ERROR.API.SAS.ERROR_DEVICE_BINDING_FAILED
         * @type {string}
         * @public
         */
        ERROR_DEVICE_BINDING_FAILED: 'device_binding_failed',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_DEVICE_ID_TOO_LONG ('device_id_too_long')</code>: The device ID is too long.
         * The length limit for the device ID is 1000 characters.
         * @constant OO.ERROR.API.SAS.ERROR_DEVICE_ID_TOO_LONG
         * @type {string}
         * @public
         */
        ERROR_DEVICE_ID_TOO_LONG: 'device_id_too_long',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_DRM_RIGHTS_SERVER_ERROR ('drm_server_error')</code>: DRM server error.
         * @constant OO.ERROR.API.SAS.ERROR_DRM_RIGHTS_SERVER_ERROR
         * @type {string}
         * @public
         */
        ERROR_DRM_RIGHTS_SERVER_ERROR: 'drm_server_error',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_DRM_GENERAL_FAILURE ('drm_general_failure')</code>: General error with acquiring license.
         * @constant OO.ERROR.API.SAS.ERROR_DRM_GENERAL_FAILURE
         * @type {string}
         * @public
         */
        ERROR_DRM_GENERAL_FAILURE: 'drm_general_failure',

        /**
         * @description <code>OO.ERROR.API.SAS.ERROR_INVALID_ENTITLEMENTS ('invalid_entitlements')</code>: User Entitlement Terminated - Stream No Longer Active for the User.
         * @constant OO.ERROR.API.SAS.ERROR_INVALID_ENTITLEMENTS
         * @type {string}
         * @public
         */
        ERROR_INVALID_ENTITLEMENTS: 'invalid_entitlements'
      },

      /**
      * @description <code>OO.ERROR.API.CONTENT_TREE ('content_tree')</code>: Invalid Content.
      * @constant OO.ERROR.API.CONTENT_TREE
      * @type {string}
      * @public
      */
      CONTENT_TREE: 'content_tree',

      /**
      * @description <code>OO.ERROR.API.METADATA ('metadata')</code>: Invalid Metadata.
      * @constant OO.ERROR.API.METADATA
      * @type {string}
      * @public
      */
      METADATA: 'metadata'
    },

    /**
    * @description Represents the <code>OO.ERROR.PLAYBACK</code> Ooyala V4 Player Errors. Use message bus events to handle errors by subscribing to the <code>OO.EVENTS.ERROR</code> event.
    * For more information, see <a href='http://support.ooyala.com/developers/documentation/concepts/errors_overview.html' target='target'>Errors and Error Handling Overview</a>.
    * @summary Represents the <code>OO.ERROR.PLAYBACK</code> Ooyala V4 Player Errors.
    * @namespace OO.ERROR.PLAYBACK
    * @public
    */
    PLAYBACK: {
      /**
      * @description <code>OO.ERROR.PLAYBACK.GENERIC ('playback')</code>: Could not play the content.
      * @constant OO.ERROR.PLAYBACK.GENERIC
      * @type {string}
      * @public
      */
      GENERIC: 'playback',

      /**
       * @description <code>OO.ERROR.PLAYBACK.STREAM ('stream')</code>: This video is not encoded for your device.
       * @constant OO.ERROR.PLAYBACK.STREAM
       * @type {string}
       * @public
       */
      STREAM: 'stream',

      /**
       * @description <code>OO.ERROR.PLAYBACK.LIVESTREAM ('livestream')</code>: Live stream is off air.
       * @constant OO.ERROR.PLAYBACK.LIVESTREAM
       * @type {string}
       * @public
       */
      LIVESTREAM: 'livestream',

      /**
       * @description <code>OO.ERROR.PLAYBACK.NETWORK ('network_error')</code>: The network connection was temporarily lost.
       * @constant OO.ERROR.PLAYBACK.NETWORK
       * @type {string}
       * @public
       */
      NETWORK: 'network_error'
    },
    CHROMECAST: {
      MANIFEST: 'chromecast_manifest',
      MEDIAKEYS: 'chromecast_mediakeys',
      NETWORK: 'chromecast_network',
      PLAYBACK: 'chromecast_playback'
    },

    /**
    * @description <code>OO.ERROR.UNPLAYABLE_CONTENT ('unplayable_content')</code>: This video is not playable on this player.
    * @constant OO.ERROR.UNPLAYABLE_CONTENT
    * @type {string}
    * @public
    */
    UNPLAYABLE_CONTENT: 'unplayable_content',

    /**
    * @description <code>OO.ERROR.INVALID_EXTERNAL_ID ('invalid_external_id')</code>: Invalid External ID.
    * @constant OO.ERROR.INVALID_EXTERNAL_ID
    * @type {string}
    * @public
    */
    INVALID_EXTERNAL_ID: 'invalid_external_id',

    /**
     * @description <code>OO.ERROR.EMPTY_CHANNEL ('empty_channel')</code>: This channel is empty.
     * @constant OO.ERROR.EMPTY_CHANNEL
     * @type {string}
     * @public
     */
    EMPTY_CHANNEL: 'empty_channel',

    /**
     * @description <code>OO.ERROR.EMPTY_CHANNEL_SET ('empty_channel_set')</code>: This channel set is empty.
     * @constant OO.ERROR.EMPTY_CHANNEL_SET
     * @type {string}
     * @public
     */
    EMPTY_CHANNEL_SET: 'empty_channel_set',

    /**
     * @description <code>OO.ERROR.CHANNEL_CONTENT ('channel_content')</code>: This channel is not playable at this time.
     * @constant OO.ERROR.CHANNEL_CONTENT
     * @type {string}
     * @public
     */
    CHANNEL_CONTENT: 'channel_content',

    /**
     * @description Represents the <code>OO.ERROR.VC</code> Ooyala V4 Player Errors for the Video Technology stack.
     * Use message bus events to handle errors by subscribing to the <code>OO.EVENTS.ERROR</code> event.
         * For more information, see <a href='http://support.ooyala.com/developers/documentation/concepts/errors_overview.html' target='target'>Errors and Error Handling Overview</a>.
         * @summary Represents the <code>OO.ERROR.VC</code> Ooyala V4 Player Errors.
     * @namespace OO.ERROR.VC
     */
    VC: {
      /**
      * @description <code>OO.ERROR.VC.UNSUPPORTED_ENCODING ('unsupported_encoding')</code>:
      *    This device does not have an available decoder for this stream type.
      * @constant OO.ERROR.VC.UNSUPPORTED_ENCODING
      * @type {string}
      */
      UNSUPPORTED_ENCODING: 'unsupported_encoding',

      /**
      * @description <code>OO.ERROR.VC.UNABLE_TO_CREATE_VIDEO_ELEMENT ('unable_to_create_video_element')</code>:
      *    A video element to play the given stream could not be created.
      * @constant OO.ERROR.VC.UNABLE_TO_CREATE_VIDEO_ELEMENT
      * @type {string}
      */
      UNABLE_TO_CREATE_VIDEO_ELEMENT: 'unable_to_create_video_element'
    },

    /**
     * @namespace OO.ERROR.MULTIAUDIO
     */
    MULTIAUDIO: {
      /**
       * @description <code>OO.ERROR.VC.MULTIAUDIO_UNSUPPORTED_ENCODING ('multiaudio_unsupported_encoding')</code>:
       * This stream type is not supported for multiaudio.
       * @constant OO.ERROR.MULTIAUDIO.UNSUPPORTED_ENCODING
       * @type {string}
       */
      UNSUPPORTED_ENCODING: 'multiaudio_unsupported_encoding'
    },

    /**
     * @namespace OO.ERROR.MEDIA
     */
    MEDIA: {
      /**
       * @description <code>OO.ERROR.MEDIA.MEDIA_ERR_ABORTED ('aborted')</code>:
       * The fetching of the associated resource was aborted by the user's request.
       * @constant OO.ERROR.MEDIA.MEDIA_ERR_ABORTED
       * @type {string}
       */
      MEDIA_ERR_ABORTED: 'aborted',

      /**
       * @description <code>OO.ERROR.MEDIA.MEDIA_ERR_NETWORK ('aborted')</code>:
       * Some kind of network error occurred which prevented the media from being
       * successfully fetched, despite having previously been available.
       * @constant OO.ERROR.MEDIA.MEDIA_ERR_NETWORK
       * @type {string}
       */
      MEDIA_ERR_NETWORK: 'network_error',

      /**
       * @description <code>OO.ERROR.MEDIA.MEDIA_ERR_DECODE ('aborted')</code>:
       * Despite having previously been determined to be usable, an error occurred
       * while trying to decode the media resource, resulting in an error.
       * @constant OO.ERROR.MEDIA.MEDIA_ERR_DECODE
       * @type {string}
       */
      MEDIA_ERR_DECODE: 'decode_error',

      /**
       * @description <code>OO.ERROR.MEDIA.MEDIA_ERR_SRC_NOT_SUPPORTED ('aborted')</code>:
       * The associated resource or media provider object has been found to be unsuitable.
       * @constant OO.ERROR.MEDIA.MEDIA_ERR_SRC_NOT_SUPPORTED
       * @type {string}
       */
      MEDIA_ERR_SRC_NOT_SUPPORTED: 'unsupported_source'
    }
  }; // All Server-side URLS

  OO.URLS = {
    VAST_PROXY: _.template('http://player.ooyala.com/nuplayer/mobile_vast_ads_proxy' + '?callback=<%=cb%>&embed_code=<%=embedCode%>&expires=<%=expires%>&tag_url=<%=tagUrl%>'),
    EXTERNAL_ID: _.template('<%=server%>/player_api/v1/content_tree/external_id/<%=pcode%>/<%=externalId%>'),
    CONTENT_TREE: _.template('<%=server%>/player_api/v1/content_tree/embed_code/<%=pcode%>/<%=embedCode%>'),
    METADATA: _.template('<%=server%>/player_api/v1/metadata/embed_code/' + '<%=playerBrandingId%>/<%=embedCode%>?videoPcode=<%=pcode%>'),
    EMBED_CODE_METADATA: _.template('<%=server%>/player_api/v1/metadata/embed_code/' + 'xxx/<%=embedCode%>?videoPcode=<%=pcode%>'),
    SAS: _.template('<%=server%>/player_api/v2/authorization/embed_code/<%=pcode%>/<%=embedCode%>'),
    ANALYTICS: _.template('<%=server%>/reporter.js'),
    THUMBNAILS: _.template('<%=server%>/api/v1/thumbnail_images/<%=embedCode%>'),
    GEO_BLOCKING: _.template('<%=server%>/player_api/v2/mid_stream_check/' + '<%=pcode%>/<%=embedCode%>/<%=authToken%>'),
    __end_marker: true
  };
  /**
   * Defines all the possible tracking levels for analytics.
   * @private
   */

  OO.TRACKING_LEVEL = {
    /**
     * Default tracking level. Full tracking enabled.
     * @private
     */
    DEFAULT: 'default',

    /**
     * Anonymous mode. Tracking is enabled but a new GUID is created for each session.
     * GUID not saved in local storage.
     * @private
     */
    ANONYMOUS: 'anonymous',

    /**
     * Tracking completely disabled. IQ, Librato and Analytics plugins are not loaded.
     * GUID not saved in local storage.
     * @private
     */
    DISABLED: 'disabled'
  };
  /**
   * Defines the names that are used when registering these modules using
   * either OO.plugin() or OO.registerModule().
   * Note that this is not a comprehensive list of all the existing modules.
   * These are mostly used for matching modules to exclude during player creation.
   * @private
   */

  OO.MODULE_NAMES = {
    OOYALA_ANALYTICS: 'ooyala_analytics',
    ANALYTICS_FRAMEWORK_TRANSLATOR: 'AnalyticsFrameworkTranslator',
    LIBRATO: 'Librato'
  };
  /**
   * Defines the list of module ids (names) that belong to modules that track
   * user data. These modules are prevented from loading when OO.trackingLevel
   * is set to 'disabled'.
   * @private
   */

  OO.TRACKING_MODULES = [OO.MODULE_NAMES.OOYALA_ANALYTICS, OO.MODULE_NAMES.ANALYTICS_FRAMEWORK_TRANSLATOR, OO.MODULE_NAMES.LIBRATO];
  OO.PLUGINS = {
    ADS: 'ads',
    VIDEO: 'video',
    ANALYTICS: 'analytics',
    PLAYLIST: 'playlist',
    SKIN: 'skin',
    PLAYLISTS_PLUGIN: 'playlistsPlugin'
  };
  OO.PAGE_LEVEL_PARAMS = {
    USE_FIRST_VIDEO_FROM_PLAYLIST: 'useFirstVideoFromPlaylist'
  };
  OO.VIDEO = {
    MAIN: 'main',
    RELOAD: 'reload',
    ADS: 'ads',

    /**
     * @description Represents the <code>OO.VIDEO.ENCODING</code> encoding types.
     * @summary Represents the <code>OO.VIDEO.ENCODING</code> encoding types.
     * @namespace OO.VIDEO.ENCODING
     */
    ENCODING: {
      /**
       * @description Represents DRM support for the encoding types.
       * @summary Represents the <code>OO.VIDEO.ENCODING.DRM</code> encoding types.
       * @namespace OO.VIDEO.ENCODING.DRM
       */
      DRM: {
        /**
         * @description <code>OO.VIDEO.ENCODING.DRM.HLS ('hls_drm')</code>:
         *   An encoding type for drm HLS streams.
         * @constant OO.VIDEO.ENCODING.DRM.HLS
         * @type {string}
         */
        HLS: 'hls_drm',

        /**
         * @description <code>OO.VIDEO.ENCODING.DRM.DASH ('dash_drm')</code>:
         *   An encoding type for drm dash streams.
         * @constant OO.VIDEO.ENCODING.DRM.DASH
         * @type {string}
         */
        DASH: 'dash_drm'
      },

      /**
       * @description <code>OO.VIDEO.ENCODING.AUDIO ('audio')</code>:
       *   An encoding type for non-drm audio streams.
       * @constant OO.VIDEO.ENCODING.AUDIO
       * @type {string}
       */
      AUDIO: 'audio',

      /**
       * @description <code>OO.VIDEO.ENCODING.AUDIO_OGG ('audio_ogg')</code>:
       *   An encoding type for non-drm ogg audio streams.
       * @constant OO.VIDEO.ENCODING.AUDIO_OGG
       * @type {string}
       */
      AUDIO_OGG: 'audio_ogg',

      /**
       * @description <code>OO.VIDEO.ENCODING.AUDIO_M4A ('audio_m4a')</code>:
       *   An encoding type for non-drm m4a audio streams.
       * @constant OO.VIDEO.ENCODING.AUDIO_M4A
       * @type {string}
       */
      AUDIO_M4A: 'audio_m4a',

      /**
       * @description <code>OO.VIDEO.ENCODING.AUDIO_HLS ('audio_hls')</code>:
       *   An encoding type for non-drm audio only HLS streams.
       * @constant OO.VIDEO.ENCODING.AUDIO_HLS
       * @type {string}
       */
      AUDIO_HLS: 'audio_hls',

      /**
       * @description <code>OO.VIDEO.ENCODING.DASH ('dash')</code>:
       *   An encoding type for non-drm dash streams (mpd extension).
       * @constant OO.VIDEO.ENCODING.DASH
       * @type {string}
       */
      DASH: 'dash',

      /**
       * @description <code>OO.VIDEO.ENCODING.HDS ('hds')</code>:
       *   An encoding type for non-drm hds streams (hds extension).
       * @constant OO.VIDEO.ENCODING.HDS
       * @type {string}
       */
      HDS: 'hds',

      /**
       * @description <code>OO.VIDEO.ENCODING.HLS ('hls')</code>:
       *   An encoding type for non-drm HLS streams (m3u8 extension).
       * @constant OO.VIDEO.ENCODING.HLS
       * @type {string}
       */
      HLS: 'hls',

      /**
       * @description <code>OO.VIDEO.ENCODING.IMA ('ima')</code>:
       *   A string that represents a video stream that is controlled and configured directly by IMA.
       * @constant OO.VIDEO.ENCODING.IMA
       * @type {string}
       */
      IMA: 'ima',

      /**
       * @description <code>OO.VIDEO.ENCODING.PULSE ('pulse')</code>:
       *   A string that represents a video stream that is controlled and configured directly by Pulse.
       * @constant OO.VIDEO.ENCODING.PULSE
       * @type {string}
       */
      PULSE: 'pulse',

      /**
       * @description <code>OO.VIDEO.ENCODING.MP4 ('mp4')</code>:
       *   An encoding type for non-drm mp4 streams (mp4 extension).
       * @constant OO.VIDEO.ENCODING.MP4
       * @type {string}
       */
      MP4: 'mp4',

      /**
       * @description <code>OO.VIDEO.ENCODING.YOUTUBE ('youtube')</code>:
       *   An encoding type for non-drm youtube streams.
       * @constant OO.VIDEO.ENCODING.YOUTUBE
       * @type {string}
       */
      YOUTUBE: 'youtube',

      /**
       * @description <code>OO.VIDEO.ENCODING.RTMP ('rtmp')</code>:
       *   An encoding type for non-drm rtmp streams.
       * @constant OO.VIDEO.ENCODING.RTMP
       * @type {string}
       */
      RTMP: 'rtmp',

      /**
       * @description <code>OO.VIDEO.ENCODING.SMOOTH ('smooth')</code>:
       *   An encoding type for non-drm smooth streams.
       * @constant OO.VIDEO.ENCODING.SMOOTH
       * @type {string}
       */
      SMOOTH: 'smooth',

      /**
       * @description <code>OO.VIDEO.ENCODING.WEBM ('webm')</code>:
       *   An encoding type for non-drm webm streams (webm extension).
       * @constant OO.VIDEO.ENCODING.WEBM
       * @type {string}
       */
      WEBM: 'webm',

      /**
       * @description <code>OO.VIDEO.ENCODING.AKAMAI_HD_VOD ('akamai_hd_vod')</code>:
       *   An encoding type for akamai hd vod streams.
       * @constant OO.VIDEO.ENCODING.AKAMAI_HD_VOD
       * @type {string}
       */
      AKAMAI_HD_VOD: 'akamai_hd_vod',

      /**
       * @description <code>OO.VIDEO.ENCODING.AKAMAI_HD2_VOD_HLS ('akamai_hd2_vod_hls')</code>:
       *   An encoding type for akamai hd2 vod hls streams.
       * @constant OO.VIDEO.ENCODING.AKAMAI_HD2_VOD_HLS
       * @type {string}
       */
      AKAMAI_HD2_VOD_HLS: 'akamai_hd2_vod_hls',

      /**
       * @description <code>OO.VIDEO.ENCODING.AKAMAI_HD2_VOD_HDS ('akamai_hd2_vod_hds')</code>:
       *   An encoding type for akamai hd2 vod hds streams.
       * @constant OO.VIDEO.ENCODING.AKAMAI_HD2_VOD_HDS
       * @type {string}
       */
      AKAMAI_HD2_VOD_HDS: 'akamai_hd2_vod_hds',

      /**
       * @description <code>OO.VIDEO.ENCODING.AKAMAI_HD2_HDS ('akamai_hd2_hds')</code>:
       *   An encoding type for akamai hd2 live/remote hds streams.
       * @constant OO.VIDEO.ENCODING.AKAMAI_HD2_HDS
       * @type {string}
       */
      AKAMAI_HD2_HDS: 'akamai_hd2_hds',

      /**
       * @description <code>OO.VIDEO.ENCODING.AKAMAI_HD2_HLS ('akamai_hd2_hls')</code>:
       *   An encoding type for akamai hd2 live hls streams.
       * @constant OO.VIDEO.ENCODING.AKAMAI_HD2_HLS
       * @type {string}
       */
      AKAMAI_HD2_HLS: 'akamai_hd2_hls',

      /**
       * @description <code>OO.VIDEO.ENCODING.FAXS_HLS ('faxs_hls')</code>:
       *   An encoding type for adobe faxs streams.
       * @constant OO.VIDEO.ENCODING.FAXS_HLS
       * @type {string}
       */
      FAXS_HLS: 'faxs_hls',

      /**
       * @description <code>OO.VIDEO.ENCODING.WIDEVINE_HLS ('wv_hls')</code>:
       *   An encoding type for widevine hls streams.
       * @constant OO.VIDEO.ENCODING.WIDEVINE_HLS
       * @type {string}
       */
      WIDEVINE_HLS: 'wv_hls',

      /**
       * @description <code>OO.VIDEO.ENCODING.WIDEVINE_MP4 ('wv_mp4')</code>:
       *   An encoding type for widevine mp4 streams.
       * @constant OO.VIDEO.ENCODING.WIDEVINE_MP4
       * @type {string}
       */
      WIDEVINE_MP4: 'wv_mp4',

      /**
       * @description <code>OO.VIDEO.ENCODING.WIDEVINE_WVM ('wv_wvm')</code>:
       *   An encoding type for widevine wvm streams.
       * @constant OO.VIDEO.ENCODING.WIDEVINE_WVM
       * @type {string}
       */
      WIDEVINE_WVM: 'wv_wvm',

      /**
       * @description <code>OO.VIDEO.ENCODING.UNKNOWN ('unknown')</code>:
       *   An encoding type for unknown streams.
       * @constant OO.VIDEO.ENCODING.UNKNOWN
       * @type {string}
       */
      UNKNOWN: 'unknown'
    },

    /**
     * @description Represents the <code>OO.VIDEO.FEATURE</code> feature list. Used to denote which
     * features are supported by a video player.
     * @summary Represents the <code>OO.VIDEO.FEATURE</code> feature list.
     * @namespace OO.VIDEO.FEATURE
     */
    FEATURE: {
      /**
       * @description <code>OO.VIDEO.FEATURE.CLOSED_CAPTIONS ('closedCaptions')</code>:
       *   Closed captions parsed by the video element and sent to the player.
       * @constant OO.VIDEO.FEATURE.CLOSED_CAPTIONS
       * @type {string}
       */
      CLOSED_CAPTIONS: 'closedCaptions',

      /**
       * @description <code>OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_GIVE ('videoObjectSharingGive')</code>:
       *   The video object is accessible and can be found by the player via the DOM element id.  Other
       *   modules can use this video object if required.
       * @constant OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_GIVE
       * @type {string}
       */
      VIDEO_OBJECT_SHARING_GIVE: 'videoObjectSharingGive',

      /**
       * @description <code>OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_TAKE ('videoObjectSharingTake')</code>:
       *   The video object used can be created external from this video plugin.  This plugin will use the
       *   existing video element as its own.
       * @constant OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_TAKE
       * @type {string}
       */
      VIDEO_OBJECT_SHARING_TAKE: 'videoObjectSharingTake',

      /**
       * @description <code>OO.VIDEO.FEATURE.BITRATE_CONTROL ('bitrateControl')</code>:
       *   The video object allows the playing bitrate to be selected via the SET_TARGET_BITRATE event.
       *   The video controller must publish BITRATE_INFO_AVAILABLE with a list of bitrate objects that can be selected.
       *   The video controller must publish BITRATE_CHANGED events with the bitrate object that was switched to.
       *   A bitrate object should at minimum contain height, width, and bitrate properties. Height and width
       *   should be the vertical and horizontal resoluton of the stream and bitrate should be in bits per second.
       * @constant OO.VIDEO.FEATURE.BITRATE_CONTROL
       * @type {string}
       */
      BITRATE_CONTROL: 'bitrateControl'
    },

    /**
     * @description Represents the <code>OO.VIDEO.TECHNOLOGY</code> core video technology.
     * @summary Represents the <code>OO.VIDEO.TECHNOLOGY</code> core technology of the video element.
     * @namespace OO.VIDEO.TECHNOLOGY
     */
    TECHNOLOGY: {
      /**
       * @description <code>OO.VIDEO.TECHNOLOGY.FLASH ('flash')</code>:
       *   The core video technology is based on Adobe Flash.
       * @constant OO.VIDEO.TECHNOLOGY.FLASH
       * @type {string}
       */
      FLASH: 'flash',

      /**
       * @description <code>OO.VIDEO.TECHNOLOGY.HTML5 ('html5')</code>:
       *   The core video technology is based on the native html5 'video' tag.
       * @constant OO.VIDEO.TECHNOLOGY.HTML5
       * @type {string}
       */
      HTML5: 'html5',

      /**
       * @description <code>OO.VIDEO.TECHNOLOGY.MIXED ('mixed')</code>:
       *   The core video technology used may be based on any one of multiple core technologies.
       * @constant OO.VIDEO.TECHNOLOGY.MIXED
       * @type {string}
       */
      MIXED: 'mixed',

      /**
       * @description <code>OO.VIDEO.TECHNOLOGY.OTHER ('other')</code>:
       *   The video is based on a core video technology that doesn't fit into another classification
       *   found in <code>OO.VIDEO.TECHNOLOGY</code>.
       * @constant OO.VIDEO.TECHNOLOGY.OTHER
       * @type {string}
       */
      OTHER: 'other'
    }
  };
  OO.VIDEO_PLAYERS = {
    OOYALA_HTML5_VIDEO_TECH: 'ooyalaHtml5VideoTech',
    BIT_WRAPPER: 'bit-wrapper'
  };
  OO.PLAYER_VR = {
    /**
     * @description Default settings for playback video360. Can be changed by metadata
     */
    DEFAULT_SETTINGS: {
      /**
       * @description stereo mode
       * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.STEREO
       * @type {boolean}
       */
      STEREO: false,

      /**
       * @description It describes 360 video format
       * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.CONTENT_TYPE
       * @type {string}
       */
      CONTENT_TYPE: 'single',

      /**
       * @description It defines a spatial horizontal offset (angle) in degree for the first view-port displayed.
       * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.CONTENT_TYPE
       * @type {number}
       */
      START_POSITION: 0,

      /**
       * @description Represents a viewing window for VR content. The current viewing direction is restricted to the set viewing window.
       */
      VIEW_WINDOW: {
        /**
         * @description Lower bound for yaw.
         * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.VIEW_WINDOW.maxYaw
         * @type {number}
         */
        minYaw: 0,

        /**
         * @description Upper bound for yaw.
         * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.VIEW_WINDOW.maxYaw
         * @type {number}
         */
        maxYaw: 360,

        /**
         * @description Lower bound for pitch.
         * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.VIEW_WINDOW.minPitch
         * @type {number}
         */
        minPitch: -90,

        /**
         * @description Upper bound for pitch.
         * @constant OO.PLAYER_VR.DEFAULT_SETTINGS.VIEW_WINDOW.maxPitch
         * @type {number}
         */
        maxPitch: 90
      }
    }
  };
  OO.CSS = {
    VISIBLE_POSITION: '0px',
    INVISIBLE_POSITION: '-100000px',
    VISIBLE_DISPLAY: 'block',
    INVISIBLE_DISPLAY: 'none',
    VIDEO_Z_INDEX: 10000,
    SUPER_Z_INDEX: 20000,
    ALICE_SKIN_Z_INDEX: 11000,
    OVERLAY_Z_INDEX: 10500,
    TRANSPARENT_COLOR: 'rgba(255, 255, 255, 0)',
    __end_marker: true
  };
  OO.TEMPLATES = {
    RANDOM_PLACE_HOLDER: ['[place_random_number_here]', '<now>', '[timestamp]', '<rand-num>', '[cache_buster]', '[random]'],
    REFERAK_PLACE_HOLDER: ['[referrer_url]', '[LR_URL]', '[description_url]'],
    EMBED_CODE_PLACE_HOLDER: ['[oo_embedcode]'],
    MESSAGE: '<table width="100%" height="100%" bgcolor="black" ' + 'style="padding-left:55px; padding-right:55px; background-color:black; color: white;">' + '<tbody>' + '<tr valign="middle">' + '<td align="right"><span style="font-family:Arial; font-size:20px">' + '<%= message %>' + '</span></td></tr></tbody></table>',
    __end_marker: true
  };
  OO.CONSTANTS = {
    // Ad frequency constants
    AD_PLAY_COUNT_KEY: 'oo_ad_play_count',
    AD_ID_TO_PLAY_COUNT_DIVIDER: ': ',
    AD_PLAY_COUNT_DIVIDER: '|',
    MAX_AD_PLAY_COUNT_HISTORY_LENGTH: 20,
    CONTROLS_BOTTOM_PADDING: 10,
    SEEK_TO_END_LIMIT: 4,

    /**
     * @description <code>OO.CONSTANTS.PLAYER_TYPE</code>:
     *   An object containing the possible modes in which the player can operate.
     * @constant OO.CONSTANTS.PLAYER_TYPE
     * @type {object}
     */
    PLAYER_TYPE: {
      /**
       * @description <code>OO.CONSTANTS.PLAYER_TYPE.VIDEO ('video')</code>:
       *   The default player type (video player).
       * @constant OO.CONSTANTS.PLAYER_TYPE.VIDEO
       * @type {string}
       */
      VIDEO: 'video',

      /**
       * @description <code>OO.CONSTANTS.PLAYER_TYPE.AUDIO ('audio')</code>:
       *   The audio-only player type.
       * @constant OO.CONSTANTS.PLAYER_TYPE.AUDIO
       * @type {string}
       */
      AUDIO: 'audio'
    },
    HEVC_CODEC: {
      HEV1: 'hev1',
      HVC1: 'hvc1'
    },
    AUTO_BITRATE: 'auto',
    CLOSED_CAPTIONS: {
      SHOWING: 'showing',
      HIDDEN: 'hidden',
      DISABLED: 'disabled'
    },
    OOYALA_PLAYER_SETTINGS_KEY: 'ooyala_player_settings',

    /**
     * @description <code>OO.CONSTANTS.SELECTED_AUDIO ('selectedAudio')</code>:
     *  This is the key of selected audio stream
     * @constant OO.CONSTANTS.SELECTED_AUDIO
     * @type {string}
     */
    SELECTED_AUDIO: 'selectedAudio',
    VALHALLA_CACHE_CONTENT_TREE_KEY: 'content_tree',
    VALHALLA_CACHE_METADATA_KEY: 'metadata',
    VALHALLA_CACHE_SAS_KEY: 'sas_auth',

    /**
     * The name of the local storage key for the device GUID
     * that is used for analytics.
     * @constant OO.CONSTANTS.GUID_STORAGE_KEY
     * @private
     */
    GUID_STORAGE_KEY: 'ooyala_guid',
    PLAYBACK_SPEED: {
      /**
       * The minimum allowed speed multiplier for a video playback.
       * @constant OO.CONSTANTS.PLAYBACK_SPEED.MIN
       * @type {Number}
       */
      MIN: 0.5,

      /**
       * @description The maximum allowed speed multiplier for a video playback.
       * @constant OO.CONSTANTS.PLAYBACK_SPEED.MAX
       * @type {Number}
       */
      MAX: 2.0
    },
    AUTOPLAY_STATE: {
      ALL_UNBLOCKED: 'All_Unblocked',
      // autoplay works and sound is not muted
      ALL_BLOCKED: 'All_Blocked',
      // autoplay does not work in this browser
      UNBLOCKED_WITHOUT_AUDIO: 'Unblocked_without_Audio' // autoplay works, but sound is muted

    },
    __end_marker: true
  };
})(OO, OO._);

},{}],58:[function(require,module,exports){
"use strict";

var $ = require('jquery');

var _ = require('underscore'); // Resolve all 3rd parties conflicts
// Beyond this point we can use OO._ for underscore and OO.$ for zepto


OO._ = _;
OO.$ = $;
OO.publicApi = OO.publicApi || {}; // used for inserting player_params in dev harness version
// please don't remove
// the corresponding insertion code is found at start.js

/* INSERT_PLAYER_PARAMS */

OO.playerParams = OO.playerParams || {};
/**
 * Determines the analytics tracking level to use. Should be treated as 'default'
 * when not set. The value can be overriden by creating an OO object at the window
 * level with a trackingLevel property before loading the core.
 * Note that this is made available to the plublic API so that analytics plugins
 * can read it directly.
 * Valid values (see OO.TRACKING_LEVEL for details): 'default', 'anonymous', 'disabled'
 * @property OO#trackingLevel
 */

OO.publicApi.trackingLevel = OO.trackingLevel = (window.OO || {}).trackingLevel;
var consoleFilter;
var recordingConsole = false;
var MAX_CONSOLE_OUTPUT_LINES = 2000;
/**
 * This stores the output recorded from calls to OO.log.  Recording is started
 * with OO.startRecordingConsoleOutput and stopped with OO.stopRecordingConsoleOutput.
 * @property OO#consoleOutput
 */

OO.consoleOutput = [];

OO.log = function () {
  if (typeof window.console !== 'undefined' && typeof window.console.log === 'function') {
    if (OO.playerParams.debug) {
      window.console.log.apply(window.console, arguments);
    }
  }

  if (recordingConsole) {
    var toAppend = '';
    var index;

    for (index = 0; index < arguments.length; index++) {
      toAppend += arguments[index] + ' ';
    }

    if (!OO.consoleOutput) {
      OO.consoleOutput = [];
    }

    var regexFilter;

    if (consoleFilter) {
      regexFilter = new RegExp(consoleFilter);
    } // check if the resulting output should be filtered out or not


    if (!regexFilter || regexFilter.test(toAppend)) {
      // if we are going over the max number of lines to store, remove the oldest one.
      if (OO.consoleOutput.length >= MAX_CONSOLE_OUTPUT_LINES) {
        OO.consoleOutput.shift();
      }

      OO.consoleOutput.push(toAppend);
    }
  }
};
/**
 * Enables recording the output sent to OO.log. To see the output check the value
 * of OO.consoleOutput
 * @method OO#startRecordingConsoleOutput
 * @param {*} filter - filter for Console
 * @returns {String} Message that states recording was started (Main for debugging in console)
 */


OO.startRecordingConsoleOutput = function (filter) {
  consoleFilter = filter;
  recordingConsole = true;
  return 'CONSOLE RECORDING STARTED';
};
/**
 * Disables recording the output sent to OO.log. To see the output check the value
 * of OO.consoleOutput
 * @method OO#stopRecordingConsoleOutput
 * @returns {String} Message that states recording was stopped (Main for debugging in console)
 */


OO.stopRecordingConsoleOutput = function () {
  recordingConsole = false;
  return 'CONSOLE RECORDING STOPPED';
};
/**
 * Clears the value stored in OO.consoleOutput.
 * @method OO#clearRecordedConsoleOutput
 * @returns {String} Message that states recorded output was cleared (Main for debugging in console)
 */


OO.clearRecordedConsoleOutput = function () {
  if (!OO.consoleOutput) {
    OO.consoleOutput = [];
  }

  OO.consoleOutput.splice(0, OO.consoleOutput.length);
  return 'CONSOLE RECORDING CLEARED';
};
/**
 * Set max number of lines to record. If new number is less than current output
 * it will delete the oldest lines to fit.
 * @method OO#setMaxConsoleOutputLines
 * @param {Number} numLines - amount of the lines
 * @returns {String} Message about max lines in Console
 */


OO.setMaxConsoleOutputLines = function (numLines) {
  if (!OO.consoleOutput) {
    OO.consoleOutput = [];
  }

  if (numLines < OO.consoleOutput.length) {
    OO.consoleOutput.splice(0, OO.consoleOutput.length - numLines);
  }

  MAX_CONSOLE_OUTPUT_LINES = numLines;
  return 'CONSOLE MAX LINES: ' + MAX_CONSOLE_OUTPUT_LINES;
}; // Compatibility for browsers without native JSON library (IE)


if (!window.JSON) {
  window.JSON = {
    stringify: function stringify(obj) {
      return '<object>';
    },
    __end_marker: true
  };
} // namespace resolution


var namespace = OO.playerParams.namespace || 'OO'; // default namespace is OO
// Check if there is any conflicts here. (If we load one version of player already.)

if (window[namespace] && window[namespace].Player) {
  OO.log('PlayerV4 is loaded already!!!');

  if (window[namespace].REV !== OO.publicApi.REV) {
    OO.log('there is a different VERSION loaded:', window[namespace].REV, OO.publicApi.REV);
  }

  throw new Error('PlayerV4 already defined!!');
} // we want to maintain a subset of the namespace so that OO.ready is available
// as soon as this first script loads
// do not clobber namespace.__static


if (window[namespace] && window[namespace].__static) {
  OO.publicApi.__static = window[namespace].__static;
} else {
  OO.publicApi.__static = {
    readyList: [],
    docReady: false,
    apiReady: false
  };
}

window[namespace] = OO.publicApi;
window[namespace].__internal = OO;

OO.isReady = function () {
  return OO.publicApi.__static.apiReady && OO.publicApi.__static.docReady;
};

OO.tryCallReady = function () {
  if (!OO.isReady()) {
    return;
  }

  while (OO.publicApi.__static.readyList.length > 0) {
    var fn = OO.publicApi.__static.readyList.pop();

    if (typeof fn === 'function') {
      try {
        fn(OO.publicApi);
      } catch (error) {
        OO.log('Error executing ready function', error, error.stack);
      }
    }
  }
};

OO.publicApi.ready = function (fn) {
  OO.publicApi.__static.readyList.unshift(fn);

  OO.tryCallReady();
};

var curOO = OO;

OO.publicApi.plugin = function (moduleName, moduleClassFactory) {
  // This is to make sure side load module will register to the correct canary code.
  if (curOO.isReady()) {
    OO.log('plugin is ready to register', curOO, moduleName);
    curOO.plugin(moduleName, moduleClassFactory);
  } else {
    OO.log('plugin', moduleName); // Make sure third party module is evaluated before normal ready callback.

    OO.publicApi.__static.readyList.push(function (ns) {
      ns.plugin(moduleName, moduleClassFactory);
    });
  }
};

},{"jquery":34,"underscore":36}],59:[function(require,module,exports){
"use strict";

(function (OO) {
  OO.LANGUAGE_LIST = [{
    '1': 'aa',
    '3': 'aar',
    'name': 'Afar',
    '2B': 'aar',
    '2T': '',
    'local': 'Qafaraf'
  }, {
    '1': 'ab',
    '3': 'abk',
    'name': 'Abkhazian',
    '2B': 'abk',
    '2T': '',
    'local': 'Аҧсуа бызшәа'
  }, {
    '1': '',
    '3': 'ace',
    'name': 'Achinese',
    '2B': 'ace',
    '2T': '',
    'local': 'بهسا اچيه'
  }, {
    '1': '',
    '3': 'ach',
    'name': 'Acoli',
    '2B': 'ach',
    '2T': '',
    'local': 'Lwo'
  }, {
    '1': '',
    '3': 'ada',
    'name': 'Adangme',
    '2B': 'ada',
    '2T': '',
    'local': 'Dangme'
  }, {
    '1': '',
    '3': 'ady',
    'name': 'Adyghe',
    '2B': 'ady',
    '2T': '',
    'local': 'Адыгабзэ'
  }, {
    '1': '',
    '3': '',
    'name': 'Afro-Asiatic languages',
    '2B': 'afa',
    '2T': '',
    'local': 'Afro-Asiatic languages'
  }, {
    '1': '',
    '3': 'afh',
    'name': 'Afrihili',
    '2B': 'afh',
    '2T': '',
    'local': 'El-Afrihili'
  }, {
    '1': 'af',
    '3': 'afr',
    'name': 'Afrikaans',
    '2B': 'afr',
    '2T': '',
    'local': 'Afrikaans'
  }, {
    '1': '',
    '3': 'ain',
    'name': 'Ainu',
    '2B': 'ain',
    '2T': '',
    'local': 'アイヌ・イタㇰ'
  }, {
    '1': 'ak',
    '3': 'aka',
    'name': 'Akan',
    '2B': 'aka',
    '2T': '',
    'local': 'Akan'
  }, {
    '1': '',
    '3': 'akk',
    'name': 'Akkadian',
    '2B': 'akk',
    '2T': '',
    'local': '𒀝𒅗𒁺𒌑'
  }, {
    '1': 'sq',
    '3': 'sqi',
    'name': 'Albanian',
    '2B': 'alb',
    '2T': 'sqi',
    'local': 'Shqip'
  }, {
    '1': '',
    '3': 'ale',
    'name': 'Aleut',
    '2B': 'ale',
    '2T': '',
    'local': 'Унáӈам тунуý'
  }, {
    '1': '',
    '3': '',
    'name': 'Algonquian languages',
    '2B': 'alg',
    '2T': '',
    'local': 'Algonquian languages'
  }, {
    '1': '',
    '3': 'alt',
    'name': 'Southern Altai',
    '2B': 'alt',
    '2T': '',
    'local': 'Алтай тили'
  }, {
    '1': 'am',
    '3': 'amh',
    'name': 'Amharic',
    '2B': 'amh',
    '2T': '',
    'local': 'አማርኛ'
  }, {
    '1': '',
    '3': 'ang',
    'name': 'Old English (ca. 450–1100)',
    '2B': 'ang',
    '2T': '',
    'local': 'Ænglisc'
  }, {
    '1': '',
    '3': 'anp',
    'name': 'Angika',
    '2B': 'anp',
    '2T': '',
    'local': 'Angika'
  }, {
    '1': '',
    '3': '',
    'name': 'Apache languages',
    '2B': 'apa',
    '2T': '',
    'local': 'Apache languages'
  }, {
    '1': 'ar',
    '3': 'ara',
    'name': 'Arabic',
    '2B': 'ara',
    '2T': '',
    'local': 'العَرَبِيَّة'
  }, {
    '1': '',
    '3': 'arc',
    'name': 'Official Aramaic (700–300 BCE)',
    '2B': 'arc',
    '2T': '',
    'local': 'Official Aramaic (700–300 BCE)'
  }, {
    '1': 'an',
    '3': 'arg',
    'name': 'Aragonese',
    '2B': 'arg',
    '2T': '',
    'local': 'aragonés'
  }, {
    '1': 'hy',
    '3': 'hye',
    'name': 'Armenian',
    '2B': 'arm',
    '2T': 'hye',
    'local': 'Հայերէն'
  }, {
    '1': '',
    '3': 'arn',
    'name': 'Mapudungun',
    '2B': 'arn',
    '2T': '',
    'local': 'Mapudungun'
  }, {
    '1': '',
    '3': 'arp',
    'name': 'Arapaho',
    '2B': 'arp',
    '2T': '',
    'local': 'Hinónoʼeitíít'
  }, {
    '1': '',
    '3': '',
    'name': 'Artificial languages',
    '2B': 'art',
    '2T': '',
    'local': 'Artificial languages'
  }, {
    '1': '',
    '3': 'arw',
    'name': 'Arawak',
    '2B': 'arw',
    '2T': '',
    'local': 'Lokono'
  }, {
    '1': 'as',
    '3': 'asm',
    'name': 'Assamese',
    '2B': 'asm',
    '2T': '',
    'local': 'অসমীয়া'
  }, {
    '1': '',
    '3': 'ast',
    'name': 'Asturian',
    '2B': 'ast',
    '2T': '',
    'local': 'Asturianu'
  }, {
    '1': '',
    '3': '',
    'name': 'Athapascan languages',
    '2B': 'ath',
    '2T': '',
    'local': 'Athapascan languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Australian languages',
    '2B': 'aus',
    '2T': '',
    'local': 'Australian languages'
  }, {
    '1': 'av',
    '3': 'ava',
    'name': 'Avaric',
    '2B': 'ava',
    '2T': '',
    'local': 'Магӏарул мацӏ'
  }, {
    '1': 'ae',
    '3': 'ave',
    'name': 'Avestan',
    '2B': 'ave',
    '2T': '',
    'local': 'Avestan'
  }, {
    '1': '',
    '3': 'awa',
    'name': 'Awadhi',
    '2B': 'awa',
    '2T': '',
    'local': 'अवधी'
  }, {
    '1': 'ay',
    '3': 'aym',
    'name': 'Aymara',
    '2B': 'aym',
    '2T': '',
    'local': 'Aymar aru'
  }, {
    '1': 'az',
    '3': 'aze',
    'name': 'Azerbaijani',
    '2B': 'aze',
    '2T': '',
    'local': 'Azərbaycan dili'
  }, {
    '1': '',
    '3': '',
    'name': 'Banda languages',
    '2B': 'bad',
    '2T': '',
    'local': 'Banda languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Bamileke languages',
    '2B': 'bai',
    '2T': '',
    'local': 'Bamiléké'
  }, {
    '1': 'ba',
    '3': 'bak',
    'name': 'Bashkir',
    '2B': 'bak',
    '2T': '',
    'local': 'Башҡорт теле'
  }, {
    '1': '',
    '3': 'bal',
    'name': 'Baluchi',
    '2B': 'bal',
    '2T': '',
    'local': 'بلوچی'
  }, {
    '1': 'bm',
    '3': 'bam',
    'name': 'Bambara',
    '2B': 'bam',
    '2T': '',
    'local': 'ߓߊߡߊߣߊߣߞߊߣ'
  }, {
    '1': '',
    '3': 'ban',
    'name': 'Balinese',
    '2B': 'ban',
    '2T': '',
    'local': 'ᬪᬵᬱᬩᬮᬶ'
  }, {
    '1': 'eu',
    '3': 'eus',
    'name': 'Basque',
    '2B': 'baq',
    '2T': 'eus',
    'local': 'euskara'
  }, {
    '1': '',
    '3': 'bas',
    'name': 'Basa',
    '2B': 'bas',
    '2T': '',
    'local': 'Mbene'
  }, {
    '1': '',
    '3': '',
    'name': 'Baltic languages',
    '2B': 'bat',
    '2T': '',
    'local': 'Baltic languages'
  }, {
    '1': '',
    '3': 'bej',
    'name': 'Beja',
    '2B': 'bej',
    '2T': '',
    'local': 'Bidhaawyeet'
  }, {
    '1': 'be',
    '3': 'bel',
    'name': 'Belarusian',
    '2B': 'bel',
    '2T': '',
    'local': 'Беларуская мова'
  }, {
    '1': '',
    '3': 'bem',
    'name': 'Bemba',
    '2B': 'bem',
    '2T': '',
    'local': 'Chibemba'
  }, {
    '1': 'bn',
    '3': 'ben',
    'name': 'Bengali',
    '2B': 'ben',
    '2T': '',
    'local': 'বাংলা'
  }, {
    '1': '',
    '3': '',
    'name': 'Berber languages',
    '2B': 'ber',
    '2T': '',
    'local': 'Tamaziɣt'
  }, {
    '1': '',
    '3': 'bho',
    'name': 'Bhojpuri',
    '2B': 'bho',
    '2T': '',
    'local': 'भोजपुरी'
  }, {
    '1': 'bh',
    '3': '',
    'name': 'Bihari languages',
    '2B': 'bih',
    '2T': '',
    'local': 'Bihari languages'
  }, {
    '1': '',
    '3': 'bik',
    'name': 'Bikol',
    '2B': 'bik',
    '2T': '',
    'local': 'Bikol'
  }, {
    '1': '',
    '3': 'bin',
    'name': 'Bini',
    '2B': 'bin',
    '2T': '',
    'local': 'Ẹ̀dó'
  }, {
    '1': 'bi',
    '3': 'bis',
    'name': 'Bislama',
    '2B': 'bis',
    '2T': '',
    'local': 'Bislama'
  }, {
    '1': '',
    '3': 'bla',
    'name': 'Siksika',
    '2B': 'bla',
    '2T': '',
    'local': 'ᓱᖽᐧᖿ'
  }, {
    '1': '',
    '3': '',
    'name': 'Bantu languages',
    '2B': 'bnt',
    '2T': '',
    'local': 'Bantu languages'
  }, {
    '1': 'bo',
    '3': 'bod',
    'name': 'Tibetan',
    '2B': 'ib',
    '2T': 'bod',
    'local': 'བོད་སྐད་'
  }, {
    '1': 'bs',
    '3': 'bos',
    'name': 'Bosnian',
    '2B': 'bos',
    '2T': '',
    'local': 'bosanski'
  }, {
    '1': '',
    '3': 'bra',
    'name': 'Braj',
    '2B': 'bra',
    '2T': '',
    'local': 'Braj'
  }, {
    '1': 'br',
    '3': 'bre',
    'name': 'Breton',
    '2B': 'bre',
    '2T': '',
    'local': 'Brezhoneg'
  }, {
    '1': '',
    '3': '',
    'name': 'Batak languages',
    '2B': 'btk',
    '2T': '',
    'local': 'Batak languages'
  }, {
    '1': '',
    '3': 'bua',
    'name': 'Buriat',
    '2B': 'bua',
    '2T': '',
    'local': 'буряад хэлэн'
  }, {
    '1': '',
    '3': 'bug',
    'name': 'Buginese',
    '2B': 'bug',
    '2T': '',
    'local': 'ᨅᨔ ᨕᨘᨁᨗ'
  }, {
    '1': 'bg',
    '3': 'bul',
    'name': 'Bulgarian',
    '2B': 'bul',
    '2T': '',
    'local': 'български език'
  }, {
    '1': 'my',
    '3': 'mya',
    'name': 'Burmese',
    '2B': 'bur',
    '2T': 'mya',
    'local': 'မြန်မာစာ'
  }, {
    '1': '',
    '3': 'byn',
    'name': 'Bilin',
    '2B': 'byn',
    '2T': '',
    'local': 'ብሊና, ብሊን'
  }, {
    '1': '',
    '3': 'cad',
    'name': 'Caddo',
    '2B': 'cad',
    '2T': '',
    'local': 'Hasí:nay'
  }, {
    '1': '',
    '3': '',
    'name': 'Central American Indian languages',
    '2B': 'cai',
    '2T': '',
    'local': 'Central American Indian languages'
  }, {
    '1': '',
    '3': 'car',
    'name': 'Galibi Carib',
    '2B': 'car',
    '2T': '',
    'local': 'Kari\'nja'
  }, {
    '1': 'ca',
    '3': 'cat',
    'name': 'Catalan',
    '2B': 'cat',
    '2T': '',
    'local': 'català'
  }, {
    '1': '',
    '3': '',
    'name': 'Caucasian languages',
    '2B': 'cau',
    '2T': '',
    'local': 'Caucasian languages'
  }, {
    '1': '',
    '3': 'ceb',
    'name': 'Cebuano',
    '2B': 'ceb',
    '2T': '',
    'local': 'Sinugbuanong Binisayâ'
  }, {
    '1': '',
    '3': '',
    'name': 'Celtic languages',
    '2B': 'cel',
    '2T': '',
    'local': 'Celtic languages'
  }, {
    '1': 'cs',
    '3': 'ces',
    'name': 'Czech',
    '2B': 'ze',
    '2T': 'ces',
    'local': 'čeština'
  }, {
    '1': 'ch',
    '3': 'cha',
    'name': 'Chamorro',
    '2B': 'cha',
    '2T': '',
    'local': 'Finu\' Chamoru'
  }, {
    '1': '',
    '3': 'chb',
    'name': 'Chibcha',
    '2B': 'chb',
    '2T': '',
    'local': 'Muysccubun'
  }, {
    '1': 'ce',
    '3': 'che',
    'name': 'Chechen',
    '2B': 'che',
    '2T': '',
    'local': 'Нохчийн мотт'
  }, {
    '1': '',
    '3': 'chg',
    'name': 'Chagatai',
    '2B': 'chg',
    '2T': '',
    'local': 'جغتای'
  }, {
    '1': 'zh',
    '3': 'zho',
    'name': 'Chinese',
    '2B': 'chi',
    '2T': 'zho',
    'local': '中文'
  }, {
    '1': '',
    '3': 'chk',
    'name': 'Chuukese',
    '2B': 'chk',
    '2T': '',
    'local': 'Chuukese'
  }, {
    '1': '',
    '3': 'chm',
    'name': 'Mari',
    '2B': 'chm',
    '2T': '',
    'local': 'марий йылме'
  }, {
    '1': '',
    '3': 'chn',
    'name': 'Chinook jargon',
    '2B': 'chn',
    '2T': '',
    'local': 'chinuk wawa'
  }, {
    '1': '',
    '3': 'cho',
    'name': 'Choctaw',
    '2B': 'cho',
    '2T': '',
    'local': 'Chahta\''
  }, {
    '1': '',
    '3': 'chp',
    'name': 'Chipewyan',
    '2B': 'chp',
    '2T': '',
    'local': 'ᑌᓀᓱᒼᕄᓀ (Dënesųłiné)'
  }, {
    '1': '',
    '3': 'chr',
    'name': 'Cherokee',
    '2B': 'chr',
    '2T': '',
    'local': 'ᏣᎳᎩ ᎦᏬᏂᎯᏍᏗ'
  }, {
    '1': 'cu',
    '3': 'chu',
    'name': 'Church Slavic',
    '2B': 'chu',
    '2T': '',
    'local': 'Славе́нскїй ѧ҆зы́къ'
  }, {
    '1': 'cv',
    '3': 'chv',
    'name': 'Chuvash',
    '2B': 'chv',
    '2T': '',
    'local': 'Чӑвашла'
  }, {
    '1': '',
    '3': 'chy',
    'name': 'Cheyenne',
    '2B': 'chy',
    '2T': '',
    'local': 'Tsėhésenėstsestȯtse'
  }, {
    '1': '',
    '3': '',
    'name': 'Chamic languages',
    '2B': 'cmc',
    '2T': '',
    'local': 'Chamic languages'
  }, {
    '1': '',
    '3': 'cnr',
    'name': 'Montenegrin',
    '2B': 'cnr',
    '2T': '',
    'local': 'crnogorski / црногорски'
  }, {
    '1': '',
    '3': 'cop',
    'name': 'Coptic',
    '2B': 'cop',
    '2T': '',
    'local': 'ϯⲙⲉⲑⲣⲉⲙⲛ̀ⲭⲏⲙⲓ'
  }, {
    '1': 'kw',
    '3': 'cor',
    'name': 'Cornish',
    '2B': 'cor',
    '2T': '',
    'local': 'Kernowek'
  }, {
    '1': 'co',
    '3': 'cos',
    'name': 'Corsican',
    '2B': 'cos',
    '2T': '',
    'local': 'Corsu'
  }, {
    '1': '',
    '3': '',
    'name': 'English based Creoles and pidgins',
    '2B': 'cpe',
    '2T': '',
    'local': 'English based Creoles and pidgins'
  }, {
    '1': '',
    '3': '',
    'name': 'French-based Creoles and pidgins',
    '2B': 'cpf',
    '2T': '',
    'local': 'French-based Creoles and pidgins'
  }, {
    '1': '',
    '3': '',
    'name': 'Portuguese-based Creoles and pidgins',
    '2B': 'cpp',
    '2T': '',
    'local': 'Portuguese-based Creoles and pidgins'
  }, {
    '1': 'cr',
    '3': 'cre',
    'name': 'Cree',
    '2B': 'cre',
    '2T': '',
    'local': 'Cree'
  }, {
    '1': '',
    '3': 'crh',
    'name': 'Crimean Tatar',
    '2B': 'crh',
    '2T': '',
    'local': 'Къырымтатарджа'
  }, {
    '1': '',
    '3': '',
    'name': 'Creoles and pidgins',
    '2B': 'crp',
    '2T': '',
    'local': 'Creoles and pidgins'
  }, {
    '1': '',
    '3': 'csb',
    'name': 'Kashubian',
    '2B': 'csb',
    '2T': '',
    'local': 'Kaszëbsczi jãzëk'
  }, {
    '1': '',
    '3': '',
    'name': 'Cushitic languages',
    '2B': 'cus',
    '2T': '',
    'local': 'Cushitic languages'
  }, {
    '1': 'cy',
    '3': 'cym',
    'name': 'Welsh',
    '2B': 'el',
    '2T': 'cym',
    'local': 'Cymraeg'
  }, {
    '1': 'cs',
    '3': 'ces',
    'name': 'Czech',
    '2B': 'cze',
    '2T': 'ces',
    'local': 'čeština'
  }, {
    '1': '',
    '3': 'dak',
    'name': 'Dakota',
    '2B': 'dak',
    '2T': '',
    'local': 'Dakhótiyapi'
  }, {
    '1': 'da',
    '3': 'dan',
    'name': 'Danish',
    '2B': 'dan',
    '2T': '',
    'local': 'dansk'
  }, {
    '1': '',
    '3': 'dar',
    'name': 'Dargwa',
    '2B': 'dar',
    '2T': '',
    'local': 'дарган мез'
  }, {
    '1': '',
    '3': '',
    'name': 'Land Dayak languages',
    '2B': 'day',
    '2T': '',
    'local': 'Land Dayak languages'
  }, {
    '1': '',
    '3': 'del',
    'name': 'Delaware',
    '2B': 'del',
    '2T': '',
    'local': 'Delaware'
  }, {
    '1': '',
    '3': 'den',
    'name': 'Slave (Athapascan)',
    '2B': 'den',
    '2T': '',
    'local': 'Dene K\'e'
  }, {
    '1': 'de',
    '3': 'deu',
    'name': 'German',
    '2B': 'ger',
    '2T': 'deu',
    'local': 'Deutsch'
  }, {
    '1': '',
    '3': 'dgr',
    'name': 'Dogrib',
    '2B': 'dgr',
    '2T': '',
    'local': 'डोगरी ڈوگرى'
  }, {
    '1': '',
    '3': 'din',
    'name': 'Dinka',
    '2B': 'din',
    '2T': '',
    'local': 'Thuɔŋjäŋ'
  }, {
    '1': 'dv',
    '3': 'div',
    'name': 'Dhivehi',
    '2B': 'div',
    '2T': '',
    'local': 'ދިވެހި'
  }, {
    '1': '',
    '3': 'doi',
    'name': 'Dogri',
    '2B': 'doi',
    '2T': '',
    'local': 'डोगरी'
  }, {
    '1': '',
    '3': '',
    'name': 'Dravidian languages',
    '2B': 'dra',
    '2T': '',
    'local': 'Dravidian languages'
  }, {
    '1': '',
    '3': 'dsb',
    'name': 'Lower Sorbian',
    '2B': 'dsb',
    '2T': '',
    'local': 'Dolnoserbski'
  }, {
    '1': '',
    '3': 'dua',
    'name': 'Duala',
    '2B': 'dua',
    '2T': '',
    'local': 'Duala'
  }, {
    '1': '',
    '3': 'dum',
    'name': 'Middle Dutch (ca. 1050–1350)',
    '2B': 'dum',
    '2T': '',
    'local': 'Middle Dutch (ca. 1050–1350)'
  }, {
    '1': 'nl',
    '3': 'nld',
    'name': 'Dutch',
    '2B': 'dut',
    '2T': 'nld',
    'local': 'Nederlands'
  }, {
    '1': '',
    '3': 'dyu',
    'name': 'Dyula',
    '2B': 'dyu',
    '2T': '',
    'local': 'Julakan'
  }, {
    '1': 'dz',
    '3': 'dzo',
    'name': 'Dzongkha',
    '2B': 'dzo',
    '2T': '',
    'local': 'རྫོང་ཁ་'
  }, {
    '1': '',
    '3': 'efi',
    'name': 'Efik',
    '2B': 'efi',
    '2T': '',
    'local': 'Efik'
  }, {
    '1': '',
    '3': 'egy',
    'name': 'Egyptian (Ancient)',
    '2B': 'egy',
    '2T': '',
    'local': 'Egyptian (Ancient)'
  }, {
    '1': '',
    '3': 'eka',
    'name': 'Ekajuk',
    '2B': 'eka',
    '2T': '',
    'local': 'Ekajuk'
  }, {
    '1': 'el',
    '3': 'ell',
    'name': 'Modern Greek (1453–)',
    '2B': 're',
    '2T': 'ell',
    'local': 'Νέα Ελληνικά'
  }, {
    '1': '',
    '3': 'elx',
    'name': 'Elamite',
    '2B': 'elx',
    '2T': '',
    'local': 'Elamite'
  }, {
    '1': 'en',
    '3': 'eng',
    'name': 'English',
    '2B': 'eng',
    '2T': '',
    'local': 'English'
  }, {
    '1': '',
    '3': 'enm',
    'name': 'Middle English (1100–1500)',
    '2B': 'enm',
    '2T': '',
    'local': 'Middle English (1100–1500)'
  }, {
    '1': 'eo',
    '3': 'epo',
    'name': 'Esperanto',
    '2B': 'epo',
    '2T': '',
    'local': 'Esperanto'
  }, {
    '1': 'et',
    '3': 'est',
    'name': 'Estonian',
    '2B': 'est',
    '2T': '',
    'local': 'eesti keel'
  }, {
    '1': 'eu',
    '3': 'eus',
    'name': 'Basque',
    '2B': 'aq',
    '2T': 'eus',
    'local': 'euskara'
  }, {
    '1': 'ee',
    '3': 'ewe',
    'name': 'Ewe',
    '2B': 'ewe',
    '2T': '',
    'local': 'Èʋegbe'
  }, {
    '1': '',
    '3': 'ewo',
    'name': 'Ewondo',
    '2B': 'ewo',
    '2T': '',
    'local': 'Ewondo'
  }, {
    '1': '',
    '3': 'fan',
    'name': 'Fang',
    '2B': 'fan',
    '2T': '',
    'local': 'Fang'
  }, {
    '1': 'fo',
    '3': 'fao',
    'name': 'Faroese',
    '2B': 'fao',
    '2T': '',
    'local': 'føroyskt'
  }, {
    '1': 'fa',
    '3': 'fas',
    'name': 'Persian',
    '2B': 'er',
    '2T': 'fas',
    'local': 'فارسی'
  }, {
    '1': '',
    '3': 'fat',
    'name': 'Fanti',
    '2B': 'fat',
    '2T': '',
    'local': 'Mfantse'
  }, {
    '1': 'fj',
    '3': 'fij',
    'name': 'Fijian',
    '2B': 'fij',
    '2T': '',
    'local': 'Na Vosa Vakaviti'
  }, {
    '1': '',
    '3': 'fil',
    'name': 'Filipino',
    '2B': 'fil',
    '2T': '',
    'local': 'Wikang Filipino'
  }, {
    '1': 'fi',
    '3': 'fin',
    'name': 'Finnish',
    '2B': 'fin',
    '2T': '',
    'local': 'suomen kieli'
  }, {
    '1': '',
    '3': '',
    'name': 'Finno-Ugrian languages',
    '2B': 'fiu',
    '2T': '',
    'local': 'Finno-Ugrian languages'
  }, {
    '1': '',
    '3': 'fon',
    'name': 'Fon',
    '2B': 'fon',
    '2T': '',
    'local': 'Fon gbè'
  }, {
    '1': 'fr',
    '3': 'fra',
    'name': 'French',
    '2B': 'fre',
    '2T': 'fra',
    'local': 'Français'
  }, {
    '1': '',
    '3': 'frm',
    'name': 'Middle French (ca. 1400–1600)',
    '2B': 'frm',
    '2T': '',
    'local': 'François'
  }, {
    '1': '',
    '3': 'fro',
    'name': 'Old French (842–ca. 1400)',
    '2B': 'fro',
    '2T': '',
    'local': 'Franceis'
  }, {
    '1': '',
    '3': 'frr',
    'name': 'Northern Frisian',
    '2B': 'frr',
    '2T': '',
    'local': 'Frasch'
  }, {
    '1': '',
    '3': 'frs',
    'name': 'Eastern Frisian',
    '2B': 'frs',
    '2T': '',
    'local': 'Seeltersk'
  }, {
    '1': 'fy',
    '3': 'fry',
    'name': 'Western Frisian',
    '2B': 'fry',
    '2T': '',
    'local': 'Frysk'
  }, {
    '1': 'ff',
    '3': 'ful',
    'name': 'Fulah',
    '2B': 'ful',
    '2T': '',
    'local': 'Fulfulde'
  }, {
    '1': '',
    '3': 'fur',
    'name': 'Friulian',
    '2B': 'fur',
    '2T': '',
    'local': 'Furlan'
  }, {
    '1': '',
    '3': 'gaa',
    'name': 'Ga',
    '2B': 'gaa',
    '2T': '',
    'local': 'Gã'
  }, {
    '1': '',
    '3': 'gay',
    'name': 'Gayo',
    '2B': 'gay',
    '2T': '',
    'local': 'Basa Gayo'
  }, {
    '1': '',
    '3': 'gba',
    'name': 'Gbaya',
    '2B': 'gba',
    '2T': '',
    'local': 'Gbaya'
  }, {
    '1': '',
    '3': '',
    'name': 'Germanic languages',
    '2B': 'gem',
    '2T': '',
    'local': 'Germanic languages'
  }, {
    '1': 'ka',
    '3': 'kat',
    'name': 'Georgian',
    '2B': 'geo',
    '2T': 'kat',
    'local': 'ქართული'
  }, {
    '1': 'de',
    '3': 'deu',
    'name': 'German',
    '2B': 'ger',
    '2T': 'deu',
    'local': 'Deutsch'
  }, {
    '1': '',
    '3': 'gez',
    'name': 'Geez',
    '2B': 'gez',
    '2T': '',
    'local': 'ግዕዝ'
  }, {
    '1': '',
    '3': 'gil',
    'name': 'Gilbertese',
    '2B': 'gil',
    '2T': '',
    'local': 'Taetae ni Kiribati'
  }, {
    '1': 'gd',
    '3': 'gla',
    'name': 'Gaelic',
    '2B': 'gla',
    '2T': '',
    'local': 'Gàidhlig'
  }, {
    '1': 'ga',
    '3': 'gle',
    'name': 'Irish',
    '2B': 'gle',
    '2T': '',
    'local': 'Gaeilge'
  }, {
    '1': 'gl',
    '3': 'glg',
    'name': 'Galician',
    '2B': 'glg',
    '2T': '',
    'local': 'galego'
  }, {
    '1': 'gv',
    '3': 'glv',
    'name': 'Manx',
    '2B': 'glv',
    '2T': '',
    'local': 'Gaelg'
  }, {
    '1': '',
    '3': 'gmh',
    'name': 'Middle High German (ca. 1050–1500)',
    '2B': 'gmh',
    '2T': '',
    'local': 'Diutsch'
  }, {
    '1': '',
    '3': 'goh',
    'name': 'Old High German (ca. 750–1050)',
    '2B': 'goh',
    '2T': '',
    'local': 'Diutisk'
  }, {
    '1': '',
    '3': 'gon',
    'name': 'Gondi',
    '2B': 'gon',
    '2T': '',
    'local': 'Gondi'
  }, {
    '1': '',
    '3': 'gor',
    'name': 'Gorontalo',
    '2B': 'gor',
    '2T': '',
    'local': 'Bahasa Hulontalo'
  }, {
    '1': '',
    '3': 'got',
    'name': 'Gothic',
    '2B': 'got',
    '2T': '',
    'local': 'Gothic'
  }, {
    '1': '',
    '3': 'grb',
    'name': 'Grebo',
    '2B': 'grb',
    '2T': '',
    'local': 'Grebo'
  }, {
    '1': '',
    '3': 'grc',
    'name': 'Ancient Greek (to 1453)',
    '2B': 'grc',
    '2T': '',
    'local': 'Ἑλληνική'
  }, {
    '1': 'el',
    '3': 'ell',
    'name': 'Modern Greek (1453–)',
    '2B': 'gre',
    '2T': 'ell',
    'local': 'Νέα Ελληνικά'
  }, {
    '1': 'gn',
    '3': 'grn',
    'name': 'Guarani',
    '2B': 'grn',
    '2T': '',
    'local': 'Avañe\'ẽ'
  }, {
    '1': '',
    '3': 'gsw',
    'name': 'Swiss German',
    '2B': 'gsw',
    '2T': '',
    'local': 'Schwiizerdütsch'
  }, {
    '1': 'gu',
    '3': 'guj',
    'name': 'Gujarati',
    '2B': 'guj',
    '2T': '',
    'local': 'ગુજરાતી'
  }, {
    '1': '',
    '3': 'gwi',
    'name': 'Gwichʼin',
    '2B': 'gwi',
    '2T': '',
    'local': 'Dinjii Zhu’ Ginjik'
  }, {
    '1': '',
    '3': 'hai',
    'name': 'Haida',
    '2B': 'hai',
    '2T': '',
    'local': 'X̱aat Kíl'
  }, {
    '1': 'ht',
    '3': 'hat',
    'name': 'Haitian',
    '2B': 'hat',
    '2T': '',
    'local': 'kreyòl ayisyen'
  }, {
    '1': 'ha',
    '3': 'hau',
    'name': 'Hausa',
    '2B': 'hau',
    '2T': '',
    'local': 'Harshen Hausa'
  }, {
    '1': '',
    '3': 'haw',
    'name': 'Hawaiian',
    '2B': 'haw',
    '2T': '',
    'local': 'ʻŌlelo Hawaiʻi'
  }, {
    '1': 'he',
    '3': 'heb',
    'name': 'Hebrew',
    '2B': 'heb',
    '2T': '',
    'local': 'עברית'
  }, {
    '1': 'hz',
    '3': 'her',
    'name': 'Herero',
    '2B': 'her',
    '2T': '',
    'local': 'Otjiherero'
  }, {
    '1': '',
    '3': 'hil',
    'name': 'Hiligaynon',
    '2B': 'hil',
    '2T': '',
    'local': 'Ilonggo'
  }, {
    '1': '',
    '3': '',
    'name': 'Himachali languages',
    '2B': 'him',
    '2T': '',
    'local': 'Himachali languages'
  }, {
    '1': 'hi',
    '3': 'hin',
    'name': 'Hindi',
    '2B': 'hin',
    '2T': '',
    'local': 'हिन्दी'
  }, {
    '1': '',
    '3': 'hit',
    'name': 'Hittite',
    '2B': 'hit',
    '2T': '',
    'local': '𒉈𒅆𒇷'
  }, {
    '1': '',
    '3': 'hmn',
    'name': 'Hmong',
    '2B': 'hmn',
    '2T': '',
    'local': 'lus Hmoob'
  }, {
    '1': 'ho',
    '3': 'hmo',
    'name': 'Hiri Motu',
    '2B': 'hmo',
    '2T': '',
    'local': 'Hiri Motu'
  }, {
    '1': 'hr',
    '3': 'hrv',
    'name': 'Croatian',
    '2B': 'hrv',
    '2T': '',
    'local': 'hrvatski'
  }, {
    '1': '',
    '3': 'hsb',
    'name': 'Upper Sorbian',
    '2B': 'hsb',
    '2T': '',
    'local': 'hornjoserbšćina'
  }, {
    '1': 'hu',
    '3': 'hun',
    'name': 'Hungarian',
    '2B': 'hun',
    '2T': '',
    'local': 'magyar nyelv'
  }, {
    '1': '',
    '3': 'hup',
    'name': 'Hupa',
    '2B': 'hup',
    '2T': '',
    'local': 'Na:tinixwe Mixine:whe\''
  }, {
    '1': 'hy',
    '3': 'hye',
    'name': 'Armenian',
    '2B': 'rm',
    '2T': 'hye',
    'local': 'Հայերէն'
  }, {
    '1': '',
    '3': 'iba',
    'name': 'Iban',
    '2B': 'iba',
    '2T': '',
    'local': 'Jaku Iban'
  }, {
    '1': 'ig',
    '3': 'ibo',
    'name': 'Igbo',
    '2B': 'ibo',
    '2T': '',
    'local': 'Asụsụ Igbo'
  }, {
    '1': 'is',
    '3': 'isl',
    'name': 'Icelandic',
    '2B': 'ice',
    '2T': 'isl',
    'local': 'íslenska'
  }, {
    '1': 'io',
    '3': 'ido',
    'name': 'Ido',
    '2B': 'ido',
    '2T': '',
    'local': 'Ido'
  }, {
    '1': 'ii',
    '3': 'iii',
    'name': 'Sichuan Yi',
    '2B': 'iii',
    '2T': '',
    'local': 'ꆈꌠꉙ'
  }, {
    '1': '',
    '3': '',
    'name': 'Ijo languages',
    '2B': 'ijo',
    '2T': '',
    'local': 'Ịjọ'
  }, {
    '1': 'iu',
    '3': 'iku',
    'name': 'Inuktitut',
    '2B': 'iku',
    '2T': '',
    'local': 'ᐃᓄᒃᑎᑐᑦ'
  }, {
    '1': 'ie',
    '3': 'ile',
    'name': 'Interlingue',
    '2B': 'ile',
    '2T': '',
    'local': 'Interlingue'
  }, {
    '1': '',
    '3': 'ilo',
    'name': 'Iloko',
    '2B': 'ilo',
    '2T': '',
    'local': 'Pagsasao nga Ilokano'
  }, {
    '1': 'ia',
    '3': 'ina',
    'name': 'Interlingua (International Auxiliary Language Association)',
    '2B': 'ina',
    '2T': '',
    'local': 'Interlingua (International Auxiliary Language Association)'
  }, {
    '1': '',
    '3': '',
    'name': 'Indic languages',
    '2B': 'inc',
    '2T': '',
    'local': 'Indic languages'
  }, {
    '1': 'id',
    '3': 'ind',
    'name': 'Indonesian',
    '2B': 'ind',
    '2T': '',
    'local': 'bahasa Indonesia'
  }, {
    '1': '',
    '3': '',
    'name': 'Indo-European languages',
    '2B': 'ine',
    '2T': '',
    'local': 'Indo-European languages'
  }, {
    '1': '',
    '3': 'inh',
    'name': 'Ingush',
    '2B': 'inh',
    '2T': '',
    'local': 'ГӀалгӀай мотт'
  }, {
    '1': 'ik',
    '3': 'ipk',
    'name': 'Inupiaq',
    '2B': 'ipk',
    '2T': '',
    'local': 'Iñupiaq'
  }, {
    '1': '',
    '3': '',
    'name': 'Iranian languages',
    '2B': 'ira',
    '2T': '',
    'local': 'Iranian languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Iroquoian languages',
    '2B': 'iro',
    '2T': '',
    'local': 'Iroquoian languages'
  }, {
    '1': 'is',
    '3': 'isl',
    'name': 'Icelandic',
    '2B': 'ce',
    '2T': 'isl',
    'local': 'íslenska'
  }, {
    '1': 'it',
    '3': 'ita',
    'name': 'Italian',
    '2B': 'ita',
    '2T': '',
    'local': 'italiano'
  }, {
    '1': 'jv',
    '3': 'jav',
    'name': 'Javanese',
    '2B': 'jav',
    '2T': '',
    'local': 'ꦧꦱꦗꦮ'
  }, {
    '1': '',
    '3': 'jbo',
    'name': 'Lojban',
    '2B': 'jbo',
    '2T': '',
    'local': 'la .lojban.'
  }, {
    '1': 'ja',
    '3': 'jpn',
    'name': 'Japanese',
    '2B': 'jpn',
    '2T': '',
    'local': '日本語'
  }, {
    '1': '',
    '3': 'jpr',
    'name': 'Judeo-Persian',
    '2B': 'jpr',
    '2T': '',
    'local': 'Dzhidi'
  }, {
    '1': '',
    '3': 'jrb',
    'name': 'Judeo-Arabic',
    '2B': 'jrb',
    '2T': '',
    'local': 'عربية يهودية / ערבית יהודית'
  }, {
    '1': '',
    '3': 'kaa',
    'name': 'Kara-Kalpak',
    '2B': 'kaa',
    '2T': '',
    'local': 'Qaraqalpaq tili'
  }, {
    '1': '',
    '3': 'kab',
    'name': 'Kabyle',
    '2B': 'kab',
    '2T': '',
    'local': 'Tamaziɣt Taqbaylit'
  }, {
    '1': '',
    '3': 'kac',
    'name': 'Kachin',
    '2B': 'kac',
    '2T': '',
    'local': 'Jingpho'
  }, {
    '1': 'kl',
    '3': 'kal',
    'name': 'Kalaallisut',
    '2B': 'kal',
    '2T': '',
    'local': 'Kalaallisut'
  }, {
    '1': '',
    '3': 'kam',
    'name': 'Kamba',
    '2B': 'kam',
    '2T': '',
    'local': 'Kamba'
  }, {
    '1': 'kn',
    '3': 'kan',
    'name': 'Kannada',
    '2B': 'kan',
    '2T': '',
    'local': 'ಕನ್ನಡ'
  }, {
    '1': '',
    '3': '',
    'name': 'Karen languages',
    '2B': 'kar',
    '2T': '',
    'local': 'Karen languages'
  }, {
    '1': 'ks',
    '3': 'kas',
    'name': 'Kashmiri',
    '2B': 'kas',
    '2T': '',
    'local': 'कॉशुर / كأشُر'
  }, {
    '1': 'ka',
    '3': 'kat',
    'name': 'Georgian',
    '2B': 'eo',
    '2T': 'kat',
    'local': 'ქართული'
  }, {
    '1': 'kr',
    '3': 'kau',
    'name': 'Kanuri',
    '2B': 'kau',
    '2T': '',
    'local': 'Kanuri'
  }, {
    '1': '',
    '3': 'kaw',
    'name': 'Kawi',
    '2B': 'kaw',
    '2T': '',
    'local': 'ꦧꦱꦗꦮ'
  }, {
    '1': 'kk',
    '3': 'kaz',
    'name': 'Kazakh',
    '2B': 'kaz',
    '2T': '',
    'local': 'қазақ тілі / qazaq tili'
  }, {
    '1': '',
    '3': 'kbd',
    'name': 'Kabardian',
    '2B': 'kbd',
    '2T': '',
    'local': 'Адыгэбзэ (Къэбэрдейбзэ)'
  }, {
    '1': '',
    '3': 'kha',
    'name': 'Khasi',
    '2B': 'kha',
    '2T': '',
    'local': 'কা কতিয়েন খাশি'
  }, {
    '1': '',
    '3': '',
    'name': 'Khoisan languages',
    '2B': 'khi',
    '2T': '',
    'local': 'Khoisan languages'
  }, {
    '1': 'km',
    '3': 'khm',
    'name': 'Central Khmer',
    '2B': 'khm',
    '2T': '',
    'local': 'ភាសាខ្មែរ'
  }, {
    '1': '',
    '3': 'kho',
    'name': 'Khotanese',
    '2B': 'kho',
    '2T': '',
    'local': 'Khotanese'
  }, {
    '1': 'ki',
    '3': 'kik',
    'name': 'Kikuyu',
    '2B': 'kik',
    '2T': '',
    'local': 'Gĩkũyũ'
  }, {
    '1': 'rw',
    '3': 'kin',
    'name': 'Kinyarwanda',
    '2B': 'kin',
    '2T': '',
    'local': 'Kinyarwanda'
  }, {
    '1': 'ky',
    '3': 'kir',
    'name': 'Kirghiz',
    '2B': 'kir',
    '2T': '',
    'local': 'кыргызча'
  }, {
    '1': '',
    '3': 'kmb',
    'name': 'Kimbundu',
    '2B': 'kmb',
    '2T': '',
    'local': 'Kimbundu'
  }, {
    '1': '',
    '3': 'kok',
    'name': 'Konkani',
    '2B': 'kok',
    '2T': '',
    'local': 'कोंकणी'
  }, {
    '1': 'kv',
    '3': 'kom',
    'name': 'Komi',
    '2B': 'kom',
    '2T': '',
    'local': 'Коми кыв'
  }, {
    '1': 'kg',
    '3': 'kon',
    'name': 'Kongo',
    '2B': 'kon',
    '2T': '',
    'local': 'Kongo'
  }, {
    '1': 'ko',
    '3': 'kor',
    'name': 'Korean',
    '2B': 'kor',
    '2T': '',
    'local': '한국어'
  }, {
    '1': '',
    '3': 'kos',
    'name': 'Kosraean',
    '2B': 'kos',
    '2T': '',
    'local': 'Kosraean'
  }, {
    '1': '',
    '3': 'kpe',
    'name': 'Kpelle',
    '2B': 'kpe',
    '2T': '',
    'local': 'Kpɛlɛwoo'
  }, {
    '1': '',
    '3': 'krc',
    'name': 'Karachay-Balkar',
    '2B': 'krc',
    '2T': '',
    'local': 'Къарачай-Малкъар тил'
  }, {
    '1': '',
    '3': 'krl',
    'name': 'Karelian',
    '2B': 'krl',
    '2T': '',
    'local': 'karjal'
  }, {
    '1': '',
    '3': '',
    'name': 'Kru languages',
    '2B': 'kro',
    '2T': '',
    'local': 'Kru languages'
  }, {
    '1': '',
    '3': 'kru',
    'name': 'Kurukh',
    '2B': 'kru',
    '2T': '',
    'local': 'कुड़ुख़'
  }, {
    '1': 'kj',
    '3': 'kua',
    'name': 'Kuanyama',
    '2B': 'kua',
    '2T': '',
    'local': 'Kuanyama'
  }, {
    '1': '',
    '3': 'kum',
    'name': 'Kumyk',
    '2B': 'kum',
    '2T': '',
    'local': 'къумукъ тил/qumuq til'
  }, {
    '1': 'ku',
    '3': 'kur',
    'name': 'Kurdish',
    '2B': 'kur',
    '2T': '',
    'local': 'Kurdî / کوردی'
  }, {
    '1': '',
    '3': 'kut',
    'name': 'Kutenai',
    '2B': 'kut',
    '2T': '',
    'local': 'Kutenai'
  }, {
    '1': '',
    '3': 'lad',
    'name': 'Ladino',
    '2B': 'lad',
    '2T': '',
    'local': 'Judeo-español'
  }, {
    '1': '',
    '3': 'lah',
    'name': 'Lahnda',
    '2B': 'lah',
    '2T': '',
    'local': 'بھارت کا'
  }, {
    '1': '',
    '3': 'lam',
    'name': 'Lamba',
    '2B': 'lam',
    '2T': '',
    'local': 'Lamba'
  }, {
    '1': 'lo',
    '3': 'lao',
    'name': 'Lao',
    '2B': 'lao',
    '2T': '',
    'local': 'ພາສາລາວ'
  }, {
    '1': 'la',
    '3': 'lat',
    'name': 'Latin',
    '2B': 'lat',
    '2T': '',
    'local': 'Lingua latīna'
  }, {
    '1': 'lv',
    '3': 'lav',
    'name': 'Latvian',
    '2B': 'lav',
    '2T': '',
    'local': 'Latviešu valoda'
  }, {
    '1': '',
    '3': 'lez',
    'name': 'Lezghian',
    '2B': 'lez',
    '2T': '',
    'local': 'Лезги чӏал'
  }, {
    '1': 'li',
    '3': 'lim',
    'name': 'Limburgan',
    '2B': 'lim',
    '2T': '',
    'local': 'Lèmburgs'
  }, {
    '1': 'ln',
    '3': 'lin',
    'name': 'Lingala',
    '2B': 'lin',
    '2T': '',
    'local': 'Lingala'
  }, {
    '1': 'lt',
    '3': 'lit',
    'name': 'Lithuanian',
    '2B': 'lit',
    '2T': '',
    'local': 'lietuvių kalba'
  }, {
    '1': '',
    '3': 'lol',
    'name': 'Mongo',
    '2B': 'lol',
    '2T': '',
    'local': 'Lomongo'
  }, {
    '1': '',
    '3': 'loz',
    'name': 'Lozi',
    '2B': 'loz',
    '2T': '',
    'local': 'Lozi'
  }, {
    '1': 'lb',
    '3': 'ltz',
    'name': 'Luxembourgish',
    '2B': 'ltz',
    '2T': '',
    'local': 'Lëtzebuergesch'
  }, {
    '1': '',
    '3': 'lua',
    'name': 'Luba-Lulua',
    '2B': 'lua',
    '2T': '',
    'local': 'Tshiluba'
  }, {
    '1': 'lu',
    '3': 'lub',
    'name': 'Luba-Katanga',
    '2B': 'lub',
    '2T': '',
    'local': 'Kiluba'
  }, {
    '1': 'lg',
    '3': 'lug',
    'name': 'Ganda',
    '2B': 'lug',
    '2T': '',
    'local': 'Luganda'
  }, {
    '1': '',
    '3': 'lui',
    'name': 'Luiseno',
    '2B': 'lui',
    '2T': '',
    'local': 'Cham\'teela'
  }, {
    '1': '',
    '3': 'lun',
    'name': 'Lunda',
    '2B': 'lun',
    '2T': '',
    'local': 'Chilunda'
  }, {
    '1': '',
    '3': 'luo',
    'name': 'Luo (Kenya and Tanzania)',
    '2B': 'luo',
    '2T': '',
    'local': 'Dholuo'
  }, {
    '1': '',
    '3': 'lus',
    'name': 'Lushai',
    '2B': 'lus',
    '2T': '',
    'local': 'Mizo ṭawng'
  }, {
    '1': 'mk',
    '3': 'mkd',
    'name': 'Macedonian',
    '2B': 'mac',
    '2T': 'mkd',
    'local': 'македонски јазик'
  }, {
    '1': '',
    '3': 'mad',
    'name': 'Madurese',
    '2B': 'mad',
    '2T': '',
    'local': 'Madhura'
  }, {
    '1': '',
    '3': 'mag',
    'name': 'Magahi',
    '2B': 'mag',
    '2T': '',
    'local': 'मगही'
  }, {
    '1': 'mh',
    '3': 'mah',
    'name': 'Marshallese',
    '2B': 'mah',
    '2T': '',
    'local': 'Kajin M̧ajeļ'
  }, {
    '1': '',
    '3': 'mai',
    'name': 'Maithili',
    '2B': 'mai',
    '2T': '',
    'local': 'मैथिली'
  }, {
    '1': '',
    '3': 'mak',
    'name': 'Makasar',
    '2B': 'mak',
    '2T': '',
    'local': 'Basa Mangkasara\' / ᨅᨔ ᨆᨀᨔᨑ'
  }, {
    '1': 'ml',
    '3': 'mal',
    'name': 'Malayalam',
    '2B': 'mal',
    '2T': '',
    'local': 'മലയാളം'
  }, {
    '1': '',
    '3': 'man',
    'name': 'Mandingo',
    '2B': 'man',
    '2T': '',
    'local': 'Mandi\'nka kango'
  }, {
    '1': 'mi',
    '3': 'mri',
    'name': 'Maori',
    '2B': 'mao',
    '2T': 'mri',
    'local': 'Te Reo Māori'
  }, {
    '1': '',
    '3': '',
    'name': 'Austronesian languages',
    '2B': 'map',
    '2T': '',
    'local': 'Austronesian languages'
  }, {
    '1': 'mr',
    '3': 'mar',
    'name': 'Marathi',
    '2B': 'mar',
    '2T': '',
    'local': 'मराठी'
  }, {
    '1': '',
    '3': 'mas',
    'name': 'Masai',
    '2B': 'mas',
    '2T': '',
    'local': 'ɔl'
  }, {
    '1': 'ms',
    '3': 'msa',
    'name': 'Malay',
    '2B': 'may',
    '2T': 'msa',
    'local': 'Bahasa Melayu'
  }, {
    '1': '',
    '3': 'mdf',
    'name': 'Moksha',
    '2B': 'mdf',
    '2T': '',
    'local': 'мокшень кяль'
  }, {
    '1': '',
    '3': 'mdr',
    'name': 'Mandar',
    '2B': 'mdr',
    '2T': '',
    'local': 'Mandar'
  }, {
    '1': '',
    '3': 'men',
    'name': 'Mende',
    '2B': 'men',
    '2T': '',
    'local': 'Mɛnde yia'
  }, {
    '1': '',
    '3': 'mga',
    'name': 'Middle Irish (900–1200)',
    '2B': 'mga',
    '2T': '',
    'local': 'Gaoidhealg'
  }, {
    '1': '',
    '3': 'mic',
    'name': 'Mi\'kmaq',
    '2B': 'mic',
    '2T': '',
    'local': 'Míkmawísimk'
  }, {
    '1': '',
    '3': 'min',
    'name': 'Minangkabau',
    '2B': 'min',
    '2T': '',
    'local': 'Baso Minang'
  }, {
    '1': '',
    '3': 'mis',
    'name': 'Uncoded languages',
    '2B': 'mis',
    '2T': '',
    'local': 'Uncoded languages'
  }, {
    '1': 'mk',
    '3': 'mkd',
    'name': 'Macedonian',
    '2B': 'ac',
    '2T': 'mkd',
    'local': 'македонски јазик'
  }, {
    '1': '',
    '3': '',
    'name': 'Mon-Khmer languages',
    '2B': 'mkh',
    '2T': '',
    'local': 'Mon-Khmer languages'
  }, {
    '1': 'mg',
    '3': 'mlg',
    'name': 'Malagasy',
    '2B': 'mlg',
    '2T': '',
    'local': 'Malagasy'
  }, {
    '1': 'mt',
    '3': 'mlt',
    'name': 'Maltese',
    '2B': 'mlt',
    '2T': '',
    'local': 'Malti'
  }, {
    '1': '',
    '3': 'mnc',
    'name': 'Manchu',
    '2B': 'mnc',
    '2T': '',
    'local': 'ᠮᠠᠨᠵᡠ ᡤᡳᠰᡠᠨ'
  }, {
    '1': '',
    '3': 'mni',
    'name': 'Manipuri',
    '2B': 'mni',
    '2T': '',
    'local': 'Manipuri'
  }, {
    '1': '',
    '3': '',
    'name': 'Manobo languages',
    '2B': 'mno',
    '2T': '',
    'local': 'Manobo languages'
  }, {
    '1': '',
    '3': 'moh',
    'name': 'Mohawk',
    '2B': 'moh',
    '2T': '',
    'local': 'Kanien’kéha'
  }, {
    '1': 'mn',
    '3': 'mon',
    'name': 'Mongolian',
    '2B': 'mon',
    '2T': '',
    'local': 'монгол хэл'
  }, {
    '1': '',
    '3': 'mos',
    'name': 'Mossi',
    '2B': 'mos',
    '2T': '',
    'local': 'Mooré'
  }, {
    '1': 'mi',
    '3': 'mri',
    'name': 'Maori',
    '2B': 'ao',
    '2T': 'mri',
    'local': 'Te Reo Māori'
  }, {
    '1': 'ms',
    '3': 'msa',
    'name': 'Malay',
    '2B': 'ay',
    '2T': 'msa',
    'local': 'Bahasa Melayu'
  }, {
    '1': '',
    '3': 'mul',
    'name': 'Multiple languages',
    '2B': 'mul',
    '2T': '',
    'local': 'Multiple languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Munda languages',
    '2B': 'mun',
    '2T': '',
    'local': 'Munda languages'
  }, {
    '1': '',
    '3': 'mus',
    'name': 'Creek',
    '2B': 'mus',
    '2T': '',
    'local': 'Mvskoke'
  }, {
    '1': '',
    '3': 'mwl',
    'name': 'Mirandese',
    '2B': 'mwl',
    '2T': '',
    'local': 'mirandés'
  }, {
    '1': '',
    '3': 'mwr',
    'name': 'Marwari',
    '2B': 'mwr',
    '2T': '',
    'local': 'मारवाड़ी'
  }, {
    '1': 'my',
    '3': 'mya',
    'name': 'Burmese',
    '2B': 'ur',
    '2T': 'mya',
    'local': 'မြန်မာစာ'
  }, {
    '1': '',
    '3': '',
    'name': 'Mayan languages',
    '2B': 'myn',
    '2T': '',
    'local': 'Mayan languages'
  }, {
    '1': '',
    '3': 'myv',
    'name': 'Erzya',
    '2B': 'myv',
    '2T': '',
    'local': 'эрзянь кель'
  }, {
    '1': '',
    '3': '',
    'name': 'Nahuatl languages',
    '2B': 'nah',
    '2T': '',
    'local': 'Nahuatl languages'
  }, {
    '1': '',
    '3': '',
    'name': 'North American Indian languages',
    '2B': 'nai',
    '2T': '',
    'local': 'North American Indian languages'
  }, {
    '1': '',
    '3': 'nap',
    'name': 'Neapolitan',
    '2B': 'nap',
    '2T': '',
    'local': 'napulitano'
  }, {
    '1': 'na',
    '3': 'nau',
    'name': 'Nauru',
    '2B': 'nau',
    '2T': '',
    'local': 'dorerin Naoero'
  }, {
    '1': 'nv',
    '3': 'nav',
    'name': 'Navajo',
    '2B': 'nav',
    '2T': '',
    'local': 'Diné bizaad'
  }, {
    '1': 'nr',
    '3': 'nbl',
    'name': 'South Ndebele',
    '2B': 'nbl',
    '2T': '',
    'local': 'isiNdebele seSewula'
  }, {
    '1': 'nd',
    '3': 'nde',
    'name': 'North Ndebele',
    '2B': 'nde',
    '2T': '',
    'local': 'siNdebele saseNyakatho'
  }, {
    '1': 'ng',
    '3': 'ndo',
    'name': 'Ndonga',
    '2B': 'ndo',
    '2T': '',
    'local': 'ndonga'
  }, {
    '1': '',
    '3': 'nds',
    'name': 'Low German',
    '2B': 'nds',
    '2T': '',
    'local': 'Plattdütsch'
  }, {
    '1': 'ne',
    '3': 'nep',
    'name': 'Nepali',
    '2B': 'nep',
    '2T': '',
    'local': 'नेपाली भाषा'
  }, {
    '1': '',
    '3': 'new',
    'name': 'Nepal Bhasa',
    '2B': 'new',
    '2T': '',
    'local': 'नेवाः भाय्'
  }, {
    '1': '',
    '3': 'nia',
    'name': 'Nias',
    '2B': 'nia',
    '2T': '',
    'local': 'Li Niha'
  }, {
    '1': '',
    '3': '',
    'name': 'Niger-Kordofanian languages',
    '2B': 'nic',
    '2T': '',
    'local': 'Niger-Kordofanian languages'
  }, {
    '1': '',
    '3': 'niu',
    'name': 'Niuean',
    '2B': 'niu',
    '2T': '',
    'local': 'ko e vagahau Niuē'
  }, {
    '1': 'nl',
    '3': 'nld',
    'name': 'Dutch',
    '2B': 'ut',
    '2T': 'nld',
    'local': 'Nederlands'
  }, {
    '1': 'nn',
    '3': 'nno',
    'name': 'Norwegian Nynorsk',
    '2B': 'nno',
    '2T': '',
    'local': 'nynorsk'
  }, {
    '1': 'nb',
    '3': 'nob',
    'name': 'Norwegian Bokmål',
    '2B': 'nob',
    '2T': '',
    'local': 'bokmål'
  }, {
    '1': '',
    '3': 'nog',
    'name': 'Nogai',
    '2B': 'nog',
    '2T': '',
    'local': 'Ногай тили'
  }, {
    '1': '',
    '3': 'non',
    'name': 'Old Norse',
    '2B': 'non',
    '2T': '',
    'local': 'Dǫnsk tunga'
  }, {
    '1': 'no',
    '3': 'nor',
    'name': 'Norwegian',
    '2B': 'nor',
    '2T': '',
    'local': 'norsk'
  }, {
    '1': '',
    '3': 'nqo',
    'name': 'N\'Ko',
    '2B': 'nqo',
    '2T': '',
    'local': 'N\'Ko'
  }, {
    '1': '',
    '3': 'nso',
    'name': 'Pedi',
    '2B': 'nso',
    '2T': '',
    'local': 'Sesotho sa Leboa'
  }, {
    '1': '',
    '3': '',
    'name': 'Nubian languages',
    '2B': 'nub',
    '2T': '',
    'local': 'لغات نوبية'
  }, {
    '1': '',
    '3': 'nwc',
    'name': 'Classical Newari',
    '2B': 'nwc',
    '2T': '',
    'local': 'पुलां भाय्'
  }, {
    '1': 'ny',
    '3': 'nya',
    'name': 'Chichewa',
    '2B': 'nya',
    '2T': '',
    'local': 'Chichewa'
  }, {
    '1': '',
    '3': 'nym',
    'name': 'Nyamwezi',
    '2B': 'nym',
    '2T': '',
    'local': 'Nyamwezi'
  }, {
    '1': '',
    '3': 'nyn',
    'name': 'Nyankole',
    '2B': 'nyn',
    '2T': '',
    'local': 'Nyankole'
  }, {
    '1': '',
    '3': 'nyo',
    'name': 'Nyoro',
    '2B': 'nyo',
    '2T': '',
    'local': 'Runyoro'
  }, {
    '1': '',
    '3': 'nzi',
    'name': 'Nzima',
    '2B': 'nzi',
    '2T': '',
    'local': 'Nzima'
  }, {
    '1': 'oc',
    '3': 'oci',
    'name': 'Occitan (post 1500)',
    '2B': 'oci',
    '2T': '',
    'local': 'occitan'
  }, {
    '1': 'oj',
    '3': 'oji',
    'name': 'Ojibwa',
    '2B': 'oji',
    '2T': '',
    'local': 'Ojibwa'
  }, {
    '1': 'or',
    '3': 'ori',
    'name': 'Oriya',
    '2B': 'ori',
    '2T': '',
    'local': 'ଓଡ଼ିଆ'
  }, {
    '1': 'om',
    '3': 'orm',
    'name': 'Oromo',
    '2B': 'orm',
    '2T': '',
    'local': 'Afaan Oromoo'
  }, {
    '1': '',
    '3': 'osa',
    'name': 'Osage',
    '2B': 'osa',
    '2T': '',
    'local': 'Wazhazhe ie / 𐓏𐓘𐓻𐓘𐓻𐓟 𐒻𐓟'
  }, {
    '1': 'os',
    '3': 'oss',
    'name': 'Ossetian',
    '2B': 'oss',
    '2T': '',
    'local': 'Ирон æвзаг'
  }, {
    '1': '',
    '3': 'ota',
    'name': 'Ottoman Turkish (1500–1928)',
    '2B': 'ota',
    '2T': '',
    'local': 'لسان عثمانى / lisân-ı Osmânî'
  }, {
    '1': '',
    '3': '',
    'name': 'Otomian languages',
    '2B': 'oto',
    '2T': '',
    'local': 'Otomian languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Papuan languages',
    '2B': 'paa',
    '2T': '',
    'local': 'Papuan languages'
  }, {
    '1': '',
    '3': 'pag',
    'name': 'Pangasinan',
    '2B': 'pag',
    '2T': '',
    'local': 'Salitan Pangasinan'
  }, {
    '1': '',
    '3': 'pal',
    'name': 'Pahlavi',
    '2B': 'pal',
    '2T': '',
    'local': 'Pārsīk'
  }, {
    '1': '',
    '3': 'pam',
    'name': 'Pampanga',
    '2B': 'pam',
    '2T': '',
    'local': 'Amánung Kapampangan'
  }, {
    '1': 'pa',
    '3': 'pan',
    'name': 'Panjabi',
    '2B': 'pan',
    '2T': '',
    'local': 'ਪੰਜਾਬੀ / پنجابی'
  }, {
    '1': '',
    '3': 'pap',
    'name': 'Papiamento',
    '2B': 'pap',
    '2T': '',
    'local': 'Papiamentu'
  }, {
    '1': '',
    '3': 'pau',
    'name': 'Palauan',
    '2B': 'pau',
    '2T': '',
    'local': 'a tekoi er a Belau'
  }, {
    '1': '',
    '3': 'peo',
    'name': 'Old Persian (ca. 600–400 B.C.)',
    '2B': 'peo',
    '2T': '',
    'local': 'Old Persian (ca. 600–400 B.C.)'
  }, {
    '1': 'fa',
    '3': 'fas',
    'name': 'Persian',
    '2B': 'per',
    '2T': 'fas',
    'local': 'فارسی'
  }, {
    '1': '',
    '3': '',
    'name': 'Philippine languages',
    '2B': 'phi',
    '2T': '',
    'local': 'Philippine languages'
  }, {
    '1': '',
    '3': 'phn',
    'name': 'Phoenician',
    '2B': 'phn',
    '2T': '',
    'local': '𐤃𐤁𐤓𐤉𐤌 𐤊𐤍𐤏𐤍𐤉𐤌'
  }, {
    '1': 'pi',
    '3': 'pli',
    'name': 'Pali',
    '2B': 'pli',
    '2T': '',
    'local': 'Pāli'
  }, {
    '1': 'pl',
    '3': 'pol',
    'name': 'Polish',
    '2B': 'pol',
    '2T': '',
    'local': 'Język polski'
  }, {
    '1': '',
    '3': 'pon',
    'name': 'Pohnpeian',
    '2B': 'pon',
    '2T': '',
    'local': 'Pohnpeian'
  }, {
    '1': 'pt',
    '3': 'por',
    'name': 'Portuguese',
    '2B': 'por',
    '2T': '',
    'local': 'português'
  }, {
    '1': '',
    '3': '',
    'name': 'Prakrit languages',
    '2B': 'pra',
    '2T': '',
    'local': 'Prakrit languages'
  }, {
    '1': '',
    '3': 'pro',
    'name': 'Old Provençal (to 1500)',
    '2B': 'pro',
    '2T': '',
    'local': 'Old Provençal (to 1500)'
  }, {
    '1': 'ps',
    '3': 'pus',
    'name': 'Pushto',
    '2B': 'pus',
    '2T': '',
    'local': 'پښتو'
  }, {
    '1': '',
    '3': 'qaa-qtz',
    'name': 'Reserved for local use',
    '2B': 'qaa-qtz',
    '2T': '',
    'local': 'Reserved for local use'
  }, {
    '1': 'qu',
    '3': 'que',
    'name': 'Quechua',
    '2B': 'que',
    '2T': '',
    'local': 'Runa simi'
  }, {
    '1': '',
    '3': 'raj',
    'name': 'Rajasthani',
    '2B': 'raj',
    '2T': '',
    'local': 'राजस्थानी'
  }, {
    '1': '',
    '3': 'rap',
    'name': 'Rapanui',
    '2B': 'rap',
    '2T': '',
    'local': 'Vananga rapa nui'
  }, {
    '1': '',
    '3': 'rar',
    'name': 'Rarotongan',
    '2B': 'rar',
    '2T': '',
    'local': 'Māori Kūki \'Āirani'
  }, {
    '1': '',
    '3': '',
    'name': 'Romance languages',
    '2B': 'roa',
    '2T': '',
    'local': 'Romance languages'
  }, {
    '1': 'rm',
    '3': 'roh',
    'name': 'Romansh',
    '2B': 'roh',
    '2T': '',
    'local': 'Rumantsch'
  }, {
    '1': '',
    '3': 'rom',
    'name': 'Romany',
    '2B': 'rom',
    '2T': '',
    'local': 'romani čhib'
  }, {
    '1': 'ro',
    '3': 'ron',
    'name': 'Romanian',
    '2B': 'um',
    '2T': 'ron',
    'local': 'limba română'
  }, {
    '1': 'ro',
    '3': 'ron',
    'name': 'Romanian',
    '2B': 'rum',
    '2T': 'ron',
    'local': 'limba română'
  }, {
    '1': 'rn',
    '3': 'run',
    'name': 'Rundi',
    '2B': 'run',
    '2T': '',
    'local': 'Ikirundi'
  }, {
    '1': '',
    '3': 'rup',
    'name': 'Aromanian',
    '2B': 'rup',
    '2T': '',
    'local': 'armãneashce'
  }, {
    '1': 'ru',
    '3': 'rus',
    'name': 'Russian',
    '2B': 'rus',
    '2T': '',
    'local': 'Русский язык'
  }, {
    '1': '',
    '3': 'sad',
    'name': 'Sandawe',
    '2B': 'sad',
    '2T': '',
    'local': 'Sandaweeki'
  }, {
    '1': 'sg',
    '3': 'sag',
    'name': 'Sango',
    '2B': 'sag',
    '2T': '',
    'local': 'yângâ tî sängö'
  }, {
    '1': '',
    '3': 'sah',
    'name': 'Yakut',
    '2B': 'sah',
    '2T': '',
    'local': 'Сахалыы'
  }, {
    '1': '',
    '3': '',
    'name': 'South American Indian languages',
    '2B': 'sai',
    '2T': '',
    'local': 'South American Indian languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Salishan languages',
    '2B': 'sal',
    '2T': '',
    'local': 'Salishan languages'
  }, {
    '1': '',
    '3': 'sam',
    'name': 'Samaritan Aramaic',
    '2B': 'sam',
    '2T': '',
    'local': 'ארמית'
  }, {
    '1': 'sa',
    '3': 'san',
    'name': 'Sanskrit',
    '2B': 'san',
    '2T': '',
    'local': 'संस्कृतम्'
  }, {
    '1': '',
    '3': 'sas',
    'name': 'Sasak',
    '2B': 'sas',
    '2T': '',
    'local': 'Sasak'
  }, {
    '1': '',
    '3': 'sat',
    'name': 'Santali',
    '2B': 'sat',
    '2T': '',
    'local': 'ᱥᱟᱱᱛᱟᱲᱤ'
  }, {
    '1': '',
    '3': 'scn',
    'name': 'Sicilian',
    '2B': 'scn',
    '2T': '',
    'local': 'Sicilianu'
  }, {
    '1': '',
    '3': 'sco',
    'name': 'Scots',
    '2B': 'sco',
    '2T': '',
    'local': 'Braid Scots'
  }, {
    '1': '',
    '3': 'sel',
    'name': 'Selkup',
    '2B': 'sel',
    '2T': '',
    'local': 'Selkup'
  }, {
    '1': '',
    '3': '',
    'name': 'Semitic languages',
    '2B': 'sem',
    '2T': '',
    'local': 'Semitic languages'
  }, {
    '1': '',
    '3': 'sga',
    'name': 'Old Irish (to 900)',
    '2B': 'sga',
    '2T': '',
    'local': 'Goídelc'
  }, {
    '1': '',
    '3': '',
    'name': 'Sign languages',
    '2B': 'sgn',
    '2T': '',
    'local': 'Sign languages'
  }, {
    '1': '',
    '3': 'shn',
    'name': 'Shan',
    '2B': 'shn',
    '2T': '',
    'local': 'ၵႂၢမ်းတႆးယႂ်'
  }, {
    '1': '',
    '3': 'sid',
    'name': 'Sidamo',
    '2B': 'sid',
    '2T': '',
    'local': 'Sidaamu Afoo'
  }, {
    '1': 'si',
    '3': 'sin',
    'name': 'Sinhala',
    '2B': 'sin',
    '2T': '',
    'local': 'සිංහල'
  }, {
    '1': '',
    '3': '',
    'name': 'Siouan languages',
    '2B': 'sio',
    '2T': '',
    'local': 'Siouan languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Sino-Tibetan languages',
    '2B': 'sit',
    '2T': '',
    'local': 'Sino-Tibetan languages'
  }, {
    '1': '',
    '3': '',
    'name': 'Slavic languages',
    '2B': 'sla',
    '2T': '',
    'local': 'Slavic languages'
  }, {
    '1': 'sk',
    '3': 'slk',
    'name': 'Slovak',
    '2B': 'slo',
    '2T': 'slk',
    'local': 'slovenčina'
  }, {
    '1': 'sk',
    '3': 'slk',
    'name': 'Slovak',
    '2B': 'lo',
    '2T': 'slk',
    'local': 'slovenčina'
  }, {
    '1': 'sl',
    '3': 'slv',
    'name': 'Slovenian',
    '2B': 'slv',
    '2T': '',
    'local': 'slovenski jezik'
  }, {
    '1': '',
    '3': 'sma',
    'name': 'Southern Sami',
    '2B': 'sma',
    '2T': '',
    'local': 'Åarjelsaemien gïele'
  }, {
    '1': 'se',
    '3': 'sme',
    'name': 'Northern Sami',
    '2B': 'sme',
    '2T': '',
    'local': 'davvisámegiella'
  }, {
    '1': '',
    '3': '',
    'name': 'Sami languages',
    '2B': 'smi',
    '2T': '',
    'local': 'Sami languages'
  }, {
    '1': '',
    '3': 'smj',
    'name': 'Lule Sami',
    '2B': 'smj',
    '2T': '',
    'local': 'julevsámegiella'
  }, {
    '1': '',
    '3': 'smn',
    'name': 'Inari Sami',
    '2B': 'smn',
    '2T': '',
    'local': 'anarâškielâ'
  }, {
    '1': 'sm',
    '3': 'smo',
    'name': 'Samoan',
    '2B': 'smo',
    '2T': '',
    'local': 'Gagana faʻa Sāmoa'
  }, {
    '1': '',
    '3': 'sms',
    'name': 'Skolt Sami',
    '2B': 'sms',
    '2T': '',
    'local': 'sääʹmǩiõll'
  }, {
    '1': 'sn',
    '3': 'sna',
    'name': 'Shona',
    '2B': 'sna',
    '2T': '',
    'local': 'chiShona'
  }, {
    '1': 'sd',
    '3': 'snd',
    'name': 'Sindhi',
    '2B': 'snd',
    '2T': '',
    'local': 'سنڌي / सिन्धी / ਸਿੰਧੀ'
  }, {
    '1': '',
    '3': 'snk',
    'name': 'Soninke',
    '2B': 'snk',
    '2T': '',
    'local': 'Sooninkanxanne'
  }, {
    '1': '',
    '3': 'sog',
    'name': 'Sogdian',
    '2B': 'sog',
    '2T': '',
    'local': 'Sogdian'
  }, {
    '1': 'so',
    '3': 'som',
    'name': 'Somali',
    '2B': 'som',
    '2T': '',
    'local': 'af Soomaali'
  }, {
    '1': '',
    '3': '',
    'name': 'Songhai languages',
    '2B': 'son',
    '2T': '',
    'local': 'Songhai languages'
  }, {
    '1': 'st',
    '3': 'sot',
    'name': 'Southern Sotho',
    '2B': 'sot',
    '2T': '',
    'local': 'Sesotho [southern]'
  }, {
    '1': 'es',
    '3': 'spa',
    'name': 'Spanish',
    '2B': 'spa',
    '2T': '',
    'local': 'Español'
  }, {
    '1': 'sq',
    '3': 'sqi',
    'name': 'Albanian',
    '2B': 'lb',
    '2T': 'sqi',
    'local': 'Shqip'
  }, {
    '1': 'sc',
    '3': 'srd',
    'name': 'Sardinian',
    '2B': 'srd',
    '2T': '',
    'local': 'sardu'
  }, {
    '1': '',
    '3': 'srn',
    'name': 'Sranan Tongo',
    '2B': 'srn',
    '2T': '',
    'local': 'Sranan Tongo'
  }, {
    '1': 'sr',
    '3': 'srp',
    'name': 'Serbian',
    '2B': 'srp',
    '2T': '',
    'local': 'српски / srpski'
  }, {
    '1': '',
    '3': 'srr',
    'name': 'Serer',
    '2B': 'srr',
    '2T': '',
    'local': 'Seereer'
  }, {
    '1': '',
    '3': '',
    'name': 'Nilo-Saharan languages',
    '2B': 'ssa',
    '2T': '',
    'local': 'Nilo-Saharan languages'
  }, {
    '1': 'ss',
    '3': 'ssw',
    'name': 'Swati',
    '2B': 'ssw',
    '2T': '',
    'local': 'siSwati'
  }, {
    '1': '',
    '3': 'suk',
    'name': 'Sukuma',
    '2B': 'suk',
    '2T': '',
    'local': 'Kɪsukuma'
  }, {
    '1': 'su',
    '3': 'sun',
    'name': 'Sundanese',
    '2B': 'sun',
    '2T': '',
    'local': 'ᮘᮞ ᮞᮥᮔ᮪ᮓ / Basa Sunda'
  }, {
    '1': '',
    '3': 'sus',
    'name': 'Susu',
    '2B': 'sus',
    '2T': '',
    'local': 'Sosoxui'
  }, {
    '1': '',
    '3': 'sux',
    'name': 'Sumerian',
    '2B': 'sux',
    '2T': '',
    'local': '𒅴𒂠'
  }, {
    '1': 'sw',
    '3': 'swa',
    'name': 'Swahili',
    '2B': 'swa',
    '2T': '',
    'local': 'Kiswahili'
  }, {
    '1': 'sv',
    '3': 'swe',
    'name': 'Swedish',
    '2B': 'swe',
    '2T': '',
    'local': 'svenska'
  }, {
    '1': '',
    '3': 'syc',
    'name': 'Classical Syriac',
    '2B': 'syc',
    '2T': '',
    'local': 'Classical Syriac'
  }, {
    '1': '',
    '3': 'syr',
    'name': 'Syriac',
    '2B': 'syr',
    '2T': '',
    'local': 'ܠܫܢܐ ܣܘܪܝܝܐ'
  }, {
    '1': 'ty',
    '3': 'tah',
    'name': 'Tahitian',
    '2B': 'tah',
    '2T': '',
    'local': 'Reo Tahiti'
  }, {
    '1': '',
    '3': '',
    'name': 'Tai languages',
    '2B': 'tai',
    '2T': '',
    'local': 'ภาษาไท'
  }, {
    '1': 'ta',
    '3': 'tam',
    'name': 'Tamil',
    '2B': 'tam',
    '2T': '',
    'local': 'தமிழ்'
  }, {
    '1': 'tt',
    '3': 'tat',
    'name': 'Tatar',
    '2B': 'tat',
    '2T': '',
    'local': 'татар теле / tatar tele / تاتار'
  }, {
    '1': 'te',
    '3': 'tel',
    'name': 'Telugu',
    '2B': 'tel',
    '2T': '',
    'local': 'తెలుగు'
  }, {
    '1': '',
    '3': 'tem',
    'name': 'Timne',
    '2B': 'tem',
    '2T': '',
    'local': 'KʌThemnɛ'
  }, {
    '1': '',
    '3': 'ter',
    'name': 'Tereno',
    '2B': 'ter',
    '2T': '',
    'local': 'Terêna'
  }, {
    '1': '',
    '3': 'tet',
    'name': 'Tetum',
    '2B': 'tet',
    '2T': '',
    'local': 'Lia-Tetun'
  }, {
    '1': 'tg',
    '3': 'tgk',
    'name': 'Tajik',
    '2B': 'tgk',
    '2T': '',
    'local': 'тоҷикӣ / tojikī'
  }, {
    '1': 'tl',
    '3': 'tgl',
    'name': 'Tagalog',
    '2B': 'tgl',
    '2T': '',
    'local': 'Wikang Tagalog'
  }, {
    '1': 'th',
    '3': 'tha',
    'name': 'Thai',
    '2B': 'tha',
    '2T': '',
    'local': 'ภาษาไทย'
  }, {
    '1': 'bo',
    '3': 'bod',
    'name': 'Tibetan',
    '2B': 'tib',
    '2T': 'bod',
    'local': 'བོད་སྐད་'
  }, {
    '1': '',
    '3': 'tig',
    'name': 'Tigre',
    '2B': 'tig',
    '2T': '',
    'local': 'ትግረ'
  }, {
    '1': 'ti',
    '3': 'tir',
    'name': 'Tigrinya',
    '2B': 'tir',
    '2T': '',
    'local': 'ትግርኛ'
  }, {
    '1': '',
    '3': 'tiv',
    'name': 'Tiv',
    '2B': 'tiv',
    '2T': '',
    'local': 'Tiv'
  }, {
    '1': '',
    '3': 'tkl',
    'name': 'Tokelau',
    '2B': 'tkl',
    '2T': '',
    'local': 'Tokelau'
  }, {
    '1': '',
    '3': 'tlh',
    'name': 'Klingon',
    '2B': 'tlh',
    '2T': '',
    'local': 'Klingon'
  }, {
    '1': '',
    '3': 'tli',
    'name': 'Tlingit',
    '2B': 'tli',
    '2T': '',
    'local': 'Lingít'
  }, {
    '1': '',
    '3': 'tmh',
    'name': 'Tamashek',
    '2B': 'tmh',
    '2T': '',
    'local': 'Tamashek'
  }, {
    '1': '',
    '3': 'tog',
    'name': 'Tonga (Nyasa)',
    '2B': 'tog',
    '2T': '',
    'local': 'chiTonga'
  }, {
    '1': 'to',
    '3': 'ton',
    'name': 'Tonga (Tonga Islands)',
    '2B': 'ton',
    '2T': '',
    'local': 'lea faka-Tonga'
  }, {
    '1': '',
    '3': 'tpi',
    'name': 'Tok Pisin',
    '2B': 'tpi',
    '2T': '',
    'local': 'Tok Pisin'
  }, {
    '1': '',
    '3': 'tsi',
    'name': 'Tsimshian',
    '2B': 'tsi',
    '2T': '',
    'local': 'Tsimshian'
  }, {
    '1': 'tn',
    '3': 'tsn',
    'name': 'Tswana',
    '2B': 'tsn',
    '2T': '',
    'local': 'Setswana'
  }, {
    '1': 'ts',
    '3': 'tso',
    'name': 'Tsonga',
    '2B': 'tso',
    '2T': '',
    'local': 'Xitsonga'
  }, {
    '1': 'tk',
    '3': 'tuk',
    'name': 'Turkmen',
    '2B': 'tuk',
    '2T': '',
    'local': 'Türkmençe / Түркменче / تورکمن تیلی ,تورکمنچه'
  }, {
    '1': '',
    '3': 'tum',
    'name': 'Tumbuka',
    '2B': 'tum',
    '2T': '',
    'local': 'chiTumbuka'
  }, {
    '1': '',
    '3': '',
    'name': 'Tupi languages',
    '2B': 'tup',
    '2T': '',
    'local': 'Tupi languages'
  }, {
    '1': 'tr',
    '3': 'tur',
    'name': 'Turkish',
    '2B': 'tur',
    '2T': '',
    'local': 'Türkçe'
  }, {
    '1': '',
    '3': '',
    'name': 'Altaic languages',
    '2B': 'tut',
    '2T': '',
    'local': 'Altaic languages'
  }, {
    '1': '',
    '3': 'tvl',
    'name': 'Tuvalua',
    '2B': 'tvl',
    '2T': '',
    'local': 'Te Ggana Tuuvalu'
  }, {
    '1': 'tw',
    '3': 'twi',
    'name': 'Twi',
    '2B': 'twi',
    '2T': '',
    'local': 'Twi'
  }, {
    '1': '',
    '3': 'tyv',
    'name': 'Tuvinian',
    '2B': 'tyv',
    '2T': '',
    'local': 'тыва дыл'
  }, {
    '1': '',
    '3': 'udm',
    'name': 'Udmurt',
    '2B': 'udm',
    '2T': '',
    'local': 'удмурт кыл'
  }, {
    '1': '',
    '3': 'uga',
    'name': 'Ugaritic',
    '2B': 'uga',
    '2T': '',
    'local': 'Ugaritic'
  }, {
    '1': 'ug',
    '3': 'uig',
    'name': 'Uighur',
    '2B': 'uig',
    '2T': '',
    'local': 'ئۇيغۇرچە  '
  }, {
    '1': 'uk',
    '3': 'ukr',
    'name': 'Ukrainian',
    '2B': 'ukr',
    '2T': '',
    'local': 'українська мова'
  }, {
    '1': '',
    '3': 'umb',
    'name': 'Umbundu',
    '2B': 'umb',
    '2T': '',
    'local': 'Úmbúndú'
  }, {
    '1': '',
    '3': 'und',
    'name': 'Undefined language',
    '2B': 'und',
    '2T': '',
    'local': 'Undefined language'
  }, {
    '1': 'ur',
    '3': 'urd',
    'name': 'Urdu',
    '2B': 'urd',
    '2T': '',
    'local': 'اُردُو'
  }, {
    '1': 'uz',
    '3': 'uzb',
    'name': 'Uzbek',
    '2B': 'uzb',
    '2T': '',
    'local': 'Oʻzbekcha / ўзбекча / ئوزبېچه'
  }, {
    '1': '',
    '3': 'vai',
    'name': 'Vai',
    '2B': 'vai',
    '2T': '',
    'local': 'ꕙꔤ'
  }, {
    '1': 've',
    '3': 'ven',
    'name': 'Venda',
    '2B': 'ven',
    '2T': '',
    'local': 'Tshivenḓa'
  }, {
    '1': 'vi',
    '3': 'vie',
    'name': 'Vietnamese',
    '2B': 'vie',
    '2T': '',
    'local': 'Tiếng Việt'
  }, {
    '1': 'vo',
    '3': 'vol',
    'name': 'Volapük',
    '2B': 'vol',
    '2T': '',
    'local': 'Volapük'
  }, {
    '1': '',
    '3': 'vot',
    'name': 'Votic',
    '2B': 'vot',
    '2T': '',
    'local': 'vađđa ceeli'
  }, {
    '1': '',
    '3': '',
    'name': 'Wakashan languages',
    '2B': 'wak',
    '2T': '',
    'local': 'Wakashan languages'
  }, {
    '1': '',
    '3': 'wal',
    'name': 'Wolaitta',
    '2B': 'wal',
    '2T': '',
    'local': 'Wolaitta'
  }, {
    '1': '',
    '3': 'war',
    'name': 'Waray',
    '2B': 'war',
    '2T': '',
    'local': 'Winaray'
  }, {
    '1': '',
    '3': 'was',
    'name': 'Washo',
    '2B': 'was',
    '2T': '',
    'local': 'wá:šiw ʔítlu'
  }, {
    '1': 'cy',
    '3': 'cym',
    'name': 'Welsh',
    '2B': 'wel',
    '2T': 'cym',
    'local': 'Cymraeg'
  }, {
    '1': '',
    '3': '',
    'name': 'Sorbian languages',
    '2B': 'wen',
    '2T': '',
    'local': 'Serbsce / Serbski'
  }, {
    '1': 'wa',
    '3': 'wln',
    'name': 'Walloon',
    '2B': 'wln',
    '2T': '',
    'local': 'Walon'
  }, {
    '1': 'wo',
    '3': 'wol',
    'name': 'Wolof',
    '2B': 'wol',
    '2T': '',
    'local': 'Wolof'
  }, {
    '1': '',
    '3': 'xal',
    'name': 'Kalmyk',
    '2B': 'xal',
    '2T': '',
    'local': 'Хальмг келн / Xaľmg keln'
  }, {
    '1': 'xh',
    '3': 'xho',
    'name': 'Xhosa',
    '2B': 'xho',
    '2T': '',
    'local': 'isiXhosa'
  }, {
    '1': '',
    '3': 'yao',
    'name': 'Yao',
    '2B': 'yao',
    '2T': '',
    'local': 'Yao'
  }, {
    '1': '',
    '3': 'yap',
    'name': 'Yapese',
    '2B': 'yap',
    '2T': '',
    'local': 'Yapese'
  }, {
    '1': 'yi',
    '3': 'yid',
    'name': 'Yiddish',
    '2B': 'yid',
    '2T': '',
    'local': 'ייִדיש, יידיש'
  }, {
    '1': 'yo',
    '3': 'yor',
    'name': 'Yoruba',
    '2B': 'yor',
    '2T': '',
    'local': 'èdè Yorùbá'
  }, {
    '1': '',
    '3': '',
    'name': 'Yupik languages',
    '2B': 'ypk',
    '2T': '',
    'local': 'Yupik languages'
  }, {
    '1': '',
    '3': 'zap',
    'name': 'Zapotec',
    '2B': 'zap',
    '2T': '',
    'local': 'Diidxazá'
  }, {
    '1': '',
    '3': 'zbl',
    'name': 'Blissymbols',
    '2B': 'zbl',
    '2T': '',
    'local': 'Blissymbols'
  }, {
    '1': '',
    '3': 'zen',
    'name': 'Zenaga',
    '2B': 'zen',
    '2T': '',
    'local': 'Tuḍḍungiyya'
  }, {
    '1': '',
    '3': 'zgh',
    'name': 'Standard Moroccan Tamazight',
    '2B': 'zgh',
    '2T': '',
    'local': 'ⵜⴰⵎⴰⵣⵉⵖⵜ ⵜⴰⵏⴰⵡⴰⵢⵜ'
  }, {
    '1': 'za',
    '3': 'zha',
    'name': 'Zhuang',
    '2B': 'zha',
    '2T': '',
    'local': 'Vahcuengh / 話僮'
  }, {
    '1': 'zh',
    '3': 'zho',
    'name': 'Chinese',
    '2B': 'hi',
    '2T': 'zho',
    'local': '中文'
  }, {
    '1': '',
    '3': '',
    'name': 'Zande languages',
    '2B': 'znd',
    '2T': '',
    'local': 'Zande languages'
  }, {
    '1': 'zu',
    '3': 'zul',
    'name': 'Zulu',
    '2B': 'zul',
    '2T': '',
    'local': 'isiZulu'
  }, {
    '1': '',
    '3': 'zun',
    'name': 'Zuni',
    '2B': 'zun',
    '2T': '',
    'local': 'Shiwi\'ma'
  }, {
    '1': '',
    '3': 'zxx',
    'name': 'No linguistic content',
    '2B': 'zxx',
    '2T': '',
    'local': 'No linguistic content'
  }, {
    '1': '',
    '3': 'zza',
    'name': 'Zaza',
    '2B': 'zza',
    '2T': '',
    'local': 'Zaza'
  }];
})(OO);

},{}],60:[function(require,module,exports){
"use strict";

(function (OO) {
  OO.MESSAGES = {
    EN: {},
    ES: {},
    FR: {},
    JA: {}
  };
  var en = OO.MESSAGES.EN;
  var es = OO.MESSAGES.ES;
  var fr = OO.MESSAGES.FR;
  var ja = OO.MESSAGES.JA; // ENGLISH

  en[OO.ERROR.API.NETWORK] = 'Cannot Contact Server';
  en[OO.ERROR.API.SAS.GENERIC] = 'Invalid Authorization Response';
  en[OO.ERROR.API.SAS.GEO] = 'This video is not authorized in your location';
  en[OO.ERROR.API.SAS.DOMAIN] = 'This video is not authorized for your domain';
  en[OO.ERROR.API.SAS.FUTURE] = 'This video will be available soon';
  en[OO.ERROR.API.SAS.PAST] = 'This video is no longer available';
  en[OO.ERROR.API.SAS.DEVICE] = 'This video is not authorized for playback on this device';
  en[OO.ERROR.API.SAS.PROXY] = 'An anonymous proxy was detected. Please disable the proxy and retry.';
  en[OO.ERROR.API.SAS.CONCURRENT_STREAMS] = 'You have exceeded the maximum number of concurrent streams';
  en[OO.ERROR.API.SAS.INVALID_HEARTBEAT] = 'Invalid heartbeat response';
  en[OO.ERROR.API.SAS.ERROR_INVALID_ENTITLEMENTS] = 'User Entitlement Terminated - ' + 'Stream No Longer Active for the User';
  en[OO.ERROR.API.CONTENT_TREE] = 'Invalid Content';
  en[OO.ERROR.API.METADATA] = 'Invalid Metadata';
  en[OO.ERROR.PLAYBACK.GENERIC] = 'Could not play the content';
  en[OO.ERROR.PLAYBACK.STREAM] = "This video isn't encoded for your device";
  en[OO.ERROR.PLAYBACK.LIVESTREAM] = 'Live stream is off air';
  en[OO.ERROR.PLAYBACK.NETWORK] = 'Network connection temporarily lost';
  en[OO.ERROR.UNPLAYABLE_CONTENT] = 'This video is not playable on this player';
  en[OO.ERROR.INVALID_EXTERNAL_ID] = 'Invalid External ID';
  en[OO.ERROR.EMPTY_CHANNEL] = 'This channel is empty';
  en[OO.ERROR.EMPTY_CHANNEL_SET] = 'This channel set is empty';
  en[OO.ERROR.CHANNEL_CONTENT] = 'This channel is not playable at this time';
  en[OO.ERROR.VC_PLAY_FAILED] = 'This video is not encoded for your device';
  en[OO.TEXT.ADS_COUNTDOWN] = 'Advertisement: Your Video will resume shortly';
  en[OO.TEXT.ADS_COUNTDOWN_SECONDS] = 'Advertisement: Your Video will resume in <%= time %> <%= seconds %>';
  en[OO.TEXT.LIVE] = 'LIVE'; // SPANISH

  es[OO.ERROR.API.NETWORK] = 'No se puede contactar al servidor';
  es[OO.ERROR.API.SAS.GENERIC] = 'Respuesta de autorización no válida';
  es[OO.ERROR.API.SAS.GEO] = 'El vídeo no está autorizado en su ubicación';
  es[OO.ERROR.API.SAS.DOMAIN] = 'El vídeo no está autorizado para su dominio';
  es[OO.ERROR.API.SAS.FUTURE] = 'El vídeo estará disponible pronto';
  es[OO.ERROR.API.SAS.PAST] = 'El vídeo ya no está disponible';
  es[OO.ERROR.API.SAS.DEVICE] = 'El vídeo no está autorizado para reproducirse en este dispositivo';
  es[OO.ERROR.API.SAS.PROXY] = 'Se detectó un proxy anónimo. Deshabilite el proxy e intente nuevamente.';
  es[OO.ERROR.API.SAS.CONCURRENT_STREAMS] = 'Ha superado la cantidad máxima de transmisiones concurrentes';
  es[OO.ERROR.API.SAS.INVALID_HEARTBEAT] = 'Respuesta de pulso no válida';
  es[OO.ERROR.API.SAS.ERROR_INVALID_ENTITLEMENTS] = 'La suscripción del usuario a terminado - ' + 'El video ya no está disponible para el usuario';
  es[OO.ERROR.API.CONTENT_TREE] = 'Contenido no válido';
  es[OO.ERROR.API.METADATA] = 'Metadatos no válidos';
  es[OO.ERROR.PLAYBACK.GENERIC] = 'No se pudo reproducir el contenido';
  es[OO.ERROR.PLAYBACK.STREAM] = 'El vídeo no está codificado para su dispositivo';
  es[OO.ERROR.PLAYBACK.LIVESTREAM] = 'La transmisión en vivo está fuera del aire';
  es[OO.ERROR.PLAYBACK.NETWORK] = 'La conexión de red se halla temporalmente perdida';
  es[OO.ERROR.UNPLAYABLE_CONTENT] = 'El vídeo no se puede reproducir en este reproductor';
  es[OO.ERROR.INVALID_EXTERNAL_ID] = 'ID externo no válido';
  es[OO.ERROR.EMPTY_CHANNEL] = 'El canal está vacío';
  es[OO.ERROR.EMPTY_CHANNEL_SET] = 'El conjunto de canales está vacío';
  es[OO.ERROR.CHANNEL_CONTENT] = 'El canal no se puede reproducir en este momento';
  es[OO.ERROR.VC_PLAY_FAILED] = 'El vídeo no está codificado para su dispositivo';
  es[OO.TEXT.ADS_COUNTDOWN] = 'Anuncio: el vídeo se reanudará en breve';
  es[OO.TEXT.LIVE] = 'EN VIVO'; // FRENCH

  fr[OO.ERROR.API.NETWORK] = 'Impossible de contacter le serveur';
  fr[OO.ERROR.API.SAS.GENERIC] = "Réponse d'autorisation non valide";
  fr[OO.ERROR.API.SAS.GEO] = "Cette vidéo n'est pas autorisée dans votre pays";
  fr[OO.ERROR.API.SAS.DOMAIN] = "Cette vidéo n'est pas autorisée pour votre domaine";
  fr[OO.ERROR.API.SAS.FUTURE] = 'Cette vidéo sera bientôt disponible';
  fr[OO.ERROR.API.SAS.PAST] = "Cette vidéo n'est plus disponible";
  fr[OO.ERROR.API.SAS.DEVICE] = "La lecture de cette vidéo n'est pas autorisée sur cet appareil";
  fr[OO.ERROR.API.SAS.PROXY] = 'Un proxy anonyme a été détecté. Désactivez le proxy, puis réessayez.';
  fr[OO.ERROR.API.SAS.CONCURRENT_STREAMS] = 'Vous avez dépassé le nombre maximum de flux simultanés.';
  fr[OO.ERROR.API.SAS.INVALID_HEARTBEAT] = "Réponse du signal de pulsation ('heartbeat') non valide";
  fr[OO.ERROR.API.CONTENT_TREE] = 'Contenu non valide';
  fr[OO.ERROR.API.METADATA] = 'Métadonnées non valides';
  fr[OO.ERROR.PLAYBACK.GENERIC] = 'Impossible de lire le contenu';
  fr[OO.ERROR.PLAYBACK.STREAM] = "Cette vidéo n'est pas encodée pour votre appareil";
  fr[OO.ERROR.PLAYBACK.LIVESTREAM] = 'Le flux direct a été interrompu';
  fr[OO.ERROR.PLAYBACK.NETWORK] = 'Connexion au réseau temporairement interrompue';
  fr[OO.ERROR.UNPLAYABLE_CONTENT] = 'Vous ne pouvez pas lire cette vidéo sur ce lecteur';
  fr[OO.ERROR.INVALID_EXTERNAL_ID] = 'Identifiant externe non valide';
  fr[OO.ERROR.EMPTY_CHANNEL] = 'Cette chaîne est vide';
  fr[OO.ERROR.EMPTY_CHANNEL_SET] = 'Ce groupe de chaînes est vide';
  fr[OO.ERROR.CHANNEL_CONTENT] = 'Vous ne pouvez pas lire cette chaîne pour le moment';
  fr[OO.ERROR.VC_PLAY_FAILED] = "Cette vidéo n'est pas encodée pour votre appareil";
  fr[OO.TEXT.ADS_COUNTDOWN] = 'Publicité : votre vidéo reprendra bientôt';
  fr[OO.TEXT.LIVE] = 'EN DIRECT'; // JAPANESE

  ja[OO.ERROR.API.NETWORK] = '後でご確認ください。';
  ja[OO.ERROR.API.SAS.GENERIC] = 'ビデオを認証できません。';
  ja[OO.ERROR.API.SAS.GEO] = 'この地域ではこのビデオは許可されていません。';
  ja[OO.ERROR.API.SAS.DOMAIN] = 'お使いのドメインではこのビデオは許可されていません。';
  ja[OO.ERROR.API.SAS.FUTURE] = 'このビデオはしばらくすると再生可能になります。';
  ja[OO.ERROR.API.SAS.PAST] = 'このビデオは、既に御利用いただけません。';
  ja[OO.ERROR.API.SAS.DEVICE] = 'このビデオは、このデバイスでの再生は許可されていません。';
  ja[OO.ERROR.API.SAS.CONCURRENT_STREAMS] = '最大同時接続数を超えています。';
  ja[OO.ERROR.API.SAS.INVALID_HEARTBEAT] = '同時再生ストリームの最大数に達しました。';
  ja[OO.ERROR.API.CONTENT_TREE] = '不正なコンテンツです。';
  ja[OO.ERROR.API.METADATA] = '不正なメタデータです。';
  ja[OO.ERROR.PLAYBACK.GENERIC] = 'このコンテンツを再生できませんでした。';
  ja[OO.ERROR.PLAYBACK.STREAM] = 'このビデオは、お使いのデバイス向けにエンコードされていません。';
  ja[OO.ERROR.PLAYBACK.LIVESTREAM] = 'ライブ配信はされておりません。';
  ja[OO.ERROR.PLAYBACK.NETWORK] = 'ネットワークに一時的に接続できません。';
  ja[OO.ERROR.UNPLAYABLE_CONTENT] = 'このビデオは、このプレーヤーでは再生できません。';
  ja[OO.ERROR.INVALID_EXTERNAL_ID] = 'External IDが不正です。';
  ja[OO.ERROR.EMPTY_CHANNEL] = 'このチャンネルは空です。';
  ja[OO.ERROR.EMPTY_CHANNEL_SET] = 'このチャンネルセットは空です。';
  ja[OO.ERROR.CHANNEL_CONTENT] = 'このチャンネルは、現在再生できません。';
  ja[OO.ERROR.VC_PLAY_FAILED] = 'このビデオは、お使いのデバイス向けにエンコードされていません。';
  ja[OO.TEXT.ADS_COUNTDOWN] = '広告：';
  ja[OO.TEXT.ADS_COUNTDOWN_SECONDS] = '広告: <%= time %>数秒後にビデオの再生が開始します';
  ja[OO.TEXT.LIVE] = 'ライブ';

  OO.getLocalizedMessage = function (code) {
    var language = OO.getLocale();
    return (OO.MESSAGES[language] ? OO.MESSAGES[language][code] : undefined) || OO.MESSAGES.EN[code] || '';
  };
})(OO);

},{}],61:[function(require,module,exports){
"use strict";

(function (OO) {
  // place holder for all text resource key
  OO.TEXT = {
    ADS_COUNTDOWN: 'adsCountdown',
    ADS_COUNTDOWN_SECONDS: 'adsCountdownSeconds',
    LIVE: 'LIVE',
    __end_marker: true
  };
})(OO);

},{}],62:[function(require,module,exports){
"use strict";

require('./include/init.js');

require('./core/3rd_party_initializer.js');

require('./core/environment.js');

require('./include/constants.js');

require('./include/resource.js');

require('./include/messages.js');

require('./include/languages.js');

require('./autogen/stylus_css.js');

require('./autogen/oo_rev.js');

require('./assets/asset_utils.js');

require('./core/utils.js');

require('./core/emitter.js');

require('./core/message_bus.js');

require('./core/state_machine.js');

require('./core/registration.js');

require('./core/player.js');

require('./core/playerExternalApi.js');

require('./modules/ooyala_storage.js');

require('./modules/device_id.js');

require('./modules/chromeless_ui.js');

require('./modules/ha_failover.js');

require('./modules/asset/asset_controller.js');

require('./modules/playback/playback_controller.js');

require('./modules/playback/video_controller.js');

require('./modules/valhalla_cache.js');

require('./modules/api.js');

require('./modules/channels.js');

require('./modules/external_id.js');

require('./modules/auth_heartbeat.js');

require('./modules/ads/ad_manager_controller.js');

require('./modules/ads/ad_manager_ooyala.js');

require('../html5-analytics-plugins/js/framework/AnalyticsFramework.js');

require('../html5-analytics-plugins/js/plugins/iq.js');

require('./modules/analytics/analytics_framework_translator.js');

require('./analytics/analytics.js');

require('./analytics/analytics_base.js');

require('./analytics/ooyala_analytics.js');

require('./modules/plugins/librato.js');

require('./modules/chromecastSender.js');

require('./modules/airplay.js');

},{"../html5-analytics-plugins/js/framework/AnalyticsFramework.js":5,"../html5-analytics-plugins/js/plugins/iq.js":7,"./analytics/analytics.js":42,"./analytics/analytics_base.js":43,"./analytics/ooyala_analytics.js":44,"./assets/asset_utils.js":45,"./autogen/oo_rev.js":46,"./autogen/stylus_css.js":47,"./core/3rd_party_initializer.js":48,"./core/emitter.js":49,"./core/environment.js":50,"./core/message_bus.js":51,"./core/player.js":52,"./core/playerExternalApi.js":53,"./core/registration.js":54,"./core/state_machine.js":55,"./core/utils.js":56,"./include/constants.js":57,"./include/init.js":58,"./include/languages.js":59,"./include/messages.js":60,"./include/resource.js":61,"./modules/ads/ad_manager_controller.js":63,"./modules/ads/ad_manager_ooyala.js":64,"./modules/airplay.js":65,"./modules/analytics/analytics_framework_translator.js":66,"./modules/api.js":67,"./modules/asset/asset_controller.js":68,"./modules/auth_heartbeat.js":69,"./modules/channels.js":70,"./modules/chromecastSender.js":71,"./modules/chromeless_ui.js":72,"./modules/device_id.js":73,"./modules/external_id.js":74,"./modules/ha_failover.js":75,"./modules/ooyala_storage.js":76,"./modules/playback/playback_controller.js":77,"./modules/playback/video_controller.js":78,"./modules/plugins/librato.js":79,"./modules/valhalla_cache.js":80}],63:[function(require,module,exports){
(function (global){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/*
 * Ad Manager Controller
 *
 * owner: PBI
 * version: 1.0
 *
 */

/* eslint no-magic-numbers: "off" */
(function (OO, _, $) {
  /**
   * The ad manager controller has finished playing postrolls. This is still fired with a postroll count of 0.
   *
   *
   * @event OO.EVENTS#AMC_ALL_ADS_DONE
   */
  OO.EVENTS.AMC_ALL_ADS_DONE = 'adManagerControllerAllAdsDone';
  /**
   * The ad manager controller has finished playing prerolls. This is still fired with a preroll count of 0.
   *
   *
   * @event OO.EVENTS#AMC_PREROLLS_DONE
   */

  OO.EVENTS.AMC_PREROLLS_DONE = 'adManagerControllerPrerollsDone';
  /**
   * The ad manager controller has finished initializing. The handler is called with an object
   * of the following structure:
   *
   * <ul>
   *   <li>prerolls: The number of prerolls the ad manager controller has detected in its timeline</li>
   * </ul>
   *
   * @event OO.EVENTS#AMC_ALL_READY
   */

  OO.EVENTS.AMC_ALL_READY = 'adManagerControllerAllReady';
  /**
   * The ad manager will now prepare for ad playback. Will bring the ad manager controller into linear ad mode.
   *
   *
   * @event OO.EVENTS#AMC_AD_SETUP
   */

  OO.EVENTS.AMC_AD_SETUP = 'adManagerControllerAdSetup';
  /**
  * A set of ads from an ad manager has started. This may be followed by multiple WILL_PLAY_SINGLE_AD/SINGLE_AD_PLAYED events.
  *
  *
  * @event OO.EVENTS#AD_POD_STARTED
  */

  OO.EVENTS.AD_POD_STARTED = 'adPodStarted';
  /**
  * A set of ads from an ad manager has ended.
  *
  *
  * @event OO.EVENTS#AD_POD_ENDED
  */

  OO.EVENTS.AD_POD_ENDED = 'adPodEnded';
  /**
  * A nonlinear ad has finished playing.
  *
  *
  * @event OO.EVENTS#NONLINEAR_AD_PLAYED
  */

  OO.EVENTS.NONLINEAR_AD_PLAYED = 'nonlinearAdPlayed';
  /**
  * A nonlinear ad will be hidden. This will not count against the clock timer determining how long the ad will be shown.
  *
  *
  * @event OO.EVENTS#HIDE_NONLINEAR_AD
  */

  OO.EVENTS.HIDE_NONLINEAR_AD = 'hideNonlinearAd';
  /**
  * A hidden nonlinear ad will be shown.
  *
  *
  * @event OO.EVENTS#SHOW_NONLINEAR_AD
  */

  OO.EVENTS.SHOW_NONLINEAR_AD = 'showNonlinearAd';
  /**
  * A nonlinear ad will now display a close button.
  *
  *
  * @event OO.EVENTS#SHOW_NONLINEAR_AD_CLOSE_BUTTON
  */

  OO.EVENTS.SHOW_NONLINEAR_AD_CLOSE_BUTTON = 'showNonlinearAdCloseButton';
  /**
  * A nonlinear ad was loaded in the UI.
  *
  *
  * @event OO.EVENTS#NONLINEAR_AD_DISPLAYED
  */

  OO.EVENTS.NONLINEAR_AD_DISPLAYED = 'nonlinearAdDisplayed';
  /**
  * An individual ad manager is taking control of the session to play an ad. This only happens when an ad manager controls its own timeline.
  *
  *
  * @event OO.EVENTS#AD_MANAGER_HANDLED_ADS
  */

  OO.EVENTS.AD_MANAGER_HANDLED_ADS = 'adManagerHandledAds';
  /**
  * A linear ad can now enable or display a skip button.
  *
  *
  * @event OO.EVENTS#SHOW_AD_SKIP_BUTTON
  */

  OO.EVENTS.SHOW_AD_SKIP_BUTTON = 'showAdSkipButton';
  /**
   * Event for signaling Ad Controls (Scrubber bar and Control bar) rendering:
   *   <ul>
   *     <li>Boolean parameter, 'false' to not show ad controls, 'true' to show ad controls based on skin config</li>
   *   </ul>
   *
   *
   * @event OO.EVENTS#SHOW_AD_CONTROLS
   */

  OO.EVENTS.SHOW_AD_CONTROLS = 'showAdControls';
  /**
   * Event for signaling Ad Marquee rendering:
   *   <ul>
   *     <li>Boolean parameter, 'false' to not show ad marquee, 'true' to show ad marquee based on skin config</li>
   *   </ul>
   *
   *
   * @event OO.EVENTS#SHOW_AD_MARQUEE
   */

  OO.EVENTS.SHOW_AD_MARQUEE = 'showAdMarquee';
  /**
   * Event for signaling that an Ad Clickthrough URL has opened a new window.
   *
   * @event OO.EVENTS#ADS_CLICKTHROUGH_OPENED
   */

  OO.EVENTS.ADS_CLICKTHROUGH_OPENED = 'adsClickthroughOpened'; // Timeouts

  var MAX_AD_MANAGER_LOAD_TIMEOUT = 3000;
  var MAX_AD_LOAD_TIMEOUT = 25000;
  var DEFAULT_VIDEO_SKIP_BUTTON_TIME = 5; // Maximum duration for ad request before timeout

  var MAX_AD_REQUEST_TIMEOUT = 8000;
  var POSTROLL_POSITION = 1000000000; // same number used in backlot

  /**
   * The list of registered ad managers.
   *   key: ad manager name (the name property of the ad manager object)
   *   value: ad manager (object)
   * @private
   */

  var adManagerFactories = {}; // Settings to store in adManagerSettings.  These could come from the page or the server.

  var SETTINGS = {
    PAUSE_AD_ON_CLICK: 'pauseAdOnClick',
    AD_MANAGER_LOAD_TIMEOUT: 'adManagerLoadTimeout',
    AD_LOAD_TIMEOUT: 'adLoadTimeout',
    DISPLAY_CUE_POINTS: 'displayCuePointMarkers',
    REPLAY_ADS: 'replayAds',
    SHOW_NONLINEAR_CLOSE_BUTTON: 'showNonLinearCloseButton',
    SHOW_LINEAR_AD_SKIP_BUTTON: 'showLinearAdSkipButton',
    LINEAR_AD_SKIP_BUTTON_START_TIME: 'linearAdSkipButtonStartTime',
    ALLOW_AD_CLICK_THROUGH_ON_VIDEO: 'allowAdClickThroughOnVideo',
    PAUSE_ON_LIVE_ADS: 'pauseOnLiveAds',
    DELAY_FOR_PREROLL: 'delayForPreroll',
    LATE_PREROLL_RESTART_THRESHOLD: 'latePrerollRestartThreshold',
    PRELOAD_ADS: 'preloadAds'
  };
  /**
   * This array is used to keep a list of all ad managers that were unregistered before the controller was
   * setup. The controller will use this list to raise an event for each unregistered ad manager.
   * @private
   * @type {Array}
   */

  var unregisteredAdManagerFactories = [];
  /**
   * @class OO.Ads
   * @classdesc Enables you to register, verify, and unregister ad managers within the Ooyala player.
   * The related ad manager events are not processed on the standard message bus.
   * @public
   */

  OO.Ads = {
    /**
     * Registers a new ad manager factory. The factory will be used to instantiate ad managers
     * when the player is created. The format of the resulting ad manager is validated and the
     * ad manager factory is only registered if the ad manager defines the required functions and properties.
     * @public
     * @method OO.Ads#manager
     * @param {object} adManagerFactory The ad manager factory function to register
     */
    manager: function manager(adManagerFactory) {
      if (typeof adManagerFactory === 'function') {
        // validate the resulting ad manager
        var adManager = adManagerFactory.apply({}, [_, $]);

        if (OO.Ads.validateAdManager(adManager)) {
          OO.log('AMC: Registering ad manager factory: ' + adManager.name);
          adManagerFactories[adManager.name] = adManagerFactory;
        }
      }
    },

    /**
     * Unregisters an ad manager factory.
     * @public
     * @method OO.Ads#unregisterAdManager
     * @memberOf OO.Ads
     * @param {string} name The name of the ad manager factory to unregister, traditionally represented by
     *                      the resulting ad manager instance adManager.name
     */
    unregisterAdManager: function unregisterAdManager(name) {
      OO.log('AMC: Removing an ad manager factory: ' + name);

      if (name && adManagerFactories[name]) {
        unregisteredAdManagerFactories.push(name);
        delete adManagerFactories[name];
      }
    },

    /**
     * Validates the format of an ad manager and checks if the ad manager is already registered.<br/>
     * The ad manager must define the following functions:<br/>
     * <ul><li>initialize</li>
     *     <li>buildTimeline</li>
     *     <li>playAd</li>
     *     <li>cancelAd</li> </ul>
     * The ad manager must define the following properties:
     * <ul><li>name (string)</li>
     *     <li>ready (boolean)</li></ul>
     * @public
     * @method validateAdManager
     * @memberOf OO.Ads
     * @instance
     * @param {object} adManager The ad manager object
     * @returns {boolean} <code>true</code> if the ad manager meets the template requirements, <code>false</code> otherwise.
     */
    validateAdManager: function validateAdManager(adManager) {
      var properties = {
        'name': 'string',
        'ready': 'boolean'
      };
      var functions = ['initialize', 'buildTimeline', 'playAd', 'cancelAd'];
      /**
       *
       * @param {String} errorString - error msg
       */

      function raiseValidationError(errorString) {
        OO.log('AMC: ' + errorString); // TODO - raise real error
        // mb.publish(OO.EVENTS.ERROR, { code : OO.ERROR.NEW_CODE });
      }
      /**
       *
       * @param {String} propertyName - ?
       * @param {String} propertyType - ?
       * @param {String} managerName - ?
       * @returns {boolean} true if the property in adManager is given type
       */


      function checkForProperty(propertyName, propertyType, managerName) {
        if (!_.has(adManager, propertyName)) {
          raiseValidationError('The ad manager "' + managerName + '" requires a "' + propertyName + '" property');
          return false;
        }

        if ((0, _typeof2.default)(adManager[propertyName]) !== propertyType) {
          // eslint-disable-line valid-typeof
          raiseValidationError('The ad manager "' + managerName + '" property "' + propertyName + '" should be type "' + propertyType + '"');
          return false;
        }

        return true;
      }
      /**
       *
       * @param {String} functionName - ?
       * @param {String} managerName - ?
       * @returns {boolean} true if adManager has the functionName, otherwise false
       */


      function checkForFunction(functionName, managerName) {
        if (!_.isFunction(adManager[functionName])) {
          raiseValidationError('The ad manager "' + managerName + '" requires a "' + functionName + '" function');
          return false;
        }

        return true;
      }

      if (!adManager) {
        raiseValidationError(' The ad manager must be defined');
        return false;
      }

      if (!_.isObject(adManager)) {
        raiseValidationError('The ad manager must be an object');
        return false;
      }

      for (var key in properties) {
        if (!checkForProperty(key, properties[key], adManager.name)) return false;
      }

      for (var funcIndex = 0; funcIndex < functions.length; funcIndex++) {
        if (!checkForFunction(functions[funcIndex], adManager.name)) return false;
      }

      if (adManagerFactories[adManager.name]) {
        raiseValidationError('The ad manager "' + adManager.name + '" has already been registered');
        return false;
      }

      return true;
    },

    /**
     * Returns the names of ad managers that were registered but have been unregistered.
     * This is used in testing.
     * @method OO.Ads#getUnregisteredAdManagers
     * @public
     * @returns {string[]} A list of all ad managers that have been unregistered.
     */
    getUnregisteredAdManagers: function getUnregisteredAdManagers() {
      return unregisteredAdManagerFactories;
    }
  };
  OO.exposeStaticApi('Ads', OO.Ads);
  /**
   * @class OO.AdManagerInterface
   * @classdesc
   * Exposes certain parts of the Ad Manager Controller (AMC) to ad managers.  This acts as a layer through
   * which the ad manager can interact with the ad manager controller.
   * @private
   */

  var AdManagerInterface = function AdManagerInterface() {
    // List of properties and functions to expose
    var exposedProperties = ['EVENTS', 'ADTYPE', 'AD_CANCEL_CODE', 'AD_SETTINGS', 'MAX_AD_REQUEST_TIMEOUT', 'Ad', 'ui', 'platform', 'adManagerSettings', 'playerSettings', 'backlotSettings', 'pageSettings', 'currentEmbedCode', 'movieMetadata', 'startTime', 'movieDuration', 'isLiveStream', 'uiLanguage'];
    var exposedFunctions = ['updateMainStreamUrl', 'playAd', 'addPlayerListener', 'removePlayerListener', 'loadAdModule', 'notify', 'onAdManagerReady', 'removeAdManager', 'adsClicked', 'raiseAdError', 'appendToTimeline', 'showCompanion', 'forceAdToPlay', 'adManagerWillControlAds', 'adsClickthroughOpened', 'adManagerDoneControllingAds', 'notifyPodStarted', 'notifyPodEnded', 'notifyLinearAdStarted', 'notifyLinearAdEnded', 'notifyNonlinearAdStarted', 'notifyNonlinearAdEnded', 'hidePlayerUi', 'isLastAdPlayed', 'sendURLToLoadAndPlayNonLinearAd', 'showSkipVideoAdButton', 'showNonlinearAdCloseButton', 'focusAdVideo', 'getRegisteredAdManagers', 'unregisterAdManager', 'onSdkAdEvent', 'onAdSdkLoaded', 'onAdSdkLoadFailure', 'onAdRequest', 'onAdRequestSuccess', 'onAdRequestEmpty', 'onAdRequestError', 'onAdPlaybackError', 'onAdCompleted', 'onAdSdkImpression', 'reportPluginLoaded', 'willRequireEmbedCodeMetadata', 'notifySSAIAdTimelineReceived', 'notifySSAIAdPlaying', 'notifySSAIAdPlayed', 'raiseApiError'];

    var exposed = _.union(exposedProperties, exposedFunctions);

    for (var index = 0; index < exposed.length; index++) {
      if (_.isFunction(controller[exposed[index]])) {
        // exposes functions bound to the correct instance
        this[exposed[index]] = _.bind(controller[exposed[index]], controller);
      } else {
        // exposes properties bound to the correct instance
        var getter = _.bind(function (key) {
          return this[key];
        }, controller, exposed[index]);

        Object.defineProperty(this, exposed[index], {
          get: getter
        });
      }
    }
  };
  /**
   * @class OO.AdManagerControllerPlatform
   * @classdesc Exposes information about the device platform as defined by the Ooyala player.
   * @public
   * @property {string} platform The device platform.
   * @property {string} os The device operating system.
   * @property {boolean} isIos <code>true</code> if the OS is iOS, <code>false</code> otherwise.
   * @property {string} iosMajorVersion The iOS version if applicable.
   * @property {boolean} isAndroid4Plus <code>true</code> if the OS is Android 4.0 or above, <code>false</code> otherwise.
   * @property {boolean} isAndroid4_4Plus <code>true</code> if the OS is Android > 4.3, <code>false</code> otherwise.
   * @property {boolean} isFirefox <code>true</code> if the browser is Firefox, <code>false</code> otherwise.
   * @property {boolean} isChrome <code>true</code> if the browser is Chrome, <code>false</code> otherwise.
   * @property {string} chromeMajorVersion The browser version if the browser is Chrome
   * @property {boolean} isIE <code>true</code> if the browser is Internet Explorer, <code>false</code> otherwise.
   * @property {boolean} isIE11Plus <code>true</code> if the browser version is IE 11.0 or above
   * @property {boolean} isMacOs <code>true</code> if the OS is desktop Mac OS, <code>false</code> otherwise.
   * @property {boolean} isMacOsLionOrLater <code>true</code> if the OS version is Mac OS Lion or later, <code>false</code> otherwise.
   * @property {boolean} isKindleHD <code>true</code> if the device is Kindle HD, <code>false</code> otherwise.
   * @property {boolean} isSSL <code>true</code> if SSL is being used, <code>false</code> otherwise.
   * @property {string} device Device information
   * @property {boolean} isIphone <code>true</code> if the device is an iPhone, <code>false</code> otherwise.
   * @property {boolean} isIpad <code>true</code> if the device is an iPad, <code>false</code> otherwise.
   * @property {boolean} isAndroid <code>true</code> if the OS is Android OS, <code>false</code> otherwise.
   * @property {boolean} isRimDevice <code>true</code> if the device is Rim device, <code>false</code> otherwise.
   * @property {boolean} isWinPhone <code>true</code> if the device is a Windows Phone, <code>false</code> otherwise.
   * @property {boolean} isSmartTV <code>true</code> if the device is a SmartTV, <code>false</code> otherwise.
   * @property {boolean} DEV <code>true</code> if running in debug mode, <code>false</code> otherwise.
   */


  var AdManagerControllerPlatform = function AdManagerControllerPlatform() {
    this.requiredInEnvironment = OO.requiredInEnvironment;
    /**
     * The list of properties in OO that should be exposed to ad managers.
     * @private
     */

    var platformParams = ['platform', 'os', 'isIos', 'iosMajorVersion', 'isAndroid4Plus', 'isAndroid4_4Plus', 'isFirefox', 'isChrome', 'chromeMajorVersion', 'isIE', 'isIE11Plus', 'isMacOs', 'isMacOsLionOrLater', 'isKindleHD', 'isSSL', 'device', 'isIphone', 'isIpad', 'isAndroid', 'isRimDevice', 'isWinPhone', 'isSmartTV', 'DEV'];

    for (var index = 0; index < platformParams.length; index++) {
      this[platformParams[index]] = OO[platformParams[index]];
    }
  };
  /**
   * @class OO.AdManagerControllerUi
   * @classdesc
   * Handles the display of video ads, ad marquee, and controls.
   * Exposes information about the UI as defined by the Ooyala player.
   * All elements are jQuery elements.  To access the DOM element, append <code>[0]</code>.
   * These values are only ready once <code>{adManager}.registerUi</code> is called.
   * @public
   * @property {boolean} useSingleVideoElement <code>true</code> if a single video element is used for both the ad and the
   *                                           content video, <code>false</code> otherwise.
   * @property {object} rootElement The root html element of the Ooyala player.
   * @property {object} videoWrapper The parent element to the content video element.
   * @property {object} playerSkinVideoWrapper The skin-integrated parent element to the content video element.
   *                                           Currently the same as videoWrapper.
   * @property {object} ooyalaVideoElement The content video element.
   * @property {object} adVideoElement The ad video element.  Sometimes this is the same as the content video
   *                                   element.
   * @property {object} adWrapper The parent element for plugin elements.
   * @property {object} pluginsElement The element to house ad video and ad UI
   * @property {object} playerSkinPluginsElement The skin-integrated element to house ad video and ad UI
   * @property {number} height The player height.
   * @property {number} width The player width.
   * @property {object} uiParameters Contains parameters (videoWrapperClass and pluginsClass) required to setup the UI
   * @param {object} messageBus The player message bus
   * @param {object} settings Ad playback settings (e.g. showAdMarquee)
   * @param {object} registeredAdManagers A reference to the registered ad managers
   */


  var AdManagerControllerUi = function AdManagerControllerUi(messageBus, settings, registeredAdManagers) {
    var mb = messageBus;
    var adManagers = registeredAdManagers; // Page Elements

    this.elementId = null;
    this.useSingleVideoElement = false;
    this.rootElement = null;
    this.videoWrapper = null;
    this.playerSkinVideoWrapper = null;
    this.ooyalaVideoElement = null;
    this.adVideoElement = null;
    this.adWrapper = null;
    this.pluginsElement = null;
    this.playerSkinPluginsElement = null;
    this.height = null;
    this.width = null;
    this.uiParameters = {};
    this.aliceUiParameters = {};
    var elementInFocus = null;

    var _init = _.bind(function () {
      this.useSingleVideoElement = OO.requiresSingleVideoElement;
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amcUi', _videoElementCreated);
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_DISPOSED, 'amcUi', _videoElementDisposed);
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, 'amcUi', _videoElementInFocus);
      mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED, 'amcUi', _embedCodeChanged);
      mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD, 'amcUi', _embedCodeChangedAfterOoyalaAd);
    }, this);
    /**
     * Destroys the UI class.
     * @protected
     * @method AdManagerControllerUi#destroy
     */


    this.destroy = function () {
      _disposeElements(true);

      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amcUi');
      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, 'amcUi');
      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_DISPOSED, 'amcUi');
      mb.unsubscribe(OO.EVENTS.EMBED_CODE_CHANGED, 'amcUi');
      mb.unsubscribe(OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD, 'amcUi');
    };
    /**
     * Generates an unused element id by taking in a base id and appending
     * a random string to the end of it if necessary.
     * @private
     * @param {string} baseId  the base id to use
     * @returns {string} uniq string id
     */


    var _generateUniqueElementId = function _generateUniqueElementId(baseId) {
      var generatedId = baseId;

      while (document.getElementById(generatedId)) {
        generatedId = baseId + '-' + OO.getRandomString();
      }

      return generatedId;
    };
    /**
     * Sets the element properties and creates ad elements.
     * @protected
     * @method AdManagerControllerUi#setupUiElements
     */


    this.setupUiElements = function () {
      var uiParams = this.uiParameters; // TODO: Should the ids for these elements be set by ChromelessUI?

      this.videoWrapper = this.rootElement.find('.' + uiParams.videoWrapperClass);
      this.pluginsElement = this.videoWrapper.find('.' + uiParams.pluginsClass); // TODO: Set this id somewhere else
      // When we have multiple players, we want our plugin div ids
      // to be unique for the instances where the plugin will search
      // for the div (like ad SDKs)

      this.pluginsElement.attr('id', _generateUniqueElementId('ooyala-plugins-element')); // TODO: Set this id somewhere else
      // When we have multiple players, we want our wrapper div ids
      // to be unique for the instances where the plugin will search
      // for the div (like ad SDKs)

      this.videoWrapper.attr('id', _generateUniqueElementId('ooyala-inner-wrapper')); // Alice UI params are used for ad plugins that need to interact with the Alice UI,
      // such as IMA.

      var aliceUiParams = this.aliceUiParameters;

      if (!_.isEmpty(aliceUiParams)) {
        this.playerSkinVideoWrapper = this.rootElement.find('.' + aliceUiParams.videoWrapperClass);
        this.playerSkinPluginsElement = this.playerSkinVideoWrapper.find('.' + aliceUiParams.pluginsClass);
        this.playerSkinPluginsElement.attr('id', _generateUniqueElementId('ooyala-plugins-element'));
        this.playerSkinVideoWrapper.attr('id', _generateUniqueElementId('ooyala-inner-wrapper'));
      }

      this.adWrapper = this.useSingleVideoElement ? this.videoWrapper : this.pluginsElement;
    };
    /**
     * Register the ui elements with the ad managers
     * @protected
     * @method AdManagerControllerUi#registerUi
     */


    this.registerUi = function () {
      for (var key in adManagers) {
        if (adManagers[key]) {
          _safeFunctionCall(adManagers[key], 'registerUi', []);
        }
      }
    };
    /**
     * Sets up the UI elements for ad use and registers the UI elements with the ad managers.
     * @protected
     * @method AdManagerControllerUi#setupAndRegisterUi
     */


    this.setupAndRegisterUi = function () {
      this.setupUiElements();
      this.registerUi();
    };
    /**
     * This function should be called page load.  It primes the player for HTML5 playback by
     * creating an ad video element before play is called.  This is required for platforms that only
     * allow video play on user interaction (such as Android and iOS).
     * @private
     */


    this.prepAdVideoElement = function () {
      OO.log('AMC: Prepping player with a video element on load');
      var streams = {};
      streams[OO.VIDEO.ENCODING.MP4] = ''; // Get list of restrictions from registered ad managers

      var restrictionTech = null;
      var restrictionFeatures = [];

      for (var adManager in adManagers) {
        if (adManagers[adManager].videoRestrictions) {
          if (adManagers[adManager].videoRestrictions.technology) {
            restrictionTech = adManagers[adManager].videoRestrictions.technology;
          }

          if (adManagers[adManager].videoRestrictions.features) {
            for (var index in adManagers[adManager].videoRestrictions.features) {
              restrictionFeatures.push(adManagers[adManager].videoRestrictions.features[index]);
            }
          }
        }
      }

      restrictionFeatures = _.uniq(restrictionFeatures);
      this.createAdVideoElement(streams, {
        'technology': restrictionTech,
        'features': restrictionFeatures
      });
    };
    /**
     * Creates the adVideoElement.
     * @protected
     * @method AdManagerControllerUi#createAdVideoElement
     * @param {object} streamsDesired An object listing the stream urls and encoding types of the ads
     * @param {object} restrictions An object that lists restrictions the ad manager has on the video plugin
     *   used.  ex. {"technology":OO.VIDEO.TECHNOLOGY.HTML5, "features":[OO.VIDEO.FEATURE.VIDEO_OBJECT_OPEN]}
     * @fires OO.EVENTS.VC_CREATE_VIDEO_ELEMENT
     */


    this.createAdVideoElement = function (streamsDesired, restrictions) {
      var streams = {};

      for (var encoding in streamsDesired) {
        streams[encoding] = {
          url: streamsDesired[encoding]
        };
      }

      mb.publish(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, OO.VIDEO.ADS, streams, this.pluginsElement, restrictions);
    };
    /**
     * Saves the video element if it was created successfully.
     * @private
     * @method AdManagerControllerUi#_videoElementCreated
     * @param {string} eventName The name of the event that triggered this callback
     * @param {object} elementParams The parameters of the element created including id, domId, parent,
     *                               video element, and supported encodings
     */


    var _videoElementCreated = _.bind(function (eventName, elementParams) {
      if (elementParams['videoId'] === OO.VIDEO.MAIN) {
        this.ooyalaVideoElement = elementParams['videoElement']; // If single video element is required, registered the ui after the main video element has been created

        if (this.useSingleVideoElement) {
          // setup UI
          this.setupAndRegisterUi();
        }
      } else if (elementParams['videoId'] === OO.VIDEO.ADS) {
        this.adVideoElement = elementParams['videoElement'];
        this.adWrapper = elementParams['parent'];
      }
    }, this);
    /**
     * Destroys any existing video elements associated with the AMF.
     * @private
     * @method AdManagerControllerUi#_disposeElements
     * @param {boolean} forceDispose Forces dispose on platforms on which video elements are recycled
     * @fires OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT
     */


    var _disposeElements = _.bind(function (forceDispose) {
      if (this.adVideoElement) {
        // We no longer want to dispose elements (unless forcefully)
        // in order to preserve the original user click for non-muted playback
        // and for mobile devices that require a user gesture to start playback
        if (forceDispose) {
          mb.publish(OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT, OO.VIDEO.ADS);
        }
      }
    }, this);
    /**
     * Removes the ad video element from saved properties.
     * @private
     * @method AdManagerControllerUi#_videoElementDisposed
     * @param {string} eventName The name of the event that triggered this callback
     * @param {string} videoId The video tech id of the element disposed
     */


    var _videoElementDisposed = _.bind(function (eventName, videoId) {
      if (videoId === OO.VIDEO.ADS) {
        this.adVideoElement = null;
      }
    }, this);
    /**
     * Called when a video element is brought to focus.  Saves the focused element id.
     * @private
     * @method AdManagerControllerUi#_videoElementInFocus
     * @param {string} eventName The name of the event that triggered this callback
     * @param {string} videoId The video tech id of the element in focus
     */


    var _videoElementInFocus = _.bind(function (eventName, videoId) {
      elementInFocus = videoId;

      if (elementInFocus === OO.VIDEO.ADS) {
        for (var key in adManagers) {
          if (adManagers[key]) {
            _safeFunctionCall(adManagers[key], 'adVideoFocused', []);
          }
        }
      }
    }, this);
    /**
     * Destroys any ad video elements when the content video is switched.
     * @private
     * @method AdManagerControllerUi#_embedCodeChanged
     */


    var _embedCodeChanged = _.bind(function () {}, this);
    /**
     * Transitions the UI from ad video to content video.
     * @private
     * @method AdManagerControllerUi#_embedCodeChangedAfterOoyalaAd
     */


    var _embedCodeChangedAfterOoyalaAd = _.bind(function () {
      if (OO.isAndroid || OO.isIos) {
        mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, OO.VIDEO.MAIN, 'true');
      }
    }, this); /// /// UI Transition Functions //////

    /**
     * Retrieves whether or not the ad is in focus.
     * @protected
     * @method AdManagerControllerUi#isAdInFocus
     * @returns {boolean} true if ad is in focus, false otherwise
     */


    this.isAdInFocus = function () {
      return elementInFocus === OO.VIDEO.ADS;
    };
    /**
     * Transitions the UI from content video to ad.
     * @protected
     * @method AdManagerControllerUi#transitionToAd
     */


    this.transitionToAd = function () {
      mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, OO.VIDEO.ADS);
    };
    /**
     * Transitions the UI from ad video to content video.
     * @protected
     * @method AdManagerControllerUi#transitionToMainContent
     * @param {boolean} shouldResumeContent True if the player should resume the content after transitioning
     * @param {boolean} ended True if the stream has ended
     * @param {number} resetToInitialTime If provided, will set the content to this initial time, in seconds
     * @fires OO.EVENTS.PLAY
     */


    this.transitionToMainContent = function (shouldResumeContent, ended, resetToInitialTime) {
      if (elementInFocus !== OO.VIDEO.MAIN) {
        mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, OO.VIDEO.MAIN);
      }

      if (shouldResumeContent && !ended) {
        mb.publish(OO.EVENTS.VC_PLAY, OO.VIDEO.MAIN);

        if (_.isNumber(resetToInitialTime)) {
          mb.publish(OO.EVENTS.VC_SET_INITIAL_TIME, OO.VIDEO.MAIN, resetToInitialTime);
        }
      }
    };
    /**
     * Called when the ad manager controller initializes.  Raises SHOULD_DISPLAY_CUE_POINTS with true or false
     * depending on whether or not cue points should be displayed according to the metadata.
     * @fires OO.EVENTS.SHOULD_DISPLAY_CUE_POINTS
     */


    this.shouldDisplayCuePointMarkers = function () {
      mb.publish(OO.EVENTS.SHOULD_DISPLAY_CUE_POINTS, settings[SETTINGS.DISPLAY_CUE_POINTS]);
    };
    /**
     * Uses the timeline and movie duration to create a list of times in seconds at which to display cue points.
     * @param {Array} timeline The array of ads in the timeline
     * @param {int} duration The duration of the main content video in seconds
     * @fires OO.EVENTS.RESET_CUE_POINTS
     */


    this.resetCuePoints = function (timeline, duration) {
      // replace position>duration with duration
      var times = timeline.map(function (ad) {
        if (ad.position > duration) return duration;
        return ad.position;
      }, this);
      mb.publish(OO.EVENTS.RESET_CUE_POINTS, times);
    };

    _init();
  };
  /**
   * @class OO.AdManagerController
   * @classdesc The ad manager controller main class.  This class is registered as a module with the player.
   * @public
   * @property {object} adManagerSettings Ad settings used by the ad manager controller.
   * @property {object} playerSettings Ad settings specific to the player.
   * @property {object} backlotSettings Ad settings set in Backlot.
   * @property {object} pageSettings Ad settings set at the page level.
   * @property {object} ui The current instance of the <code>AdManagerControllerUi</code> class.
   * @property {object} platform The current instance of <code>AdManagerControllerPlatform</code> class.
   * @property {string} currentEmbedCode Code representing the current content video stream.
   * @property {object} movieMetadata Metadata for the content video stream.
   * @property {number} startTime The start position of the content video stream (seconds).
   * @property {number} movieDuration The duration of the content video stream (seconds).
   * @param {object} messageBus The player message bus.
   * @param {string} id The ID of the player module.
   */


  OO.AdManagerController = function (messageBus, id) {
    // Module Properties
    var moduleName = 'adManagerController';
    var mb = messageBus; // Indicates whether or not all registered ad managers are ready

    var allready = false; // TODO: This could get out of sync if an ad manager is loaded late
    // Listeners registered by the ad managers

    var managerListeners = {}; // Indicates whether or not the ad manager controller has been initialized

    var initialized = false;
    var ooyalaAdManager = {}; // Player/page Properties

    this.adManagerSettings = {};
    this.playerSettings = {};
    this.backlotSettings = null;
    this.pageSettings = null;
    this.uiLanguage = '';
    var backlotSettingsRaised = null;
    var pageSettingsRaised = null;
    var movieMetadataRaised = null;
    var autoplayChecked = false;
    var autoplayed = false;
    var autoplayedFirstVideo;
    var autoplayAbility = {};
    var latePrerollRestartThreshold = 5; // in seconds
    // Movie Properties

    var lastEmbedCode = '';
    this.currentEmbedCode = '';
    this.movieMetadata = null;
    this.startTime = -1;
    this.movieDuration = -1;
    this.isLiveStream = false; // Live Stream Properties for maintaining the playhead

    this.liveStreamTimestamps = {};
    this.timeMainVideoIdleMs = 0; // Movie state Properties

    var currentPlayhead = 0;
    var timeline = [];
    var repeatAds = [];
    var adQueue = [];
    var skipAdsOnSeek = false;
    var seekToEndThreshold = 0;
    var seeking = false;
    var seeked = false;
    var seekedPosition = 0;
    var paused = false;
    var started = false;
    var startTriggered = false;
    this.ended = false;
    this.waitForPostrollToPlay = true;
    var adManagersControllingAds = {};
    var csaiMode = false; // This flag is used when initialTime (customization) is greater than 0.
    // This is to prevent ads prior to initialTime from triggering when
    // the initial time seek is slightly less (milliseconds) than the initial time.
    // This is mainly observed in iOS devices.

    var reachedStartTime = false;
    var lastFullscreenState = false;
    var initialPlayReceived = false; // This lets us know if a new stream is being loaded
    // This is needed so that don't call AMC_PREROLLS_DONE if an ad was playing and was cancelled
    // when a new stream was loaded.

    var newStreamHandling = false;
    var amcPrerollsDoneCalled = false; // UI Setup

    var uiSetup = false; // Ad state Properties

    var overlay = false;
    var currentAd = null;
    var lastOverlayAd = null;
    this.adStarted = false;
    var adPaused = false;
    var cancelling = false;
    var adTimeouts = {};
    var skipButtonTimeout = {};
    var adManagerShowSkipButton = true;
    var adManagerSkipButtonOffset = null;
    var singleAdPlaying = false;
    var pendingPodEnd = false;
    var ssaiAdPlaying = false;
    var adElementsToCreate = 0;
    var delayForPreroll = false;
    var readyForAdPlayback = false;
    var isChromeCasting = false; // AMC modules

    this.ui = null;
    this.platform = null;
    this.amcInterface = null; // AMC Ad Managers

    this.adManagers = {};
    this.unregisteredAdManagers = []; // Timeouts
    // OO.playerParams.maxAdsTimeout - TODO: see if this value is useful in the AMC

    this.MAX_AD_MODULE_LOAD_TIMEOUT = 5000;
    this.MAX_AD_REQUEST_TIMEOUT = MAX_AD_REQUEST_TIMEOUT; // Ad Frequency

    var VIDEO_COUNT_KEY = 'OO Main Video Count'; // Unit test helper

    this.testMode = false; // Exposing settings from adManagerSettings. These are the options specified on the page or from the server.

    this.AD_SETTINGS = SETTINGS;
    /**
     * Events to which ad managers can subscribe. These events are not processed on the standard message bus.
     * @public
     * @member AdManagerController#EVENTS
     * @example
     * var amc = new AdManagerController(mb, id);
     * amc.addPlayerListener(amc.EVENTS.INITIAL_PLAY_REQUESTED, callback);
     * @property {string} INITIAL_PLAY_REQUESTED Raised the first time playback is requested.
     * @property {string} REPLAY_REQUESTED Raised when a stream is replayed.
     * @property {string} PLAY_STARTED Raised when the content video first begins to play.
     * @property {string} PLAYHEAD_TIME_CHANGED Raised periodically during content playback, reporting the
     *                    current position and duration.
     * @property {string} AD_PLAYHEAD_TIME_CHANGED Raised periodically during ad playback, reporting the
     *                    current position and duration.
     * @property {string} PAUSE Raised when the content video is paused.
     * @property {string} RESUME Raised when the content video is resumed.
     * @property {string} CONTENT_COMPLETED Raised when the content video completes.
     * @property {string} CONTENT_AND_ADS_COMPLETED Raised when the content video and all ads have completed playing.
     * @property {string} SIZE_CHANGED Raised when the size of the player is changed.
     * @property {string} CONTENT_CHANGED Raised when the content video is changed.
     * @property {string} FULLSCREEN_CHANGED Raised when the player enters and exits fullscreen mode.
     * @property {string} VOLUME_CHANGED Raised when the user requests a change in video volume.
     * @property {string} AD_VOLUME_CHANGED Raised when the user requests a change in video volume against the
     *                    <code>OO.VIDEO.ADS</code> element.
     * @property {string} MUTE_STATE_CHANGED Raised when the user changes the mute state during an ssai ad.
     * @property {string} MAIN_CONTENT_IN_FOCUS Raised when the main element has gained focus.
     * @property {string} VIDEO_TAG_FOUND Raised when an embedded tag has been found in the video stream.
     * @property {string} CONTENT_URL_CHANGED Raised when a url has been selected to stream from.
     * @property {string} NONLINEAR_AD_DISPLAYED Raised when the UI has successfully rendered the nonlinear ad.
     * @property {string} DEVICE_ID_SET Raised when the player generates a guid to identify the device or
     *                    reads the stored guid from browser local storage. Reports the guid as the device id.
     */

    this.EVENTS = {
      INITIAL_PLAY_REQUESTED: 'initialPlayRequested',
      REPLAY_REQUESTED: 'replayRequested',
      PLAY_STARTED: 'playStarted',
      PLAYHEAD_TIME_CHANGED: 'playheadTimeChanged',
      AD_PLAYHEAD_TIME_CHANGED: 'adPlayheadTimeChanged',
      PAUSE: 'pause',
      RESUME: 'resume',
      CONTENT_COMPLETED: 'contentCompleted',
      CONTENT_AND_ADS_COMPLETED: 'contentAndAdsCompleted',
      CONTENT_TREE_FETCHED: 'contentTreeFetched',
      SIZE_CHANGED: 'sizeChanged',
      CONTROLS_SHOWN: 'controlsShown',
      CONTROLS_HIDDEN: 'controlsHidden',
      CONTENT_CHANGED: 'contentChanged',
      FULLSCREEN_CHANGED: 'fullscreenChanged',
      VOLUME_CHANGED: 'volumeChanged',
      AD_VOLUME_CHANGED: 'adVolumeChanged',
      MUTE_STATE_CHANGED: 'muteStateChanged',
      MAIN_CONTENT_IN_FOCUS: 'mainContentInFocus',
      VIDEO_TAG_FOUND: 'videoTagFound',
      CONTENT_URL_CHANGED: 'contentURLChanged',
      NONLINEAR_AD_DISPLAYED: 'nonlinearAdDisplayed',
      WILL_FETCH_AD_AUTHORIZATION: 'willFetchAdAuthorization',
      AMC_PREROLLS_DONE: 'amcPrerollsDone',
      SET_EMBED_CODE: 'setEmbedCode',
      SET_EMBED_CODE_AFTER_OOYALA_AD: 'setEmbedCodeAfterOoyalaAd',
      DEVICE_ID_SET: 'deviceIdSet'
    };
    /**
     * States used internally for passing into _checkTimeline function.
     * @private
     * @member AdManagerController#STATES
     * @property {string} SEEKED The seeked state
     * @property {string} CONTENT_VIDEO_PLAYED The contentVideoPlayed state
     */

    var STATES = {
      SEEKED: 'seeked',
      CONTENT_VIDEO_PLAYED: 'contentVideoPlayed'
    };
    /**
     * Defines possible ad types.
     * @public
     * @member AdManagerController#ADTYPE
     * @example
     * var amc = new AdManagerController(mb, id);
     * var ad = new amc.Ad(position, duration, name, adObj, amc.ADTYPE.LINEAR_VIDEO);
     * @property {string} LINEAR_OVERLAY The type name for an ad that is not a video but requires the main
     *                                   video be paused.
     * @property {string} NONLINEAR_OVERLAY The type name for an ad that is not a video and does not require
     *                                      the main video be paused.
     * @property {string} LINEAR_VIDEO The type name for an ad that is a video and requires the main video be
     *                                 paused.
     * @property {string} COMPANION The type name for an ad that is a companion ad.
     * @property {string} AD_REQUEST The type name for an ad request.
     * @property {string} UNKNOWN_AD_REQUEST The type name for an unknown ad request.
     */

    this.ADTYPE = {
      LINEAR_OVERLAY: 'linearOverlay',
      NONLINEAR_OVERLAY: 'nonlinearOverlay',
      LINEAR_VIDEO: 'linearVideo',
      NONLINEAR_VIDEO: 'nonlinearVideo',
      COMPANION: 'companion',
      AD_REQUEST: 'adRequest',
      UNKNOWN_AD_REQUEST: 'unknownAdRequest'
    };
    /**
     * Defines ad cancellation codes.
     * @public
     * @member AdManagerController#AD_CANCEL_CODE
     * @property {string} SKIPPED The ad was skipped by the user via the skip ad button
     * @property {string} TIMEOUT The ad timed out
     * @property {string} ERROR The ad threw an error
     * @property {string} STREAM_ENDED The main video stream ended
     */

    this.AD_CANCEL_CODE = {
      SKIPPED: 'skipped',
      TIMEOUT: 'timeout',
      ERROR: 'error',
      STREAM_ENDED: 'streamEnded'
    };
    /**
     * An ad that is forced to play immediately should be assigned this position.
     * @type {Number}
     */

    this.FORCED_AD_POSITION = -1;
    /**
     * @class OO.Ad
     * @classdesc Represents an ad or a set of podded ads. This object contains a reference to the actual ad object provided by
     * the ad manager.
     * <b>Constructor</b>: Represents an ad or a set of podded ads. This object contains a reference to the actual ad object provided by
     * the ad manager.
     * @public
     * @example
     * var amc = new AdManagerController(mb, id);
     * var ad = new amc.Ad({position:10000, duration:7000, adManager:"example-ad-manager", ad:adObj,
     *                      adType:amc.ADTYPE.LINEAR_VIDEO});
     * @param {object} adDataDirty The ad data object describes the ad, it must contain the following fields:<br/>
     *   <code>position {number}</code> The time in the video at which the ad(s) will play (Refer to positionType for time unit)<br />
     *   <code>positionType {string}</code> How to interpret the ad position value. Either 'p' for percents(0-100) or 't' for time in seconds. Default is 't' if not specified.<br />
     *   <code>mainContentDuration {number}</code> The time length, seconds, of the main video stream<br />
     *   <code>duration {number}</code> The duration of the ad(s) (seconds).<br />
     *   <code>adManager {string}</code> The name of the ad manager (<code>{adManager}.name</code>) that will play the ad.<br />
     *   <code>ad {object}</code> The ad object.<br />
     *   <code>adType {string}</code> The type of ad created (e.g. <code>{AdManagerController}.ADTYPE.LINEAR_VIDEO</code>).
     * @property {string} id A unique ID for the ad.
     * @property {number} position The position in the stream at which to play the ad (seconds).
     * @property {number} duration The duration of the ad (seconds).
     * @property {string} adManager The name of the ad manager that owns the ad.
     * @property {object} ad The ad object.
     * @property {boolean} isLinear <code>true</code> if the ad is linear, <code>false</code> otherwise.
     * @property {boolean} played <code>true</code> if the ad has been played during the current video, <code>false</code> otherwise.
     * @property {object} videoRestrictions An object that lists restrictions the ad manager has on the video plugin
     * @property {boolean} isRequest True if this ad is only for an ad request and the ad isn't known
     * @property {object} streams An object containing keys for the stream format and values that are the urls for those streams
     *   used.  ex. {"technology":OO.VIDEO.TECHNOLOGY.HTML5, "features":[OO.VIDEO.FEATURE.VIDEO_OBJECT_OPEN]}
     */

    this.Ad = function (adDataDirty) {
      var adData = adDataDirty || {};
      this.id = _.uniqueId(adData['adManager'] + '_');
      this.duration = adData['duration'] || 0;
      this.adManager = adData['adManager'];
      this.ad = adData['ad'] || {};
      this.adType = adData['adType'] || controller.ADTYPE.LINEAR_VIDEO;
      this.isLinear = this.adType === controller.ADTYPE.LINEAR_VIDEO || this.adType === controller.ADTYPE.LINEAR_OVERLAY;
      this.isRequest = this.adType === controller.ADTYPE.AD_REQUEST || this.adType === controller.ADTYPE.UNKNOWN_AD_REQUEST;
      this.streams = adData['streams'] || {};
      this.played = false;
      this.videoRestrictions = adData['videoRestrictions']; // setup the ad position.

      var positionType = 't'; // only change to percent position type if specified otherwise, assume it's time

      if (adData.positionType === 'p') {
        positionType = 'p';
      }

      var adDataPosition = +adData['position'];

      if (_.isNumber(adDataPosition) && _.isFinite(adDataPosition)) {
        this.position = adDataPosition;
      } else {
        this.position = 0;
      }

      switch (positionType) {
        case 'p':
          // the movie duration may be rounded or off by a little, so we want to
          // insure that ads that are supposed to be postrolls actually play as postrolls and don't get skipped over.
          if (this.position >= 100) {
            this.position = POSTROLL_POSITION;
          } else {
            // convert the number from percentage to actual time stamp.
            var movieDuration = adData['mainContentDuration'];

            if (_.isFinite(movieDuration) && movieDuration > 0) {
              this.position = this.position / 100 * movieDuration;
            } else {
              OO.log('Creating a Ad instance with movieDuration = 0');
              this.position = 0;
            }
          }

          break;

        case 't':
        default:
          // do nothing
          break;
      }

      ;
    };

    var statesNoLinearAdPlaying = ['Init', 'Ready', 'Playback', 'Reload', 'Overlay'];
    var statesLinearAd = ['LinearAd']; // State Machine

    this.fsm = OO.StateMachine.create({
      initial: 'Init',
      messageBus: mb,
      moduleName: moduleName,
      target: this,
      events: [// Setup and teardown
      {
        name: OO.EVENTS.PLAYER_CREATED,
        from: 'Init',
        to: 'Init'
      }, // Playback events
      {
        name: OO.EVENTS.PLAY,
        from: statesLinearAd,
        to: '*'
      }, {
        name: OO.EVENTS.INITIAL_PLAY,
        from: 'Ready',
        to: 'Playback'
      }, {
        name: OO.EVENTS.SET_EMBED_CODE,
        from: '*',
        to: 'Reload'
      }, {
        name: OO.EVENTS.EMBED_CODE_CHANGED,
        from: '*',
        to: 'Ready'
      }, {
        name: OO.EVENTS.PLAYED,
        from: '*',
        to: 'Ready'
      }, {
        name: OO.EVENTS.REPLAY,
        from: '*',
        to: 'Playback'
      }, // Ad events
      {
        name: OO.EVENTS.AMC_ALL_READY,
        from: '*',
        to: 'Ready'
      }, {
        name: OO.EVENTS.AMC_AD_SETUP,
        from: statesNoLinearAdPlaying,
        to: 'LinearAd'
      }, {
        name: OO.EVENTS.WILL_PLAY_ADS,
        from: statesNoLinearAdPlaying,
        to: 'LinearAd'
      }, {
        name: OO.EVENTS.AD_POD_STARTED,
        from: '*',
        to: 'LinearAd'
      }, {
        name: OO.EVENTS.WILL_PLAY_NONLINEAR_AD,
        from: '*',
        to: '*'
      }, {
        name: OO.EVENTS.PLAY_NONLINEAR_AD,
        from: '*',
        to: 'Overlay'
      }, {
        name: OO.EVENTS.NONLINEAR_AD_PLAYED,
        from: '*',
        to: 'Playback'
      }, {
        name: OO.EVENTS.ADS_PLAYED,
        from: '*',
        to: 'Playback'
      }]
    }); /// // Setup /////
    // Load the ad managers if all the settings are available

    var _tryInit = _.bind(function () {
      if (initialized || !pageSettingsRaised || !backlotSettingsRaised || !movieMetadataRaised) return;
      initialized = true; // Parse global metadata locally

      var settings = _.values(SETTINGS);

      for (var settingsIndex = 0; settingsIndex < settings.length; settingsIndex++) {
        var setting = settings[settingsIndex];

        if (typeof this.pageSettings[setting] !== 'undefined') {
          this.adManagerSettings[setting] = this.pageSettings[setting];
        }
      }

      var metadataMap = {}; // Send the metadata to the ad managers

      var adManagerNames = _.keys(this.adManagers);

      for (var adManagerNameIndex = 0; adManagerNameIndex < adManagerNames.length; adManagerNameIndex++) {
        var adManagerName = adManagerNames[adManagerNameIndex];
        var adManagerClass = this.adManagers[adManagerName];

        if (adManagerClass) {
          // Merge the backlot and page level data where page level gets precedence
          var metadata = OO.getInnerProperty(this.backlotSettings, ['modules', adManagerName, 'metadata']) || {};
          metadata = _.extend(metadata, OO.getInnerProperty(this.pageSettings, [adManagerName])); // Note: For now the amc must parse ad-manager specific settings
          //       We should only support setting these settings globally and this code should be removed

          for (var _settingsIndex = 0; _settingsIndex < settings.length; _settingsIndex++) {
            var _setting = settings[_settingsIndex];

            if (typeof metadata[_setting] !== 'undefined') {
              // Question: Doesn't this mean that if there are backlot settings from multiple ad managers that
              // whoever is last in the for-loop iteration get's its settings applied? Consider a multiple ad managers
              // on a page scenario.
              this.adManagerSettings[_setting] = metadata[_setting];
            }
          }

          metadataMap[adManagerName] = {
            metadata: metadata,
            adManagerClass: adManagerClass
          };
        }
      } // Change the type of booleans to proper boolean with proper defaults


      this.adManagerSettings[SETTINGS.PAUSE_AD_ON_CLICK] = typeof this.adManagerSettings[SETTINGS.PAUSE_AD_ON_CLICK] === 'undefined' ? true : _stringToBoolean(this.adManagerSettings[SETTINGS.PAUSE_AD_ON_CLICK]);
      this.adManagerSettings[SETTINGS.DISPLAY_CUE_POINTS] = typeof this.adManagerSettings[SETTINGS.DISPLAY_CUE_POINTS] === 'undefined' ? true : _stringToBoolean(this.adManagerSettings[SETTINGS.DISPLAY_CUE_POINTS]);
      this.adManagerSettings[SETTINGS.REPLAY_ADS] = typeof this.adManagerSettings[SETTINGS.REPLAY_ADS] === 'undefined' ? true : _stringToBoolean(this.adManagerSettings[SETTINGS.REPLAY_ADS]);
      this.adManagerSettings[SETTINGS.SHOW_NONLINEAR_CLOSE_BUTTON] = typeof this.adManagerSettings[SETTINGS.SHOW_NONLINEAR_CLOSE_BUTTON] === 'undefined' ? false : _stringToBoolean(this.adManagerSettings[SETTINGS.SHOW_NONLINEAR_CLOSE_BUTTON]);
      this.adManagerSettings[SETTINGS.SHOW_LINEAR_AD_SKIP_BUTTON] = typeof this.adManagerSettings[SETTINGS.SHOW_LINEAR_AD_SKIP_BUTTON] === 'undefined' ? false : _stringToBoolean(this.adManagerSettings[SETTINGS.SHOW_LINEAR_AD_SKIP_BUTTON]);
      this.adManagerSettings[SETTINGS.LINEAR_AD_SKIP_BUTTON_START_TIME] = typeof this.adManagerSettings[SETTINGS.LINEAR_AD_SKIP_BUTTON_START_TIME] === 'undefined' ? DEFAULT_VIDEO_SKIP_BUTTON_TIME : parseInt(this.adManagerSettings[SETTINGS.LINEAR_AD_SKIP_BUTTON_START_TIME]);
      this.adManagerSettings[SETTINGS.ALLOW_AD_CLICK_THROUGH_ON_VIDEO] = typeof this.adManagerSettings[SETTINGS.ALLOW_AD_CLICK_THROUGH_ON_VIDEO] === 'undefined' ? true : _stringToBoolean(this.adManagerSettings[SETTINGS.ALLOW_AD_CLICK_THROUGH_ON_VIDEO]);
      this.adManagerSettings[SETTINGS.AD_LOAD_TIMEOUT] = !_isValidTimeout(this.adManagerSettings[SETTINGS.AD_LOAD_TIMEOUT]) ? null : this.adManagerSettings[SETTINGS.AD_LOAD_TIMEOUT] * 1000;
      this.adManagerSettings[SETTINGS.AD_MANAGER_LOAD_TIMEOUT] = !_isValidTimeout(this.adManagerSettings[SETTINGS.AD_MANAGER_LOAD_TIMEOUT]) ? null : this.adManagerSettings[SETTINGS.AD_MANAGER_LOAD_TIMEOUT] * 1000;
      this.adManagerSettings[SETTINGS.PRELOAD_ADS] = typeof this.adManagerSettings[SETTINGS.PRELOAD_ADS] === 'undefined' ? false : _stringToBoolean(this.adManagerSettings[SETTINGS.PRELOAD_ADS]);
      this.preloadAds = this.adManagerSettings[SETTINGS.PRELOAD_ADS]; // Update timeout constants if the property in adManagerSettings is still valid

      if (_isValidTimeout(this.adManagerSettings[SETTINGS.AD_LOAD_TIMEOUT])) {
        MAX_AD_LOAD_TIMEOUT = this.adManagerSettings[SETTINGS.AD_LOAD_TIMEOUT];
      }

      if (_isValidTimeout(this.adManagerSettings[SETTINGS.AD_MANAGER_LOAD_TIMEOUT])) {
        MAX_AD_MANAGER_LOAD_TIMEOUT = this.adManagerSettings[SETTINGS.AD_MANAGER_LOAD_TIMEOUT];
      }

      if (typeof this.adManagerSettings[SETTINGS.DELAY_FOR_PREROLL] === 'boolean') {
        delayForPreroll = this.adManagerSettings[SETTINGS.DELAY_FOR_PREROLL];
      }

      if (typeof this.adManagerSettings[SETTINGS.LATE_PREROLL_RESTART_THRESHOLD] === 'number') {
        latePrerollRestartThreshold = this.adManagerSettings[SETTINGS.LATE_PREROLL_RESTART_THRESHOLD];
      } // csai


      if (this.adManagerSettings[SETTINGS.PAUSE_ON_LIVE_ADS] !== undefined) {
        csaiMode = !this.adManagerSettings[SETTINGS.PAUSE_ON_LIVE_ADS];
      }

      if (this.testMode) {
        _declareAllReadyOnTimeout();
      } else {
        _.delay(_.bind(_declareAllReadyOnTimeout, this), MAX_AD_MANAGER_LOAD_TIMEOUT);
      }

      var mappingObjects = _.values(metadataMap);

      for (var mapObjectIndex = 0; mapObjectIndex < mappingObjects.length; mapObjectIndex++) {
        var mappingObject = mappingObjects[mapObjectIndex];

        _safeFunctionCall(mappingObject.adManagerClass, '' + 'loadMetadata', [mappingObject.metadata, OO.getInnerProperty(this.backlotSettings, ['base']) || {}, this.movieMetadata]);
      } // Handle metadata settings


      this.ui.shouldDisplayCuePointMarkers();

      _checkAllReady();
    }, this);
    /**
     * Helper function to determine if a value is a non-negative number.
     * @private
     * @method AdManagerController#_isValidTimeout
     * @param {*} value The value to test
     * @returns {boolean} true if value is a non-negative number. Otherwise, returns false.
     */


    var _isValidTimeout = _.bind(function (value) {
      return _.isFinite(value) && value >= 0;
    }, this);
    /**
     * Helper function to convert a string to boolean. Accepts values of "true", "yes",
     * and "1" to be true.
     * @private
     * @method AdManagerController#_stringToBoolean
     * @param {string} value The value to convert
     * @returns {boolean} true if value is "true", "yes", or "1". Otherwise, returns false.
     */


    var _stringToBoolean = function _stringToBoolean(value) {
      var normalizedValue = value.toString().toLowerCase();
      return normalizedValue === 'true' || normalizedValue === 'yes' || normalizedValue === '1';
    };

    var _resetPlaybackEventDependencies = function _resetPlaybackEventDependencies(destroying) {
      var normalizedDestroying = destroying || false; // Remove existing dependencies

      mb.removeDependent(OO.EVENTS.PLAYBACK_READY, OO.EVENTS.AMC_ALL_READY);
      mb.removeDependent(OO.EVENTS.WILL_PLAY_FROM_BEGINNING, OO.EVENTS.AMC_PREROLLS_DONE);
      mb.removeDependent(OO.EVENTS.PLAYED, OO.EVENTS.AMC_ALL_ADS_DONE); // AD_MANAGER_HANDLED_ADS should be removed but NOT re-added

      mb.removeDependent(OO.EVENTS.PLAYED, OO.EVENTS.AD_MANAGER_HANDLED_ADS); // Reset this because it tracks which ad managers are trying to block PLAYED

      adManagersControllingAds = {};

      if (normalizedDestroying) {
        return;
      } // This ensures that the parameters from the blocked event are maintained if it has a dependent
      // If nothing (or null) is returned, the blocked event would get raised with the parameters of
      // the blocker rather than the parameters which were specified by the caller.
      // This is required to ensure that VC_PLAY passes the stream url
      // This will change with PBW-2910 and can be removed at that time.


      var restoreOrigParams = function restoreOrigParams(eventName, dependentEvent, origParams, args) {
        return origParams;
      }; // Add new dependencies


      mb.addDependent(OO.EVENTS.PLAYBACK_READY, OO.EVENTS.AMC_ALL_READY, moduleName, restoreOrigParams);
      mb.addDependent(OO.EVENTS.WILL_PLAY_FROM_BEGINNING, OO.EVENTS.AMC_PREROLLS_DONE, moduleName, restoreOrigParams);
      mb.addDependent(OO.EVENTS.PLAYED, OO.EVENTS.AMC_ALL_ADS_DONE, moduleName, restoreOrigParams);
    };
    /**
     * Collects page settings, sets up event dependencies, attempts init, destroys self if required, sets
     * up UI, platform, and interface classes, sets up root video element references in AdManagerControllerUi.
     * @method AdManagerController#onPlayerCreated
     * @protected
     * @param {string} eventName The name of the event for which this callback is called
     * @param {string} elementId The ID of the root Ooyala element
     * @param {object} params Page level parameters
     * @fires OO.EVENTS.AMC_ALL_READY
     * @returns {undefined}
     */


    this.onPlayerCreated = function (eventName, elementId, params) {
      var destroyEarly = _.bind(function () {
        _destroy();

        mb.publish(OO.EVENTS.AMC_ALL_READY, {
          prerolls: 0
        });
      }, this); // instantiate the ad managers


      for (var element in adManagerFactories) {
        var adManagerFactory = adManagerFactories[element];
        var adManager = adManagerFactory.apply({}, [_, $]);
        OO.log('AMC: Registering ad manager: ' + adManager.name);
        this.adManagers[adManager.name] = adManager;
      }

      if (!this.adManagers || _.isEmpty(this.adManagers)) {
        destroyEarly();
        return;
      }

      if (!OO.supportAds || !OO.requiredInEnvironment('ads') || OO.requiredInEnvironment('flash-playback')) {
        destroyEarly();
        return;
      }

      this.ui = new AdManagerControllerUi(mb, this.adManagerSettings, this.adManagers);
      this.platform = new AdManagerControllerPlatform(mb);
      this.amcInterface = new AdManagerInterface(this);
      this.pageSettings = params;
      pageSettingsRaised = true;

      if (params && params.initialTime != null) {
        this.startTime = params.initialTime;
      } // Setup root element


      this.ui.elementId = elementId;
      this.ui.rootElement = $('#' + elementId);
      if (!this.ui.rootElement) return destroyEarly();
      this.ui.height = this.ui.rootElement.height();
      this.ui.width = this.ui.rootElement.width(); // Add dependecies for preroll and postroll

      _resetPlaybackEventDependencies();

      mb.intercept(OO.EVENTS.DESTROY, moduleName, _.bind(this.onDestroy, this)); // Initialize ad managers

      for (var key in this.adManagers) {
        if (this.adManagers[key]) {
          _safeFunctionCall(this.adManagers[key], 'initialize', [this.amcInterface, elementId]);
        }
      } // Init


      mb.subscribe(OO.EVENTS.PLAYER_EMBEDDED, moduleName, _.bind(this.onPlayerEmbedded, this));
      mb.subscribe(OO.EVENTS.METADATA_FETCHED, moduleName, _.bind(this.onMetadataFetched, this));
      mb.subscribe(OO.EVENTS.CONTENT_TREE_FETCHED, moduleName, _.bind(this.onContentTreeFetched, this));
      mb.subscribe(OO.EVENTS.AUTHORIZATION_FETCHED, moduleName, _.bind(this.onAuthorizationFetched, this));
      mb.subscribe(OO.EVENTS.ASSET_CHANGED, moduleName, _.bind(this.onAssetChanged, this));
      mb.subscribe(OO.EVENTS.UI_READY, moduleName, _.bind(this.onUiReady, this));
      mb.subscribe(OO.EVENTS.PLAYBACK_READY, moduleName, _.bind(this.onPlaybackReady, this));
      mb.subscribe(OO.EVENTS.AD_AUTHORIZATION_FETCHED, moduleName, _.bind(this.onAdAuthorizationFetched, this));
      mb.subscribe(OO.EVENTS.GUID_SET, moduleName, _.bind(this.onGuidSet, this)); // Playback

      mb.subscribe(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, moduleName, _.bind(this.onAutoplayCheckComplete, this));
      mb.subscribe(OO.EVENTS.WILL_PLAY_FROM_BEGINNING, moduleName, _.bind(this.onWillPlayFromBeginning, this));
      mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, moduleName, this.onPlayheadTimeChanged); // function bound at declaration

      mb.subscribe(OO.EVENTS.PAUSE, moduleName, _.bind(this.onPause, this));
      mb.subscribe(OO.EVENTS.WILL_PLAY, moduleName, _.bind(this.onWillPlay, this));
      mb.subscribe(OO.EVENTS.PLAYING, moduleName, _.bind(this.onPlaying, this));
      mb.subscribe(OO.EVENTS.SEEK, moduleName, _.bind(this.onSeek, this));
      mb.subscribe(OO.EVENTS.SEEKED, moduleName, _.bind(this.onSeeked, this));
      mb.subscribe(OO.EVENTS.VC_PLAY, moduleName, onVideoPlay);
      mb.subscribe(OO.EVENTS.VC_PAUSED, moduleName, _.bind(this.onVideoPaused, this));
      mb.subscribe(OO.EVENTS.VC_PLAYING, moduleName, _.bind(this.onVideoPlaying, this));
      mb.subscribe(OO.EVENTS.VC_PLAY_FAILED, moduleName, _.bind(this.onVideoPlayFailed, this));
      mb.subscribe(OO.EVENTS.VC_PLAYED, moduleName, _.bind(this.onVideoPlayed, this));
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, moduleName, _.bind(this.onVideoElementInFocus, this));
      mb.subscribe(OO.EVENTS.MUTE_STATE_CHANGED, moduleName, _.bind(this.onMuteStateChanged, this));
      mb.subscribe(OO.EVENTS.SKIN_UI_LANGUAGE, moduleName, _.bind(this.onSkinUiLanguage, this)); // Settings

      mb.subscribe(OO.EVENTS.FULLSCREEN_CHANGED, moduleName, _.bind(this.onFullscreenChanged, this));
      mb.subscribe(OO.EVENTS.SIZE_CHANGED, moduleName, _.bind(this.onSizeChanged, this));
      mb.subscribe(OO.EVENTS.VOLUME_CHANGED, moduleName, _.bind(this.onVolumeChanged, this));
      mb.subscribe(OO.EVENTS.CONTROLS_SHOWN, moduleName, _.bind(this.onControlsShown, this));
      mb.subscribe(OO.EVENTS.CONTROLS_HIDDEN, moduleName, _.bind(this.onControlsHidden, this)); // Interaction

      mb.subscribe(OO.EVENTS.ADS_CLICKED, moduleName, _.bind(this.onAdsClicked, this));
      mb.subscribe(OO.EVENTS.SKIP_AD, moduleName, _.bind(this.onSkipAd, this)); // Ad events

      mb.subscribe(OO.EVENTS.WILL_PAUSE_ADS, moduleName, _.bind(this.onWillPauseAds, this));
      mb.subscribe(OO.EVENTS.WILL_RESUME_ADS, moduleName, _.bind(this.onWillResumeAds, this));
      mb.subscribe(OO.EVENTS.AD_POD_ENDED, moduleName, _.bind(this.onAdPodEnded, this));
      mb.subscribe(OO.EVENTS.NONLINEAR_AD_DISPLAYED, moduleName, _.bind(this.onNonlinearAdDisplayed, this)); // SSAI events (like ID3 tags)

      mb.subscribe(OO.EVENTS.VC_TAG_FOUND, moduleName, _.bind(this.onVideoTagFound, this));
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, moduleName, _.bind(this.onVideoElementCreated, this)); // Chromecast events

      mb.subscribe(OO.EVENTS.CHROMECAST_START_CAST, moduleName, _.bind(this.onChromecastStartCast, this));
      mb.subscribe(OO.EVENTS.CHROMECAST_END_CAST, moduleName, _.bind(this.onChromecastEndCast, this));

      _tryInit();
    };

    var trySetupUI = _.bind(function () {
      // We want to make sure we have the ui parameters from Mjolnir before proceeding
      if (!uiSetup && !_.isEmpty(this.ui.uiParameters)) {
        // setup UI
        this.ui.setupAndRegisterUi();
        uiSetup = true;
      }
    }, this);
    /**
     * Called when the player is embedded. Stores the provided UI parameters for possible later use.
     * @method OO.AdManagerController#onPlayerEmbedded
     * @param {String} eventName - name of the event
     * @param {Object} uiParams - ?
     * @protected
     */


    this.onPlayerEmbedded = function (eventName, uiParams) {
      // Store the ui params received here for later use (either when we
      // receive UI_READY event or PLAYBACK_READY event)
      // We only want to use the values from PLAYER_EMBEDDED if we did not
      // receive any from the UI_READY event
      if (uiParams) {
        this.ui.uiParameters = uiParams;
      }
    };
    /**
     * Called when the Alice UI is ready. Sets up the AMC UI with the parameters
     * provided in the message.
     * @method AdManagerController#onUiReady
     * @param {String} eventName - name of the event
     * @param {Object} uiParams - ?
     * @protected
     */


    this.onUiReady = function (eventName, uiParams) {
      if (uiParams) {
        this.ui.aliceUiParameters = uiParams;
      } // When using single video elements, we will setup the UI later
      // when the video element is created


      if (!this.ui.useSingleVideoElement) {
        trySetupUI();
      }
    };
    /**
     * Called when playback is deemed ready. Attempts to setup the UI.
     * @method AdManagerController#onPlaybackReady
     * @protected
     */


    this.onPlaybackReady = function () {
      // When using single video elements, we will setup the UI later
      // when the video element is created
      if (!this.ui.useSingleVideoElement) {
        trySetupUI();
      }
    };
    /**
     * Called when Backlot settings are available.
     * Attempts initialization.
     * @method AdManagerController#onMetadataFetched
     * @protected
     * @param {string} eventName The name of the event for which this callback is called
     * @param {object} metadata Backlot metadata
     * @fires OO.EVENTS.AMC_ALL_READY
     */


    this.onMetadataFetched = function (eventName, metadata) {
      this.backlotSettings = metadata;
      backlotSettingsRaised = true;

      _tryInit();
    };
    /**
     * Called when the movie metadata is available.
     * Attempts initialization.
     * @method AdManagerController#onContentTreeFetched
     * @protected
     * @param {string} eventName The name of the event for which this callback is called
     * @param {object} content Movie metadata (duration in milliseconds)
     * @fires OO.EVENTS.AMC_ALL_READY
     */


    this.onContentTreeFetched = function (eventName, content) {
      this.movieMetadata = content;
      movieMetadataRaised = true;

      if (content && content.duration) {
        this.movieDuration = content.duration / 1000;

        _triggerAdManagerCallback(this.EVENTS.CONTENT_TREE_FETCHED, (0, _objectSpread2.default)({}, content, {
          // it's ugly, but backend sends 6610 for 6 min video
          // no idea what is it
          // ad manager needs to be initialized with non null video duration
          duration: content.duration / 1000 * 60
        }));
      }

      _tryInit();
    };
    /**
     * Called when authorization with the Ooyala server has completed.  Checks if the content is live or VOD.
     * @method AdManagerController#onAuthorizationFetched
     * @protected
     * @param {string} event The name of the event for which this callback is called
     * @param {object} authorization - ?
     */


    this.onAuthorizationFetched = function (event, authorization) {
      this.isLiveStream = false;

      if (authorization && authorization.streams && authorization.streams[0]) {
        this.isLiveStream = authorization.streams[0]['is_live_stream'] || false;
      }

      for (var key in this.adManagers) {
        if (this.adManagers[key]) {
          _safeFunctionCall(this.adManagers[key], 'authorizationFetched');
        }
      }
    };
    /**
     * Called when authorization with the Ooyala server has completed.  Checks if the content contains an OoyalaAd.
     * @method AdManagerController#onAdAuthorizationFetched
     * @protected
     * @param {string} event The name of the event for which this callback is called
     * @param {object} response - ?
     */


    this.onAdAuthorizationFetched = function (event, response) {
      var ooyalaAds = response;

      for (var key in this.adManagers) {
        if (this.adManagers[key] && key === 'ooyala-ads-manager') {
          _safeFunctionCall(this.adManagers[key], 'ooyalaAdData', [ooyalaAds]);

          ooyalaAdManager = this.adManagers[key];
        }
      }
    };
    /**
     * Called when the CMSless flow is used, receiving a JSON object full of asset metadata and player params.
     * @method AdManagerController#onAssetChanged
     * @protected
     * @param {string} event The name of the even for which the callback is called
     * @param {object} asset The JSON object containing all of the asset metadata
     * @param {object} params The page level player parameters specified for the asset.
     */


    this.onAssetChanged = function (event, asset, params) {
      // Mark each ad manager as not ready - need to load new metadata
      for (var name in this.adManagers) {
        this.adManagers[name].ready = false;
      }

      if (asset.id !== this.currentEmbedCode) {
        lastEmbedCode = this.currentEmbedCode;
      }

      this.currentEmbedCode = asset.id;

      if (lastEmbedCode !== '' && lastEmbedCode !== this.currentEmbedCode) {
        _triggerAdManagerCallback(this.EVENTS.CONTENT_CHANGED);

        _handleNewStream();
      }

      this.pageSettings = params;
      this.backlotSettings = {};
      backlotSettingsRaised = true;
      this.movieMetadata = asset.content;
      movieMetadataRaised = true;

      if (asset.content && asset.content.duration) {
        this.movieDuration = asset.content.duration / 1000;
      }

      this.isLiveStream = false;

      if (asset.content && asset.content.streams && asset.content.streams[0]) {
        this.isLiveStream = asset.content.streams[0]['is_live_stream'] || false;
      }

      _tryInit();
    };
    /**
     * Loads an ad module asynchronously from the network.
     * @public
     * @method AdManagerController#loadAdModule
     * @param {string} adManager The name of the ad manager making the request (<code>{adManager}.name</code>).
     * @param {string} path The network path to the remote ad module to load.
     * @param {function} callback Calls this function when the network request is complete with one parameter
     *                            indicating success (<code>true</code>) or failure (<code>false</code>).
     */


    this.loadAdModule = function (adManager, path, callback) {
      _.defer(function (amc, adManager, path, callback) {
        OO.loadScriptOnce(path, _.bind(function () {
          callback(true); // eslint-disable-line standard/no-callback-literal

          amc.onAdManagerReady();
        }, amc, adManager, callback), _.bind(function () {
          callback(false); // eslint-disable-line standard/no-callback-literal

          amc.removeAdManager(adManager);
        }, amc, adManager, callback), amc.MAX_AD_MODULE_LOAD_TIMEOUT);
      }, this, adManager, path, callback);
    };
    /**
     * When one ad manager reports it is ready, the ad manager controller checks all of the registered managers
     * to see if they are ready.
     * @public
     * @method AdManagerController#onAdManagerReady
     * @param {boolean} prepAdVideo True to notify the player to create an MP4 ad video element, false otherwise
     * @fires OO.EVENTS.AMC_ALL_READY
     */


    this.onAdManagerReady = function (prepAdVideo) {
      if (prepAdVideo) {
        // [PBW-1743] We need to create and "activate" the plugin video on a click so that we can control
        // it with JS later on mobile
        // Always create ad video element so "load" can be called on it if necessary for muted autoplay
        this.ui.prepAdVideoElement();
      }

      _checkAllReady();
    };
    /**
     * Called when an ad manager plugin will require the provider for an embed code
     * @public
     * @method AdManagerController#willRequireEmbedCodeMetadata
     * @fires OO.EVENTS.WILL_REQUIRE_EMBED_CODE_METADATA
     */


    this.willRequireEmbedCodeMetadata = function () {
      mb.publish(OO.EVENTS.WILL_REQUIRE_EMBED_CODE_METADATA, true);
    };
    /**
     * Called when a ad manager plugin has set itself to ready. The ad manager controller will then
     * fire an OO.EVENTS.PLUGIN_LOADED evemt containing the plugin name and load time
     * to see if they are ready.
     * @public
     * @method AdManagerController#reportPluginLoaded
     * @param {Any} time - ?
     * @param {Any} name - ?
     * @fires OO.EVENTS.PLUGIN_LOADED
     */


    this.reportPluginLoaded = function (time, name) {
      mb.publish(OO.EVENTS.PLUGIN_LOADED, OO.PLUGINS.ADS, name, time);
    };
    /**
     * Unregisters an ad manager.  This is called when an ad manager fails to set up or become ready.
     * @public
     * @method AdManagerController#removeAdManager
     * @param {string} adManager The name of the ad manager.
     * @fires OO.EVENTS.AMC_ALL_READY
     */


    this.removeAdManager = function (adManager) {
      OO.log('AMC: removing failed ad manager ' + adManager);
      this.unregisterAdManager(adManager);

      _checkAllReady();
    }; // Check if all ad managers loaded


    var _checkAllReady = _.bind(function () {
      // TODO: figure out why this is called twice when a manager fails to load
      if (allready) return;

      for (var adManager in this.adManagers) {
        if (!this.adManagers[adManager].ready) return;
      }

      allready = true;

      _buildTimeline();

      var prerolls = _extractPrerolls(timeline);

      mb.publish(OO.EVENTS.AMC_ALL_READY, {
        prerolls: prerolls.length
      });
    }, this); // Abort ad managers that are not yet ready


    var _declareAllReadyOnTimeout = _.bind(function () {
      if (!allready) {
        for (var adManager in this.adManagers) {
          if (!this.adManagers[adManager].ready) {
            this.removeAdManager(adManager);
          }
        }

        if (!allready) {
          allready = true;

          _buildTimeline();

          var prerolls = _extractPrerolls(timeline);

          mb.publish(OO.EVENTS.AMC_ALL_READY, {
            prerolls: prerolls.length
          });
        }
      }
    }, this);
    /**
     * Destroys self if there are no ad managers registered.
     * Resets the newStreamHandling flag as the handling is now completed.
     * @method AdManagerController#onAdManagerControllerAllReady
     * @protected
     */


    this.onAdManagerControllerAllReady = function () {
      if (!adManagerFactories || _.isEmpty(adManagerFactories)) {
        OO.log('AMC: No ad manager factories, destroying AMC');

        _destroy();

        return;
      }

      newStreamHandling = false;
      checkIfReadyForAds();
    }; /// /////// Timeline Control //////////
    // Build timeline for ads


    var _buildTimeline = _.bind(function () {
      for (var key in this.adManagers) {
        var manager = this.adManagers[key];

        if (manager) {
          // TODO: Check if returned array of this.Ad where the adManager property is set correctly
          // or should we just set the adManager property?
          var managerTimeline = _safeFunctionCall(manager, 'buildTimeline', []);

          if (_.isArray(managerTimeline)) {
            timeline = _.union(timeline, managerTimeline);

            _extractRepeatAds(timeline);
          }
        }
      }

      timeline = _sortAdArray(timeline); // TODO: Make sure this is called when an ad manager asynchronously adds ads

      this.ui.resetCuePoints(timeline, this.movieDuration);
    }, this); // goes through timeline to find any repeat ads


    var _extractRepeatAds = _.bind(function (timeline) {
      _.each(timeline, function (timelineAd) {
        if (isRepeatAd(timelineAd)) {
          timelineAd.ad.lastPlayed = timelineAd.position;
          timelineAd.ad.playTimes = {};
          repeatAds.push(timelineAd);
        }
      }, this);
    }, this); // goes through timeline to find any preroll ads


    var _extractPrerolls = _.bind(function (timeline) {
      var prerolls = [];

      _.each(timeline, function (timelineAd) {
        if (timelineAd.position === 0) {
          prerolls.push(timelineAd);
        }
      }, this);

      return prerolls;
    }, this);
    /**
     * Extracts any ads from the timeline for a given ad manager
     * @method AdManagerController#_extractAdsForAdManager
     * @private
     * @param {object[]} timeline The timeline of ads to be played
     * @param {string} adManagerName The name of the ad manager to extract ads for
     * @return {object[]} An array of the ads in the timeline for the given ad manager. If no ads are found,
     *                    an empty array is returned.
     */


    var _extractAdsForAdManager = _.bind(function (timeline, adManagerName) {
      var ads = [];

      _.each(timeline, function (timelineAd) {
        if (timelineAd.adManager === adManagerName) {
          ads.push(timelineAd);
        }
      }, this);

      return ads;
    }, this);
    /**
     * Adds ads to the controller's ad timeline.  This function can be called at any time.
     * @method AdManagerController#appendToTimeline
     * @public
     * @param {OO.AdManagerController#Ad[]} adManagerTimeline An array of ads to add to the timeline.
     *                                                        The ads are not required to be in time order.
     */


    this.appendToTimeline = function (adManagerTimeline) {
      if (_.isArray(adManagerTimeline)) {
        timeline = timeline.concat(adManagerTimeline);
        timeline = _sortAdArray(timeline);

        _extractRepeatAds(adManagerTimeline);
      }
    };
    /**
     * Add single ad to the controller's active ad queue and then re-sort them.
     * @private
     * @param {OO.AdManagerController#Ad[]} adToAppend Single ad that is appended to adQueue
     *                                                 and sorted into place.
     */


    var _appendToQueue = _.bind(function (adToAppend) {
      adQueue.push(adToAppend);
      adQueue = _sortAdArray(adQueue);
    }, this); // Sort ad array by time increasing
    // Sort (!isLinear) last
    // Sort isRequest first


    var _sortAdArray = function _sortAdArray(adArray) {
      var sortedArray = adArray;

      if (!OO._.isArray(sortedArray) || !sortedArray.length || sortedArray.length < 1) {
        return [];
      }

      sortedArray.sort(function (prevElement, nextElement) {
        if (!prevElement || !OO._.isObject(prevElement) || prevElement.position === undefined) {
          return 1;
        }

        if (!nextElement || !OO._.isObject(nextElement) || nextElement.position === undefined) {
          return -1;
        }

        if (prevElement.position < nextElement.position) {
          return -1;
        } // if the positions are the same, then sort by played/not played.


        if (prevElement.position === nextElement.position) {
          if (prevElement.played === true && nextElement.played === false) {
            return -1;
          } else if (prevElement.played === false && nextElement.played === true) {
            return 1;
          } else {
            // if the played state is the same then sort but ad type (linear, non-linear, request)
            if (prevElement.isRequest) {
              return -1;
            } else if (nextElement.isRequest) {
              return 1;
            } else if (!prevElement.isLinear) {
              return 1;
            } else if (!nextElement.isLinear) {
              return -1;
            } else {
              return 0;
            }
          }
        }

        return 1;
      });
      return sortedArray;
    };
    /**
     * Raises an event on the message bus to notify listeners that a companion ad is to be shown.
     * @method AdManagerController#showCompanion
     * @public
     * @param {object} companion The companion ad to display.
     * @fires OO.EVENTS.WILL_SHOW_COMPANION_ADS
     */


    this.showCompanion = function (companion) {
      // Defer so that external JS exception will not hang our player.
      mb.publish(OO.EVENTS.WILL_SHOW_COMPANION_ADS, {
        ads: companion
      });
    };
    /**
     * Not yet implemented.
     * @private
     * @method AdManagerController#hideCompanion
     */


    this.hideCompanion = function () {};
    /**
     * Blocks the AMC from bringing up the end screen until <code>adManagerDoneControllingAds()</code>
     * is called.
     * @public
     * @method AdManagerController#adManagerWillControlAds
     * @param {string} adManagerName The name of the ad manager.
     */
    // EVENTS.CONTENT_COMPLETED will not be called as long as you are in this mode.


    this.adManagerWillControlAds = function (adManagerName) {
      if (!adManagersControllingAds[adManagerName]) {
        if ($.isEmptyObject(adManagersControllingAds)) {
          mb.addDependent(OO.EVENTS.PLAYED, OO.EVENTS.AD_MANAGER_HANDLED_ADS, moduleName, function () {});
        }

        adManagersControllingAds[adManagerName] = true;
      }
    };
    /**
     * Forces an ad to play immediately, bypassing the timeline.
     * @public
     * @method AdManagerController#forceAdToPlay
     * @param {object} adManager The name of the ad manager that will play the ad.
     * @param {object} ad An object containing all the optional parameters for the ad.
     * @param {ADTYPE} adType The type of ad you are trying to force.
     * @param {object} streams Object containing the ad video stream types.
     * @param {number} duration The duration of the ad.
     */


    this.forceAdToPlay = function (adManager, ad, adType, streams, duration) {
      var adData = {
        'adManager': adManager,
        'adType': adType,
        'ad': ad,
        'streams': streams,
        'duration': duration,
        'position': this.FORCED_AD_POSITION // we want it to play immediately

      };
      var newAd = new this.Ad(adData);

      _appendToQueue(newAd);

      _extractRepeatAds([newAd]); // if we've received a pod end notification, do not check timeline.
      // The timeline will be checked when we handle the adPodEnded message


      if (!pendingPodEnd) {
        _checkTimeline(currentPlayhead, false);
      }
    };
    /**
     * Unblocks the ad manager controller so it can bring up the end screen.
     * @public
     * @method AdManagerController#adManagerDoneControllingAds
     * @param {string} adManagerName The name of the ad manager.
     */


    this.adManagerDoneControllingAds = function (adManagerName) {
      if (adManagersControllingAds[adManagerName]) {
        // delete this ad manager from the list and if it's empty then publish the message.
        delete adManagersControllingAds[adManagerName];

        if ($.isEmptyObject(adManagersControllingAds)) {
          // releasing the dependent, so EVENTS.PLAYED can be sent out.
          mb.publish(OO.EVENTS.AD_MANAGER_HANDLED_ADS);
        }
      }
    };
    /**
     * If we don't provide argument, this checks if some ad manager is controlling ads.
     * If we provide an argument, this checks if the specified ad manager is controlling ads.
     * @private
     * @method OO.AdManagerController#isAdManagerControllingAds
     * @param {String} adManagerName - ?
     * @returns {boolean} Whether ads are being controlled by any ad manager/a particular ad manager,
     *                    depending on whether an argument is provided.
     */


    this.isAdManagerControllingAds = function (adManagerName) {
      if (!adManagerName) {
        return $.isEmptyObject(adManagersControllingAds);
      }

      return !!adManagersControllingAds[adManagerName];
    }; // Check if an ad should be played at the current time
    // state is an optional string parameter
    // TODO: If you end up with an overlay in the middle, playback will run until the time of the next ad
    //       If this happens we don't respect people's pauses because we are still working through the ad queue

    /**
     * Checks the timeline for ads based on our current playhead position.
     * @private
     * @method OO.AdManagerController#_checkTimeline
     * @param {number} playhead The current playhead in seconds
     * @param {boolean} lastAdBreakOnly True to only playback the last ad break encountered. Typically only used for seeks
     * @param {string} state The current player ad state
     * @param {boolean} adRequestOnly True to attempt to only request the ad (without playback) in order to preload the ad
     */


    var _checkTimeline = _.bind(function (playhead, lastAdBreakOnly, state, adRequestOnly) {
      if (!timeline || singleAdPlaying || isChromeCasting || !readyForAdPlayback && !adRequestOnly) {
        return;
      }

      if (!seekToEndThreshold) {
        seekToEndThreshold = this.movieDuration - OO.CONSTANTS.SEEK_TO_END_LIMIT;
      }

      var adDuration = _populateQueue(playhead, lastAdBreakOnly, state); // TODO: Consider moving the duration calculation here.
      // Play the ads in the queue


      if (adQueue.length > 0) {
        // If we're ready for ads, trigger next ad
        if (adRequestOnly || $.inArray(this.currentState, statesLinearAd) >= 0) {
          _triggerNextAd(adRequestOnly);
        } else {
          // else setup for ads first
          _setupAd({
            type: adQueue[0].adManager,
            duration: adDuration
          }); // TODO: type needs to change to FREEWHEEL and GOOGLE_IMA and LIVERAIL
          // TODO: Liverail used to call this with useCustomCountdown:true, maybe need to add metadata to the ad object and include it here

        }

        return;
      } else if (this.tryAdsCompleted()) {
        return;
      } // no ads, publish prerolls done if needed


      if (!adRequestOnly) {
        _tryPublishPrerollsDone();
      }
    }, this);
    /**
     * Will publish AMC_PREROLLS_DONE if one of the following conditions is met:
     * 1. The content has not started and we're not switching streams
     * 2. AMC_PREROLLS_DONE has not been published yet and we're on a mobile platform where priming is required
     * @private
     * @method OO.AdManagerController#_tryPublishPrerollsDone
     * @returns {boolean} True if AMC_PREROLLS_DONE was published, false otherwise
     */


    var _tryPublishPrerollsDone = _.bind(function () {
      var published = false; // resume from preroll, NOTE: (started=false) on replay unless in single element mode
      // We may have already started content due to priming on iOS or Android. If AMC_PREROLLS_DONE
      // has not been published yet on iOS or Android, publish it now

      if (!newStreamHandling && !amcPrerollsDoneCalled && (!started || OO.isIos || OO.isAndroid)) {
        mb.publish(OO.EVENTS.AMC_PREROLLS_DONE);
        amcPrerollsDoneCalled = true;
        published = true;
      }

      return published;
    }, this);

    var _handleRepeatAds = _.bind(function (playhead, areAdsPlaying, state) {
      var adQueueTemp = [];

      if (state !== STATES.SEEKED) {
        _.each(repeatAds, function (repeatAd) {
          var nextTimeToPlay = repeatAd.ad.lastPlayed + repeatAd.ad.repeatAfter; // Check if the current playhead has passed the next time the repeat is supposed to play
          // If the main content video has ended, we may want to play a repeat ad

          if (nextTimeToPlay <= playhead && playhead < this.movieDuration || !areAdsPlaying && state === STATES.CONTENT_VIDEO_PLAYED) {
            if (this.startTime >= 0) {
              var repeatInterval = repeatAd.ad.repeatAfter;
              var positionOfLastAd;

              if (playhead > repeatAd.position) {
                positionOfLastAd = Math.floor((playhead - repeatAd.position) / repeatInterval) * repeatInterval + repeatAd.position;
              } else {
                positionOfLastAd = repeatAd.position;
              }

              repeatAd.ad.lastPlayed = positionOfLastAd;
            } else {
              repeatAd.ad.lastPlayed = nextTimeToPlay;
            } // Only play the repeat ad if a non-repeat ad is not playing (i.e. a midroll/postroll)


            if (!areAdsPlaying && !_checkRepeatAdPlayed(repeatAd, repeatAd.ad.lastPlayed)) {
              adQueue.push(repeatAd);
            }
          }
        }, this);
      } else {
        // only do logic for repeat ads if seeking to the future
        _.each(repeatAds, function (repeatAd) {
          var repeatInterval = repeatAd.ad.repeatAfter;

          var currentAd = _getCurrentAd();

          if (currentAd && currentAd === repeatAd) {
            repeatAd.ad.firstPlay = true;
          } // this get's where the repeat ad was supposed to play last
          // (consider: repeat interval of 5 seconds and current play head is at 28,
          // 28 / 5 = 5 * 5 = 25 seconds is the where the last repeat ad should have played)


          var positionOfLastAd;

          if (playhead > repeatAd.position) {
            positionOfLastAd = Math.floor((playhead - repeatAd.position) / repeatInterval) * repeatInterval + repeatAd.position;
          } else {
            positionOfLastAd = repeatAd.position;
          } // if there isn't an ad to play after seek then assume lastPlayed is the "supposed" last played position
          // and try to play repeat the ad


          if (!currentAd) {
            var nextTimeToPlay = repeatAd.ad.lastPlayed + repeatInterval; // do not play if the playhead is too close to end of main content
            // also, only care about paying the ad tax for the closest repeat ad position (position of last ad)

            if (nextTimeToPlay <= playhead && playhead < seekToEndThreshold && !_checkRepeatAdPlayed(repeatAd, positionOfLastAd)) {
              adQueueTemp.push(repeatAd);
            }

            repeatAd.ad.lastPlayed = positionOfLastAd;
          } else if (currentAd && playhead >= positionOfLastAd) {
            // if there is a current ad but the playhead would be past the point
            // of a supposed last ad, then pretend the lastPlayed for repeat ad is at the
            // supposed last ad position
            repeatAd.ad.lastPlayed = positionOfLastAd;
          }
        }, this);
      }

      adQueue = adQueue.concat(adQueueTemp);
    }, this);

    var _checkRepeatAdPlayed = _.bind(function (repeatAd, positionOfLastAd) {
      var played = false;

      if (repeatAd) {
        if (positionOfLastAd in repeatAd.ad.playTimes) {
          played = repeatAd.ad.playTimes[positionOfLastAd];
        }
      }

      return played;
    }, this);

    var _populateQueue = _.bind(function (playhead, lastAdBreakOnly, state) {
      var adDuration = 0;

      if (timeline === undefined || timeline === null || timeline.length === 0) {
        return adDuration;
      } // If we should only play the last ad, clear the queue of all ads except
      // ones that were forcefully added


      if (lastAdBreakOnly) {
        adQueue = _.filter(adQueue, _.bind(function (ad) {
          return ad.position === this.FORCED_AD_POSITION;
        }, this));
      }

      var index = 0; // find the ad who's position is closest to the playhead without going past the playhead

      for (index = 0; index < timeline.length - 1; index++) {
        if (timeline[index + 1].position >= playhead) {
          break;
        }
      } // the index is now pointing to an ad that has the correct timestamp for
      // the ads we want to play.  Now walk back in the timeline to find the first
      // ad with the same position value that has not been played yet.


      while (index > 0 && timeline[index].position === timeline[index - 1].position && timeline[index].played !== true) {
        index--;
      } // Build up the ad queue


      while (timeline[index] && timeline[index].position <= playhead) {
        if ( // if the ad has already played, then don't add it to the queue.
        timeline[index].played || skipAdsOnSeek && timeline[index].position < seekedPosition || // Check if it's already in the queue
        _.indexOf(adQueue, timeline[index]) >= 0) {
          index++;
          continue; // eslint-disable-line no-continue
        }

        adQueue.push(timeline[index]);

        if (timeline[index].isLinear) {
          adDuration = adDuration + timeline[index].duration;
        }

        index++;
      } // try to add repeat ads to queue


      if (adQueue.length > 0) {
        _handleRepeatAds(playhead, true, state);
      } else {
        _handleRepeatAds(playhead, false, state);

        _.each(adQueue, function (ad) {
          if (ad.isLinear) {
            adDuration = adDuration + ad.duration;
          }
        }, this);
      } // sort ads in case of 2 repeat ads where one is an overlay and the other is a linear ad
      // linear ad should go first


      adQueue = _sortAdArray(adQueue);
      return adDuration;
    }, this);
    /**
     * Returns the ad timeline.  This is used in unit testing.
     * @method AdManagerController#getTimeline
     * @protected
     * @returns {AdManagerController#Ad[]} An array of the ads to play during the current video,
     *                                        arranged in order of time and ad type.
     */


    this.getTimeline = function () {
      return timeline;
    };
    /**
     * Returns the repeat ads.  This is used in unit testing.
     * @method AdManagerController#getRepeatAds
     * @protected
     * @returns {AdManagerController#Ad[]} An array of ads that have been specified to repeat.
     */


    this.getRepeatAds = function () {
      return _.clone(repeatAds);
    };
    /**
     * Returns the ad queue.  This is used in unit testing.
     * @method AdManagerController#getAdQueue
     * @protected
     * @returns {AdManagerController#Ad[]} An array of the ads in the queue to be played during the
     *                                        current commercial break, arranged in play order.
     */


    this.getAdQueue = function () {
      return adQueue;
    };
    /**
     * Function to return the value of current playhead.
     * @public
     * @method AdManagerController#getCurrentPlayhead
     * @returns {number} The current playhead represented in seconds.
     */


    this.getCurrentPlayhead = _.bind(function () {
      return currentPlayhead;
    }, this);
    /**
     * Getter for AD_MANAGER_LOAD_TIMEOUT.
     * @public
     * @method AdManagerController#getAdManagerLoadTimeout
     * @returns {number} The timeout constant.
     */

    this.getAdManagerLoadTimeout = function () {
      return MAX_AD_MANAGER_LOAD_TIMEOUT;
    };
    /**
     * Getter for AD_LOAD_TIMEOUT.
     * @public
     * @method AdManagerController#getAdLoadTimeout
     * @returns {number} The timeout constant.
     */


    this.getAdLoadTimeout = function () {
      return MAX_AD_LOAD_TIMEOUT;
    };
    /**
     * Determines whether the last ad in the timeline is marked as played.
     * @method AdManagerController#isLastAdPlayed
     * @public
     * @returns {boolean} <code>true</code> if the last ad in the timeline is marked as played, <code>false</code> otherwise.
    */


    this.isLastAdPlayed = function () {
      return timeline.length === 0 || timeline[timeline.length - 1].played;
    };
    /**
     * Dispatches a <code>WILL_PLAY_NONLINEAR_AD</code> event with the nonLinear ad URL.
     * @method AdManagerController#sendURLToLoadAndPlayNonLinearAd
     * @public
     * @param {object} ad Contains the ad details.
     * @param {string} adId Contains the unique ID that the AMC provides to the ad.
     * @param {string} url The URL for the overlay image.
     * @fires OO.EVENTS.WILL_PLAY_NONLINEAR_AD
     */


    this.sendURLToLoadAndPlayNonLinearAd = function (ad, adId, url) {
      mb.publish(OO.EVENTS.PLAY_NONLINEAR_AD, {
        'ad': ad,
        'url': url
      });
      this.notifyNonlinearAdStarted(adId); // If url is null, do not show the close button; the close button is currently only supported on overlays that we
      // render. Additionally, close button should not be displayed if customer sets parameter to true without a url.

      if (url && this.adManagerSettings[SETTINGS.SHOW_NONLINEAR_CLOSE_BUTTON]) {
        mb.publish(OO.EVENTS.SHOW_NONLINEAR_AD_CLOSE_BUTTON);
      }
    };
    /**
     * Sets the flag allowSkipButtonToBeShow to True or false, called by the ad managers. NOTE: It is important to call
     * this function before starting to play the ad, so that the flag is set when the play head updates.
     * @method AdManagerController#showSkipVideoAdButton
     * @public
     * @param {boolean} allowButton If set to <code>true</code>, then the skip button will be displayed, provided the page level parameter is also
     * set. If set to <code>false</code>, the button will be prevented from displaying, even if the page level parameter is set to <code>true</code>.
     * @param {string} offset Optional parameter which includes a time offset value in seconds which must be met before skip button is shown.
     *                        If a percent ('%') is suffixed, will be treated as a percentage of duration rather than seconds. Will
     *                        only be accepted if allowButton is valid.
     */


    this.showSkipVideoAdButton = function (allowButton, offset) {
      if (typeof allowButton === 'boolean') {
        adManagerShowSkipButton = allowButton;

        if (offset) {
          adManagerSkipButtonOffset = offset;
        }
      }
    };
    /**
     * Attempts to trigger the next ad. If there are ads in the ad queue appropriate for our current state, we will
     * play the first ad in the ad queue. Otherwise, we will publish ADS_PLAYED.
     * @private
     * @method AdManagerController#_triggerNextAd
     * @fires OO.EVENTS.ADS_PLAYED
     * @param {boolean} adRequestOnly True to attempt to only request the ad (without playback) in order to preload the ad
     */


    var _triggerNextAd = _.bind(function (adRequestOnly) {
      if (!readyForAdPlayback && !adRequestOnly) {
        return;
      }

      var linear = _inLinearAdMode(); // Some ad managers will create a fake ad to take time to download the list of ads while the movie is paused.
      // If this happens they will be appended to the timeline by the time adPodEnded is called.  Check the timeline
      // immediately and trigger ads to prevent the main video from advancing if more ads were added at the current
      // time slot.
      // lastAdBreakOnly is used to ensure that the end user is not overwhelmed with ads at a given point
      // when seeking or starting a video with a start time > 0.


      var lastAdBreakOnly = seeked || !started && currentPlayhead > 0 || this.startTime >= this.movieDuration && !this.isLiveStream;

      if (this.startTime >= this.movieDuration || this.ended) {
        currentPlayhead = Number.MAX_VALUE;
      }

      _populateQueue(currentPlayhead, lastAdBreakOnly); // We want to play an ad appropriate for the mode we are in. If we are in
      // linear ad mode, we want to play a linear ad if the next ad is linear.
      // If we are not in linear ad mode, we want to play a non linear ad.


      if (adQueue.length <= 0 || adQueue[0] && !adQueue[0].isRequest && adQueue[0].isLinear !== linear) {
        // if we're currently in linear ad mode, publish ads played to get out
        // since we have run out of linear ads to play
        if (linear) {
          mb.publish(OO.EVENTS.ADS_PLAYED);
        }

        return;
      } // When we're only doing the ad request, we don't want to remove the ad from our ad queue.
      // We'll be attempting to playback the ad at its reguarly scheduled point later


      var nextAd = adRequestOnly ? adQueue[0] : adQueue.shift();
      this.playAd(nextAd, adRequestOnly);
    }, this);

    var _resetRepeatAds = _.bind(function () {
      repeatAds = [];
    }, this);

    var _getCurrentAd = function _getCurrentAd() {
      if (adQueue.length > 0) {
        return adQueue[0];
      }

      return null;
    };

    var _cancelCurrentAd = _.bind(function (cancelParams) {
      cancelling = true;

      if (currentAd && currentAd.adManager !== 'ooyala-ads-manager' && this.adManagers[currentAd.adManager]) {
        _notifyCancelAd(currentAd, cancelParams); // Overlay should be hidden by the ad manager now.  This should be done in cancelAd.


        mb.publish(OO.EVENTS.ADS_PLAYED);
      }
    }, this);

    var _notifyCancelAd = _.bind(function (ad, cancelParams) {
      if (ad && this.adManagers[ad.adManager]) {
        _safeFunctionCall(this.adManagers[ad.adManager], 'cancelAd', [ad, cancelParams]);
      }
    }, this); /// ///// End Timeline Control ////////
    /// ////// Ad Manager Control /////////

    /**
     * Update the url of the main stream content being played.
     * @public
     * @method AdManagerController#updateMainStreamUrl
     * @param  {string} newUrl The new url to be used.
     * @fires OO.EVENTS.VC_UPDATE_ELEMENT_STREAM
     */


    this.updateMainStreamUrl = function (newUrl) {
      mb.publish(OO.EVENTS.VC_UPDATE_ELEMENT_STREAM, OO.VIDEO.MAIN, newUrl);
    }; // TODO: If an ad manager calls this we should also raise WILL_PLAY_ADS somehow.
    // Maybe expose a different function to the ad managers

    /**
     * Triggers playback of an ad.
     * @public
     * @method AdManagerController#playAd
     * @param {object} ad From <code>this.Ad</code>, the object representing the ad.
     * @param {boolean} adRequestOnly True to attempt to only request the ad (without playback) in order to preload the ad
     * @fires OO.EVENTS.AD_POD_STARTED
     * @fires OO.EVENTS.WILL_PLAY_SINGLE_AD
     * @fires OO.EVENTS.WILL_PLAY_NONLINEAR_AD
     */


    this.playAd = function (ad, adRequestOnly) {
      if (!ad || !ad.ad) {
        return;
      }

      cancelling = false;
      currentAd = ad;
      currentAd.played = !adRequestOnly; // Setup functions to cancel and end ads

      var cancelAd = _.bind(function (mb, ad, adId) {
        OO.log('AMC: Cancelling an ad due to timeout ' + adId);

        _notifyCancelAd(ad, {
          code: this.AD_CANCEL_CODE.TIMEOUT
        });

        mb.publish(OO.EVENTS.SINGLE_AD_PLAYED, adId);
        mb.publish(OO.EVENTS.AD_POD_ENDED, adId);
      }, this, mb, ad, ad.id);

      if (!_shouldPlayAd(ad.ad.first_shown, ad.ad.frequency)) {
        cancelAd();
        return;
      }

      if (_.isFinite(ad.duration) && ad.duration > 0) {
        this.timeMainVideoIdleMs += ad.duration * 1000;
      } // add the ad's current play position if it is a repeat ad


      if (isRepeatAd(ad)) {
        var position; // if firstPlay is true, it means that the currentAd playing is the first play of an ad that
        // is supposed to repeat. this issue/situation only happens if the repeat ad is a midroll and
        // the user seeks far past the midroll.

        if (ad.ad.firstPlay) {
          position = ad.position;
          ad.ad.firstPlay = false;
        } else {
          position = ad.ad.lastPlayed;
        }

        ad.ad.playTimes[position] = true;
      }

      if (ad.isLinear || ad.isRequest) {
        // Linear ad (not overlay)
        // These params may not be required
        OO.log('AMC: Will play a linear ad for time: ' + ad.position + ' at playhead ' + currentPlayhead);
        setAdTimeouts(ad, cancelAd, MAX_AD_LOAD_TIMEOUT); // trigger ads

        if (ad.adManager && this.adManagers[ad.adManager]) {
          var videoRestrictions = this.adManagers[ad.adManager].videoRestrictions ? this.adManagers[ad.adManager].videoRestrictions : {};

          if (ad.videoRestrictions) {
            videoRestrictions = ad.videoRestrictions;
          } // We need to pass the page level platform setting to the VTC to ensure the proper
          // video element is created


          var platform = this.pageSettings ? this.pageSettings.platform : null;

          if (videoRestrictions && platform) {
            videoRestrictions['platform'] = platform;
          }

          if (ad.adType === this.ADTYPE.UNKNOWN_AD_REQUEST || ad.adType === this.ADTYPE.LINEAR_VIDEO && (!ad.ad || !ad.ad.ssai)) {
            mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amc', _.bind(startAdPlayback, this, adRequestOnly));
            mb.subscribe(OO.EVENTS.VC_ERROR, 'amc', _.bind(_stopAdOnVcError, this, ad.id)); // Create video element

            this.ui.createAdVideoElement(ad.streams, videoRestrictions);
          } else {
            if (ad.ad.ssai) {
              this.hidePlayerUi(true, true);
            } // Play linear overlay ads through the ad manager itself


            _safeFunctionCall(this.adManagers[ad.adManager], 'playAd', [ad, adRequestOnly]);
          }
        } else {
          this.notifyPodEnded(ad.id);
        }
      } else {
        overlay = true;
        currentAd = ad; // Non-linear ad (overlay)
        // Storing the ad details so that if a video ad plays and ends we can redisplay the overlay.

        lastOverlayAd = currentAd;
        mb.publish(OO.EVENTS.WILL_PLAY_NONLINEAR_AD, ad);
      }
    };
    /**
    * Determines whether or not the current ad is a repeat ad.
    * @param currentAd The current ad to check
    */


    var isRepeatAd = _.bind(function (currentAd) {
      if (currentAd && currentAd.ad) {
        return currentAd.ad.repeatAfter;
      }

      return null;
    }, this);
    /**
    * Sets a timeout for the specified ad, and calls the specified callback
    * if the timeout occurs.
    * @param ad The ad for which to set the timeout.
    * @param callback The function to call when a timeout occurs.
    * @param duration The timeout limit.
    */


    var setAdTimeouts = _.bind(function (ad, callback, duration) {
      // we want to avoid the situation where our ad timeout is
      // different from our ad manager's timeout if they control ads
      // until we can sync timeouts, we will not handle our ad timeout
      // if the ad manager is controlling ads
      if (ad && typeof callback === 'function' && !this.isAdManagerControllingAds(ad.adManager)) {
        clearAdTimeout(ad.id);
        adTimeouts[ad.id] = _.delay(callback, duration);
      }
    }, this);
    /**
     * Tells the ui class to transition to the ad video element.
     * @public
     * @method AdManagerController#focusAdVideo
     */


    this.focusAdVideo = function () {
      this.ui.transitionToAd(); // If we've reached this point as an unknown ad request,
      // we now know the video is a linear video
      // Since we did not publish VC_PLAY prior to this because we did not
      // know if the ad was a linear video, publish it now

      if (currentAd && currentAd.adType === this.ADTYPE.UNKNOWN_AD_REQUEST) {
        mb.publish(OO.EVENTS.VC_PLAY, OO.VIDEO.ADS);
      }
    };
    /**
     * Trigger ads from the ad manager itself and publish VTC play event.
     * @private
     * @method AdManagerController#startAdPlayback
     * @param {boolean} adRequestOnly True to attempt to only request the ad (without playback) in order to preload the ad
     * @fires OO.EVENTS.VC_PLAY
     */


    var startAdPlayback = _.bind(function (adRequestOnly) {
      OO.log('AMC: Start play ad');
      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amc');
      mb.unsubscribe(OO.EVENTS.VC_ERROR, 'amc');

      _safeFunctionCall(this.adManagers[currentAd.adManager], 'playAd', [currentAd, adRequestOnly]);

      if (currentAd.adType === this.ADTYPE.LINEAR_VIDEO) {
        mb.publish(OO.EVENTS.VC_PLAY, OO.VIDEO.ADS);
      }
    }, this);
    /**
     * Setup for when an ad is about to start playback. Will publish WILL_PLAY_ADS if it is the first
     * ad to start after transitioning from content.
     * @private
     * @method AdManagerController#handleAdStarted
     * @param {string} adId The id of the ad that is about to start
     */


    var handleAdStarted = _.bind(function (adId) {
      if (!this.adStarted) {
        var details = {};

        if (currentAd && currentAd.id === adId) {
          details.type = currentAd.adManager;
          details.duration = currentAd.duration;
        }

        mb.publish(OO.EVENTS.WILL_PLAY_ADS, details);

        if (started && (!currentAd || !currentAd.ad || !currentAd.ad.ssai)) {
          var contentStartTime = Math.max(0, this.startTime);
          var contentDifference = currentPlayhead - contentStartTime; // If the user has not watched a significant portion of the content (defined by the value of
          // latePrerollRestartThreshold), we will seek back to time 0 for a better user experience.
          // If we're in an environment where we are only allowed to have a single video element,
          // we'll instead reset after the ads have played in onAdsPlayed due to this limitation

          if (contentDifference >= 0 && contentDifference <= latePrerollRestartThreshold && !OO.requiresSingleVideoElement) {
            mb.publish(OO.EVENTS.VC_SET_INITIAL_TIME, OO.VIDEO.MAIN, contentStartTime);
          }
        }
      }

      clearAdTimeout(adId);
      this.adStarted = true;
    }, this);
    /**
     * Helper function that checks if a timeout exists for a particular adId and
     * erases it.
     * @private
     * @method AdManagerController#clearAdTimeout
     * @param adId The ad id whose timeout should be erased. (Ad id comes from the
     *        AMC when playAd() is called)
     */


    var clearAdTimeout = _.bind(function (adId) {
      if (adTimeouts && adTimeouts[adId]) {
        clearTimeout(adTimeouts[adId]);
        delete adTimeouts[adId];
      }
    }, this);
    /**
     * Stops the ad playback attempt upon error raised from VTC.
     * @private
     * @method AdManagerController#_stopAdOnVcError
     * @param {string} adId The id of the ad (Ad.id)
     * @param {string} eventName The name of the event triggering the callback
     * @param {string} videoId The id of the video that encountered an error
     * @param {number} errorCode The error code associated with the VTC error
     */


    var _stopAdOnVcError = _.bind(function (adId, eventName, videoId, errorCode) {
      if (videoId !== OO.VIDEO.ADS) {
        return;
      }

      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amc');
      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, 'amc');
      mb.unsubscribe(OO.EVENTS.VC_ERROR, 'amc');

      if (currentAd && currentAd.isLinear && this.adManagers[currentAd.adManager]) {
        _safeFunctionCall(this.adManagers[currentAd.adManager], 'adVideoError', [currentAd, errorCode]);
      }

      this.notifyPodEnded(adId);
    }, this);
    /**
     * Notifies the player a timeline of ads has been received.  Used for SSAI ads.
     * @public
     * @method AdManagerController#notifyAdTimelineReceived
     * @param {array} timeline The list of objects containing the ad timeline.
     * @fires OO.EVENTS.SSAI_AD_TIMELINE_RECEIVED
     */


    this.notifySSAIAdTimelineReceived = function (timeline) {
      mb.publish(OO.EVENTS.SSAI_AD_TIMELINE_RECEIVED, timeline);
    };
    /**
     * Notifies the player a when an SSAI ad break has started
     * @public
     * @method AdManagerController#notifySSAIAdPlaying
     * @param {Object} adObject - ?
     * @fires OO.EVENTS.SSAI_PLAY_SINGLE_AD
     */


    this.notifySSAIAdPlaying = function (adObject) {
      ssaiAdPlaying = true;
      mb.publish(OO.EVENTS.SSAI_PLAY_SINGLE_AD, adObject);
    };
    /**
     * Notifies the player a when an SSAI ad break has ended
     * @public
     * @method AdManagerController#notifySSAIAdPlayed
     * @fires OO.EVENTS.SSAI_SINGLE_AD_PLAYED
     */


    this.notifySSAIAdPlayed = function () {
      ssaiAdPlaying = false;
      mb.publish(OO.EVENTS.SSAI_SINGLE_AD_PLAYED);
    };
    /**
     * Notifies the player that an ad or a set of podded ads has begun.  This cancels any ad timeouts.
     * @public
     * @method AdManagerController#notifyPodStarted
     * @param {string} adId The ID of the ad (<code>Ad.id</code>).
     * @param {number} numberOfAds The number of ads in the pod or set.
     * @fires OO.EVENTS.AD_POD_STARTED
     */


    this.notifyPodStarted = function (adId, numberOfAds) {
      OO.log('AMC: Start ad pod ' + adId);
      clearAdTimeout(adId);
      mb.publish(OO.EVENTS.AD_POD_STARTED, numberOfAds);
    };
    /**
     * Notifies the player that an ad or a set of podded ads has ended.
     * @public
     * @method AdManagerController#notifyPodEnded
     * @param {string} adId The ID of the ad (<code>Ad.id</code>).
     * @fires OO.EVENTS.AD_POD_ENDED
     */


    this.notifyPodEnded = function (adId) {
      OO.log('AMC: End ad pod ' + adId);
      pendingPodEnd = true;
      clearAdTimeout(adId); // We want to publish the UI messages before the ended message.
      // Otherwise, the ended message can queue up another ad, and we might
      // end up showing the UI for an ad when we don't want UI for with this line

      _showPlayerUi();

      mb.publish(OO.EVENTS.AD_POD_ENDED, adId);
    };
    /**
     * Notifies the player that a nonlinear ad has begun.  This cancels any ad timeouts.
     * @public
     * @method AdManagerController#notifyNonlinearAdStarted
     * @param {string} adId The ID of the ad (<code>Ad.id</code>).
     */
    // TODO: None of our ad plugins are actually calling this. How come? Is this no longer needed?


    this.notifyNonlinearAdStarted = function (adId) {
      OO.log('AMC: Start of non-linear ad ' + adId);
      handleAdStarted(adId);
    };
    /**
     * Notifies the player that a nonlinear ad has ended.
     * @public
     * @method AdManagerController#notifyNonlinearAdEnded
     * @param {string} adId The ID of the ad (<code>Ad.id</code>).
     * @fires OO.EVENTS.NONLINEAR_AD_PLAYED
     */


    this.notifyNonlinearAdEnded = function (adId) {
      lastOverlayAd = null;
      OO.log('AMC: End of non-linear ad ' + adId); // We want to publish the UI messages before the played message.
      // Otherwise, the played message can queue up another ad, and we might
      // end up showing the UI for an ad when we don't want UI for with this line

      _showPlayerUi();

      mb.publish(OO.EVENTS.NONLINEAR_AD_PLAYED, adId);
    };
    /**
     * Notifies the player that a single linear ad has started.  The ad may be within a pod of ads.
     * @public
     * @method AdManagerController#notifyLinearAdStarted
     * @param {string} adId The id of the AMC ad recieved from playad()
     * @param {object} properties Properties of the ad.  This is an object containing
     *   <code>name</code> (string), <code>duration</code> (seconds), <code>clickUrl</code> (string), <code>indexInPod</code> (number indicating the position
     *   among podded ads (1 for first ad, 2 for second, etc), <code>skippable</code> (boolean).
     * @fires OO.EVENTS.WILL_PLAY_SINGLE_AD
     */


    this.notifyLinearAdStarted = function (adId, properties) {
      OO.log('AMC: Start of linear ad ' + adId);
      singleAdPlaying = true;

      if (!currentAd || !currentAd.ad || !currentAd.ad.ssai) {
        this.focusAdVideo();
      }

      handleAdStarted(adId);
      mb.publish(OO.EVENTS.WILL_PLAY_SINGLE_AD, properties);
    };
    /**
     * Notifies the player that a single linear ad has ended.  The ad may be within a pod of ads.
     * @public
     * @method AdManagerController#notifyLinearAdEnded
     * @param {string} adId The ID of the ad (<code>Ad.id</code>).
     * @fires OO.EVENTS.SINGLE_AD_PLAYED
     */


    this.notifyLinearAdEnded = function (adId) {
      OO.log('AMC: End of linear ad ' + adId);
      singleAdPlaying = false;
      clearTimeout(skipButtonTimeout);
      mb.publish(OO.EVENTS.SINGLE_AD_PLAYED, adId);
    };
    /**
     * Requests the player to hide its UI. Used by Ad Managers that handle their own UI.
     * @public
     * @method AdManagerController#hidePlayerUi
     * @param {boolean} showAdControls override to show the ad controls
     * @param {boolean} showAdMarquee override to show the ad marquee
     * @param {boolean} autoHideAdControls override to hide the ad controls
     * @fires OO.EVENTS.SHOW_AD_MARQUEE
     */


    this.hidePlayerUi = function (showAdControls, showAdMarquee, autoHideAdControls) {
      var sanitizedShowAdControls = _.isBoolean(showAdControls) ? showAdControls : false;
      var sanitizedShowAdMarquee = _.isBoolean(showAdMarquee) ? showAdMarquee : false;
      var sanitizedAutoHideAdControls = _.isBoolean(autoHideAdControls) ? autoHideAdControls : true;
      mb.publish(OO.EVENTS.SHOW_AD_CONTROLS, sanitizedShowAdControls, sanitizedAutoHideAdControls);
      mb.publish(OO.EVENTS.SHOW_AD_MARQUEE, sanitizedShowAdMarquee);
    };
    /**
     * Requests the player to show its UI.
     * @private
     * @method AdManagerController#_showPlayerUi
     * @fires OO.EVENTS.SHOW_AD_MARQUEE
     */


    var _showPlayerUi = _.bind(function () {
      mb.publish(OO.EVENTS.SHOW_AD_CONTROLS, true);
      mb.publish(OO.EVENTS.SHOW_AD_MARQUEE, true);
    }, this);
    /**
     * Requests the player to show the nonlinear ad close button.
     * @method AdManagerController#showNonlinearAdCloseButton
     * @public
     * @fires OO.EVENTS.SHOW_NONLINEAR_AD_CLOSE_BUTTON)
     */


    this.showNonlinearAdCloseButton = function () {
      mb.publish(OO.EVENTS.SHOW_NONLINEAR_AD_CLOSE_BUTTON);
    };
    /**
     * Raises an ads error on the message bus.
     * @method AdManagerController#raiseAdError
     * @protected
     * @param {(object|string)} error The error name or information.
     * @fires OO.EVENTS.ADS_ERROR
     */


    this.raiseAdError = function (error) {
      mb.publish(OO.EVENTS.ADS_ERROR, error);
    };
    /**
     * Raises an api error on the message bus.
     * @method AdManagerController#raiseApiError
     * @protected
     * @param {(object|string)} code The error name or information.
     * @param {String} message - ?
     * @param {String} url - ?
     * @fires OO.EVENTS.API_ERROR
     */


    this.raiseApiError = function (code, message, url) {
      mb.publish(OO.EVENTS.API_ERROR, code, message, url);
    }; /// // AD MANAGER MESSAGE BUS APIs /////

    /**
     * Adds listeners on events in <code>AdManagerController.EVENTS</code> that are triggered by this class.
     * @public
     * @method AdManagerController#addPlayerListener
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {function} callback The listener callback function.
     */


    this.addPlayerListener = function (eventName, callback) {
      // Ad managers can call this to listen to events through the AdManagerController
      // Throw warning if selecting an event that's not allowed?
      if (_.indexOf(_.values(this.EVENTS), eventName) < 0) return;

      if (managerListeners[eventName] == null) {
        managerListeners[eventName] = [];
      }

      if (!_.isFunction(callback)) return;
      managerListeners[eventName].push(callback);
    };
    /**
     * Publishes Ad events to the message bus.
     * @private
     * @method AdManagerController#notify
     * @param {String} eventName - name of the event
     * @param {Any} response - ?
     * @param {Any} params - ?
     */


    this.notify = function (eventName, response, params) {
      mb.publish(eventName, response, params);
    };
    /**
     * Removes listeners on events in <code>AdManagerController.EVENTS</code> that are triggered by this class.
     * @public
     * @method AdManagerController#removePlayerListener
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {function} callback The listener callback function.
     */


    this.removePlayerListener = function (eventName, callback) {
      var callbackList = managerListeners[eventName];

      if (callbackList) {
        var index = callbackList.indexOf(callback);

        if (index >= 0) {
          callbackList.splice(index, 1);
        }

        if (callbackList.length <= 0) {
          delete managerListeners[eventName];
        }
      }
    }; // Trigger callbacks on behalf of the ad managers


    var _triggerAdManagerCallback = _.bind(function (playEvent) {
      if (managerListeners[playEvent] && _.isArray(managerListeners[playEvent])) {
        for (var index = 0; index < managerListeners[playEvent].length; index++) {
          managerListeners[playEvent][index].apply(this, arguments);
        }
      }
    }, this); /// // Playback Listeners /////

    /**
     * Called when playback is triggered.  Resumes ad playback if an ad was playing.
     * @method AdManagerController#onPlay
     * @protected
     * @fires OO.EVENTS.WILL_RESUME_ADS
     */


    this.onPlay = function () {
      // to be safe, again check linear ad mode
      if ($.inArray(this.currentState, statesLinearAd) < 0 || !this.adStarted) return; // apply the play to the linear ad

      mb.publish(OO.EVENTS.WILL_RESUME_ADS);
    };
    /**
     * A new stream is being played, checks the timeline for ads before playback begins.
     * @method AdManagerController#onInitialPlay
     * @protected
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {number} unixTimeMs The UNIX timestamp, in milliseconds, of the time
     * @param {boolean} wasAutoplayed True if the video was autoplayed, false otherwise
     * OO.EVENTS.INITIAL_PLAY was published
     * @fires this.EVENTS.INITIAL_PLAY_REQUESTED
     */


    this.onInitialPlay = function (eventName, unixTimeMs, wasAutoplayed) {
      initialPlayReceived = true;

      if (this.startTime <= 0) {
        currentPlayhead = 0;
        this.startTime = 0;
      }

      _incrementMainVideoCount();

      if (this.isLiveStream) {
        this.liveStreamTimestamps.initialPlay = {
          ms: unixTimeMs,
          delayUsed: false
        };
      }

      adElementsToCreate = 0;

      for (var key in this.adManagers) {
        if (this.adManagers[key]) {
          // Check to see if the timeline has any ads from this ad manager
          var ads = _extractAdsForAdManager(timeline, key);

          if (ads.length) {
            // If so, check to see if there are any ad video elements that need to be created
            var encodings = _safeFunctionCall(this.adManagers[key], 'createAdVideoElementOnPlayerInit', []) || [];
            var adEncodings = void 0;

            for (var index = 0; index < encodings.length; index++) {
              adEncodings = {};
              adEncodings[encodings[index]] = '';
              this.ui.createAdVideoElement(adEncodings);
              adElementsToCreate++;
            }
          }
        }
      } // If we have any ad elements that need to be created, wait until they are created before proceeding.
      // These elements need to exist so that the video controller can communicate with the ad plugins for
      // purposes such as setting up for autoplay


      if (!adElementsToCreate) {
        this.setupInitialPlay(wasAutoplayed);
      } else {
        mb.subscribe(OO.EVENTS.VC_ERROR, 'amc', _.bind(function () {
          OO.log('Error creating ad video element on initial play');
          adElementsToCreate--;

          if (!adElementsToCreate) {
            this.setupInitialPlay(wasAutoplayed);
          }
        }, this));
        mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amc', _.bind(function () {
          adElementsToCreate--;

          if (!adElementsToCreate) {
            this.setupInitialPlay(wasAutoplayed);
          }
        }, this));
      }
    };
    /**
     * @param {String} event - name of the event
     * @param {Object} results - ?
     * @AdManagerController#onAutoplayCheckComplete
     */


    this.onAutoplayCheckComplete = function (event, results) {
      autoplayChecked = true;
      autoplayAbility = results;
      checkIfReadyForAds();
    };
    /**
     * Notifies the ad managers that initial play has occurred.
     * @AdManagerController#setupInitialPlay
     * @param {Boolean} wasAutoplayed True if the initial play was autoplayed, false otherwise
     */


    this.setupInitialPlay = function (wasAutoplayed) {
      autoplayed = wasAutoplayed;

      if (typeof autoplayedFirstVideo === 'undefined') {
        autoplayedFirstVideo = !!wasAutoplayed;
      }

      mb.unsubscribe(OO.EVENTS.VC_ERROR, 'amc');
      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amc'); // [PBK-255] [PBW-199] [PBW-223]

      if (OO.isAndroid && OO.isChrome) {
        // Required to pass OO.VIDEO.MAIN so that the video controller knows to reload this element
        // even if it's not in focus
        mb.publish(OO.EVENTS.VC_RELOAD, OO.VIDEO.MAIN);
      } // Set the current playhead to the start time so we only play the ad pod
      // that is closest to the start time and skip other previous ones.


      currentPlayhead = this.startTime;

      if (delayForPreroll && initialPlayReceived) {
        _tryPublishPrerollsDone();
      }

      checkIfReadyForAds();
    };
    /**
     * Checks to see if we are ready for ads. Will wait for the following conditions to be true
     * 1. We are not already ready for playback
     * 2. The INITIAL_PLAY has occurred
     * 3. If we are autoplaying on the first playback, we need to be able to autoplay in the environment
     * After these conditions are fulfilled, we will notify the ad plugins of INITIAL_PLAY_REQUESTED
     * @private
     * @method AdManagerController#checkIfReadyForAds
     */


    var checkIfReadyForAds = _.bind(function () {
      var canAutoplay = autoplayAbility.muted || autoplayAbility.unmuted;
      var inconclusiveAutoplayCheck = autoplayChecked && (typeof autoplayAbility.muted === 'undefined' || typeof autoplayAbility.unmuted === 'undefined');
      var adRequestOnly = this.preloadAds;

      if (!readyForAdPlayback && (initialPlayReceived || adRequestOnly) && (!autoplayed || !autoplayedFirstVideo || canAutoplay || inconclusiveAutoplayCheck)) {
        if (initialPlayReceived) {
          readyForAdPlayback = true;

          _triggerAdManagerCallback(this.EVENTS.INITIAL_PLAY_REQUESTED, autoplayed);
        } // We want to only make an ad request without playback if initial play has not started yet
        // If initial play has started, we'll just go with the regular ad flow


        _checkTimeline(currentPlayhead, currentPlayhead > 0, null, !initialPlayReceived);
      }
    }, this);
    /**
     * Called when a replay is triggered.  Resets AMC settings and triggers prerolls.
     * @protected
     * @method AdManagerController#onReplay
     */


    this.onReplay = function () {
      // Movie state Properties
      this.startTime = 0;
      currentPlayhead = 0;

      _incrementMainVideoCount();

      _resetMovieState();

      _resetAdState();

      _resetPlaybackEventDependencies();

      _resetRepeatAds();

      _triggerAdManagerCallback(this.EVENTS.REPLAY_REQUESTED); // clear the timeline if we want to replay ads


      if (this.adManagerSettings[SETTINGS.REPLAY_ADS]) {
        timeline = [];

        _buildTimeline();
      } else {
        _.each(timeline, _.bind(function (ad) {
          ad.played = true;
        }, this));
      }

      _checkTimeline(0, false);
    };
    /**
     * Called when a stream is first played.  Used to set the <code>lastEmbedCode</code> field.
     * @protected
     * @method AdManagerController#onWillPlayFromBeginning
     */


    this.onWillPlayFromBeginning = function () {
      if (started) return;
      if ($.inArray(this.currentState, statesLinearAd) >= 0) return;
      lastEmbedCode = this.currentEmbedCode;
    };
    /**
     * Called when the embed code is set for a movie.
     * @protected
     * @method AdManagerController#onSetEmbedCode
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {string} embedCode The video’s Ooyala content ID found in Backlot.
     * @param {object} options Page level settings for the new embed code.
     */


    this.onSetEmbedCode = function (eventName, embedCode, options) {
      if (options) {
        this.pageSettings = _.extend(this.pageSettings, options);
      }
    };
    /**
     * Called when the embed code is changed.<br/>
     * If the embed code is new:<br/>
     * <ul><li>ad timelines are reset</li>
     *     <li>new metadata will be loaded</li>
     *     <li>ad managers are marked as not ready</li>
     *     <li><code>adManager['loadMetadata']</code> is called with the new metadata</li>
     * @protected
     * @method AdManagerController#onEmbedCodeChanged
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {string} embedcode The video’s Ooyala content ID found in Backlot.
     * @fires this.EVENTS.CONTENT_CHANGED
     */


    this.onEmbedCodeChanged = function (eventName, embedcode) {
      // Mark each ad manager as not ready - need to load new metadata
      for (var name in this.adManagers) {
        this.adManagers[name].ready = false;
      }

      if (embedcode !== this.currentEmbedCode) {
        lastEmbedCode = this.currentEmbedCode;
      }

      this.currentEmbedCode = embedcode;

      if (lastEmbedCode !== '' && lastEmbedCode !== this.currentEmbedCode) {
        _triggerAdManagerCallback(this.EVENTS.CONTENT_CHANGED);

        _handleNewStream();
      }
    };
    /**
     * Called when a video time changes.
     * If the main video is not paused or seeking, then the timeline is checked for ads to play.
     * @protected
     * @method AdManagerController#onPlayheadTimeChanged
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {number} dirtyPlayhead Current video time (seconds).
     * @param {number} duration Duration of the current video (seconds)
     * @param {Number} buffer -  ?
     * @param {Number} seekRange - ?
     * @param {String} videoId - the id of the element that came into focus
     * @fires this.EVENTS.PLAYHEAD_TIME_CHANGED
     */


    this.onPlayheadTimeChanged = function (eventName, dirtyPlayhead, duration, buffer, seekRange, videoId) {
      var offset = null;
      var playhead = dirtyPlayhead;

      if (this.isLiveStream && !csaiMode) {
        offset = playhead;
        playhead = _calculateLivePlayhead();
      }

      if (videoId === OO.VIDEO.MAIN) {
        // if the movie duration was not set by the content tree due to
        // lack of availability, set it here if we receive a duration
        if (this.movieDuration === -1 && duration > 0) {
          this.movieDuration = duration;
        } // for main content playheads, we are reading the playhead time to determine
        // when to start ad playback
        // Throw out playheads before we started playback


        if (!started || this.ended) {
          return;
        }

        currentPlayhead = playhead;

        if (paused || seeked || seeking) {
          return;
        }

        if (!reachedStartTime && currentPlayhead > this.startTime) {
          OO.log('Reached start time at playhead: ' + currentPlayhead + ' for start time: ' + this.startTime);
          reachedStartTime = true;
        }

        if (this.startTime === -1) {
          this.startTime = currentPlayhead;
          return;
        } // Do not play additional ads if we are currently in ad mode or if we are not ready for ads


        var linear = _inLinearAdMode();

        if (linear || !readyForAdPlayback) {
          return;
        } // Set to true in order to only play the last ad on the timeline when it reaches
        // the new time.


        if (reachedStartTime) {
          _checkTimeline(currentPlayhead, true);
        } // Call ad manager listeners


        _triggerAdManagerCallback(this.EVENTS.PLAYHEAD_TIME_CHANGED, playhead, duration, offset);
      } else if (videoId === OO.VIDEO.ADS) {
        // for ad playheads, we are reading the playhead time to determine
        // when to show the skip ad button
        var adManagerSetting = {};
        adManagerSetting[SETTINGS.SHOW_LINEAR_AD_SKIP_BUTTON] = adManagerShowSkipButton; // Retrieve the skip button setting prioritized by: page level, XML (via ad manager),
        // then provider level/default value

        var showSkipButton = getSetting(SETTINGS.SHOW_LINEAR_AD_SKIP_BUTTON, [this.pageSettings, adManagerSetting, this.adManagerSettings]);

        if (typeof showSkipButton !== 'undefined') {
          showSkipButton = _stringToBoolean(showSkipButton);
        }

        if (showSkipButton) {
          var adManagerOffset; // Calculate the XML provided offset depending on if it was provided as a percent or in seconds

          if (adManagerSkipButtonOffset) {
            if (adManagerSkipButtonOffset.indexOf('%') === adManagerSkipButtonOffset.length - 1) {
              adManagerOffset = parseInt(adManagerSkipButtonOffset) / 100 * currentAd.duration;
            } else {
              adManagerOffset = parseInt(adManagerSkipButtonOffset);
            }
          }

          adManagerSetting[SETTINGS.LINEAR_AD_SKIP_BUTTON_START_TIME] = adManagerOffset; // Priority (most to least): page level, XML (via ad manager), provider level/default value

          var triggerPoint = getSetting(SETTINGS.LINEAR_AD_SKIP_BUTTON_START_TIME, [this.pageSettings, adManagerSetting, this.adManagerSettings]);

          if (_.isNumber(triggerPoint) && triggerPoint >= 0) {
            if (playhead >= triggerPoint) {
              mb.publish(OO.EVENTS.SHOW_AD_SKIP_BUTTON);
            }
          }
        } // Call ad manager listeners


        _triggerAdManagerCallback(this.EVENTS.AD_PLAYHEAD_TIME_CHANGED, playhead, duration, offset);
      }
    }.bind(this);
    /**
     * Retrieves the value of a setting (key). Iterates through the provided settings to grab the first
     * value it can find for the provided key. Prioritized from first item in the array to the last.
     * @private
     * @method AdManagerController#getSetting
     * @param {string} setting The setting to retrieve (the key)
     * @param {array} settings The settings to iterate through. Prioritized from first to last. Each item
     *                         in the array must be an object with key value pairs.
     * @return {object|boolean|string} The retrieved setting (the value), if found. Otherwise returns undefined
     */


    var getSetting = _.bind(function (setting, settings) {
      var settingsObject, value;

      for (var index = 0; index < settings.length; index++) {
        settingsObject = settings[index];
        value = settingsObject[setting];

        if (typeof value !== 'undefined') {
          break;
        }
      }

      return value;
    }, this);
    /**
     * Called when pause is triggered.
     * @protected
     * @method AdManagerController#onPause
     * @fires this.EVENTS.PAUSE
     * @fires OO.EVENTS.WILL_PAUSE_ADS
     */


    this.onPause = function () {
      // If in linear ad mode, apply the controls to the ad
      if ($.inArray(this.currentState, statesLinearAd) >= 0 && this.adStarted) {
        // apply the pause to the linear ad
        if (currentAd && this.adManagers[currentAd.adManager]) {
          mb.publish(OO.EVENTS.WILL_PAUSE_ADS);
        }

        return;
      }

      paused = true; // If the state is overlay, pause the overlay counter

      if (overlay) {
        var pauseOverlayTimer = 'pauseOverlayTimer';

        _triggerAdManagerCallback(pauseOverlayTimer);
      } // Call ad manager listeners


      if (started) {
        _triggerAdManagerCallback(this.EVENTS.PAUSE);
      }
    };
    /**
     * Called when the video element has entered the pause state.
     * @protected
     * @method AdManagerController#onVideoPaused
     */


    this.onVideoPaused = function () {
      if (this.liveStreamTimestamps) {
        this.liveStreamTimestamps.paused = {
          ms: Date.now(),
          delayUsed: false
        };
      }
    };
    /**
     * Called when an ad will be paused.  Triggers pauseAd in the appropriate ad manager.
     * @protected
     * @method AdManagerController#onWillPauseAds
     */


    this.onWillPauseAds = function () {
      if (currentAd && this.adManagers[currentAd.adManager]) {
        _safeFunctionCall(this.adManagers[currentAd.adManager], 'pauseAd', [currentAd]);

        if (!currentAd.ad || currentAd.ad && !currentAd.ad.ssai) {
          mb.publish(OO.EVENTS.VC_PAUSE, OO.VIDEO.ADS);
        }

        adPaused = true;
      }
    };
    /**
     * Called when an ad will be resumed.  Triggers resumeAd in the appropriate ad manager.
     * @protected
     * @method AdManagerController#onWillResumeAds
     */


    this.onWillResumeAds = function () {
      if (currentAd && this.adManagers[currentAd.adManager]) {
        _safeFunctionCall(this.adManagers[currentAd.adManager], 'resumeAd', [currentAd]);

        if (!currentAd.ad || currentAd.ad && !currentAd.ad.ssai) {
          mb.publish(OO.EVENTS.VC_PLAY, OO.VIDEO.ADS);
        }

        adPaused = false;
      }
    };
    /**
     * Called when the player generates a guid to identify the device or reads the stored guid from browser
     * local storage.
     * @protected
     * @method AdManagerController#onGuidSet
     * @param {string} eventName The name of the event for which this callback is called
     * @param {string} id The guid used to identify the device
     * @fires this.EVENTS.DEVICE_ID_SET
    **/


    this.onGuidSet = function (eventName, id) {
      _triggerAdManagerCallback(this.EVENTS.DEVICE_ID_SET, id);
    };
    /**
     * Handle seek.
     * Note: This gets called on scrubber seek but not on button seek unless the player is paused.
     * @protected
     * @method AdManagerController#onWillPlay
     * @param {string} eventName The name of the event for which this callback is called
     * @param {string} streamurl The url of the stream about to play
     * @fires this.EVENTS.PLAY_STARTED
     */


    this.onWillPlay = function (eventName, streamurl) {
      // Notify ad managers of initial play
      if (!started) {
        _triggerAdManagerCallback(this.EVENTS.PLAY_STARTED);
      }

      if (paused && startTriggered) {
        _triggerAdManagerCallback(this.EVENTS.RESUME, streamurl);
      }

      if (!paused) return;
      paused = false;

      if (seeked) {
        _handleSeek();
      }
    };
    /**
     * Called when a video is told to play.  Tracks whether or not the main video has been told to play.
     * @private
     * @method AdManagerController#onVideoPlay
     */


    var onVideoPlay = _.bind(function (event, videoId) {
      if (videoId === OO.VIDEO.MAIN) {
        startTriggered = true;
      }
    }, this);
    /**
     * Called when main video is playing
     * @protected
     * @method AdManagerController#onPlaying
     */


    this.onPlaying = function () {
      // If we couldn't autoplay earlier, notify the ad plugin of initial play requested now
      if (!started && autoplayed && autoplayAbility.muted === false && autoplayAbility.unmuted === false) {
        autoplayed = false;
        checkIfReadyForAds();
      }

      seeking = false;
      started = true;
    };
    /**
     * Called when a video completes.
     * @protected
     * @method AdManagerController#onVideoPlayed
     * @param {String} event - name of the event
     * @param {String} videoId - the id of the element that came into focus
     */


    this.onVideoPlayed = function (event, videoId) {
      if (videoId === OO.VIDEO.MAIN) {
        onContentVideoPlayed(event, videoId);
      } else if (videoId === OO.VIDEO.ADS) {
        if (currentAd && currentAd.isLinear && this.adManagers[currentAd.adManager]) {
          _safeFunctionCall(this.adManagers[currentAd.adManager], 'adVideoEnded');
        } else if (ooyalaAdManager) {
          _safeFunctionCall(ooyalaAdManager, 'adVideoEnded');
        }
      }
    };
    /**
     * Called when a video element comes into focus.
     * @protected
     * @method AdManagerController#onVideoElementInFocus
     * @param {String} event - the event name
     * @param {String} videoId - the id of the element that came into focus
     */


    this.onVideoElementInFocus = function (event, videoId) {
      // notify the ad managers of the focus
      if (videoId === OO.VIDEO.MAIN) {
        _showPlayerUi();

        _triggerAdManagerCallback(this.EVENTS.MAIN_CONTENT_IN_FOCUS);
      }
    }; // TODO: This didn't get called after failed postroll

    /**
     * Called when the video in the main video element ends.
     * Triggers postrolls.
     * @private
     * @method AdManagerController#onContentVideoPlayed
     * @fires this.EVENTS.CONTENT_COMPLETED
     */


    var onContentVideoPlayed = _.bind(function (event, videoId) {
      // Ignore if not the main content video
      if (videoId !== OO.VIDEO.MAIN) return; // If an overlay is playing, stop it now
      // (PIliev) This needs to happen before this.ended = true
      // so that we don't try to show the end screen before playing postrolls
      // and end up with no end screen after postroll.
      // (AngieIsrani)we need to test for the case where ended = true before all of the
      // events triggered by CancelledCurrentAd are handled which in turn brings
      // the end screen error back

      if (overlay) {
        _cancelOverlay();
      }

      this.ended = true; // In order to prevent the overlay from appearing on replay after the post-roll we must null out the var.

      lastOverlayAd = null;
      overlay = false;
      this.waitForPostrollToPlay = false;

      _triggerAdManagerCallback(this.EVENTS.CONTENT_COMPLETED);

      _checkTimeline(Number.MAX_VALUE, false, STATES.CONTENT_VIDEO_PLAYED); // if the player is chromecasting then we need to send out that all the ads
      // are done since we don't play ads on the local player while casting. We
      // don't send this out before the end of the video to avoid canceling all
      // ads if casting stops.


      if (isChromeCasting) {
        mb.publish(OO.EVENTS.AMC_ALL_ADS_DONE);
      }
    }, this); // TODO: Does this get called on embed code change from pause

    /**
     * Called when a stream has completed.
     * @protected
     * @method AdManagerController#onPlayed
     * @fires this.EVENTS.CONTENT_COMPLETED
     */


    this.onPlayed = function () {
      started = false;
      startTriggered = false;
      lastEmbedCode = this.currentEmbedCode;
    };
    /**
     * Called while a video is seeking.  Updates the current playhead if a video ad is not playing.
     * @protected
     * @method AdManagerController#onSeek
     * @param {string} eventName The name of the event for which this callback is called
     * @param {number} playhead The current video position (seconds)
     */


    this.onSeek = function (eventName, playhead) {
      if ($.inArray(this.currentState, statesLinearAd) >= 0) {
        // Trigger a seek on ads
        if (currentAd && currentAd.adManager) {
          _safeFunctionCall(this.adManagers[currentAd.adManager], 'seekAd');
        }

        return;
      } // if a seek is detected that does not go to start time
      // this means another seek other than the initial seek has occurred.
      // We consider this as having reached the start time as well
      // (for the purposes of gating checkTImelines for playhead changes and seeks)


      if (!reachedStartTime && playhead !== this.startTime) {
        reachedStartTime = true;
      } // If true, will skip ads when seeking on the specific threshold


      skipAdsOnSeek = playhead >= seekToEndThreshold;
      seekedPosition = playhead;
      currentPlayhead = playhead;
      seeking = true;
    };
    /**
     * Called when a video has seeked.  If an ad is playing, do nothing.<br/>
     * If it just returned from playing a video ad in single element mode, switch back to the content video.<br/>
     * If the stream started from an offset note that the video has now started.<br/>
     * If not currently scrubbing, check the timeline if any ads were skipped over.<br/>
     * Note: Does not get called on seek to beginning.<br/>
     * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Does get called while scrubbing and at scrubbed and after willPlay
     * if weren't paused.
     * @protected
     * @method AdManagerController#onSeeked
     * @param {string} eventName The name of the event
     * @param {?number} playhead The current time of the video after seeking.
     */


    this.onSeeked = function (eventName, playhead) {
      if (typeof playhead === 'number') {
        currentPlayhead = playhead;
      }

      seeking = false;

      _tryHandleSeek();
    };
    /**
     * Called when video started playback. Notifies ad managers of the event.
     * @protected
     * @method AdManagerController#onVideoPlaying
     * @param {string} event The event name
     * @param {string} videoId The id of the video that started playback
     */


    this.onVideoPlaying = function (event, videoId) {
      _handleLiveStreamDelays();

      if (videoId === OO.VIDEO.ADS && currentAd) {
        _safeFunctionCall(this.adManagers[currentAd.adManager], 'adVideoPlaying');
      }
    };
    /**
     * Reset ad manager controller on stream play failed.
     * @protected
     * @method AdManagerController#onVideoPlayFailed
     * @param {string} event The name of the event triggering the callback
     * @param {string} videoId The id of the video that encountered an error
     * @param {number} errorCode The error code associated with the VTC error
     */


    this.onVideoPlayFailed = function (event, videoId, errorCode) {
      if (videoId === OO.VIDEO.ADS) {
        if (currentAd && currentAd.isLinear && this.adManagers[currentAd.adManager]) {
          _safeFunctionCall(this.adManagers[currentAd.adManager], 'adVideoError', [currentAd, errorCode]);
        }
      } else if (videoId === OO.VIDEO.MAIN) {
        // TODO: Verify that reset is the correct action to take on stream playback failure
        _reset();
      }
    }; /// // Playback Handling /////


    var _resetSeekState = _.bind(function () {
      seeked = false;
      seeking = false;
    }, this);
    /**
     * Helper function to determine checking the timeline for ad is needed.
     * @private
     * @method AdManagerController#_tryHandleSeek
     */


    var _tryHandleSeek = _.bind(function () {
      if (!started) return;
      seeking = false;
      seeked = true;

      if (!paused) {
        _handleSeek();
      }
    }, this);
    /**
     * After seeking, check the timeline for ads.
     * @private
     * @method AdManagerController#_handleSeek
     */


    var _handleSeek = _.bind(function () {
      _resetSeekState();

      if (reachedStartTime) {
        _checkTimeline(currentPlayhead, true, STATES.SEEKED);
      }
    }, this); // Reset data on new stream and trigger prerolls


    var _handleNewStream = _.bind(function () {
      _cancelCurrentAd({
        code: this.AD_CANCEL_CODE.STREAM_ENDED
      });

      _reset();

      newStreamHandling = true;
    }, this); /// // Settings Listeners /////

    /**
     * Will raise an event to tell the ad manager that it has entered or exited fullscreen mode.
     * @private
     * @method AdManagerController#onFullscreenChanged
     * @param {string} eventName The name of the event for which this callback is called
     * @param {boolean} isFullscreen The current fullscreen state
     * @fires this.EVENTS.FULLSCREEN_CHANGED
     */


    this.onFullscreenChanged = function (eventName, isFullscreen) {
      if (isFullscreen !== lastFullscreenState) {
        _triggerAdManagerCallback(this.EVENTS.FULLSCREEN_CHANGED, isFullscreen);

        lastFullscreenState = isFullscreen;
      }
    };
    /**
     * Called when the video size changes.  Note down the new size and raise event to ad managers.
     * @protected
     * @method AdManagerController#onSizeChanged
     * @param {string} event The sizeChanged event name
     * @param {number} width The new player width
     * @param {number} height The new player height
     * @fires this.EVENTS.SIZE_CHANGED
     */


    this.onSizeChanged = function (event, width, height) {
      if (width < 0 || height < 0) return;
      this.ui.height = height;
      this.ui.width = width; // Call ad manager listeners

      _triggerAdManagerCallback(this.EVENTS.SIZE_CHANGED, width, height);
    };
    /**
     * Called when the control bar is shown. Raises event to ad managers.
     * @private
     * @method AdManagerController#onControlsShown
     * @fires this.EVENTS.CONTROLS_SHOWN
     */


    this.onControlsShown = function () {
      _triggerAdManagerCallback(this.EVENTS.CONTROLS_SHOWN);
    }; // TODO: These two are set to private.
    // Set back to protected when controls_shown and controls_hidden is working.

    /**
     * Called when the control bar is shown. Raises event to ad managers.
     * @private
     * @method AdManagerController#onControlsHidden
     * @fires this.EVENTS.CONTROLS_HIDDEN
     */


    this.onControlsHidden = function () {
      _triggerAdManagerCallback(this.EVENTS.CONTROLS_HIDDEN);
    };
    /**
     * Ad managers that use VTC video elements will not need to take action on volume change.  Ad managers
     * who do not use VTC video elements will need to listen on the VOLUME_CHANGED event and trigger the
     * change manually.
     * @protected
     * @method AdManagerController#onVolumeChanged
     * @param {string} eventName The name of the event for which this callback is called
     * @param {number} volume The current volume level
     * @param {string} videoId The video tech id of the element disposed
     */


    this.onVolumeChanged = function (eventName, volume, videoId) {
      _triggerAdManagerCallback(this.EVENTS.VOLUME_CHANGED, volume); // If an ssai ad is playing videoId will be MAIN, but we should still trigger callback


      if (videoId === OO.VIDEO.ADS || ssaiAdPlaying) {
        _triggerAdManagerCallback(this.EVENTS.AD_VOLUME_CHANGED, volume);
      }
    };
    /**
     * Called when mute state is changed
     * @protected
     * @method AdManagerController#onMuteStateChanged
     * @param {String} eventName Name of the event
     * @param {boolean} muteState True if muted, false if unmuted
     * @param {string} videoId The video tech id of the element disposed
     * @param {boolean} mutingForAutoplay True if muting for autoplay, false if not
     */


    this.onMuteStateChanged = function (eventName, muteState, videoId, mutingForAutoplay) {
      _triggerAdManagerCallback(this.EVENTS.MUTE_STATE_CHANGED, muteState);
    };
    /**
     * Called when the UI language is set.
     * @protected
     * @method AdManagerController#onSkinUiLanguage
     * @param  {String} eventName name of the event
     * @param  {string} uiLanguage The language code for the UI's language.
     */


    this.onSkinUiLanguage = function (eventName, uiLanguage) {
      if (_.isString(uiLanguage)) {
        this.uiLanguage = uiLanguage;
      }
    }; /// // Interaction Listeners /////

    /**
     * When an ad is clicked:  <ul><li>If the ad is playing and if possible, pause the ad and show controls.</li>
     * <li>If the ad was paused, resume it and hide controls if necessary. However if <code>SETTINGS.ALLOW_AD_CLICK_THROUGH_ON_VIDEO</code>
     * is set to <code>false</code> (default is <code>true</code>) then we want to ignore the click if it comes from the video window.</li></ul>
     * @public
     * @method AdManagerController#adsClicked
     * @param {object} prop The argument from the event that contains an object having the source from which the button
     * was clicked.
     */


    this.adsClicked = function (prop) {
      if (ooyalaAdManager) {
        _safeFunctionCall(ooyalaAdManager, 'playerClicked');
      }

      if (!currentAd) {
        return;
      }

      if (adPaused && (!prop || prop.source !== 'learnMoreButton')) {
        mb.publish(OO.EVENTS.PLAY);
      } else {
        if (this.adManagerSettings[SETTINGS.PAUSE_AD_ON_CLICK]) {
          // Dispatch pause event to pause the main video when an overlay is clicked.
          if (currentAd && (!currentAd.isLinear || currentAd.ad && currentAd.ad.ssai)) {
            mb.publish(OO.EVENTS.PAUSE);
          } else {
            this.onPause();
          }
        }

        if (currentAd.isLinear && !this.adManagerSettings[SETTINGS.ALLOW_AD_CLICK_THROUGH_ON_VIDEO] && prop && prop.source === 'videoWindow') {
          return;
        }

        if (this.adManagers[currentAd.adManager]) {
          _safeFunctionCall(this.adManagers[currentAd.adManager], 'playerClicked', [currentAd, true]);
        }
      }
    };
    /**
     * Called when an ad's clickthrough URL is opened. Currently, it is called by each individual ad manager,
     * because clickthroughs behave differently across the different ad managers (Google IMA, FreeWheel, VAST).
     * @public
     * @method AdManagerController#adsClickthroughOpened
     * @fires OO.EVENTS.ADS_CLICKTHROUGH_OPENED
     */


    this.adsClickthroughOpened = function () {
      mb.publish(OO.EVENTS.ADS_CLICKTHROUGH_OPENED);
    };
    /**
     * When the ad is closed with the X button, cancel the ad.
     * @public
     * @method AdManagerController#onSkipAd
     */


    this.onSkipAd = function () {
      if (ooyalaAdManager) {
        _safeFunctionCall(ooyalaAdManager, 'cancelAd', [currentAd, {
          code: this.AD_CANCEL_CODE.SKIPPED
        }]);
      }

      if (this.currentState === 'LinearAd') {
        OO.log('AMC: Canceling linear ad due to skip button clicked.');

        _notifyCancelAd(currentAd, {
          code: this.AD_CANCEL_CODE.SKIPPED
        });
      } else if (this.currentState === 'Overlay') {
        OO.log('AMC: Canceling nonlinear ad due to skip button clicked.');

        _cancelOverlay();
      }
    };
    /**
     * Cancels the current overlay. Notifies the overlay's ad manager of the event.
     * @private
     * @method AdManagerController#_cancelOverlay
     */


    var _cancelOverlay = _.bind(function () {
      if (overlay && currentAd && this.adManagers[currentAd.adManager]) {
        cancelling = true;

        _safeFunctionCall(this.adManagers[currentAd.adManager], 'cancelOverlay', [currentAd]);

        mb.publish(OO.EVENTS.NONLINEAR_AD_PLAYED, currentAd.id);
      }
    }, this); /// // Events Raised Locally Listeners /////


    var _setupAd = _.bind(function (adEventDetails) {
      _resetSeekState(); // If an overlay is playing, hide it now


      if (overlay && currentAd && this.adManagers[currentAd.adManager]) {
        if (_.isFunction(this.adManagers[currentAd.adManager].hideOverlay)) {
          _safeFunctionCall(this.adManagers[currentAd.adManager], 'hideOverlay', [currentAd]);

          mb.publish(OO.EVENTS.HIDE_NONLINEAR_AD);
        } else {
          // If an overlay is playing and the ad manager cancels the overlay instead of just hiding it, we need to update
          // the state of the the AMC to know that it is cancelled and done so we don't trigger the next ad in the queue
          // if the overlay calls adPodEnded. It also calls the cancelOverlay function inside of the ad admanager.
          _cancelOverlay();
        }
      }

      mb.publish(OO.EVENTS.AMC_AD_SETUP);
    }, this);

    var _inLinearAdMode = _.bind(function () {
      return $.inArray(this.currentState, statesLinearAd) >= 0;
    }, this);
    /**
     * Called when ad mode is beginning.
     * Either notifies that the main content video will be unloaded or triggers the first ad in the set.
     * @protected
     * @method AdManagerController#onAdManagerControllerAdSetup
     */


    this.onAdManagerControllerAdSetup = function () {
      _triggerNextAd();
    };
    /**
     * When this function is called, the state machine switches to LinearAd. This empty function must exist
     * for the state machine to change states.
     * @protected
     * @method AdManagerController#onAdPodStarted
     */


    this.onAdPodStarted = function () {
      mb.publish(OO.EVENTS.DISABLE_SEEKING, OO.VIDEO.ADS);
    };
    /**
     * Sets overlay state.  Shows the overlay.
     * @protected
     * @method AdManagerController#onWillPlayNonlinearAd
     * @param {string} eventName The name of the event for which this callback is called
     * @param {object} ad The ad that will be played
     */


    this.onWillPlayNonlinearAd = function (eventName, ad) {
      // Setup functions to cancel and end ads
      var cancelAd = _.bind(function (mb, ad, adId) {
        lastOverlayAd = null;
        OO.log('AMC: Cancelling a non-linear ad due to timeout ' + adId);

        _notifyCancelAd(ad, {
          code: this.AD_CANCEL_CODE.TIMEOUT
        });

        mb.publish(OO.EVENTS.NONLINEAR_AD_PLAYED, adId);
      }, this, mb, ad, ad.id);

      setAdTimeouts(ad, cancelAd, MAX_AD_LOAD_TIMEOUT); // trigger ads

      if (ad.adManager && this.adManagers[ad.adManager]) {
        _safeFunctionCall(this.adManagers[ad.adManager], 'playAd', [ad]);
      } else {
        this.notifyNonlinearAdEnded(ad.id);
      }
    };
    /**
     * Callback for when linear ads start to play.
     * @protected
     * @method AdManagerController#onPlayNonlinearAd
     */


    this.onPlayNonlinearAd = function () {// Must be defined so the state machine remains in the proper state (overlay state)
    };

    var _handleEndOfAd = _.bind(function () {
      _resetAdState();

      if (!cancelling) {
        // only trigger more ads if we're not in ad-cancelling mode
        _triggerNextAd();
      }
    }, this);
    /**
     * Trigger next queued ad if the ended ad is the current ad.
     * @protected
     * @method AdManagerController#onAdPodEnded
     * @param {string} eventName The name of the event for which this callback is called
     * @param {string} adId ID of the ad that finished playing
     * @fires OO.EVENTS.AD_POD_STARTED
     * @fires OO.EVENTS.WILL_PLAY_SINGLE_AD
     */


    this.onAdPodEnded = function (eventName, adId) {
      pendingPodEnd = false;
      mb.publish(OO.EVENTS.ENABLE_SEEKING, OO.VIDEO.ADS);
      mb.publish(OO.EVENTS.VC_SET_VIDEO_STREAMS, OO.VIDEO.ADS, null);

      _handleEndOfAd(adId);
    };
    /**
     * Callback triggered when the UI successfully displays the nonlinear ad.
     * @public
     * @method AdManagerController#onNonlinearAdDisplayed
     * @param {string} eventname The name of the event for which this callback is called.
     */


    this.onNonlinearAdDisplayed = function (eventname) {
      _triggerAdManagerCallback(this.EVENTS.NONLINEAR_AD_DISPLAYED);
    };
    /**
     * Trigger next queued ad if the ended ad is the current ad.
     * @protected
     * @method AdManagerController#onNonlinearAdPlayed
     * @param {string} eventName The name of the event for which this callback is called.
     * @param {string} adId The ID of the ad that has ended.
     * @fires OO.EVENTS.AD_POD_STARTED
     * @fires OO.EVENTS.WILL_PLAY_SINGLE_AD
     */


    this.onNonlinearAdPlayed = function (eventName, adId) {
      // Overlay should be hidden by the ad manager now.
      _handleEndOfAd(adId);
    };
    /**
    * Checks to see if all ads are done. If so, handles the necessary state changes
    * and publishes the required events for when all ads are done.
    * @protected
    * @method AdManagerController#tryAdsCompleted
    * @fires OO.EVENTS.AMC_ALL_ADS_DONE
    * @returns {boolean} True if it is determined that all ads are done, false otherwise
    */


    this.tryAdsCompleted = function () {
      var allDone = false; // if the next ad is a non linear ad, we still want to publish AMC_ALL_ADS_DONE assuming
      // the other conditions are met

      if (this.ended && !this.waitForPostrollToPlay && (adQueue.length <= 0 || adQueue[0] && !adQueue[0].isLinear && !adQueue[0].isRequest)) {
        this.waitForPostrollToPlay = true;
        this.ui.transitionToMainContent(false, this.ended);
        allDone = true;
        OO.log('AMC: All ads completed, unblocking played event');
        mb.publish(OO.EVENTS.AMC_ALL_ADS_DONE);
      }

      return allDone;
    };
    /**
     * Resumes the content video after ads are completed.  Re-enables controls and ends ad mode.
     * @protected
     * @method AdManagerController#onAdsPlayed
     * @fires OO.EVENTS.AMC_ALL_ADS_DONE
     * @fires OO.EVENTS.AMC_PREROLLS_DONE
     * @fires OO.EVENTS.ENABLE_PLAYBACK_CONTROLS
     */


    this.onAdsPlayed = function () {
      cancelling = false;

      if (this.tryAdsCompleted()) {
        return;
      } // We do not want to disturb the play/pause state if the main content is in focus
      // so only resume when ad is in focus


      var shouldResume = !newStreamHandling && this.ui.isAdInFocus(); // If the user has not watched a significant portion of the content (defined by the value of
      // latePrerollRestartThreshold), we will seek back to time 0 for a better user experience.
      // If we're in an environment where we are only allowed to have more than a single element,
      // we'll instead reset after the the first ad has started in handleAdStarted for a smoother transition
      // from ad to content

      var contentResetTime;
      var contentStartTime = Math.max(0, this.startTime);
      var contentDifference = currentPlayhead - contentStartTime;

      if (started && contentDifference >= 0 && contentDifference <= latePrerollRestartThreshold && OO.requiresSingleVideoElement) {
        contentResetTime = contentStartTime;
      }

      this.ui.transitionToMainContent(shouldResume, this.ended, contentResetTime);

      _tryPublishPrerollsDone(); // This will trigger any pending overlays


      _triggerNextAd();

      _resetAdState(); // Reshow the overlay if the ad finished playing, if there was one.


      if (overlay && currentAd && this.adManagers[currentAd.adManager]) {
        _safeFunctionCall(this.adManagers[currentAd.adManager], 'showOverlay');

        mb.publish(OO.EVENTS.SHOW_NONLINEAR_AD);
      }
    };
    /**
     * Alerts the ad manager that an ad has been clicked on and it should react.
     * @protected
     * @method AdManagerController#onAdsClicked
     * @param {object} event The event object that sent when the event dispatches.
     * @param {object} prop An Object sent with the event that contains data we need to find what the source of ads clicked
     * was.
     */


    this.onAdsClicked = function (event, prop) {
      this.adsClicked(prop);
    };
    /**
     * Alerts the ad manager that a video stream tag has been found.
     * @protected
     * @method AdManagerController#onVideoTagFound
     * @param {string} event The event that triggered this callback.
     * @param {string} videoId The id of the video element that processed a tag.
     * @param {string} tagType The type of tag that was detected.
     * @param {object} metadata Any metadata attached to the found tag.
     */


    this.onVideoTagFound = function (event, videoId, tagType, metadata) {
      _triggerAdManagerCallback(this.EVENTS.VIDEO_TAG_FOUND, videoId, tagType, metadata);
    };
    /**
     * Notifies ad manager plugins that a URL for the MAIN element has been selected/changed.
     * @protected
     * @method AdManagerController#onVideoElementCreated
     * @param {string} eventName The name of the event that triggered this callback
     * @param {object} elementParams The parameters of the element created including id, domId, parent,
     *                               video element, and supported encodings
     */


    this.onVideoElementCreated = _.bind(function (eventName, elementParams) {
      if (elementParams['videoId'] === OO.VIDEO.MAIN) {
        var streamUrl = elementParams['streamUrl'];

        if (streamUrl) {
          _triggerAdManagerCallback(this.EVENTS.CONTENT_URL_CHANGED, streamUrl);
        }
      }
    }, this);
    /**
     * Callback for the chromecasting started event
     * @protected
     * @method AdManagerController#onChromecastStartCast
     * @param {string} eventName The name of the event that triggered this callback
     * @param {object} elementParams The parameters of the element created including id, domId, parent,
     *                               video element, and supported encodings
     */

    this.onChromecastStartCast = function () {
      isChromeCasting = true;
      mb.unsubscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, moduleName, this.onPlayheadTimeChanged);
    };
    /**
     * Callback for the chromecasting ended event
     * @protected
     * @method AdManagerController#onChromecastEndCast
     */


    this.onChromecastEndCast = function () {
      isChromeCasting = false;
      mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, moduleName, this.onPlayheadTimeChanged);
    };
    /**
     * Notifies the player that the ad plugin SDK has loaded successfully.
     * @protected
     * @method AdManagerController#onAdSdkLoaded
     * @param {string} adPluginName The name of the ad plugin that sent this event
     */


    this.onAdSdkLoaded = function (adPluginName) {
      OO.log('onAdSdkLoaded: ', adPluginName, OO.VERSION.core.releaseVersion);
      mb.publish(OO.EVENTS.AD_SDK_LOADED, adPluginName, OO.VERSION.core.releaseVersion);
    };
    /**
     * Notifies the player that the ad plugin SDK has failed to load.
     * @method AdManagerController#onAdSdkLoadFailure
     * @protected
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {(object|string)} error The error name or information.
     * @fires OO.EVENTS.AD_SDK_LOAD_FAILED
     */


    this.onAdSdkLoadFailure = function (adPluginName, error) {
      mb.publish(OO.EVENTS.AD_SDK_LOAD_FAILED, adPluginName, OO.VERSION.core.releaseVersion, error);
    };
    /**
     * Notifies the player that an ad has been requested by the sdk.
     * @protected
     * @method AdManagerController#onAdRequest
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {number} adPosition The time the ad is scheduled to play
     */


    this.onAdRequest = function (adPluginName, adPosition) {
      mb.publish(OO.EVENTS.AD_REQUEST, adPluginName, adPosition);
    };
    /**
     * Notifies the player that the ad plugin has successfully requested an ad.
     * @protected
     * @method AdManagerController#onAdRequestSuccess
     * @param {string} adPluginName The name of the ad plugin used
     * @param {number} adPosition The position the ad is scheduled to play
     * @param {number} responseTime The time in milliseconds that it took to get a response for the ad request
     * @param {number} timeSinceInitialPlay The time in milliseconds from the initial play request time to ad request success
     */


    this.onAdRequestSuccess = function (adPluginName, adPosition, responseTime, timeSinceInitialPlay) {
      mb.publish(OO.EVENTS.AD_REQUEST_SUCCESS, adPluginName, adPosition, responseTime, timeSinceInitialPlay);
    };
    /**
     * Notifies the player that the ad plugin has received an empty response to an ad request.
     * @protected
     * @method AdManagerController#onAdRequestEmpty
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {number} adPosition The time the ad is scheduled to play
     * @param {string} adTagUrl The ad tag url post macro substitution
     * @param {object} errorCode The error code if any
     * @param {string} errorMessage The error message
     */


    this.onAdRequestEmpty = function (adPluginName, adPosition, adTagUrl, errorCode, errorMessage) {
      mb.publish(OO.EVENTS.AD_REQUEST_EMPTY, adPluginName, adPosition, adTagUrl, errorCode, errorMessage);
    };
    /**
     * Notifies the player that the ad plugin has received an error response to an ad request.
     * @protected
     * @method AdManagerController#onAdRequestError
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {number} adPosition The time the ad is scheduled to play
     * @param {string} adTagUrl The ad tag url post macro substitution
     * @param {object} errorCode The error code if any
     * @param {string} errorMessage The error message
     * @param {boolean} isTimeout If ad request timed out or not
     */


    this.onAdRequestError = function (adPluginName, adPosition, adTagUrl, errorCode, errorMessage, isTimeout) {
      mb.publish(OO.EVENTS.AD_REQUEST_ERROR, adPluginName, adPosition, adTagUrl, errorCode, errorMessage, isTimeout);
    };
    /**
     * Notifies the player that the ad plugin has received an error trying to play back ad.
     * @protected
     * @method AdManagerController#onAdPlaybackError
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {number} adPosition The time the ad is scheduled to play
     * @param {string} adTagUrl The ad tag url post macro substitution
     * @param {object} errorCode The error code if any
     * @param {string} errorMessage The error message
     * @param {string} mediaFileUrl The url used to retrieve the ad media file
     */


    this.onAdPlaybackError = function (adPluginName, adPosition, adTagUrl, errorCode, errorMessage, mediaFileUrl) {
      var plugins = OO.Video.getRegisteredPlugins();
      var pluginNames = {
        pluginNames: Object.getOwnPropertyNames(plugins)
      };
      mb.publish(OO.EVENTS.AD_PLAYBACK_ERROR, adPluginName, adPosition, adTagUrl, errorCode, errorMessage, pluginNames, mediaFileUrl);
    };
    /**
     * Notifies the player when the ad impression is received.
     * @protected
     * @method AdManagerController#onAdSdkImpression
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {number} adPosition The time the ad is scheduled to play
     * @param {number} adLoadTime The time in milliseconds between the ad request success and started
     * @param {string} adProtocol The ad protocol (VAST / VPAID)
     * @param {string} adType The ad type (LinearOverlay, LinearVideo, NonLinearOverlay, NonLinearVideo)
     */


    this.onAdSdkImpression = function (adPluginName, adPosition, adLoadTime, adProtocol, adType) {
      mb.publish(OO.EVENTS.AD_SDK_IMPRESSION, adPluginName, adPosition, adLoadTime, adProtocol, adType);
    };
    /**
     * Notifies the player that an ad has completed.
     * @protected
     * @method AdManagerController#onAdCompleted
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {number} timeSinceImpression The time passed since the ad impression
     *                                        was recorded in milliseconds
     * @param {boolean} skipped True if ad was skipped by user.
     * @param {string} adTagUrl The ad tag url post macro substitution
     */


    this.onAdCompleted = function (adPluginName, timeSinceImpression, skipped, adTagUrl) {
      mb.publish(OO.EVENTS.AD_COMPLETED, adPluginName, timeSinceImpression, skipped, adTagUrl);
    };
    /**
     * Notifies the player that an SDK Ad Event has occurred. Currently private as
     * we do not want to expose this at this time.
     * @private
     * @method AdManagerController#onSdkAdEvent
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {string} adEventName The name of this event from the ad plugin
     * @param {object} adEventData An object containing details of the ad event. This may vary
     *                               between ad plugin to ad plugin.
     */


    this.onSdkAdEvent = function (adPluginName, adEventName, adEventData) {
      mb.publish(OO.EVENTS.SDK_AD_EVENT, adPluginName, adEventName, adEventData);
    }; // Live Stream Helpers

    /**
     * Helper function to calculate the duration of a pause or from the time
     * initial play is called to the time the video actually begins playing. Accumulate
     * these delays/offsets to then use as part of the calculation for the live playhead.
     * @private
     * @method AdManagerController#_handleLiveStreamDelays
     */


    var _handleLiveStreamDelays = _.bind(function () {
      var now = Date.now();
      var paused = this.liveStreamTimestamps.paused;
      var initialPlay = this.liveStreamTimestamps.initialPlay;

      if (paused && _.isFinite(paused.ms) && !paused.delayUsed) {
        this.timeMainVideoIdleMs += now - paused.ms;
        this.liveStreamTimestamps.paused.delayUsed = true;
      }

      if (initialPlay && _.isFinite(initialPlay.ms) && !initialPlay.delayUsed) {
        this.timeMainVideoIdleMs += now - initialPlay.ms;
        this.liveStreamTimestamps.initialPlay.delayUsed = true;
      }
    }, this);
    /**
     * Helper function to calculate the playhead for a livestream. The live playhead is calculated
     * by taking: timeSinceInitialPlay - timeMainVideoIdle
     * timeMainVideoIdle is the accumulation of the duration of pauses, ad playback, and
     * delay between hitting play and the stream actually playing back (aka the duration of non main
     * video playback).
     * @private
     * @method AdManagerController#_calculateLivePlayhead
     * @returns {number} The live playhead represented in milliseconds.
     */


    var _calculateLivePlayhead = _.bind(function () {
      if (this.liveStreamTimestamps && this.liveStreamTimestamps.initialPlay) {
        var ms = 1000;
        var timeSinceInitialPlayMs = Date.now() - this.liveStreamTimestamps.initialPlay.ms;
        var mainVideoPlayhead = (timeSinceInitialPlayMs - this.timeMainVideoIdleMs) / ms;
        return mainVideoPlayhead;
      }

      return 0;
    }, this);
    /**
     * Determines if we should play an ad based on the first_shown and frequency attributes
     * of the ad object backlot/page level settings provides us.
     * @private
     * @method AdManagerController#_shouldPlayAd
     * @param {number} playAfter The number of main content views prior to showing an ad
     * @param {number} adFrequency How often we want to show an ad. (adFrequency - 1) main
     * content views between ads
     * @returns {boolean} True if we should play the ad, false otherwise
     */


    var _shouldPlayAd = function _shouldPlayAd(playAfter, adFrequency) {
      var sanitizedPlayAfter = playAfter > 0 ? playAfter : 0;
      var sanitizedAdFrequency = adFrequency > 0 ? adFrequency : 0; // compare main video count against play after and ad frequency values

      var count = OO.localStorage.getItem(VIDEO_COUNT_KEY);
      count = count && +count > 0 ? +count : 0;
      var shouldPlayAd = false;

      if (count >= sanitizedPlayAfter && (sanitizedAdFrequency === 0 || (count - sanitizedPlayAfter) % sanitizedAdFrequency === 0)) {
        shouldPlayAd = true;
      }

      return shouldPlayAd;
    };
    /**
     * Increments a count of main content playbacks by this user.
     * @private
     * @method AdManagerController#_incrementMainVideoCount
     */


    var _incrementMainVideoCount = _.bind(function () {
      // Add main video count to local storage so ad frequency
      // can be upheld
      var count = OO.localStorage.getItem(VIDEO_COUNT_KEY);
      count = (count && +count > 0 ? +count : 0) + 1;
      OO.setItem(VIDEO_COUNT_KEY, count);
      OO.log('MAIN VIDEO COUNT: ' + OO.localStorage.getItem(VIDEO_COUNT_KEY));
    }, this); /// ////// CLEANUP ////////


    var _resetAdState = _.bind(function () {
      if (lastOverlayAd) {
        currentAd = lastOverlayAd;
        overlay = true;
        this.adStarted = true;
      } else {
        currentAd = null;
        overlay = false;
        this.adStarted = false;
      }

      singleAdPlaying = false;
      adPaused = false;
      ssaiAdPlaying = false;
      adManagerShowSkipButton = true;
      adManagerSkipButtonOffset = null;
      pendingPodEnd = false;
    }, this);

    var _resetMovieState = _.bind(function () {
      adQueue = [];
      seeked = false;
      seeking = false;
      paused = false;
      lastOverlayAd = null;
      this.ended = false;
      seekToEndThreshold = 0;
      skipAdsOnSeek = false;
      seekedPosition = 0;
      this.waitForPostrollToPlay = true;
      started = false;
      startTriggered = false;
      movieMetadataRaised = false;
      backlotSettingsRaised = false;
      initialPlayReceived = false;
      amcPrerollsDoneCalled = false;
    }, this); // Reset all movie properties


    var _reset = _.bind(function (destroying) {
      // Ad manager state
      allready = false;
      initialized = false;
      readyForAdPlayback = false; // Movie data properties

      this.movieMetadata = null;
      this.startTime = -1;
      this.movieDuration = -1;
      this.isLiveStream = false; // Movie state properties

      currentPlayhead = 0;
      timeline = [];
      cancelling = false; // remove message bus subscriptions

      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'amc');
      mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, 'amc');
      mb.unsubscribe(OO.EVENTS.VC_ERROR, 'amc');

      _resetMovieState();

      _resetAdState();

      _resetPlaybackEventDependencies(destroying);
    }, this);

    var _destroy = _.bind(function () {
      if (this.ui && typeof this.ui.destroy === 'function') {
        this.ui.destroy();
      }

      for (var _id in adTimeouts) {
        if (adTimeouts.hasOwnProperty(_id)) {
          clearAdTimeout(_id);
        }
      } // stop any ads that are playing


      if (this.currentState === 'LinearAd' || this.currentState === 'Overlay') {
        _cancelCurrentAd({
          code: this.AD_CANCEL_CODE.STREAM_ENDED
        });
      }

      for (var key in this.adManagers) {
        this.unregisterAdManager(key);
      }

      this.fsm.destroyFsm();

      _reset(true);
    }, this);
    /**
     * Called when the player is being destroyed.  Destroys the ad manager controller, including the state
     * machine and all registered ad managers.
     * @protected
     * @method AdManagerController#onDestroy
     */


    this.onDestroy = function () {
      _destroy();
    };
    /**
     * Returns a list of all registered ad managers. This can be used in testing.
     * @method AdManagerController#getRegisteredAdManagers
     * @public
     * @returns {Object[]} A list of all registered ad managers.
     */


    this.getRegisteredAdManagers = function () {
      return this.adManagers;
    };
    /**
     * Unregisters an ad manager.
     * @public
     * @method AdManagerController#unregisterAdManager
     * @param {string} name The name of the ad manager to unregister, traditionally represented by
     *                      <code>adManager.name</code>.
     */


    this.unregisterAdManager = function (name) {
      OO.log('AMC: Removing an ad manager: ' + name);

      if (name && this.adManagers[name]) {
        if (_.isFunction(this.adManagers[name].destroy)) {
          try {
            this.adManagers[name].destroy();
          } catch (err) {
            OO.log('AMC: Error destroying an ad manager - ' + err);
          }
        }

        this.unregisteredAdManagers.push(name);
        delete this.adManagers[name];
      }
    };
  }; // Helpers
  // Safely trigger an ad manager function


  var _safeFunctionCall = function _safeFunctionCall(adManager, func, params) {
    try {
      if (_.isFunction(adManager[func])) {
        return adManager[func].apply(adManager, params);
      }
    } catch (err) {
      OO.log('AMC: ad manager', adManager && adManager.name, "at function '" + func + "' threw exception -", err);
    }

    return null;
  };
  /**
   * The ad manager controller object.
   * @private
   */


  var controller = null;

  var factory = _.bind(function (messageBus, id) {
    controller = new OO.AdManagerController(messageBus, id);
    return controller;
  }, this);

  if (OO.TEST_TEST_TEST) {
    global.amcModuleFactory = factory;
  }

  OO.registerModule('adManagerController', factory);
})(OO, OO._, OO.$);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/objectSpread":16,"@babel/runtime/helpers/typeof":18}],64:[function(require,module,exports){
"use strict";

/**
 * Ad Manager For Ooyala video as Ads
 */
OO.Ads.manager(function (_, $) {
  /**
   * @class OO.OoyalaAdManager
   * @classDesc The Ooyala Ads Manager class, registered as an ads manager with the ad manager controller.
   * Controls how Ooyala ads are loaded and played as ads while communicating with the ad manager framework.
   * @public
   * @property {string} name Name of the OoyalaAdManager, must match what is sent from Backlot and used at the page level.
   * @property {boolean} ready ready Used to communicate with the ad manger controller if the manager is ready to go.
   * @property {object} movieMetadata Store metadata for the main video
   * @property {object} streams Store streams info of the ad.
   */
  var OoyalaAdManager = function OoyalaAdManager() {
    this.name = 'ooyala-ads-manager';
    this.adId = null;
    this.ready = false;
    this.initTime = Date.now();
    this.movieMetadata = {};
    this.streams = {};
    var _amc = null;
    var _adEmbedCode = '';
    var _movieEmbedCode = '';
    var _getMainVideoEmbedCode = true;
    var _adProperties = {};
    var _clickedOnAdBefore = false;
    var metadataLoaded = false;
    var fetchedAdAuthorization = false;
    var afterOoyalaAd = false;
    var startTime = 0;

    var _reset = _.bind(function () {
      OO.log(this.name + ': resetting');
      this.adId = null;
      this.ready = false;
      this.initTime = Date.now();
      this.movieMetadata = {};
      this.streams = {};
      _adEmbedCode = '';
      _movieEmbedCode = '';
      _getMainVideoEmbedCode = true;
      _adProperties = {};
      _clickedOnAdBefore = false;
      metadataLoaded = false;
      fetchedAdAuthorization = false;
      afterOoyalaAd = false;
    }, this);
    /**
     * Called by the Ad Manager Controller. Use this function to initialize, create listeners, and load
     * remote JS files.
     * @method OoyalaAdManager#initialize
     * @public
     * @param {object} adManagerController A reference to the Ad Manager Controller
     * @param {string} playerId The unique player identifier of the player initializing the class
     */


    this.initialize = function (adManagerController, playerId) {
      _reset();

      startTime = new Date().getTime();
      _amc = adManagerController;
    };
    /**
     * Called by Ad Manager Controller. When this function is called, all movie and server metadata are
     * ready to be parsed.
     * This metadata may contain the adTagUrl and other ad manager and movie specific configuration.
     * @method AdManager#loadMetadata
     * @public
     * @param {object} adManagerMetadata Ad manager-specific metadata
     * @param {object} backlotBaseMetadata Base metadata from Ooyala Backlot
     * @param {object} movieMetadata Metadata for the main video
     */


    this.loadMetadata = function (adManagerMetadata, backlotBaseMetadata, movieMetadata) {
      OO.log(this.name + ': Load Metadata at ' + (new Date().getTime() - startTime) + ' ms');

      if (!_amc) {
        return;
      }

      _amc.addPlayerListener(_amc.EVENTS.CONTENT_CHANGED, _onContentChanged);

      this.movieMetadata = movieMetadata;

      if (_getMainVideoEmbedCode && movieMetadata) {
        this.ready = false;
        _movieEmbedCode = movieMetadata.embed_code;
        _getMainVideoEmbedCode = false;
      }

      metadataLoaded = true;

      _tryFetchAdAuthorization();
    };
    /**
     * Called by Ad Manager Controller.  When this function is called, the content authorization will have been fetched.
     * At this point, we can safely fetch our ad authorization.
     * @method OoyalaAdManager#authorizationFetched
     * @public
     */


    this.authorizationFetched = function () {
      OO.log(this.name + ': Authorization Fetched at ' + (new Date().getTime() - startTime) + ' ms');
    };
    /**
     * Try to fetch our ad authorization. We will wait until the metadata has been loaded.
     * @method OoyalaAdManager#_tryFetchAdAuthorization
     * @private
     */


    var _tryFetchAdAuthorization = _.bind(function () {
      OO.log(this.name + ': Try Fetch Ad Authorization at ' + (new Date().getTime() - startTime) + ' ms'); // If we have not loaded all initial metadata, return as we are not ready to try to fetch ad authorization

      if (!metadataLoaded || !_amc || fetchedAdAuthorization) {
        return;
      } // If we have loaded all initial metadata and there are no Ooyala ads, set to ready and return as this ad
      // manager has nothing else to do


      if (!this.movieMetadata || !this.movieMetadata.ads || this.movieMetadata.ads.length <= 0 || !this.movieMetadata.ads[0] || !this.movieMetadata.ads[0].ad_embed_code) {
        OO.log(this.name + ': No Ooyala Ads at ' + (new Date().getTime() - startTime) + ' ms');
        fetchedAdAuthorization = true;

        _setReady();

        _reset(); // We need to Ooyala ads manager to remain ready in case there are other ad managers that need to load
        // The reset() call above is setting this.ready to false


        this.ready = true;
        return;
      }

      OO.log(this.name + ': Fetching Ad Authorization at ' + (new Date().getTime() - startTime) + ' ms');
      fetchedAdAuthorization = true;
      _adEmbedCode = this.movieMetadata.ads[0].ad_embed_code;
      var adsRequest = {
        pcode: this.movieMetadata.asset_pcode || 'unknown',
        embedCode: _adEmbedCode,
        server: OO.SERVER.AUTH,
        params: OO.playerParams
      };

      _amc.notify(_amc.EVENTS.WILL_FETCH_AD_AUTHORIZATION, adsRequest, sasErrorCallback);
    }, this);

    var sasErrorCallback = function sasErrorCallback(xhr, status, error) {
      OO.log('Error: Failed SAS call for Ooyala Ad. Continuing on with playback.');

      _setReady();
    };
    /**
     * Called by Ad Manager Controller.  When this function is called, all the information about the Ooyala
     * ads will be received and will notify the controller that the Ad Manager is ready.
     * @method OoyalaAdManager#ooyalaAdData
     * @public
     * @param {object} adData Ad-specific metadata
     */


    this.ooyalaAdData = function (adData) {
      OO.log(this.name + ': Ooyala Ad Data at ' + (new Date().getTime() - startTime) + ' ms');

      if (!adData) {
        return;
      }

      this.streams[OO.VIDEO.ENCODING.MP4] = adData;

      _setReady();
    };
    /**
     * Sets this ad manager as ready. Notifies the Ad Manager Controller of this event, unblocking playback.
     * @method OoyalaAdManager#_setReady
     * @private
     */


    var _setReady = _.bind(function () {
      OO.log(this.name + ': Set ready at ' + (new Date().getTime() - startTime) + ' ms');
      this.ready = true;
      var loadTime = Date.now() - this.initTime;

      _amc.reportPluginLoaded(loadTime, this.name);

      var createMp4Element = !_.isEmpty(this.streams);

      _amc.onAdManagerReady(createMp4Element);
    }, this);
    /**
     * Called once per video by Ad Manager Controller once the ad manager has set its ready flag to true.
     * This function asks the ad manager to return a list of all ads to the controller for addition in the
     * line. If the list of ads is not available at this time, then return [].
     * The duration and position of each ad should be specified in seconds.
     * @method OoyalaAdManager#buildTimeline
     * @public
     * @returns {OO.AdManagerController#Ad[]} timeline A list of the ads to play for the current video
     */


    this.buildTimeline = function () {
      var adsTimeline = [];
      OO.log(this.name + ': Build Timeline at ' + (new Date().getTime() - startTime) + ' ms');

      if (!this.movieMetadata || !this.movieMetadata.ads) {
        return adsTimeline;
      }

      for (var index = 0; index < this.movieMetadata.ads.length; index++) {
        var adData = this.movieMetadata.ads[index];

        if (adData && adData.type === 'ooyala') {
          var amcAdData = {
            'position': adData.time,
            'adManager': this.name,
            'ad': adData,
            'streams': {},
            'adType': _amc.ADTYPE.UNKNOWN_AD_REQUEST
          };
          amcAdData.streams[OO.VIDEO.ENCODING.MP4] = '';
          var adToInsert = new _amc.Ad(amcAdData);
          adsTimeline.push(adToInsert);
        }
      }

      return adsTimeline;
    };
    /**
     * Called by Ad Manager Controller. The ad manager should play the ad or group of podded ads passed to
     * the function as a parameter.
     * @method OoyalaAdManager#playAd
     * @public
     * @param {object} ad The ad object to play
     *
     * TODO: _adProperties.name and _adProperties.duration need data supplied from backlotBaseMetadata.
     *
     */


    this.playAd = function (ad) {
      OO.log(this.name + ': Play Ad at ' + (new Date().getTime() - startTime) + ' ms');
      _amc.pageSettings.autoPlay = true;
      _amc.pageSettings.ooyalaAds = true;
      _adProperties.indexInPod = 1;

      if (this.movieMetadata) {
        _adProperties.name = this.movieMetadata.title;
        _adProperties.duration = this.movieMetadata.duration;
      } else {
        _adProperties.name = '';
        _adProperties.duration = 30;
      }

      _adProperties.ooyalaAds = true;
      _adProperties.hasClickUrl = ad.ad.click_url;
      _adProperties.skippable = false;
      this.adId = ad.id;

      var tempPageSettings = _.clone(_amc.pageSettings);

      tempPageSettings.onCreate = null; // PLAYER-2796 - we need to set isAd to true here so isAdPlaying works in the player external api
      // for Ooyala Ad manager ads (MyAds).

      tempPageSettings.isAd = true;

      _amc.notify(_amc.EVENTS.SET_EMBED_CODE, _adEmbedCode, tempPageSettings);

      _amc.notifyLinearAdStarted(ad.id, _adProperties);
    };
    /**
     * Called by Ad Manager Controller. The ad manager should cancel the ad passed to the function as a
     * parameter. After cancelling the ad, the ad manager should call the adEndedCallback to indicate that
     * ad cancellation has completed. If the given ad is not currently playing and the adEndedCallback has
     * already been called, then no action is required.
     * @method OoyalaAdManager#cancelAd
     * @public
     * @param {object} ad The ad object to cancel
     * @param {object} params An object containing information about the cancellation. It will include the
     *                        following fields:
     *                 code : The _amc.AD_CANCEL_CODE for the cancellation
     */


    this.cancelAd = function (ad, params) {
      OO.log('Cancelling Ooyala ad');

      if (params && params.code === _amc.AD_CANCEL_CODE.SKIPPED) {
        _amc.pageSettings.ooyalaAds = false;

        _amc.notify(OO.EVENTS.SINGLE_AD_PLAYED, this.adId);

        _amc.notify(OO.EVENTS.AD_POD_ENDED, this.adId);

        var movieEmbedCode = _movieEmbedCode;

        _reset();

        afterOoyalaAd = true;

        _amc.notify(OO.EVENTS.SET_EMBED_CODE_AFTER_OOYALA_AD, movieEmbedCode, _amc.pageSettings);
      }
    };
    /**
     * Called when player clicks on the tap frame, if tap frame is disabled, then this function will not be
     * called
     * @method OoyalaAdManager#playerClicked
     * @public
    */


    this.playerClicked = function () {
      OO.log('Click Url = ' + _adProperties.hasClickUrl);

      if (_clickedOnAdBefore) {
        _amc.notify(OO.EVENTS.PLAY);

        _clickedOnAdBefore = false;
      } else {
        _amc.notify(OO.EVENTS.PAUSE);

        if (this.openUrl(_adProperties.hasClickUrl)) {
          _amc.adsClickthroughOpened();
        }

        _clickedOnAdBefore = true;
      }
    };
    /**
    * Checks whether URL is valid or not.
    * @private
    * @method OoyalaAdManager#isClickThroughURLValid
    * @param {string} url The url that needs to be validated
    * @returns {boolean} true, if the URL is valid. Returns false, if url is invalid.
    */


    var isClickThroughURLValid = _.bind(function (url) {
      if (typeof url === 'string' && url.length > 0) {
        return true;
      }

      return false;
    }, this);
    /**
     * Opens a new page pointing to the URL provided.
     * @public
     * @method OoyalaAdManager#openUrl
     * @param {string} url The url that we need to open in a new page
     * @returns {boolean} true, if the URL is valid. Returns false, if url is invalid.
     */


    this.openUrl = function (url) {
      if (isClickThroughURLValid(url)) {
        window.open(url);
        return true;
      }

      return false;
    };
    /**
     * Called when ad is finished playing.
     * @method OoyalaAdManager#adVideoEnded
     * @public
     */


    this.adVideoEnded = function () {
      OO.log(this.name + ': adVideoEnded at ' + (new Date().getTime() - startTime) + ' ms');
      _amc.pageSettings.ooyalaAds = false;

      _amc.notify(OO.EVENTS.SINGLE_AD_PLAYED, this.adId);

      _amc.notify(OO.EVENTS.AD_POD_ENDED, this.adId);

      var movieEmbedCode = _movieEmbedCode;

      _reset();

      afterOoyalaAd = true;

      _amc.notify(OO.EVENTS.SET_EMBED_CODE_AFTER_OOYALA_AD, movieEmbedCode, _amc.pageSettings);
    };

    var _onContentChanged = _.bind(function () {
      OO.log(this.name + ': onContentChanged at ' + (new Date().getTime() - startTime) + ' ms');
      startTime = new Date().getTime(); // We need to set to ready so the AMC can proceed when attempting to play the Ooyala ad.
      // We reset this value to false in this.loadMetadata

      this.ready = true;

      if (afterOoyalaAd) {
        _reset();
      }
    }, this);
    /**
     * Remove player listeners.
     * @public
     * @method OoyalaAdManager#destroy
     */


    this.destroy = function () {
      OO.log(this.name + ': Destroy at ' + (new Date().getTime() - startTime) + ' ms');

      if (_amc) {
        _amc.removePlayerListener(_amc.EVENTS.CONTENT_CHANGED, _onContentChanged);
      }

      _clickedOnAdBefore = false;
    };
  };

  return new OoyalaAdManager();
});

},{}],65:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

if (window.WebKitPlaybackTargetAvailabilityEvent && OO.isSafari) {
  var pluginName = 'Airplay';
  var connectedMarker = 'OO_AIRPLAY_CONNECTED';
  OO.plugin(pluginName, function (OO) {
    /**
     * @class Airplay
     * @desc This class takes care of airplay initialization in Safari
     * Also handles Webkit-ooyala events conversion
     * {@link https://developer.apple.com/documentation/webkitjs/adding_an_airplay_button_to_your_safari_media_controls Airplay documentation}
     * @public
     */
    var Airplay =
    /*#__PURE__*/
    function () {
      function Airplay(messageBus) {
        var _this = this;

        (0, _classCallCheck2.default)(this, Airplay);
        this.mb = messageBus;
        this.airplayEnabledInPlayerParams = true;
        this.vcVideoElementParams = null;
        this.safariPriorTo12m1 = Airplay.checkIfSafariVersionIsPriorTo12minor1();
        this.ignoreFirstConnectedEvent = this.safariPriorTo12m1;
        this.ignoreSecondConnectedEvent = false;
        this.availability = null;
        this.isSessionResumed = Airplay.checkIfPageWasReloadedWhileCasting();
        this.isAirplayConnected = this.isSessionResumed;
        this.mb.subscribe(OO.EVENTS.PLAYER_CREATED, pluginName, this.onPlayerCreated.bind(this));
        this.mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, pluginName, this.onVcVideoElementCreated.bind(this));
        this.mb.subscribe(OO.EVENTS.AIRPLAY.BUTTON_CLICKED, pluginName, this.onAirplayButtonClicked.bind(this));
        this.mb.subscribe(OO.EVENTS.WILL_PLAY_ADS, pluginName, function () {
          _this.adsPlaying = true;
        });
        this.mb.subscribe(OO.EVENTS.ADS_PLAYED, pluginName, function () {
          _this.adsPlaying = false;
        });
        this.mb.subscribe(OO.EVENTS.SET_EMBED_CODE, pluginName, function () {
          // ignore second Airplay#playbackTargetChanged event fired by Safari < 12.1
          // if src of a video was previously set to null or removed via removeAttibute('src')
          // see video_controller.js#embedCodeChanged or main-html5.js#setVideoUrl methods for more info
          if (_this.safariPriorTo12m1 && _this.isAirplayConnected && !_this.isSessionResumed) {
            _this.ignoreSecondConnectedEvent = true;
          }
        });
        this.mb.subscribe(OO.EVENTS.CAN_PLAY, pluginName, function () {
          // since main-html5.js video plugin sends CAN_PLAY event before VC_ELEMENT_CREATED
          // airplay initialization for main-html5.js will be done in onVcVideoElementCreated()
          if (!_this.vcVideoElementParams) {
            return;
          } // if webkit event listeners've already been initialized in VC_ELEMENT_CREATED.
          // safety check in case main-html5.js' behaviour will be changed one day


          if (_this.webkitListenersInitialized) {
            return;
          } // since Bitmovin adds <video> element to the DOM only on player.load() call


          _this.video = _this.vcVideoElementParams.parent[0].querySelector('video');

          if (_this.video && _this.airplayEnabledInPlayerParams) {
            _this.initWebkitListeners();

            _this.webkitListenersInitialized = true;
          }
        });
      }
      /**
       * Callback for the OO.EVENTS.PLAYER_CREATED event.
       * airplay page level param is received here.
       * @method Airplay#onPlayerCreated
       * @private
       * @param {string} event     Event name OO.EVENTS.PLAYER_CREATED
       * @param {string} elementId Name of the div player was created in
       * @param {object} params    Page level params for the player
       */


      (0, _createClass2.default)(Airplay, [{
        key: "onPlayerCreated",
        value: function onPlayerCreated(event, elementId, params) {
          // disable airplay only if "airplay":false is set directly
          if (params.airplay === false || params.airplay === 'false') {
            this.airplayEnabledInPlayerParams = false;
          }
        }
        /**
         * Callback for the OO.EVENTS.VC_VIDEO_ELEMENT_CREATED event.
         * The Video Controller has created the desired video element
         * @method Airplay#onVcVideoElementCreated
         * @private
         * @param {string} event  Event name OO.EVENTS.VC_VIDEO_ELEMENT_CREATED
         * @param {object} params Object containing video element created by the video plugin
         */

      }, {
        key: "onVcVideoElementCreated",
        value: function onVcVideoElementCreated(event, params) {
          if (this.safariPriorTo12m1) {
            this.ignoreFirstConnectedEvent = true;
          }

          if (this.webkitListenersInitialized) {
            return;
          }

          this.vcVideoElementParams = params;
          this.video = params.parent[0].querySelector('video');

          if (!this.video || !this.airplayEnabledInPlayerParams) {
            return;
          }

          this.initWebkitListeners();
          this.webkitListenersInitialized = true;
        }
        /**
         * This method initiated AirPlay event listeners
         * @method AirPlay#initWebkitListeners
         * @private
         */

      }, {
        key: "initWebkitListeners",
        value: function initWebkitListeners() {
          this.video.addEventListener('webkitplaybacktargetavailabilitychanged', this.onAvailabilityChanged.bind(this));
          this.video.addEventListener('webkitcurrentplaybacktargetiswirelesschanged', this.onConnectedChanged.bind(this));
        }
        /**
         * Callback for WebkitPlaybackTargetAvailabilityChanged event.
         * This event detects when AirPlay availability changes
         * @method AirPlay#onAvailabilityChanged
         * @private
         * @param {object} event object containing availability param
         */

      }, {
        key: "onAvailabilityChanged",
        value: function onAvailabilityChanged(event) {
          var availability = event.availability === 'available'; // ignore duplicate calls

          if (this.availability !== availability) {
            this.availability = availability;
            this.mb.publish(OO.EVENTS.AIRPLAY.AVAILABILITY_CHANGED, availability);
          }
        }
        /**
         * Callback for WebkitCurrentPlaybackTargetIsWirelessChanged event.
         * This event fires when a media element starts or stops AirPlay playback.
         * Also fires if page was reloaded while casting.
         * @method Airplay#onConnectedChanged
         * @private
         */

      }, {
        key: "onConnectedChanged",
        value: function onConnectedChanged() {
          if (this.adsPlaying) {
            return;
          } // ignore first call bug during initialization for Safari < 12.1


          if (this.safariPriorTo12m1 && this.ignoreFirstConnectedEvent) {
            this.ignoreFirstConnectedEvent = false;
            return;
          }

          if (this.safariPriorTo12m1 && this.ignoreSecondConnectedEvent) {
            this.ignoreSecondConnectedEvent = false;
            return;
          }

          if (this.isSessionResumed) {
            this.isSessionResumed = false;
            this.mb.publish(OO.EVENTS.AIRPLAY.SESSION_RESUMED);
            return;
          }

          Airplay.toggleSessionStorageMarker();
          this.isAirplayConnected = !this.isAirplayConnected;
          this.mb.publish(OO.EVENTS.AIRPLAY.CONNECTION_CHANGED, this.isAirplayConnected);
        }
        /**
         * Callback for OO.EVENTS.AIRPLAY.BUTTON_CLICKED event.
         * @method Airplay#onAirplayButtonClicked
         * @private
         */

      }, {
        key: "onAirplayButtonClicked",
        value: function onAirplayButtonClicked() {
          var _this2 = this;

          // in setTimeout for MacOS related bugs
          // checkbox in the targetPicker wouldn't be displayed otherwise
          setTimeout(function () {
            return _this2.video.webkitShowPlaybackTargetPicker();
          });
        }
        /**
         * Checks Session Storage for airplay-connected marker.
         * @static
         * @method AirPlay#checkIfPageWasReloadedWhileCasting
         * @returns {boolean} true if a page was reloaded while casting
         */

      }], [{
        key: "checkIfPageWasReloadedWhileCasting",
        value: function checkIfPageWasReloadedWhileCasting() {
          return Boolean(window.sessionStorage.getItem(connectedMarker));
        }
        /**
         * Checks Safari version
         * @static
         * @method AirPlay#checkIfSafariVersionIsPriorTo12minor1
         * @returns {boolean} true if Safari version is prior to 12.1
         */

      }, {
        key: "checkIfSafariVersionIsPriorTo12minor1",
        value: function checkIfSafariVersionIsPriorTo12minor1() {
          var safariVersionWithConnectionEventFixed = 12.1;
          var currentSafariVersion = parseFloat(window.navigator.userAgent.match(/Version\/([\d.]+)/)[1]);
          return currentSafariVersion < safariVersionWithConnectionEventFixed;
        }
        /**
         * Set/Remove airplay-connected marker in Session Storage
         * @static
         * @method Airplay#toggleSessionStorageMarker
         */

      }, {
        key: "toggleSessionStorageMarker",
        value: function toggleSessionStorageMarker() {
          if (window.sessionStorage.getItem(connectedMarker)) {
            window.sessionStorage.removeItem(connectedMarker);
          } else {
            window.sessionStorage.setItem(connectedMarker, true);
          }
        }
      }]);
      return Airplay;
    }();

    return Airplay;
  });
}

},{"@babel/runtime/helpers/classCallCheck":10,"@babel/runtime/helpers/createClass":11,"@babel/runtime/helpers/interopRequireDefault":13}],66:[function(require,module,exports){
"use strict";

OO.exposeStaticApi('Analytics', OO.Analytics);
OO.plugin(OO.MODULE_NAMES.ANALYTICS_FRAMEWORK_TRANSLATOR, function (OO, _, $) {
  var mb;
  var af;
  var adMode = false;
  var singleAdStarted = false;
  var lastAdPodStartedParam = null;
  var impressionMade = false; // used for OO.EVENTS.ERROR message

  var errorCategoryDictionary = {};
  errorCategoryDictionary.SAS = OO.ERROR.API.SAS;
  errorCategoryDictionary.PLAYBACK = OO.ERROR.PLAYBACK;
  errorCategoryDictionary.METADATA_LOADING = OO.ERROR.API;
  errorCategoryDictionary.GENERAL = OO.ERROR;
  /**
   * Helper function for readability mainly. Binds private functions to 'this' instance
   * of Framework, to give access to private variables.
   * @private
   * @method OO.Analytics.Framework#privateMember
   * @param  {function} functionVar The function to be bound to this instance of Framework
   * @return {function}             Bound function.
   */

  var privateMember = _.bind(function (functionVar) {
    if (!_.isFunction(functionVar)) {
      throw createErrorString('Trying to make private function but ' + functionVar + ' is not a function.');
    }

    return _.bind(functionVar, this);
  }, this);

  var AnalyticsFrameworkTranslator = function AnalyticsFrameworkTranslator(mbIn, id) {
    this.id = id;
    mb = mbIn;
    af = new OO.Analytics.Framework();
    mb.subscribe(OO.EVENTS.PLAYER_CREATED, 'AnalyticsFrameworkTranslator', onPlayerCreated);
    mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED, 'AnalyticsFrameworkTranslator', onEmbedCodeChanged);
    mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD, 'AnalyticsFrameworkTranslator', onEmbedCodeChanged);
    mb.subscribe(OO.EVENTS.CONTENT_TREE_FETCHED, 'AnalyticsFrameworkTranslator', onContentTreeFetched);
    mb.subscribe(OO.EVENTS.METADATA_FETCHED, 'AnalyticsFrameworkTranslator', onMetadataFetched);
    mb.subscribe(OO.EVENTS.AUTHORIZATION_FETCHED, 'AnalyticsFrameworkTranslator', onAuthorizationFetched);
    mb.subscribe(OO.EVENTS.INITIAL_PLAY, 'AnalyticsFrameworkTranslator', onInitialPlay);
    mb.subscribe(OO.EVENTS.PLAY, 'AnalyticsFrameworkTranslator', onPlay);
    mb.subscribe(OO.EVENTS.DOWNLOADING, 'AnalyticsFrameworkTranslator', onDownloading);
    mb.subscribe(OO.EVENTS.BUFFERING, 'AnalyticsFrameworkTranslator', onBuffering);
    mb.subscribe(OO.EVENTS.BUFFERED, 'AnalyticsFrameworkTranslator', onBuffered);
    mb.subscribe(OO.EVENTS.BITRATE_INFO_AVAILABLE, 'AnalyticsFrameworkTranslator', onBitrateInfoAvailable);
    mb.subscribe(OO.EVENTS.SET_TARGET_BITRATE, 'AnalyticsFrameworkTranslator', onSetTargetBitrate);
    mb.subscribe(OO.EVENTS.BITRATE_CHANGED, 'AnalyticsFrameworkTranslator', onBitrateChanged);
    mb.subscribe(OO.EVENTS.PLAYING, 'AnalyticsFrameworkTranslator', onPlaying);
    mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, 'AnalyticsFrameworkTranslator', onPlayheadTimeChanged);
    mb.subscribe(OO.EVENTS.PLAYED, 'AnalyticsFrameworkTranslator', onPlayed);
    mb.subscribe(OO.EVENTS.PAUSE, 'AnalyticsFrameworkTranslator', onPause);
    mb.subscribe(OO.EVENTS.PAUSED, 'AnalyticsFrameworkTranslator', onPaused);
    mb.subscribe(OO.EVENTS.REPLAY, 'AnalyticsFrameworkTranslator', onReplay);
    mb.subscribe(OO.EVENTS.SEEK, 'AnalyticsFrameworkTranslator', onSeek);
    mb.subscribe(OO.EVENTS.SEEKED, 'AnalyticsFrameworkTranslator', onSeeked);
    mb.subscribe(OO.EVENTS.WILL_PLAY_FROM_BEGINNING, 'AnalyticsFrameworkTranslator', onWillPlayFromBeginning);
    mb.subscribe(OO.EVENTS.INITIAL_PLAY_STARTING, 'AnalyticsFrameworkTranslator', onInitialPlayStarting);
    mb.subscribe(OO.EVENTS.PLAYBACK_READY, 'AnalyticsFrameworkTranslator', onPlaybackReady);
    mb.subscribe(OO.EVENTS.API_ERROR, 'AnalyticsFrameworkTranslator', onApiError);
    mb.subscribe(OO.EVENTS.BITRATE_INITIAL, 'AnalyticsFrameworkTranslator', onBitrateInitial);
    mb.subscribe(OO.EVENTS.BITRATE_FIVE_SEC, 'AnalyticsFrameworkTranslator', onBitrateFiveSec);
    mb.subscribe(OO.EVENTS.BITRATE_STABLE, 'AnalyticsFrameworkTranslator', onBitrateStable);
    mb.subscribe(OO.EVENTS.PLAYBACK_START_ERROR, 'AnalyticsFrameworkTranslator', onPlaybackStartError);
    mb.subscribe(OO.EVENTS.PLAYBACK_MIDSTREAM_ERROR, 'AnalyticsFrameworkTranslator', onPlaybackMidstreamError);
    mb.subscribe(OO.EVENTS.PLUGIN_LOADED, 'AnalyticsFrameworkTranslator', onPluginLoaded);
    mb.subscribe(OO.EVENTS.AD_SDK_LOADED, 'AnalyticsFrameworkTranslator', onLoadAdSdk);
    mb.subscribe(OO.EVENTS.AD_SDK_LOAD_FAILED, 'AnalyticsFrameworkTranslator', onLoadAdSdkFailure);
    mb.subscribe(OO.EVENTS.AD_REQUEST, 'AnalyticsFrameworkTranslator', onAdRequest);
    mb.subscribe(OO.EVENTS.AD_REQUEST_SUCCESS, 'AnalyticsFrameworkTranslator', onAdRequestSuccess);
    mb.subscribe(OO.EVENTS.AD_REQUEST_EMPTY, 'AnalyticsFrameworkTranslator', onAdRequestEmpty);
    mb.subscribe(OO.EVENTS.AD_REQUEST_ERROR, 'AnalyticsFrameworkTranslator', onAdRequestError);
    mb.subscribe(OO.EVENTS.AD_PLAYBACK_ERROR, 'AnalyticsFrameworkTranslator', onAdPlaybackError);
    mb.subscribe(OO.EVENTS.AD_SDK_IMPRESSION, 'AnalyticsFrameworkTranslator', onAdSdkImpression);
    mb.subscribe(OO.EVENTS.AD_COMPLETED, 'AnalyticsFrameworkTranslator', onAdCompleted);
    mb.subscribe(OO.EVENTS.WILL_PLAY_ADS, 'AnalyticsFrameworkTranslator', onWillPlayAds);
    mb.subscribe(OO.EVENTS.AD_POD_STARTED, 'AnalyticsFrameworkTranslator', onAdPodStarted);
    mb.subscribe(OO.EVENTS.AD_POD_ENDED, 'AnalyticsFrameworkTranslator', onAdPodEnded);
    mb.subscribe(OO.EVENTS.WILL_PLAY_SINGLE_AD, 'AnalyticsFrameworkTranslator', onWillPlaySingleAd);
    mb.subscribe(OO.EVENTS.SINGLE_AD_PLAYED, 'AnalyticsFrameworkTranslator', onSingleAdPlayed);
    mb.subscribe(OO.EVENTS.WILL_PLAY_NONLINEAR_AD, 'AnalyticsFrameworkTranslator', onWillPlayNonlinearAd);
    mb.subscribe(OO.EVENTS.NONLINEAR_AD_PLAYED, 'AnalyticsFrameworkTranslator', onNonlinearAdPlayed);
    mb.subscribe(OO.EVENTS.ADS_PLAYED, 'AnalyticsFrameworkTranslator', onAdsPlayed);
    mb.subscribe(OO.EVENTS.SKIP_AD, 'AnalyticsFrameworkTranslator', onSkipAd);
    mb.subscribe(OO.EVENTS.ADS_ERROR, 'AnalyticsFrameworkTranslator', onAdsError);
    mb.subscribe(OO.EVENTS.ADS_CLICKED, 'AnalyticsFrameworkTranslator', onAdsClicked);
    mb.subscribe(OO.EVENTS.ADS_CLICKTHROUGH_OPENED, 'AnalyticsFrameworkTranslator', onAdsClickthroughOpened);
    mb.subscribe(OO.EVENTS.SDK_AD_EVENT, 'AnalyticsFrameworkTranslator', onSdkAdEvent);
    mb.subscribe(OO.EVENTS.FULLSCREEN_CHANGED, 'AnalyticsFrameworkTranslator', onFullscreenChanged);
    mb.subscribe(OO.EVENTS.VOLUME_CHANGED, 'AnalyticsFrameworkTranslator', onVolumeChanged);
    mb.subscribe(OO.EVENTS.DESTROY, 'AnalyticsFrameworkTranslator', onDestroy);
    mb.subscribe(OO.EVENTS.VC_PLAYED, 'AnalyticsFrameworkTranslator', onVideoPlayed);
    mb.subscribe(OO.EVENTS.VC_PLAYING, 'AnalyticsFrameworkTranslator', onVideoPlaying);
    mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'AnalyticsFrameworkTranslator', onVideoElementCreated);
    mb.subscribe(OO.EVENTS.SSAI_PLAY_SINGLE_AD, 'AnalyticsFrameworkTranslator', onSsaiPlaySingleAd);
    mb.subscribe(OO.EVENTS.SSAI_SINGLE_AD_PLAYED, 'AnalyticsFrameworkTranslator', onSsaiSingleAdPlayed);
    mb.subscribe(OO.EVENTS.SSAI_AD_TIMELINE_RECEIVED, 'AnalyticsFrameworkTranslator', onSsaiAdTimelineReceived);
    mb.subscribe(OO.EVENTS.ERROR, 'AnalyticsFrameworkTranslator', onError);
    mb.subscribe(OO.EVENTS.DISCOVERY_API.SEND_DISPLAY_EVENT, 'AnalyticsFrameworkTranslator', onDiscoveryImpression);
    mb.subscribe(OO.EVENTS.DISCOVERY_API.SEND_CLICK_EVENT, 'AnalyticsFrameworkTranslator', onDiscoveryClick); // we should not be reporting while chromecasting, so turn reporting on/off with these messages

    mb.subscribe(OO.EVENTS.CHROMECAST_START_CAST, 'AnalyticsFrameworkTranslator', onChromecastStartCast);
    mb.subscribe(OO.EVENTS.CHROMECAST_END_CAST, 'AnalyticsFrameworkTranslator', onChromecastEndCast); // [DEPRECATED] (NOTE: Is being replaced by OO.EVENTS.ERROR)

    mb.subscribe(OO.EVENTS.VC_PLAY_FAILED, 'AnalyticsFrameworkTranslator', onVideoPlayFailed);
  }; // Event Callbacks

  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PLAYER_CREATED -> OO.Analytics.EVENTS.VIDEO_PLAYER_CREATED.
   * @private
   * @method AnalyticsFrameworkTranslator#onPlayerCreated
   * @param {string} eventName Core message bus event name
   * @param {string} elementId The id of the DOM element that contains the player
   * @param {object} metadata The configuration metadata associated with the player
   * (i.e. pcode, playerBrandingId, skin configuration, player configuration parameters)
   * @param {object} persistentSettings An object containing player persistent settings
   * @param {string} embedCode The embed code of the asset attempting to play
   * @param {number} createdTime The timestamp the player was created
   * @param {string} playerUrl The url of the page containing the player
   */


  var onPlayerCreated = privateMember(function (eventName, elementId, metadata, persistentSettings, embedCode, createdTime, playerUrl) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoPlayerCreatedData(OO.VERSION.core.releaseVersion, metadata, embedCode, playerUrl);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.setPluginMetadata(metadata);
    af.publishEvent(OO.Analytics.EVENTS.VIDEO_PLAYER_CREATED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.EMBED_CODE_CHANGED -> OO.Analytics.EVENTS.VIDEO_SOURCE_CHANGED.
   * @private
   * @method AnalyticsFrameworkTranslator#onEmbedCodeChanged
   * @param {string} eventName Core message bus event name
   * @param {string} embedCode The embed code
   * @param {object} params The configuration metadata associated with the player
   * (i.e. pcode, playerBrandingId, skin configuration, player configuration parameters)
   */

  var onEmbedCodeChanged = privateMember(function (eventName, embedCode, params) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoSourceData(embedCode, params);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_SOURCE_CHANGED, [param1]);
  });
  /**
   * Callback to map core mesesage bus event to AnalyticsFramework event:
   * OO.EVENTS.CONTENT_TREE_FETCHED -> OO.Analytics.EVENTS.VIDEO_CONTENT_METADATA_UPDATED.
   * @private
   * @method AnalyticsFrameworkTranslator#onContentTreeFetched
   * @param {string} eventName Core message bus event name
   * @param {object} content The metadata associated with the content
   * (i.e. title, description, duration, etc)
   */

  var onContentTreeFetched = privateMember(function (eventName, content) {
    var param1;

    try {
      var contentInfo = content;

      if (contentInfo.closed_captions === null || contentInfo.closed_captions === undefined) {
        contentInfo.closed_captions = {};
      }

      param1 = new OO.Analytics.EVENT_DATA.VideoContentMetadata(contentInfo.title, contentInfo.description, contentInfo.duration, contentInfo.closed_captions, contentInfo.content_type, contentInfo.hostedAtURL);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_CONTENT_METADATA_UPDATED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.METADATA_FETCHED -> OO.Analytics.EVENTS.VIDEO_STREAM_METADATA_UPDATED.
   * @private
   * @method AnalyticsFrameworkTranslator#onMetadataFetched
   * @param {string} eventName Core message bus event name
   * @param {object} metadata The Backdoor and Backlot metadata
   */

  var onMetadataFetched = privateMember(function (eventName, metadata) {
    var param1;

    try {
      // TODO checkDataType
      param1 = metadata;
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_STREAM_METADATA_UPDATED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.AUTHORIZATION_FETCHED -> OO.Analytics.STREAM_TYPE_UPDATED
   * @private
   * @method AnalyticsFrameworkTranslator#onAuthorizationFetched
   * @param {string} eventName Core message bus event name
   * @param {object} authMetadata Authorization metadata
   */

  var onAuthorizationFetched = privateMember(function (eventName, authMetadata) {
    var param1;

    try {
      var streamType;

      if (authMetadata && authMetadata.streams && authMetadata.streams[0] && authMetadata.streams[0]['is_live_stream']) {
        streamType = OO.Analytics.STREAM_TYPE.LIVE_STREAM;
      } else {
        streamType = OO.Analytics.STREAM_TYPE.VOD;
      }

      param1 = new OO.Analytics.EVENT_DATA.StreamTypeMetadata(streamType);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.STREAM_TYPE_UPDATED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.INITIAL_PLAY -> OO.Analytics.EVENTS.INITIAL_PLAYBACK_REQUESTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onInitialPlay
   * @param {string} eventName Core message bus event name
   */

  var onInitialPlay = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.INITIAL_PLAYBACK_REQUESTED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PLAY -> OO.Analytics.EVENTS.VIDEO_PLAY_REQUESTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onPlay
   * @param {string} eventName Core message bus event name
   */

  var onPlay = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.VIDEO_PLAY_REQUESTED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.DOWNLOADING -> OO.Analytics.EVENTS.VIDEO_STREAM_DOWNLOADING.
   * @private
   * @method AnalyticsFrameworkTranslator#onDownloading
   * @param {string} eventName Core message bus event name
   * @param {number} currentTime The current video position represented in seconds
   * @param {number} duration The total stream duration represented in seconds
   * @param {number} buffer Represents up until what time / video stream position (in seconds)
   * has been buffered
   * @param {object} seekRange Represents the range in which a user is able to seek
   */

  var onDownloading = privateMember(function (eventName, currentTime, duration, buffer, seekRange) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoDownloadingMetadata(currentTime, duration, buffer, seekRange.start, seekRange.end);
    } catch (error) {
      param1 = {};
      logEventDataError(eventName);
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_STREAM_DOWNLOADING, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.BUFFERING -> OO.Analytics.EVENTS.VIDEO_BUFFERING_STARTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onBuffering
   * @param {string} eventName Core message bus event name
   * @param {string} url The url of the stream that is buffering
   * @param {string} videoId The video Id (main, etc.)
   * @param {number} position The playhead position buffering started
   */

  var onBuffering = privateMember(function (eventName, url, videoId, position) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoBufferingStartedData(url, videoId, position);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_BUFFERING_STARTED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.BUFFERED -> OO.Analytics.EVENTS.VIDEO_BUFFERING_ENDED.
   * @private
   * @method AnalyticsFrameworkTranslator#onBuffered
   * @param {string} eventName Core message bus event name
   * @param {string} url The stream url
   */

  var onBuffered = privateMember(function (eventName, url) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoBufferingEndedData(url);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_BUFFERING_ENDED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.BITRATE_INFO_AVAILABLE -> OO.Analytics.EVENTS.VIDEO_STREAM_BITRATE_PROFILES.
   * @private
   * @method AnalyticsFrameworkTranslator#onBitrateInfoAvailable
   * @param {string} eventName Core message bus event name
   * @param {array} bitrateProfiles An array of all the bitrate profiles
   */

  var onBitrateInfoAvailable = privateMember(function (eventName, bitrateProfiles) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoBitrateProfileLookupData(bitrateProfiles.bitrates);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_STREAM_BITRATE_PROFILES, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SET_TARGET_BITRATE -> OO.Analytics.EVENTS.VIDEO_STREAM_TARGET_BITRATE_REQUESTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSetTargetBitrate
   * @param {string} eventName Core message bus event name
   * @param {string} bitrateProfileId The id of the bitrate profile requested
   */

  var onSetTargetBitrate = privateMember(function (eventName, bitrateProfileId) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoTargetBitrateData(bitrateProfileId);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_STREAM_TARGET_BITRATE_REQUESTED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.BITRATE_CHANGED -> OO.Analytics.EVENTS.VIDEO_STREAM_BITRATE_CHANGED.
   * @private
   * @method AnalyticsFrameworkTranslator#onBitrateChanged
   * @param {string} eventName Core message bus event name
   * @param {object} bitrateProfile An object containing the bitrate profile data of the new stream
   */

  var onBitrateChanged = privateMember(function (eventName, bitrateProfile) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoBitrateProfileData(bitrateProfile);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_STREAM_BITRATE_CHANGED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PLAYING -> OO.Analytics.EVENTS.VIDEO_PLAYING.
   * @private
   * @method AnalyticsFrameworkTranslator#onPlaying
   * @param {string} eventName Core message bus event name
   */

  var onPlaying = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.VIDEO_PLAYING);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PLAYHEAD_TIME_CHANGED -> OO.Analytics.EVENTS.VIDEO_STREAM_POSITION_CHANGED.
   * @private
   * @method AnalyticsFrameworkTranslator#onPlayheadTimeChanged
   * @param {string} eventName Core message bus event name
   * @param {number} playheadPosition New playhead position in the current stream
   * @param {number} streamDuration Current streams total duration
   * @param {number} buffer The amount of the stream that has been buffered
   * @param {object} seekRange The available seek range given as {end:number, start:number}
   * @param {string} videoId Id used to differentiate between various streams (such as ad vs content playback).
   *                         Possible values are defined in OO.VIDEO.
   * @param {number} currentLiveTime time used in place of playheadPosition for live streams
   */

  var onPlayheadTimeChanged = privateMember(function (eventName, playheadPosition, streamDuration, buffer, seekRange, videoId, currentLiveTime) {
    var param1;

    try {
      var liveTime = currentLiveTime;

      if (liveTime === null || liveTime === undefined) {
        liveTime = -1;
      }

      param1 = new OO.Analytics.EVENT_DATA.VideoStreamPositionChangedData(playheadPosition, streamDuration, videoId, liveTime);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_STREAM_POSITION_CHANGED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PLAYED -> OO.Analytics.EVENTS.PLAYBACK_COMPLETED.
   * @private
   * @method AnalyticsFrameworkTranslator#onPlayed
   * @param {string} eventName Core message bus event name
   */

  var onPlayed = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.PLAYBACK_COMPLETED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PAUSE -> OO.Analytics.EVENTS.VIDEO_PAUSE_REQUESTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onPause
   * @param {string} eventName Core message bus event name
   */

  var onPause = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.VIDEO_PAUSE_REQUESTED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.PAUSED -> OO.Analytics.EVENTS.VIDEO_PAUSED.
   * @private
   * @method AnalyticsFrameworkTranslator#onPaused
   * @param {string} eventName Core message bus event name
   */

  var onPaused = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.VIDEO_PAUSED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.REPLAY -> OO.Analytics.EVENTS.VIDEO_REPLAY_REQUESTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onReplay
   * @param {string} eventName Core message bus event name
   */

  var onReplay = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.VIDEO_REPLAY_REQUESTED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SEEK -> OO.Analytics.EVENTS.VIDEO_SEEK_REQUESTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSeek
   * @param {string} eventName Core message bus event name
   * @param {number} playhead The video stream position (in seconds) to seek to
   */

  var onSeek = privateMember(function (eventName, playhead) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoSeekRequestedData(playhead);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_SEEK_REQUESTED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SEEKED -> OO.Analytics.EVENTS.VIDEO_SEEK_COMPLETED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSeeked
   * @param {string} eventName Core message bus event name
   * @param {number} playhead The video stream position (in seconds) after seeking
   */

  var onSeeked = privateMember(function (eventName, playhead) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoSeekCompletedData(playhead);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_SEEK_COMPLETED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.WILL_PLAY_FROM_BEGINNING -> OO.Analytics.EVENTS.WILL_PLAY_FROM_BEGINNING.
   * @private
   * @method AnalyticsFrameworkTranslator#WILL_PLAY_FROM_BEGINNING
   * @param {string} eventName Core message bus event name
   */

  var onWillPlayFromBeginning = privateMember(function (eventName) {
    return af.publishEvent(OO.Analytics.EVENTS.WILL_PLAY_FROM_BEGINNING);
  });
  /**
   * Callback from core message bus event OO.EVENTS.INITIAL_PLAY_STARTING
   * @private
   * @method AnalyticsFrameworkTranslator#onInitialPlayStarting
   * @param {string} eventName Core message bus event name
   * @param {number} timeSinceInitialPlay The time since the initial play request was made
   * @param {boolean} autoplayed Boolean parameter. True if video was autoplayed, false otherwise
   * @param {boolean} hadPreroll True if the video had an ad play before it started.
   *                     This includes midrolls that play before content due to an initial playhead time > 0.
   *                     False otherwise.
   * @param {number} position The initial position of the playhead upon playback start.
   * @param {string} plugin The video plugin used for playback
   * @param {string} technology The browser technology used - HTML5, Flash, Mixed, or Other
   * @param {string} encoding The stream encoding type, i.e. MP4, HLS, Dash, etc.
   * @param {string} streamUrl The URL of the content being played
   * @param {string} drm The DRM being used, none if there is no DRM
   * @param {boolean} isLive Boolean parameter. True if a live stream is playing. False if VOD.
   */

  var onInitialPlayStarting = privateMember(function (eventName, timeSinceInitialPlay, autoplayed, hadPreroll, position, plugin, technology, encoding, streamUrl, drm, isLive) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.InitialPlayStartingData(OO.VERSION.core.releaseVersion, timeSinceInitialPlay, autoplayed, hadPreroll, position, plugin, technology, encoding, streamUrl, drm, isLive);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.INITIAL_PLAY_STARTING, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.PLAYBACK_READY
   * @private
   * @method AnalyticsFrameworkTranslator#onPlaybackReady
   * @param {string} eventName Core message bus event name
   * @param {number} timeSincePlayerCreated The time between player creation and playback ready state
   */

  var onPlaybackReady = privateMember(function (eventName, timeSincePlayerCreated) {
    var param1;

    try {
      var plugins = {};

      if (OO.Video) {
        plugins = OO.Video.getRegisteredPlugins();
      }

      var pluginNames = [];

      if (plugins) {
        pluginNames = Object.getOwnPropertyNames(plugins);
      }

      param1 = new OO.Analytics.EVENT_DATA.PlaybackReadyData(OO.VERSION.core.releaseVersion, timeSincePlayerCreated, pluginNames);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.PLAYBACK_READY, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.API_ERROR
   * @private
   * @method AnalyticsFrameworkTranslator#onApiError
   * @param {string} eventName Core message bus event name
   * @param {object} errorCode The error code if any
   * @param {string} errorMessage The error message
   * @param {string} url The ad tag url post macro substitution
   */

  var onApiError = privateMember(function (eventName, errorCode, errorMessage, url) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.ApiErrorData(OO.VERSION.core.releaseVersion, errorCode, errorMessage, url);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.API_ERROR, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.BITRATE_INITIAL
   * @private
   * @method AnalyticsFrameworkTranslator#onBitrateInitial
   * @param {string} eventName Core message bus event name
   * @param {number} bitrate The bitrate at the start of playback
   */

  var onBitrateInitial = privateMember(function (eventName, bitrate) {
    if (bitrate === -1) {
      // bitrate -1 is a technical value used in main_html5 module, shouldn't be reported
      return;
    }

    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.BitrateInitialData(bitrate);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.BITRATE_INITIAL, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.BITRATE_FIVE_SEC
   * @private
   * @method AnalyticsFrameworkTranslator#onBitrateFiveSec
   * @param {string} eventName Core message bus event name
   * @param {number} bitrate The bitrate at five seconds into the video
   */

  var onBitrateFiveSec = privateMember(function (eventName, bitrate) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.BitrateFiveSecData(bitrate);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.BITRATE_FIVE_SEC, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.BITRATE_STABLE
   * @private
   * @method AnalyticsFrameworkTranslator#onBitrateStable
   * @param {string} eventName Core message bus event name
   * @param {number} bitrate The bitrate at thirty seconds into the video
   */

  var onBitrateStable = privateMember(function (eventName, bitrate) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.BitrateStableData(bitrate);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.BITRATE_STABLE, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.PLAYBACK_START_ERROR
   * @private
   * @method AnalyticsFrameworkTranslator#onPlaybackStartError
   * @param {string} eventName Core message bus event name
   * @param {object} errorData The object containing the error information
   */

  var onPlaybackStartError = privateMember(function (eventName, errorData) {
    var param1;

    try {
      var errorMessages = {};
      var errorCodes = {};

      if (errorData.pluginErrorMessage != null) {
        errorMessages.plugin = errorData.pluginErrorMessage;
      }

      if (errorData.mediaErrorMessage != null) {
        errorMessages.media = errorData.mediaErrorMessage;
      }

      if (errorData.ooyalaErrorMessage != null) {
        errorMessages.ooyala = errorData.ooyalaErrorMessage;
      }

      if (errorData.pluginErrorCode != null) {
        errorCodes.plugin = errorData.pluginErrorCode;
      }

      if (errorData.mediaErrorCode != null) {
        errorCodes.media = errorData.mediaErrorCode;
      }

      if (errorData.ooyalaErrorCode != null) {
        errorCodes.ooyala = errorData.ooyalaErrorCode;
      }

      param1 = new OO.Analytics.EVENT_DATA.PlaybackStartErrorData(errorCodes, errorMessages, errorData.drm);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.PLAYBACK_START_ERROR, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.PLUGIN_LOADED
   * @private
   * @method AnalyticsFrameworkTranslator#onPluginLoaded
   * @param {string} pluginType Type of the loaded plugin - ads, playback, analytics, playlist, or skin
   * @param {string} pluginName The name of the plugin loaded
   * @param {number} loadTime The time it took for the plugin to reach the ready state
   */

  var onPluginLoaded = privateMember(function (eventName, pluginType, pluginName, loadTime) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.PluginLoadedData(OO.VERSION.core.releaseVersion, pluginType, pluginName, loadTime);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.PLUGIN_LOADED, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.PLAYBACK_MIDSTREAM_ERROR
   * @private
   * @method AnalyticsFrameworkTranslator#onPlaybackMidstreamError
   * @param {string} eventName Core message bus event name
   * @param {number} errorCode The error code if any
   * @param {string} errorMessage The error message
   * @param {number} position The playhead position the error occurred at
   */

  var onPlaybackMidstreamError = privateMember(function (eventName, errorData) {
    var param1;

    try {
      var errorMessages = {};
      var errorCodes = {};

      if (errorData.pluginErrorMessage != null) {
        errorMessages.plugin = errorData.pluginErrorMessage;
      }

      if (errorData.mediaErrorMessage != null) {
        errorMessages.media = errorData.mediaErrorMessage;
      }

      if (errorData.ooyalaErrorMessage != null) {
        errorMessages.ooyala = errorData.ooyalaErrorMessage;
      }

      if (errorData.pluginErrorCode != null) {
        errorCodes.plugin = errorData.pluginErrorCode;
      }

      if (errorData.mediaErrorCode != null) {
        errorCodes.media = errorData.mediaErrorCode;
      }

      if (errorData.ooyalaErrorCode != null) {
        errorCodes.ooyala = errorData.ooyalaErrorCode;
      }

      param1 = new OO.Analytics.EVENT_DATA.PlaybackMidstreamErrorData(errorCodes, errorMessages, errorData.playhead);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.PLAYBACK_MIDSTREAM_ERROR, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_SDK_LOADED.
   * @private
   * @method AnalyticsFrameworkTranslator#onLoadAdSdk
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName Name of the ad plugin that notified of the ad event
   * @param {string} version Player core version
   */

  var onLoadAdSdk = privateMember(function (eventName, adPluginName, version) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.LoadAdSdkData(adPluginName, version);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_SDK_LOADED, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_SDK_LOAD_FAILED.
   * @private
   * @method AnalyticsFrameworkTranslator#onLoadAdSdkFailure
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName Name of the ad plugin that notified of the ad event
   * @param {string} version Player core version
   * @param {string} error Error message associated with the sdk load failure
   */

  var onLoadAdSdkFailure = privateMember(function (eventName, adPluginName, version, error) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.LoadAdSdkFailureData(adPluginName, version, error);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_SDK_LOAD_FAILURE, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_REQUEST.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdRequest
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName Name of the ad plugin that notified of the ad event
   * @param {number} adPosition Position the ad is scheduled to play
   */

  var onAdRequest = privateMember(function (eventName, adPluginName, adPosition) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdRequestData(adPluginName, adPosition);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_REQUEST, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_REQUEST_SUCCESS.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdRequestSuccess
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin used
   * @param {number} adPosition The position the ad is scheduled to play
   * @param {number} responseTime The time in milliseconds that it took to get a response for the ad request
   * @param {number} timeSinceInitialPlay The time in milliseconds from the initial play request time to ad request success
   */

  var onAdRequestSuccess = privateMember(function (eventName, adPluginName, adPosition, responseTime, timeSinceInitialPlay) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdRequestSuccessData(adPluginName, adPosition, responseTime, timeSinceInitialPlay);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_REQUEST_SUCCESS, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_REQUEST_EMPTY.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdRequestEmpty
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin that sent this event
   * @param {string} adPosition The time the ad is scheduled to play
   * @param {string} adTagUrl The ad tag url post macro substitution
   * @param {object} errorCode The object containing error codes
   * @param {string} errorMessage The error message
   */

  var onAdRequestEmpty = privateMember(function (eventName, adPluginName, adPosition, adTagUrl, errorCode, errorMessage) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdRequestEmptyData(adPluginName, adPosition, adTagUrl, errorCode, errorMessage);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_REQUEST_EMPTY, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_REQUEST_ERROR.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdRequestError
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin that sent this event
   * @param {string} adPosition The time the ad is scheduled to play
   * @param {string} adTagUrl The ad tag url post macro substitution
   * @param {object} errorCode The object containing error codes
   * @param {string} errorMessage The error message
   * @param {boolean} isTimeout If ad request timed out or not
   */

  var onAdRequestError = privateMember(function (eventName, adPluginName, adPosition, adTagUrl, errorCode, errorMessage, isTimeout) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdRequestErrorData(adPluginName, adPosition, adTagUrl, errorCode, errorMessage, isTimeout);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_REQUEST_ERROR, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_PLAYBACK_ERROR.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdPlaybackError
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin that sent this event
   * @param {string} adPosition The time the ad is scheduled to play
   * @param {string} adTagUrl The ad tag url post macro substitution
   * @param {object} errorCodes The object containing error codes
   * @param {string} errorMessage The error message
   * @param {array} pluginNames Array containing names of all video plugins registered
   * @param {string} mediaFileUrl The url used to retrieve the ad media file
   */

  var onAdPlaybackError = privateMember(function (eventName, adPluginName, adPosition, adTagUrl, errorCodes, errorMessage, pluginNames, mediaFileUrl) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdPlaybackErrorData(adPluginName, adPosition, adTagUrl, errorCodes, errorMessage, pluginNames.pluginNames, mediaFileUrl);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_PLAYBACK_ERROR, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_SDK_IMPRESSION.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdSdkImpression
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin that sent this event
   * @param {number} adPosition The time the ad is scheduled to play
   * @param {number} adLoadTime The time in milliseconds between the ad request success and started
   * @param {string} adProtocol The ad protocol (VAST / VPAID)
   * @param {string} adType The ad type (LinearOverlay, LinearVideo, NonLinearOverlay, NonLinearVideo)
   */

  var onAdSdkImpression = privateMember(function (eventName, adPluginName, adPosition, adLoadTime, adProtocol, adType) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdSdkImpressionData(adPluginName, adPosition, adLoadTime, adProtocol, adType);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_SDK_IMPRESSION, [param1]);
  });
  /**
   * Callback from core message bus event OO.EVENTS.AD_COMPLETED.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdCompleted
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin that sent this event
   * @param {number} timeSinceImpression The time passed since the ad impression
   *                                        was recorded in milliseconds
   * @param {boolean} skipped True if ad was skipped by user.
   * @param {string} adTagUrl The ad tag url post macro substitution
   */

  var onAdCompleted = privateMember(function (eventName, adPluginName, timeSinceImpression, skipped, adTagUrl) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdCompletedData(adPluginName, timeSinceImpression, skipped, adTagUrl);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_COMPLETED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.WILL_PLAY_ADS -> OO.Analytics.EVENTS.AD_BREAK_STARTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onWillPlayAds
   * @param {string} eventName Core message bus event name
   */

  var onWillPlayAds = privateMember(function (eventName) {
    adMode = true;
    af.publishEvent(OO.Analytics.EVENTS.AD_BREAK_STARTED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.AD_POD_STARTED -> OO.Analytics.EVENTS.AD_POD_STARTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdPodStarted
   * @param {string} eventName Core message bus event name
   * @param {number} numberOfAds The number of ads in the ad pod
   */

  var onAdPodStarted = privateMember(function (eventName, numberOfAds) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdPodStartedData(numberOfAds);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    var eventParam = [param1];

    if (singleAdStarted) {
      sendAdPodStartedEvent(eventParam);
    } else {
      lastAdPodStartedParam = eventParam;
    }
  });
  /**
   * Publishes the OO.Analytics.AD_POD_STARTED analytics event.
   * @private
   * @method AnalyticsFrameworkTranslator#sendAdPodStartedEvent
   * @param {object} param The desired parameter to publish with the event
   */

  var sendAdPodStartedEvent = privateMember(function (dirtyParam) {
    var param = dirtyParam || [{}];
    af.publishEvent(OO.Analytics.EVENTS.AD_POD_STARTED, param);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.AD_POD_ENDED -> OO.Analytics.EVENTS.AD_POD_ENDED.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdPodEnded
   * @param {string} eventName Core message bus event name
   * @param {string} adId The id of the ad pod
   */

  var onAdPodEnded = privateMember(function (eventName, adId) {
    if (singleAdStarted) {
      var param1;

      try {
        param1 = new OO.Analytics.EVENT_DATA.AdPodEndedData(adId);
      } catch (error) {
        logEventDataError(eventName);
        param1 = {};
      }

      af.publishEvent(OO.Analytics.EVENTS.AD_POD_ENDED, [param1]);
    }
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.WILL_PLAY_SINGLE_AD -> OO.Analytics.EVENTS.AD_STARTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onWillPlaySingleAd
   * @param {string} eventName Core message bus event name
   * @param {object} adMetadata The ad metadata
   */

  var onWillPlaySingleAd = privateMember(function (eventName, adMetadata) {
    // If we have not started an ad yet, we need to publish the AD_BREAK
    // and AD_POD started events
    if (!singleAdStarted) {
      sendAdPodStartedEvent(lastAdPodStartedParam);
      lastAdPodStartedParam = null;
    }

    singleAdStarted = true;
    impressionMade = false;
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdStartedData(OO.Analytics.AD_TYPE.LINEAR_VIDEO, adMetadata);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_STARTED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SINGLE_AD_PLAYED -> OO.Analytics.EVENTS.AD_ENDED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSingleAdPlayed
   * @param {string} eventName Core message bus event name
   * @param {string} adId The id of the ad
   */

  var onSingleAdPlayed = privateMember(function (eventName, adId) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdEndedData(OO.Analytics.AD_TYPE.LINEAR_VIDEO, adId);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_ENDED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.WILL_PLAY_NONLINEAR_AD -> OO.Analytics.EVENTS.AD_STARTED.
   * @private
   * @method AnalyticsFrameworkTranslator#onWillPlayNonlinearAd
   * @param {string} eventName Core message bus event name
   * @param {string} adMetadata The ad metadata
   */

  var onWillPlayNonlinearAd = privateMember(function (eventName, adMetadata) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdStartedData(OO.Analytics.AD_TYPE.NONLINEAR_OVERLAY, adMetadata);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_STARTED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.NONLINEAR_AD_PLAYED -> OO.Analytics.EVENTS.AD_ENDED.
   * @private
   * @method AnalyticsFrameworkTranslator#onNonlinearAdPlayed
   * @param {string} eventName Core message bus event name
   * @param {string} adId The id of the ad
   */

  var onNonlinearAdPlayed = privateMember(function (eventName, adId) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdEndedData(OO.Analytics.AD_TYPE.NONLINEAR_OVERLAY, adId);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_ENDED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.ADS_PLAYED -> OO.Analytics.EVENTS.AD_BREAK_ENDED.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdsPlayed
   * @param {string} eventName Core message bus event name
   */

  var onAdsPlayed = privateMember(function (eventName) {
    adMode = false;
    impressionMade = false;

    if (singleAdStarted) {
      af.publishEvent(OO.Analytics.EVENTS.AD_BREAK_ENDED);
    }

    singleAdStarted = false;
    lastAdPodStartedParam = null;
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SKIP_AD -> OO.Analytics.EVENTS.AD_SKIPPED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSkipAd
   * @param {string} eventName Core message bus event name
   */

  var onSkipAd = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.AD_SKIPPED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.ADS_ERROR -> OO.Analytics.EVENTS.AD_ERROR.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdsError
   * @param {string} eventName Core message bus event name
   * @param {string|object} error The string or object containing the error information
   */

  var onAdsError = privateMember(function (eventName, error) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdErrorData(error);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_ERROR, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.ADS_CLICKED -> OO.Analytics.EVENTS.AD_CLICKED.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdsClicked
   * @param {string} eventName Core message bus event name
   * @param {object} metadata Object containing the event metadata
   */

  var onAdsClicked = privateMember(function (eventName, metadata) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.AdClickedData({
        'adMetadata': metadata
      });
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.AD_CLICKED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.ADS_CLICKTHROUGH_OPENED -> OO.Analytics.EVENTS.AD_CLICKTHROUGH_OPENED.
   * @private
   * @method AnalyticsFrameworkTranslator#onAdsClickthroughOpened
   * @param {string} eventName Core message bus event name
   */

  var onAdsClickthroughOpened = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.AD_CLICKTHROUGH_OPENED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SDK_AD_EVENT -> OO.Analytics.EVENTS.SDK_AD_EVENT.
   * @private
   * @method AnalyticsFrameworkTranslator#onSdkAdEvent
   * @param {string} eventName Core message bus event name
   * @param {string} adPluginName The name of the ad plugin that sent this event
   * @param {string} adEventName The name of this event from the ad plugin
   * @param {object} adEventData An object containing details of the ad event. This may vary
   *                               between ad plugin to ad plugin.
   */

  var onSdkAdEvent = privateMember(function (eventName, adPluginName, adEventName, adEventData) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.SdkAdEventData(adPluginName, adEventName, adEventData);
    } catch (error) {
      OO.log('Exception in AnalyticsFrameworkTranslator: ' + error);
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.SDK_AD_EVENT, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.FULLSCREEN_CHANGED -> OO.Analytics.EVENTS.FULLSCREEN_CHANGED.
   * @private
   * @method AnalyticsFrameworkTranslator#onFullscreenChanged
   * @param {string} eventName Core message bus event name
   * @param {boolean} changingToFullscreen Whether or not the player is entering fullscreen.
   * true represents that the player is entering fullscreen. false represents that the player is
   * exiting fullscreen.
   */

  var onFullscreenChanged = privateMember(function (eventName, changingToFullscreen) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.FullscreenChangedData(changingToFullscreen);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.FULLSCREEN_CHANGED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.VOLUME_CHANGED -> OO.Analytics.EVENTS.VOLUME_CHANGED.
   * @private
   * @method AnalyticsFrameworkTranslator#onVolumeChanged
   * @param {string} eventName Core message bus event name
   * @param {number} volume The current volume after the change; the volume is a
   * value from 0 - 1, with 0 representing a muted state and 1 representing
   * the maximum volume.
   */

  var onVolumeChanged = privateMember(function (eventName, volume) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VolumeChangedData(volume);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VOLUME_CHANGED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.DESTROY -> OO.Analytics.EVENTS.DESTROY.
   * @private
   * @method AnalyticsFrameworkTranslator#onDestroy
   * @param {string} eventName Core message bus event name
   */

  var onDestroy = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.DESTROY);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.VC_PLAYED -> OO.Analytics.EVENTS.VIDEO_CONTENT_COMPLETED.
   * @private
   * @method AnalyticsFrameworkTranslator#onVideoPlayed
   * @param {string} eventName Core message bus event name
   * @param {string} videoType The video type. It is either OO.VIDEO.MAIN or
   * OO.VIDEO.ADS.
   */

  var onVideoPlayed = privateMember(function (eventName, videoType) {
    if (videoType === OO.VIDEO.MAIN) {
      af.publishEvent(OO.Analytics.EVENTS.VIDEO_CONTENT_COMPLETED);
    }
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.VC_PLAYING -> OO.Analytics.EVENTS.AD_IMPRESSION.
   * @private
   * @method AnalyticsFrameworkTranslator#onVideoPlaying
   * @param {string} eventName Core message bus event name
   * @param {string} videoType The video type. It is either OO.VIDEO.MAIN or
   * OO.VIDEO.ADS.
   */

  var onVideoPlaying = privateMember(function (eventName, videoType) {
    if (videoType === OO.VIDEO.ADS && adMode && !impressionMade) {
      impressionMade = true;
      af.publishEvent(OO.Analytics.EVENTS.AD_IMPRESSION);
    }
  });
  /**
   * [DEPRECATED]
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.VC_PLAY_FAILED -> OO.Analytics.EVENTS.VIDEO_ERROR.
   * @private
   * @method AnalyticsFrameworkTranslator#onVideoPlayFailed
   * @param {string} eventName Core message bus event name
   * @param {string} videoType The video type. It is either OO.VIDEO.MAIN or
   * OO.VIDEO.ADS.
   * @param {object} codes The object containing all error codes
   */

  var onVideoPlayFailed = privateMember(function (eventName, videoType, codes) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.VideoErrorData(codes.mediaErrorCode);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.VIDEO_ERROR, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.VC_VIDEO_ELEMENT_CREATED -> OO.Analytics.EVENTS.VIDEO_ELEMENT_CREATED.
   * @private
   * @method AnalyticsFrameworkTranslator#onVideoElementCreated
   * @param {string} eventName Core message bus event name
   * @param {string} videoType The video type. It is either OO.VIDEO.MAIN or
   * OO.VIDEO.ADS.
   */

  var onVideoElementCreated = privateMember(function (eventName, videoType) {
    if (videoType) {
      var videoId = videoType.videoId; // We only want to publish this info for main content

      if (videoId === OO.VIDEO.MAIN) {
        var param1 = null;

        try {
          param1 = new OO.Analytics.EVENT_DATA.VideoElementData(videoType.streamUrl);
        } catch (error) {
          logEventDataError(eventName);
          param1 = {};
        }

        af.publishEvent(OO.Analytics.EVENTS.VIDEO_ELEMENT_CREATED, [param1]);
      }
    }
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SSAI_PLAY_SINGLE_AD -> OO.Analytics.EVENTS.SSAI_PLAY_SINGLE_AD.
   * @private
   * @method AnalyticsFrameworkTranslator#onSsaiPlaySingleAd
   * @param {string} eventName Core message bus event name
   * @param {object} ad Object containing the ssai ad data
   */

  var onSsaiPlaySingleAd = privateMember(function (eventName, ad) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.SsaiPlaySingleAdData(ad);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.SSAI_PLAY_SINGLE_AD, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SSAI_SINGLE_AD_PLAYED -> OO.Analytics.EVENTS.SSAI_SINGLE_AD_PLAYED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSsaiSingleAdPlayed
   * @param {string} eventName Core message bus event name
   */

  var onSsaiSingleAdPlayed = privateMember(function (eventName) {
    af.publishEvent(OO.Analytics.EVENTS.SSAI_SINGLE_AD_PLAYED);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.SSAI_AD_TIMELINE_RECEIVED -> OO.Analytics.EVENTS.SSAI_AD_TIMELINE_RECEIVED.
   * @private
   * @method AnalyticsFrameworkTranslator#onSsaiAdTimelineReceived
   * @param {string} eventName Core message bus event name
   * @param {object} timeline Object containing an array of ssai ad objects.
   * Ordered by adstart time
   */

  var onSsaiAdTimelineReceived = privateMember(function (eventName, timeline) {
    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.SsaiAdTimelineReceivedData(timeline.ads);
    } catch (error) {
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.SSAI_AD_TIMELINE_RECEIVED, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.DISCOVERY_API.SEND_DISPLAY_EVENT -> OO.Analytics.EVENTS.REPORT_DISCOVERY_IMPRESSION.
   * @private
   * @method AnalyticsFrameworkTranslator#onDiscoveryImpression
   * @param {string} eventName Core message bus event name
   * @param {object} eventData Data blob associated with the discovery impression event.
   */

  var onDiscoveryImpression = privateMember(function (eventName, eventData) {
    if (!eventData || !eventData.metadata) {
      return;
    }

    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.ReportDiscoveryImpressionEventData(eventData.metadata);
    } catch (error) {
      OO.log('Exception in AnalyticsFrameworkTranslator: ' + error);
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.REPORT_DISCOVERY_IMPRESSION, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.DISCOVERY_API.SEND_CLICK_EVENT -> OO.Analytics.EVENTS.REPORT_DISCOVERY_CLICK.
   * @private
   * @method AnalyticsFrameworkTranslator#onDiscoveryClick
   * @param {string} eventName Core message bus event name
   * @param {object} eventData Data blob associated with the discovery click event.
   */

  var onDiscoveryClick = privateMember(function (eventName, eventData) {
    if (!eventData || !eventData.metadata) {
      return;
    }

    var param1;

    try {
      param1 = new OO.Analytics.EVENT_DATA.ReportDiscoveryClickEventData(eventData.metadata);
    } catch (error) {
      OO.log('Exception in AnalyticsFrameworkTranslator: ' + error);
      logEventDataError(eventName);
      param1 = {};
    }

    af.publishEvent(OO.Analytics.EVENTS.REPORT_DISCOVERY_CLICK, [param1]);
  });
  /**
   * Callback to map core message bus event to AnalyticsFramework event:
   * OO.EVENTS.ERROR -> {OO.Analytics.EVENTS.ERROR.VIDEO, OO.Analytics.EVENTS.ERROR.AUTHORIZATION}.
   * @private
   * @method AnalyticsFrameworkTranslator#onError
   * @param {string} eventName Core message bus event name
   * @param {object} errorData Contains error code information
   * @param {string} errorData.code The Ooyala Error Event code
   */

  var onError = privateMember(function (eventName, errorData) {
    if (errorData && errorData.code) {
      var errorCode = errorData.code;
      var errorCategory = getErrorCategory(errorCode);

      if (errorCategory) {
        var param1;
        var errorMessage = OO.getLocalizedMessage(errorCode);

        switch (errorCategory) {
          case 'SAS':
            param1 = new OO.Analytics.EVENT_DATA.AuthorizationErrorData(errorCode, errorMessage);
            af.publishEvent(OO.Analytics.EVENTS.ERROR.AUTHORIZATION, [param1]);
            break;

          case 'PLAYBACK':
            param1 = new OO.Analytics.EVENT_DATA.VideoPlaybackErrorData(errorCode, errorMessage);
            af.publishEvent(OO.Analytics.EVENTS.ERROR.VIDEO_PLAYBACK, [param1]);
            break;

          case 'METADATA_LOADING':
            param1 = new OO.Analytics.EVENT_DATA.MetadataLoadingErrorData(errorCode, errorMessage);
            af.publishEvent(OO.Analytics.EVENTS.ERROR.METADATA_LOADING, [param1]);
            break;

          case 'GENERAL':
            param1 = new OO.Analytics.EVENT_DATA.GeneralErrorData(errorCode, errorMessage);
            af.publishEvent(OO.Analytics.EVENTS.ERROR.GENERAL, [param1]);
            break;

          default:
          /** do nothing */

        }
      } else {
        createErrorString('error while reporting error message - ' + 'error code does not fall under a recognized category. ' + 'error code provided is: ' + errorCode);
      }
    } else {
      createErrorString('error while reporting error message - ' + 'expected errorData is malformed: ' + errorData);
    }
  });
  /**
   * Callback to stop recording analytics events while user is chromecasting
   * @private
   * @method AnalyticsFrameworkTranslator#onChromecastStartCast
   * @param {string} eventName Core message bus event name
   */

  var onChromecastStartCast = privateMember(function (eventName) {
    af.stopPublishingEvents();
  });
  /**
   * Callback to start recording analytics events after user has stopped chromecasting
   * @private
   * @method AnalyticsFrameworkTranslator#onChromecastEndCast
   * @param {string} eventName Core message bus event name
   */

  var onChromecastEndCast = privateMember(function (eventName) {
    af.resumePublishingEvents();
  });
  /**
   * Helper function to return the category (SAS/PLAYBACK) that the error falls under.
   * @private
   * @method AnalyticsFrameworkTranslator#getErrorCategory
   * @param {string} errorCode The Ooyala Player Error Code emitted by the error event
   * @returns {string} The corresponding error category.
   */

  var getErrorCategory = privateMember(function (errorCode) {
    var resultingCategory = null;

    var categories = _.keys(errorCategoryDictionary);

    for (var index = 0; index < categories.length; index++) {
      var category = categories[index];

      var availableErrors = _.values(errorCategoryDictionary[category]);

      if (_.contains(availableErrors, errorCode)) {
        resultingCategory = category;
        break;
      }
    }

    return resultingCategory;
  });
  /**
   * Helper function to return an error string with the Analytics Framework Translator
   * prefix.
   * @private
   * @method AnalyticsFrameworkTranslator#createErrorString
   * @param {string} origStr the error string
   * @returns The new error string.
   */

  var createErrorString = privateMember(function (origStr) {
    return 'Error AnalyticsFrameworkTranslator: ' + origStr;
  });
  /**
   * Helper function to log the error string.
   * @private
   * @method AnalyticsFrameworkTranslator#logEventDataError
   * @param {string} eventName Core message bus event name
   */

  var logEventDataError = privateMember(function (eventName) {
    OO.log(createErrorString(eventName + ' data changed and is causing an error.'));
  });
  return AnalyticsFrameworkTranslator;
});

},{}],67:[function(require,module,exports){
"use strict";

(function (OO, _, $) {
  /*
   *  Defines the playback controller
   */
  var ApiModule = function ApiModule(messageBus, id, params) {
    this.mb = messageBus;
    this.id = id;
    this.params = params || {};
    this.ooyalaAds = false;
    this.contentTree = {};
    this.metadata = {};
    this.skinMetadata = {};
    this.attributes = {};
    this.sasResponse = {};
    this.authToken = OO.localStorage.getItem('oo_auth_token');
    this._isEmbedCodeMetadataRequired = false;
    this._aborting = false;
    this._contentAjax = null;
    this._metadataAjax = null;
    this._embedCodeMetadataAjax = null;
    this._sasAjax = null;
    this._gbAjax = null; // assign cache interface to local var, in case if not defined replace with placeholder

    this.valhallaCache = OO.publicApi.cache || {
      get: function get() {},
      exists: function exists() {}
    };
    this.mb.subscribe(OO.EVENTS.WILL_REQUIRE_EMBED_CODE_METADATA, 'api', _.bind(this._willRequireEmbedCodeMetadata, this));
    OO.StateMachine.create({
      initial: 'Init',
      messageBus: this.mb,
      moduleName: 'Api',
      target: this,
      events: [{
        name: OO.EVENTS.SET_EMBED_CODE,
        from: '*',
        to: 'Init'
      }, {
        name: OO.EVENTS.SET_EMBED_CODE_AFTER_OOYALA_AD,
        from: '*',
        to: 'Init'
      }, {
        name: OO.EVENTS.EMBED_CODE_CHANGED,
        from: 'Init',
        to: 'WaitingForAPIResponse'
      }, {
        name: OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD,
        from: 'Init',
        to: 'WaitingForAPIResponse'
      }, {
        name: OO.EVENTS.WILL_FETCH_CONTENT_TREE,
        from: 'WaitingForAPIResponse'
      }, {
        name: OO.EVENTS.WILL_FETCH_METADATA,
        from: 'WaitingForAPIResponse'
      }, {
        name: OO.EVENTS.WILL_FETCH_EMBED_CODE_METADATA,
        from: 'WaitingForAPIResponse'
      }, {
        name: OO.EVENTS.WILL_FETCH_AUTHORIZATION,
        from: 'WaitingForAPIResponse'
      }, {
        name: OO.EVENTS.WILL_FETCH_AD_AUTHORIZATION,
        from: ['WaitingForAPIResponse', 'Init']
      }, {
        name: OO.EVENTS.PLAYBACK_READY,
        from: 'WaitingForAPIResponse',
        to: 'Init'
      }]
    });
  };

  _.extend(ApiModule.prototype, {
    /*
    * @private
    */
    _processSetEmbedCode: function _processSetEmbedCode(event, embedCode, options) {
      // store parameters
      this.rootEmbedCode = embedCode;
      this.adSetCode = options ? options.adSetCode : undefined;
      this.embedToken = options && options.embedToken || this.embedToken;
      this.authToken = options && options.authToken || this.authToken;
    },
    onSetEmbedCode: function onSetEmbedCode(event, embedCode, options) {
      // store parameters
      this._processSetEmbedCode(event, embedCode, options);

      this.mb.publish(OO.EVENTS.EMBED_CODE_CHANGED, embedCode, options);
    },
    onSetEmbedCodeAfterOoyalaAd: function onSetEmbedCodeAfterOoyalaAd(event, embedCode, options) {
      // store parameters
      this._processSetEmbedCode(event, embedCode, options);

      this.mb.publish(OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD, embedCode, options);
    },

    /*
    * @private
    */
    _processOnEmbedCodeChanged: function _processOnEmbedCodeChanged(event, embedCode, params) {
      // store parameters
      this.currentEmbedCode = embedCode;
      var requestParams = {};

      if (params && params.ooyalaAds) {
        requestParams = params;
      }

      this._abort(this._contentAjax);

      this._abort(this._metadataAjax);

      this._abort(this._embedCodeMetadataAjax);

      this._abort(this._sasAjax);

      this._abort(this._gbAjax);

      if (!_.isEmpty(this.adSetCode)) {
        _.extend(requestParams, {
          adSetCode: this.adSetCode
        });
      }

      if (!_.isEmpty(this.embedToken)) {
        _.extend(requestParams, {
          embedToken: this.embedToken
        });
      }

      if (params && params[OO.CONSTANTS.HEVC_CODEC.HVC1] === true) {
        _.extend(requestParams, {
          codecPriority: 'hvc'
        });
      } else if (params && params[OO.CONSTANTS.HEVC_CODEC.HEV1] === true) {
        _.extend(requestParams, {
          codecPriority: 'hev'
        });
      } else {
        _.extend(requestParams, {
          codecPriority: 'avc'
        });
      } // start server request


      var request = {
        embedCode: this.currentEmbedCode,
        pcode: OO.playerParams.pcode || 'unknown',
        playerBrandingId: OO.playerParams.playerBrandingId || 'unknown'
      }; // Note(bz): Temporary call to fetch player xml until we move to player api

      var apiRequest = _.extend({}, request, {
        server: OO.SERVER.API
      });

      var authRequest = _.extend({}, request, {
        server: OO.SERVER.AUTH
      });

      apiRequest.params = _.clone(requestParams);
      authRequest.params = _.clone(requestParams);

      if (params && !params.ooyalaAds && typeof params.dynamicFilters === 'string') {
        authRequest.params.dynamicFilters = params.dynamicFilters; // trim out whitespace on ends of filters if necessary

        if (authRequest.params.dynamicFilters.indexOf(' ') >= 0) {
          var filters = authRequest.params.dynamicFilters.split(',');

          _.each(filters, function (element, index, list) {
            filters[index] = element.trim();
          });

          authRequest.params.dynamicFilters = filters.join(',');
        }
      } // always publish the metadata event, but only html5 should publish the others.


      this.mb.publish(OO.EVENTS.WILL_FETCH_METADATA, apiRequest);

      if (this._isEmbedCodeMetadataRequired) {
        this.mb.publish(OO.EVENTS.WILL_FETCH_EMBED_CODE_METADATA, apiRequest);
      }

      if (OO.requiredInEnvironment('html5-playback')) {
        this.mb.publish(OO.EVENTS.WILL_FETCH_PLAYER_XML, apiRequest);
        this.mb.publish(OO.EVENTS.WILL_FETCH_CONTENT_TREE, apiRequest);
        this.mb.publish(OO.EVENTS.WILL_FETCH_AUTHORIZATION, authRequest);
      }
    },
    onEmbedCodeChangedAfterOoyalaAd: function onEmbedCodeChangedAfterOoyalaAd(event, embedCode, params) {
      this._processOnEmbedCodeChanged(event, embedCode, params);
    },
    onEmbedCodeChanged: function onEmbedCodeChanged(event, embedCode, params) {
      this._processOnEmbedCodeChanged(event, embedCode, params);
    },

    /**
     * @method ApiModule#_willRequireEmbedCodeMetadata
     * @description Callback for OO.EVENTS.WILL_REQUIRE_EMBED_CODE_METADATA
     * @param {string} event The name of the event that triggered this function
     * @param {boolean} required True if embed code metadata is required
     * @private
     */
    _willRequireEmbedCodeMetadata: function _willRequireEmbedCodeMetadata(event, required) {
      this._isEmbedCodeMetadataRequired = required;
    },
    // Ooyala API Calls

    /*
     *  Content Tree
     */
    onWillFetchContentTree: function onWillFetchContentTree(event, request) {
      if (request.params && request.params.ooyalaAds) {
        this.ooyalaAds = request.params.ooyalaAds;
      } else {
        this.ooyalaAds = false;
      }

      if (this.valhallaCache.exists(OO.CONSTANTS.VALHALLA_CACHE_CONTENT_TREE_KEY)) {
        OO.log('Using valhallaCache to populate contentTree');

        this._onContentTreeFetched(this.valhallaCache.get(OO.CONSTANTS.VALHALLA_CACHE_CONTENT_TREE_KEY, true));

        return;
      }

      if (typeof this.contentTree[this.currentEmbedCode] !== 'undefined') {
        this.mb.publish(OO.EVENTS.CONTENT_TREE_FETCHED, this.contentTree[this.currentEmbedCode], this.ooyalaAds);
      } else {
        this._contentAjax = $.ajax({
          url: OO.URLS.CONTENT_TREE(request) + '?' + $.param(request.params),
          type: 'GET',
          dataType: 'json',
          crossDomain: true,
          success: _.bind(this._onContentTreeFetched, this),
          error: function (apiModule) {
            return function (xhr, status, error) {
              apiModule._onApiError(xhr, status, 'Error in Content Tree request. ' + error, this.url);
            };
          }(this)
        });
      }
    },
    _onContentTreeFetched: function _onContentTreeFetched(response) {
      var safeResponse = OO.HM.safeObject('playbackControl.contentTree', response, {});
      this._contentAjax = null;

      if (safeResponse.errors && +safeResponse.errors.code === 0) {
        _.each(safeResponse.content_tree, _.bind(function (value, embedCode) {
          this.contentTree[embedCode] = safeResponse.content_tree[embedCode];
        }, this));
      }

      var supportedContentType = ['Video', 'VideoAd', 'LiveStream', 'Channel', 'MultiChannel', 'Youtube', 'Audio'];

      if (this.contentTree[this.currentEmbedCode]) {
        var hostedAtURL = safeResponse.content_tree[this.currentEmbedCode].hostedAtURL;

        if (hostedAtURL === '' || hostedAtURL === null) {
          safeResponse.content_tree[this.currentEmbedCode].hostedAtURL = document.URL;
        }

        var contentIsSupportedInHtml5 = supportedContentType.indexOf(this.contentTree[this.currentEmbedCode].content_type) >= 0;

        if (contentIsSupportedInHtml5) {
          this.mb.publish(OO.EVENTS.CONTENT_TREE_FETCHED, this.contentTree[this.currentEmbedCode], this.ooyalaAds);
        } else {
          this.mb.publish(OO.EVENTS.ERROR, {
            code: OO.ERROR.API.CONTENT_TREE
          });
        }

        var assetPcode = this.contentTree[this.currentEmbedCode].asset_pcode;
        var playerPcode = this.params.pcode;

        if (playerPcode !== assetPcode) {
          console.warn("Warning: The PCODE (Ooyala Partner Code) \"".concat(assetPcode, "\" ") + "is not associated to the same account as the content being played \"".concat(playerPcode, "\". ") + "This may cause data to not report into Ooyala IQ and be lost.");
        }
      } else {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.UNPLAYABLE_CONTENT
        });
      }
    },

    /*
     *  Metadata
     */
    onWillFetchMetadata: function onWillFetchMetadata(event, request) {
      if (request.params && request.params.ooyalaAds) {
        this.ooyalaAds = request.params.ooyalaAds;
      } else {
        this.ooyalaAds = false;
      }

      if (this.valhallaCache.exists(OO.CONSTANTS.VALHALLA_CACHE_METADATA_KEY)) {
        OO.log('Using valhallaCache to populate metadata');

        this._onMetadataFetched(this.valhallaCache.get(OO.CONSTANTS.VALHALLA_CACHE_METADATA_KEY, true));

        return;
      } // send the metadata request


      if (typeof this.metadata[this.currentEmbedCode] !== 'undefined') {
        this.mb.publish(OO.EVENTS.METADATA_FETCHED, this.metadata[this.currentEmbedCode], this.ooyalaAds);
      } else {
        this._metadataAjax = $.ajax({
          url: OO.URLS.METADATA(request) + '&' + $.param(request.params),
          type: 'GET',
          dataType: 'json',
          crossDomain: true,
          success: _.bind(this._onMetadataFetched, this),
          error: function (apiModule) {
            return function (xhr, status, error) {
              apiModule._onApiError(xhr, status, 'Error in Metadata request. ' + error, this.url);
            };
          }(this)
        });
      }
    },
    _onMetadataFetched: function _onMetadataFetched(response) {
      this.metadata = this.metadata || {};
      var safeResponse = OO.HM.safeObject('api.metadata', response, {});
      this._metadataAjax = null;

      if (safeResponse.errors && +safeResponse.errors.code === 0) {
        this.skinMetadata = safeResponse.skin;
        this.attributes = safeResponse.attributes;

        _.each(safeResponse.metadata, _.bind(function (value, embedCode) {
          this.metadata[embedCode] = safeResponse.metadata[embedCode]; // allow to override module params from player params

          this.metadata[embedCode].modules = this.metadata[embedCode].modules || {};
          this.metadata[embedCode].modules = _.extend(this.metadata[embedCode].modules, this.params.modules || {});
        }, this));
      }

      this.mb.publish(OO.EVENTS.METADATA_FETCHED, this.metadata[this.currentEmbedCode] || {}, this.ooyalaAds);

      if (this.skinMetadata) {
        this.mb.publish(OO.EVENTS.SKIN_METADATA_FETCHED, this.skinMetadata);
      }

      if (this.attributes) {
        this.mb.publish(OO.EVENTS.ATTRIBUTES_FETCHED, this.attributes);
      }

      if (safeResponse.errors && safeResponse.errors.player_movie_mismatch && typeof window.console !== 'undefined' && typeof window.console.log === 'function') {
        console.log('WARNING: Player and movie providers do not match');
      }
    },

    /**
     * @method ApiModule#onWillFetchEmbedCodeMetadata
     * @description Call OO.URLS.EMBED_CODE_METADATA with the request
     * @param {string} event The name of the event that triggered this function
     * @param {object} request params for the call
     * @private
     */
    onWillFetchEmbedCodeMetadata: function onWillFetchEmbedCodeMetadata(event, request) {
      this._embedCodeMetadataAjax = $.ajax({
        url: OO.URLS.EMBED_CODE_METADATA(request),
        type: 'GET',
        dataType: 'json',
        crossDomain: true,
        success: _.bind(this._onEmbedCodeMetadataFetched, this),
        error: function (apiModule) {
          return function (xhr, status, error) {
            apiModule._onApiError(xhr, status, 'Error in Embed Code Metadata request. ' + error, this.url);
          };
        }(this)
      });
    },

    /**
     * @method ApiModule#onEmbedCodeMetadataFetched
     * @description Get a safeObject from embed code metadata response and
     * publish the result
     * @param {object} response from calling the embed code metadata endpoint
     * @fires OO.EVENTS.EMBED_CODE_METADATA_FETCHED with embed code metadata
     * @private
     */
    _onEmbedCodeMetadataFetched: function _onEmbedCodeMetadataFetched(response) {
      var safeResponse = OO.HM.safeObject('api.metadata', response, {});
      this._embedCodeMetadataAjax = null;

      if (!safeResponse.metadata || _.isEmpty(safeResponse.metadata)) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.METADATA
        });
        return;
      }

      if (safeResponse.errors && +safeResponse.errors.code === 0) {
        this.mb.publish(OO.EVENTS.EMBED_CODE_METADATA_FETCHED, safeResponse || {});
      }
    },

    /*
     *  SAS
     */
    onWillFetchAuthorization: function onWillFetchAuthorization(event, request) {
      // clear interval for geo-check
      this.mb.publish(OO.EVENTS.CANCEL_GEO_CHECKING);

      if (request.params && request.params.ooyalaAds) {
        this.ooyalaAds = request.params.ooyalaAds;
      } else {
        this.ooyalaAds = false;
      }

      if (this.valhallaCache.exists(OO.CONSTANTS.VALHALLA_CACHE_SAS_KEY)) {
        OO.log('Using valhallaCache to populate sasResponse');

        this._onAuthorizationFetched(this.valhallaCache.get(OO.CONSTANTS.VALHALLA_CACHE_SAS_KEY, true));

        return;
      }

      if (this.sasResponse[this.currentEmbedCode] && +this.sasResponse[this.currentEmbedCode].code === 0) {
        this.mb.publish(OO.EVENTS.AUTHORIZATION_FETCHED, this.sasResponse[this.currentEmbedCode], this.ooyalaAds);
      } else {
        // add additional params for SAS
        this._sendSasRequest(request, _.bind(this._onAuthorizationFetched, this), function (apiModule) {
          return function (xhr, status, error) {
            apiModule._onApiError(xhr, status, 'Error in SAS request. ' + error, this.url);
          };
        }(this));
      }
    },
    _onAuthorizationFetched: function _onAuthorizationFetched(response) {
      var code, codes;
      this._sasAjax = null;
      var safeResponse = OO.HM.safeObject('playbackControl.sasResponse', response, {}); // save auth token

      if (safeResponse.auth_token) {
        OO.setItem('oo_auth_token', safeResponse.auth_token);
        this.authToken = safeResponse.auth_token;
      } else {
        OO.localStorage.removeItem('oo_auth_token');
        this.authToken = null;
      }

      _.each(safeResponse.authorization_data, _.bind(function (value, embedCode) {
        this.sasResponse[embedCode] = safeResponse.authorization_data[embedCode];

        if (this.sasResponse[embedCode].is_cmaf === true || this.sasResponse[embedCode].is_cmaf === 'true') {
          var maxIosVersion = 9;

          if (OO.isIos && OO.iosMajorVersion <= maxIosVersion) {
            this.sasResponse[embedCode].streams = OO.stripNonMp4Streams(this.sasResponse[embedCode].streams);
          }
        }

        if (safeResponse.debug_data) {
          this.sasResponse[embedCode].debug_data = safeResponse.debug_data;
        }

        if (safeResponse.user_info) {
          this.sasResponse[embedCode].user_info = safeResponse.user_info;
        }

        if (safeResponse.auth_token) {
          this.sasResponse[embedCode].auth_token = safeResponse.auth_token;
        }

        if (safeResponse.heartbeat_data) {
          this.sasResponse[embedCode].heartbeat_data = safeResponse.heartbeat_data;
        }

        if (safeResponse.mid_stream_check_interval) {
          this.sasResponse[embedCode].mid_stream_check_interval = safeResponse.mid_stream_check_interval;
        }
      }, this));

      code = this.sasResponse[this.currentEmbedCode].code;
      this.checkGeoBlocking(); // Always publish the Authorization Response for Flash and only publish this on success for HTML5

      if (+code === 0) {
        this.mb.publish(OO.EVENTS.AUTHORIZATION_FETCHED, this.sasResponse[this.currentEmbedCode], this.ooyalaAds);
        return;
      }

      if (!_.isString(code)) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.GENERIC
        });
        return;
      }

      codes = code.split(',');

      if (_.contains(codes, '2')) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.DOMAIN
        });
      } else if (_.contains(codes, '3')) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.GEO
        });
      } else if (_.contains(codes, '4')) {
        var startTimestamp = this.sasResponse[this.currentEmbedCode].retry;
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.FUTURE,
          flight_start_time: startTimestamp
        });
      } else if (_.contains(codes, '5')) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.PAST
        });
      } else if (_.contains(codes, '13')) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.DEVICE
        });
      } else if (_.contains(codes, '18')) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.CONCURRENT_STREAMS
        });
      } else if (_.contains(codes, '24')) {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.PROXY
        });
      } else {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.GENERIC
        });
      }
    },
    onWillFetchAdAuthorization: function onWillFetchAdAuthorization(event, request, errorCallback) {
      this._sendSasRequest(request, _.bind(this._onAdAuthorizationFetched, this), errorCallback);
    },
    checkGeoBlocking: function checkGeoBlocking() {
      this._sendGeoBlockingRequest = this._sendGeoBlockingRequest.bind(this);

      if (this.sasResponse && this.sasResponse[this.currentEmbedCode] && this.sasResponse[this.currentEmbedCode].require_mid_stream_check) {
        if (this.sasResponse[this.currentEmbedCode].mid_stream_check_interval) {
          this._sendGeoBlockingRequest(); // you need to cancel setInterval


          var ms = 1000;
          OO.geoCheckingInterval = setInterval(this._sendGeoBlockingRequest, this.sasResponse[this.currentEmbedCode].mid_stream_check_interval * ms); // to [ms]
        }
      }
    },
    _onAdAuthorizationFetched: function _onAdAuthorizationFetched(response) {
      var safeResponse = OO.HM.safeObject('playbackControl.sasResponse', response, {});
      var ooyalaAds = {};

      _.each(safeResponse.authorization_data, _.bind(function (value, embedCode) {
        ooyalaAds[embedCode] = safeResponse.authorization_data[embedCode];
      }, this));

      this.mb.publish(OO.EVENTS.AD_AUTHORIZATION_FETCHED, ooyalaAds);
    },
    _sendSasRequest: function _sendSasRequest(request, callback, errorback) {
      var profiles = OO.supportedVideoProfiles;
      var device = OO.device;
      $.extend(request.params, {
        device: device,
        domain: OO.docDomain,
        player_type: OO.playerParams.playerType
      }); // TODO - SAS should expect player_type = "audio" but is currently
      // expecting "audio_only". This hack ensures the correct type
      // is sent for now, but should be removed once SAS changes to expect "audio"

      if (request.params.player_type === OO.CONSTANTS.PLAYER_TYPE.AUDIO) {
        request.params.player_type = request.params.player_type + '_only';
      }

      if (profiles) {
        $.extend(request.params, {
          profiles: profiles
        }); // set profiles if any
      }

      if (this.authToken) {
        $.extend(request.params, {
          auth_token: this.authToken
        });
      }

      var requestUrl = OO.URLS.SAS(request) + '?' + $.param(request.params);
      this._sasAjax = $.ajax({
        url: requestUrl,
        type: 'GET',
        dataType: 'json',
        xhrFields: {
          withCredentials: true
        },
        crossDomain: true,
        success: callback,
        error: errorback
      });
    },
    _abort: function _abort(ajax) {
      if (!ajax) {
        return;
      }

      this._aborting = true;
      ajax.abort();
      this._aborting = false;
    },
    _onApiError: function _onApiError(xhr, status, error, url) {
      if (this._aborting) {
        return;
      }

      OO.debug(error, status, xhr, url);
      this.mb.publish(OO.EVENTS.ERROR, {
        code: OO.ERROR.API.NETWORK,
        xhrStatus: status,
        description: error,
        url: url
      });
      this.mb.publish(OO.EVENTS.API_ERROR, xhr.status, error, url);
    },
    _sendGeoBlockingRequest: function _sendGeoBlockingRequest() {
      this._gbAjax = null;

      var callbackStatus = function callbackStatus() {
        this.mb.publish(OO.EVENTS.PAUSE);
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.SAS.GEO
        });
        this.mb.publish(OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT, OO.VIDEO.MAIN);
        this.mb.publish(OO.EVENTS.CANCEL_GEO_CHECKING);
      };

      var paramsRequest = {
        pcode: this.params.pcode,
        embedCode: this.currentEmbedCode,
        authToken: this.authToken,
        server: OO.SERVER.AUTH
      };
      var requestUrl = OO.URLS.GEO_BLOCKING(paramsRequest);
      this._gbAjax = $.ajax({
        url: requestUrl,
        type: 'GET',
        crossDomain: true,
        statusCode: {
          403: _.bind(callbackStatus, this)
        }
      });
    },
    __placeholder: true
  });

  OO.registerModule('api', function (messageBus, id, params) {
    return new ApiModule(messageBus, id, params);
  });
})(OO, OO._, OO.$);

},{}],68:[function(require,module,exports){
"use strict";

/*
 * Asset Controller
 */
(function (OO, _, $) {
  /**
   * @class AssetController
   * @classdesc The Asset controller main class.  This class is registered as a module with the player.
   * @private
   * @param {object} messageBus The player message bus
   * @param {string} id The ID of the player module
   */
  var AssetController = function AssetController(messageBus, id) {
    this.toString = function () {
      return 'asset-controller';
    };

    this.mb = messageBus;
    this.id = id;
    this.currentAssetId = '';
    this.mb.subscribe(OO.EVENTS.SET_ASSET, 'asset', _.bind(this.setAsset, this));
    this.mb.subscribe(OO.EVENTS.UPDATE_ASSET, 'asset', _.bind(this.updateAsset, this));
  };

  _.extend(AssetController.prototype, {
    /**
     * Converts values from the asset JSON to what the player is expecting
     * @method AssetController#normalizeAsset
     * @private
     * @param {object} asset The new asset metadata
     */
    normalizeAsset: function normalizeAsset(asset) {
      var ms = 1000;
      asset.content.duration = asset.content.duration * ms;
    },

    /**
     * Called when the asset is changed.  Verify asset object satisfy required parameters
     * @method AssetController#setAsset
     * @private
     * @param {string} eventname The name of the event raised
     * @param {object} asset The new asset metadata
     * @param {object} params The player parameters
     * @fires OO.EVENTS.PLAYBACK_READY
     */
    setAsset: function setAsset(eventname, asset, params) {
      // Verify if asset object satisfy required settings (Required settings are TBD)
      if (this.validate(asset)) {
        this.normalizeAsset(asset);
        this.currentAssetId = asset.id;

        _.defer(_.bind(function () {
          this.mb.publish(OO.EVENTS.ASSET_CHANGED, asset, params);
        }, this));

        if (this.validateKeyframes(asset)) {
          this.mb.publish(OO.EVENTS.THUMBNAILS_FETCHED, {
            data: asset.content.keyFrames
          });
        }

        if (asset.relatedVideos && asset.relatedVideos.length > 0) {
          this.mb.publish(OO.EVENTS.DISCOVERY_API.RELATED_VIDEOS_FETCHED, {
            videos: asset.relatedVideos
          });
        }
      } else {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.API.CONTENT_TREE
        });
      }
    },

    /**
     * Called to update metadata about the currently playing asset. Unrequired field in the
     * asset JSON can be filled in here after the initial SET_ASSET call without interrupting playback.
     * Will publish ASSET_UPDATED if the asset passes validation.
     * @method AssetController#updateAsset
     * @private
     * @param {string} eventname The name of the event raised
     * @param {object} asset The new asset metadata
     * @param {object} params The player parameters
     * @fires OO.EVENTS.ASSET_UPDATED
     */
    updateAsset: function updateAsset(eventname, asset, params) {
      // Verify if asset object satisfy required settings (Required settings are TBD)
      if (this.validateUpdate(asset)) {
        this.mb.publish(OO.EVENTS.ASSET_UPDATED, asset);
      }

      if (this.validateKeyframes(asset)) {
        this.mb.publish(OO.EVENTS.THUMBNAILS_FETCHED, {
          data: asset.content.keyFrames
        });
      }

      if (asset.relatedVideos.length > 0) {
        this.mb.publish(OO.EVENTS.DISCOVERY_API.RELATED_VIDEOS_FETCHED, {
          videos: asset.relatedVideos
        });
      }
    },

    /**
     * Validate asset params
     * @method AssetController#validate
     * @private
     * @param {object} asset The new asset metadata
     * @param {object} params The player parameters
     * @returns {Boolean} <code>true</code> if the asset fulfills required params, <code>false</code> otherwise.
     * Required params TBD
     */
    validate: function validate(asset) {
      this.validateRelatedVideos(asset);
      return asset && typeof asset.id === 'string' && asset.content && asset.content.streams && asset.content.streams.length > 0 && typeof asset.content.title === 'string' && typeof asset.content.description === 'string' && typeof asset.content.duration === 'number' && asset.content.posterImages && asset.content.posterImages.length > 0 && asset.content.captions;
    },

    /**
     * Validate asset params when updating the asset
     * @method AssetController#validateUpdate
     * @private
     * @param {object} asset The updated asset metadata
     * @returns {Boolean} <code>true</code> if the asset fulfills required params, <code>false</code> otherwise.
     * Required params TBD
     */
    validateUpdate: function validateUpdate(asset) {
      this.validateRelatedVideos(asset);
      return asset && typeof asset.id === 'string' && asset.id === this.currentAssetId && (asset.relatedVideos && asset.relatedVideos.length > 0 || asset.content && (typeof asset.content.title === 'string' || typeof asset.content.description === 'string' || typeof asset.content.duration === 'number' || asset.content.captions || asset.content.posterImages && asset.content.posterImages.length > 0));
    },

    /**
     * Validate related videos
     * @method AssetController#validateRelatedVideos
     * @private
     * @param {object} asset Related video asset
     */
    validateRelatedVideos: function validateRelatedVideos(asset) {
      if (asset.relatedVideos && asset.relatedVideos.length > 0) {
        var validatedRelatedVideos = [];

        for (var videoIndex = 0; videoIndex < asset.relatedVideos.length; videoIndex++) {
          if (this.validate(asset.relatedVideos[videoIndex].asset) && typeof asset.relatedVideos[videoIndex].name === 'string' && typeof asset.relatedVideos[videoIndex].preview_image_url === 'string') {
            validatedRelatedVideos.push(asset.relatedVideos[videoIndex]);
          }
        }

        asset.relatedVideos = validatedRelatedVideos;
      }
    },
    validateKeyframes: function validateKeyframes(asset) {
      return asset && asset.content && asset.content.keyFrames && asset.content.keyFrames.available_widths && asset.content.keyFrames.available_widths.length > 0 && asset.content.keyFrames.available_time_slices && asset.content.keyFrames.available_time_slices.length > 0 && asset.content.keyFrames.thumbnails && Object.keys(asset.content.keyFrames.thumbnails).length === asset.content.keyFrames.available_time_slices.length;
    }
  });

  OO.registerModule('assetController', function (messageBus, id) {
    return new AssetController(messageBus, id);
  });
})(OO, OO._, OO.$);

},{}],69:[function(require,module,exports){
"use strict";

(function (OO, _, $) {
  var AuthHeartbeat = function AuthHeartbeat(messageBus, id) {
    if (!OO.requiredInEnvironment('html5-playback')) {
      return;
    }

    this.mb = messageBus;
    this.id = id;
    this.embedCode = null;
    this.authToken = null;
    this.heartbeatInterval = 300; // in sec

    this.timer = null;
    this.retries = 3;
    this.require_heartbeat = false; // internal constants

    this.AUTH_HEARTBEAT_URL = _.template('<%=server%>/player_api/v1/auth_heartbeat/pcode/<%=pcode%>/auth_token/' + '<%=authToken%>?embed_code=<%=embedCode%>'); // listeners

    this.mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED, 'auth_heartbeat', _.bind(this._onEmbedCodeChanged, this));
    this.mb.subscribe(OO.EVENTS.AUTHORIZATION_FETCHED, 'auth_heartbeat', _.bind(this._onAuthorizationFetched, this));
    this.mb.subscribe(OO.EVENTS.INITIAL_PLAY_STARTING, 'auth_heartbeat', _.bind(this._startTimer, this));
    this.mb.subscribe(OO.EVENTS.CHROMECAST_START_CAST, 'auth_heartbeat', _.bind(this._clearTimer, this));
    this.mb.subscribe(OO.EVENTS.CHROMECAST_END_CAST, 'auth_heartbeat', _.bind(this._startTimer, this));
  };

  _.extend(AuthHeartbeat.prototype, {
    _onEmbedCodeChanged: function _onEmbedCodeChanged(event, embedCode) {
      this.embedCode = embedCode;

      if (this.timer) {
        clearInterval(this.timer);
      }

      if (this.ajax) {
        this.ajax.error = null;
        this.ajax.abort();
        this.ajax = null;
      }

      this.retries = 3;
    },
    _startTimer: function _startTimer() {
      if (this.require_heartbeat) {
        var ms = 1000;
        this.timer = setInterval(_.bind(this._onTimerTick, this), this.heartbeatInterval * ms);

        this._onTimerTick(); // Fire first heartbeat NOW.

      }
    },
    _clearTimer: function _clearTimer() {
      clearInterval(this.timer);
    },
    _onAuthorizationFetched: function _onAuthorizationFetched(event, authResponse) {
      if (authResponse.heartbeat_data && authResponse.heartbeat_data.heartbeat_interval) {
        this.heartbeatInterval = authResponse.heartbeat_data.heartbeat_interval;
      }

      if (authResponse.auth_token) {
        this.authToken = authResponse.auth_token;
      }

      this.require_heartbeat = authResponse.require_heartbeat;
    },
    _onTimerTick: function _onTimerTick() {
      // send heartbeat
      this.ajax = $.ajax({
        url: this.AUTH_HEARTBEAT_URL({
          server: OO.SERVER.AUTH,
          pcode: OO.playerParams.pcode || 'unknown',
          authToken: this.authToken || '',
          embedCode: this.embedCode || ''
        }),
        type: 'GET',
        dataType: 'json',
        crossDomain: true,
        cache: false,
        success: _.bind(this._onHeartbeatResponse, this),
        error: _.bind(this._onHeartbeatErrorResponse, this)
      });
    },
    _onHeartbeatResponse: function _onHeartbeatResponse(response) {
      this.ajax = null;

      if (!response.message || response.message !== 'OK' || !response.signature) {
        this._onHeartbeatError(OO.ERROR.API.SAS.INVALID_HEARTBEAT);
      } else {
        this.retries = 3;

        if (response.auth_token != null) {
          this.authToken = response.auth_token;
          OO.setItem('oo_auth_token', response.auth_token);
        }
      }
    },
    _onHeartbeatErrorResponse: function _onHeartbeatErrorResponse(response) {
      this.ajax = null;

      if (response && response.responseText && response.responseText.indexOf('Invalid entitlements') > -1) {
        this._onHeartbeatError(OO.ERROR.API.SAS.ERROR_INVALID_ENTITLEMENTS);
      } else {
        this._onHeartbeatError(OO.ERROR.API.SAS.CONCURRENT_STREAMS);
      }
    },
    _onHeartbeatError: function _onHeartbeatError(errorMessage) {
      this.ajax = null;
      this.retries--;

      if (this.retries > 0) {
        this._onTimerTick();

        return;
      }

      if (this.timer) {
        clearInterval(this.timer);
      }

      this.mb.publish(OO.EVENTS.ERROR, {
        code: errorMessage
      });
    }
  });

  OO.registerModule('auth_heartbeat', function (messageBus, id) {
    return new AuthHeartbeat(messageBus, id);
  });
})(OO, OO._, OO.$);

},{}],70:[function(require,module,exports){
"use strict";

OO.plugin('Channels', function (OO, _, $, Window) {
  /*
   * Channel Module:  Intercept all CONTENT_TREE_FETCHED events.
   *   If the player is a flash player, and channels are enabled, play the flash player v2 style
   *   If the player is a flash player, and channels are disabled, publish an error
   *   If the player is html5 and channels are enabled, play the first video of the channel
   *   If the player is html5 and channels are disabled, publish an error
   */
  var Channels = function Channels(mb, id) {
    this.id = id;
    this.mb = mb;
    this.channel_tree = null;
    this.channel_pos = -1;
    this.replay = false;
    OO.StateMachine.create({
      initial: 'Init',
      messageBus: this.mb,
      moduleName: 'Channels',
      target: this,
      events: [{
        name: OO.EVENTS.PLAYER_CREATED,
        from: '*'
      }]
    });
  };

  _.extend(Channels.prototype, {
    onPlayerCreated: function onPlayerCreated(event, elementId, params) {
      this.enableChannels = params.enableChannels || OO.playerParams.enableChannels || false;
      this.mb.intercept(OO.EVENTS.CONTENT_TREE_FETCHED, 'channels', _.bind(this._checkTreeForChannel, this));
    },
    _checkTreeForChannel: function _checkTreeForChannel(eventName, tree, ooyalaAds) {
      var supportedContentType = ['Channel', 'MultiChannel']; // if i get a tree from V3, it will have contenttype

      if (tree && (supportedContentType.indexOf(tree.content_type) >= 0 || tree.lineup)) {
        if (this.enableChannels) {
          // if this is a html5 player, take first child's embed code
          if (OO.requiredInEnvironment('html5-playback') || OO.requiredInEnvironment('cast-playback')) {
            if (!tree.children) {
              if (tree.content_type === 'Channel') {
                this.mb.publish(OO.EVENTS.ERROR, {
                  code: OO.ERROR.EMPTY_CHANNEL
                });
              } else {
                this.mb.publish(OO.EVENTS.ERROR, {
                  code: OO.ERROR.EMPTY_CHANNEL_SET
                });
              }

              return false;
            }

            this.channel_tree = tree;
            this.channel_pos = 0;
            this.mb.subscribe(OO.EVENTS.PLAYED, 'channels', _.bind(this.onPlayed, this));
            this.mb.subscribe(OO.EVENTS.PLAYBACK_READY, 'channels', _.bind(this.onPlaybackReady, this));
            this.mb.publish(OO.EVENTS.SET_EMBED_CODE, tree.children[0].embed_code);
          }

          return false;
        } // If this is a channel, and channels are not enabled, error out


        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.CHANNEL_CONTENT
        });
        return false;
      }

      return [tree, ooyalaAds];
    },
    onPlayed: function onPlayed(event) {
      this.channel_pos++; // Every time a video is played, set the embed code to the next video.

      if (this.channel_tree.children[this.channel_pos]) {
        this.mb.publish(OO.EVENTS.SET_EMBED_CODE, this.channel_tree.children[this.channel_pos].embed_code);
      } else {
        // If we played the last video, reset to the first video
        this.channel_pos = 0;
        this.mb.publish(OO.EVENTS.SET_EMBED_CODE, this.channel_tree.children[0].embed_code);
      }
    },
    // Every time the video is loaded (other than first), autoplay
    onPlaybackReady: function onPlaybackReady(event) {
      if (this.channel_pos > 0) {
        this.mb.publish(OO.EVENTS.PLAY);
      }
    }
  }); // Return class definition.


  return Channels;
});

},{}],71:[function(require,module,exports){
"use strict";

/* globals cast, chrome */

/* eslint no-magic-numbers: "off" */
// Chromecast only works on Chrome Desktop and Chrome Android.
if (OO.isChrome && !OO.isIos) {
  var castPluginName = 'Chromecast';
  OO.plugin(castPluginName, function (OO, _, $) {
    var debugCast = false;
    var OOYALA_NAMESPACE = 'urn:x-cast:ooyala';
    var FRAMEWORK_URL = 'https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1';
    var LOG_PREFIX = 'Ooyala Chromecast: ';
    var LOG_ERROR_PREFIX = 'Ooyala Chromecast Error: ';
    var notificationBarEnabled = OO.isAndroid && navigator.mediaSession !== null;
    var appId = '';
    var castOptions = {};
    var canCast = false;
    var initialized = false;
    var playbackReady = false;
    var mb;
    var isCasting = false;
    var PLAYER_STATE = {
      START: 'start',
      PLAYING: 'playing',
      PAUSED: 'paused',
      END: 'end'
    };
    var CHROMECAST_EVENT = {
      PLAYING: 'playing',
      PLAYED: 'played',
      PAUSED: 'paused',
      PLAYHEAD_TIME_CHANGED: 'playheadTimeChanged',
      SEEK: 'seek',
      STATUS_UPDATE: 'statusUpdate'
    };
    var CHROMECAST_ACTION = {
      RECEIVER_STATUS_LOSS: 'receiverStatusLoss',
      TOGGLE_CLOSED_CAPTIONS: 'toggleClosedCaptions',
      SET_CC_LANGUAGE: 'setCCLanguage'
    }; // this are the params that should be sent to chromecast and any other will be ignored

    var PARAMS_ALLOWED = ['playerBrandingId', 'pcode', 'encodingPriority', 'embedToken']; // the param inside are editable but localPlayer shouldn't be reassigned

    var localPlayer = {
      embedCode: '',
      params: {},
      state: PLAYER_STATE.START,
      isMuted: false,
      playbackStarted: false,
      volume: 1,
      playhead: 0,
      duration: 0,
      metadata: null
    };
    /**
     * @class Chromecast
     * @desc This class takes care of connecting to an external chromecast,
     * syncing the local player UI to the state of the Chromecast player and
     * and it can relay commands to the Chromecast to control it.
     * @param {object} messageBus The player's message bus
     *
     * @public
     */

    var Chromecast = function Chromecast(messageBus) {
      mb = messageBus;
      initialized = true;
      mb.subscribe(OO.EVENTS.PLAYER_CREATED, castPluginName, onPlayerCreated);
      mb.subscribe(OO.EVENTS.PLAYBACK_READY, castPluginName, onPlaybackReady);
      mb.subscribe(OO.EVENTS.INITIAL_PLAY, castPluginName, onInitialPlay);
      mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED, castPluginName, onEmbedCodeChanged);
      mb.subscribe(OO.EVENTS.ASSET_CHANGED, castPluginName, onAssetChanged);
      mb.subscribe(OO.EVENTS.PLAY, castPluginName, onPlay);
      mb.subscribe(OO.EVENTS.PAUSE, castPluginName, onPause);
      mb.subscribe(OO.EVENTS.SEEK, castPluginName, onSeek);
      mb.subscribe(OO.EVENTS.REPLAY, castPluginName, onReplay);
      mb.subscribe(OO.EVENTS.CHANGE_VOLUME, castPluginName, onChangeVolume);
      mb.subscribe(OO.EVENTS.CHANGE_MUTE_STATE, castPluginName, onChangeMuteState);
      mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, castPluginName, onPlayheadUpdated);
      mb.subscribe(OO.EVENTS.CONTENT_TREE_FETCHED, castPluginName, onContentTreeFetched);
      mb.subscribe(OO.EVENTS.TOGGLE_CLOSED_CAPTIONS, castPluginName, onToggleClosedCaptions);
      mb.subscribe(OO.EVENTS.SET_CLOSED_CAPTIONS_LANGUAGE, castPluginName, onSetClosedCaptionLanguage);
      tryInitPlayerForCasting();
    };
    /**
     * Helper function to unsubscribe from player
     * @private
     * @method Chromecast#disablePlugin
     */


    var disablePlugin = function disablePlugin() {
      mb.unsubscribe(OO.EVENTS.PLAYER_CREATED, castPluginName, onPlayerCreated);
      mb.unsubscribe(OO.EVENTS.PLAYBACK_READY, castPluginName, onPlaybackReady);
      mb.unsubscribe(OO.EVENTS.EMBED_CODE_CHANGED, castPluginName, onEmbedCodeChanged);
      mb.unsubscribe(OO.EVENTS.ASSET_CHANGED, castPluginName, onAssetChanged);
      mb.unsubscribe(OO.EVENTS.PLAY, castPluginName, onPlay);
      mb.unsubscribe(OO.EVENTS.PAUSE, castPluginName, onPause);
      mb.unsubscribe(OO.EVENTS.SEEK, castPluginName, onSeek);
      mb.unsubscribe(OO.EVENTS.REPLAY, castPluginName, onReplay);
      mb.unsubscribe(OO.EVENTS.CHANGE_VOLUME, castPluginName, onChangeVolume);
      mb.unsubscribe(OO.EVENTS.CHANGE_MUTE_STATE, castPluginName, onChangeMuteState);
      mb.unsubscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, castPluginName, onPlayheadUpdated);
      mb.unsubscribe(OO.EVENTS.CONTENT_TREE_FETCHED, castPluginName, onContentTreeFetched);
    };
    /**
     * Load the chromecast sdk
     * @method Chromecast#loadSDK
     * @private
     */


    var loadSDK = function loadSDK() {
      // hook into the Chromecast SDK to know if it's available.
      window['__onGCastApiAvailable'] = function (isAvailable) {
        if (isAvailable) {
          canCast = true;
          tryInitPlayerForCasting();
        }
      };

      OO.loadScriptOnce(FRAMEWORK_URL);
    };
    /**
     * Tries to initialize the chromecast sdk  and generate our hooks into the sdk,
     * when the sdk and player are loaded.
     * @method Chromecast#tryInitPlayerForCasting
     * @private
     */


    var tryInitPlayerForCasting = function tryInitPlayerForCasting() {
      if (initialized && canCast && playbackReady) {
        var castContext = cast.framework.CastContext.getInstance();
        castOptions.receiverApplicationId = appId; // Auto join policy can be one of the following three:
        // ORIGIN_SCOPED - Auto connect from same appId and page origin
        // TAB_AND_ORIGIN_SCOPED - Auto connect from same appId, page origin, and tab
        // PAGE_SCOPED - No auto connect

        castOptions.autoJoinPolicy = chrome.cast.AutoJoinPolicy.TAB_AND_ORIGIN_SCOPED;
        castContext.setOptions(castOptions);
        castContext.addEventListener(cast.framework.CastContextEventType.CAST_STATE_CHANGED, onCastConnectionChanged);
        castContext.addEventListener(cast.framework.CastContextEventType.SESSION_STATE_CHANGED, onSessionStateChanged);
      }
    };
    /**
     * Callback for the event OO.EVENTS.PLAYER_CREATED. Page level params are
     * received here.
     * @method Chromecast#onPlayerCreated
     * @private
     * @param  {string} event     Event name OO.EVENTS.PLAYER_CREATED
     * @param  {string} elementId Name of the div player was created in
     * @param  {object} params    Page level params for the player
     */


    var onPlayerCreated = function onPlayerCreated(event, elementId, params) {
      var chromecastEnabled = false;
      var settings = params.chromecast;

      if (settings && typeof settings.appId === 'string' && settings.appId !== '') {
        appId = settings.appId;
      } else {
        OO.log(LOG_ERROR_PREFIX, 'Provide your receiver appId.');
      }

      if (settings && typeof settings.enable === 'boolean' && settings.enable === true && appId !== '') {
        chromecastEnabled = true;
      }

      if (chromecastEnabled) {
        loadSDK();
      } else {
        disablePlugin();
      }
    };
    /**
     * Callback for OO.EVENTS.PLAYBACK_READY. Try to initialize the chromecast sdk
     * if the sdk is loaded.
     * @method Chromecast#onPlaybackReady
     * @param  {string} event Event name OO.EVENTS.PLAYBACK_READY
     */


    var onPlaybackReady = function onPlaybackReady(event) {
      playbackReady = true;

      if (!isCasting) {
        tryInitPlayerForCasting();
      }
    };
    /**
     * Callback for OO.EVENTS.INITIAL_PLAY.
     * @method Chromecast#onInitialPlay
     * @param  {string} event Event name OO.EVENTS.INITIAL_PLAY
     */


    var onInitialPlay = function onInitialPlay() {
      localPlayer.playbackStarted = true;
    };
    /**
     * Callback for OO.EVENTS.CONTENT_TREE_FETCHED. Gets the asset metadata
     * @method Chromecast#onContentTreeFetched
     * @param  {string} event Event name OO.EVENTS.CONTENT_TREE_FETCHED
     * @param  {object} metadata asset metadata information
     */


    var onContentTreeFetched = function onContentTreeFetched(event, metadata) {
      localPlayer.metadata = metadata;
    };
    /**
     * Callback for OO.EVENTS.TOGGLE_CLOSED_CAPTIONS. Sends corresponding message to the Receiver
     */


    var onToggleClosedCaptions = function onToggleClosedCaptions() {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        castSession.sendMessage(OOYALA_NAMESPACE, {
          action: CHROMECAST_ACTION.TOGGLE_CLOSED_CAPTIONS
        });
      }
    };
    /**
     * Callback for OO.EVENTS.CHANGE_CLOSED_CAPTION_LANGUAGE. Sends corresponding message to the Receiver
     * @param {string} event Event name OO.EVENTS.CHANGE_CLOSED_CAPTION_LANGUAGE
     * @param {string} language New CC Language
    */


    var onSetClosedCaptionLanguage = function onSetClosedCaptionLanguage(event, language) {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        castSession.sendMessage(OOYALA_NAMESPACE, {
          action: CHROMECAST_ACTION.SET_CC_LANGUAGE,
          data: language
        });
      }
    };
    /**
     * Callback for OO.EVENTS.EMBED_CODE_CHANGED. Send the new embedcode info
     * to the chromecast, if connected.
     * @method Chromecast#onEmbedCodeChanged
     * @private
     * @param  {string} event     Event name OO.EVENTS.EMBED_CODE_CHANGED
     * @param  {string} embedCode The new embed code
     * @param  {object} params    The new player params for this new embed code.
     */


    var onEmbedCodeChanged = function onEmbedCodeChanged(event, embedCode) {
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      localPlayer.playbackStarted = false;
      localPlayer.embedCode = embedCode;

      if (params && !_.isEmpty(params)) {
        localPlayer.params = _.pick(params, PARAMS_ALLOWED);
      }

      if (isCasting) {
        loadEmbedCodeOntoChromecast(localPlayer.embedCode, localPlayer.params);
      }
    };
    /**
     * Callback for OO.EVENTS.ASSET_CHANGED. Send the new video url info
     * to the chromecast, if connected.
     * [NOT IMPLEMENTED YET]
     * @method Chromecast#onAssetChanged
     * @private
     * @param  {string} event     Event name OO.EVENTS.ASSET_CHANGED
     */


    var onAssetChanged = function onAssetChanged(event) {// TODO
    };
    /**
     * Callback for OO.EVENTS.PLAY. Send play message to the chromecast, if connected.
     * @method Chromecast#onPlay
     * @private
     * @param  {string} event     Event name OO.EVENTS.PLAY
     */


    var onPlay = function onPlay(event) {
      loadOrPlayVideo();
    };
    /**
     * Helper function to either call play on the chromecast or load the video
     * if it hasn't been loaded yet.
     * @method Chromecast#loadOrPlayVideo
     * @private
     */


    var loadOrPlayVideo = function loadOrPlayVideo() {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        var mediaSession = castSession.getMediaSession();

        if (!mediaSession) {
          loadEmbedCodeOntoChromecast(localPlayer.embedCode, localPlayer.params, localPlayer.playhead);
        } else {
          // the castPlayerControler playOrPause is unreliable and can get you
          // into a stuck state if you check to see if castPlayer.isPaused is
          // true first. So we implement the chrome.cast.media.PlayRequest instead.
          var playRequest = new chrome.cast.media.PlayRequest();
          mediaSession.play(playRequest, onPlayRequestSuccess, onPlayRequestError);
        }
      } else {
        localPlayer.state = PLAYER_STATE.PLAYING;
      }
    };
    /**
     * Callback for when a chromecast play request succeeds.
     * @method Chromecast#onPlayRequestSuccess
     * @private
     */


    var onPlayRequestSuccess = function onPlayRequestSuccess() {
      OO.log(LOG_PREFIX, 'Play request done for: ', localPlayer.embedCode);
      setNotificationBarStatus(PLAYER_STATE.PLAYING);
    };
    /**
     * Callback in case the chromecast player fails to play after a play request.
     * @method Chromecast#onPlayRequestError
     * @private
     * @param  {object} error A chrome.cast.Error object containing the error
     */


    var onPlayRequestError = function onPlayRequestError(error) {
      OO.log(LOG_ERROR_PREFIX, error);
    };
    /**
     * Callback for OO.EVENTS.PAUSE. Send pause message to the chromecast, if connected.
     * @method Chromecast#onPause
     * @private
     * @param  {string} event     Event name OO.EVENTS.PAUSE
     */


    var onPause = function onPause(event) {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        var mediaSession = castSession.getMediaSession();

        if (mediaSession) {
          // the castPlayerControler playOrPause is unreliable and can get you
          // into a stuck state if you check to see if castPlayer.isPaused is
          // true first. So we implement the chrome.cast.media.PauseRequest instead.
          var pauseRequest = new chrome.cast.media.PauseRequest();
          mediaSession.pause(pauseRequest, onPauseRequestSuccess, onPauseRequestError);
        }
      } else {
        localPlayer.state = PLAYER_STATE.PAUSED;
      }
    };
    /**
     * Callback for when a chromecast pause request succeeds.
     * @method Chromecast#onPauseRequestSuccess
     * @private
     */


    var onPauseRequestSuccess = _.bind(function () {
      OO.log(LOG_PREFIX, 'Pause request done for: ', localPlayer.embedCode);
      setNotificationBarStatus(PLAYER_STATE.PAUSED);
    }, this);
    /**
     * Callback in case the chromecast player fails to pause after a pause request.
     * @method Chromecast#onPauseRequestError
     * @private
     * @param  {object} error A chrome.cast.Error object containing the error
     */


    var onPauseRequestError = _.bind(function (error) {
      OO.log(LOG_ERROR_PREFIX, error);
    }, this);
    /**
     * Callback for OO.EVENTS.SEEK. Send a seek request to the chromecast, if connected.
     * @method Chromecast#onSeek
     * @private
     * @param  {string} event Event name OO.EVENTS.SEEK
     * @param  {number} time  Time in seconds to seek to.
     */


    var onSeek = _.bind(function (event, time) {
      if (isCasting) {
        var mediaSession = cast.framework.CastContext.getInstance().getCurrentSession().getMediaSession();
        var seekReq = new chrome.cast.media.SeekRequest();
        seekReq.currentTime = time;
        mediaSession.seek(seekReq, onSeekRequestSuccess, onSeekRequestError);
      }
    }, this);
    /**
     * Callback for when a chromecast seek request succeeds.
     * @method Chromecast#onSeekRequestSuccess
     * @private
     */


    var onSeekRequestSuccess = _.bind(function () {
      OO.log(LOG_PREFIX, 'Seek request done');
    }, this);
    /**
     * Callback for when a chromecast seek request fails.
     * @method Chromecast#onSeekRequestError
     * @private
     * @param  {object} error A chrome.cast.Error object containing the error
     */


    var onSeekRequestError = _.bind(function (error) {
      OO.log(LOG_ERROR_PREFIX, 'Seek request failed:', error);
    }, this);
    /**
     * Callback for OO.EVENTS.REPLAY. Send a request for load the same asset into the chromecast.
     * chromecast (receiver) has the proper logic to handle this and fire the replay event on his
     * internal playerV4
     * @method Chromecast#onReplay
     * @private
     * @param  {string} event Event name OO.EVENTS.REPLAY
     * @param  {number} initialTime Time in seconds to seek to before replaying.
     */


    var onReplay = function onReplay(event, initialTime) {
      if (isCasting) {
        loadEmbedCodeOntoChromecast(localPlayer.embedCode, localPlayer.params, initialTime);
      }
    };
    /**
     * Callback for OO.EVENTS.CHANGE_VOLUME. Send a message to the chromecast to
     * change the volume.
     * @method Chromecast#onChangeVolume
     * @private
     * @param  {string} event  Event name OO.EVENTS.CHANGE_VOLUME
     * @param  {number} volume Percentage between 0 and 1 to change the volume to.
     */


    var onChangeVolume = function onChangeVolume(event, volume) {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        castSession.setVolume(volume).then(onCastVolumeChanged, onCastVolumeChangeError);
      } else {
        localPlayer.volume = volume;
      }
    };
    /**
     * Callback for when a chromecast change volume request fails.
     * @method Chromecast#onCastVolumeChangeError
     * @private
     * @param  {object} error A chrome.cast.Error object containing the error
     */


    var onCastVolumeChangeError = _.bind(function (error) {
      OO.log(LOG_ERROR_PREFIX, 'Volume request failed:', error);
    }, this);
    /**
     * Callback for OO.EVENTS.CHANGE_MUTE_STATE. Send a message to the chromecast
     * to change the mute state.
     * @method Chromecast#onChangeMuteState
     * @private
     * @param  {string} event Event name OO.EVENTS.CHANGE_MUTE_STATE
     * @param  {number} muted True if volume should be muted.
     */


    var onChangeMuteState = function onChangeMuteState(event, muted) {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();

        if (castSession.isMute() !== muted) {
          castSession.setMute(muted).then(onCastMuteChanged, onCastMuteChangeError);
        }
      } else {
        localPlayer.isMuted = muted;
      }
    };
    /**
     * Callback for when a chromecast change mute state request fails.
     * @method Chromecast#onCastMuteChangeError
     * @private
     * @param  {object} error A chrome.cast.Error object containing the error
     */


    var onCastMuteChangeError = _.bind(function (error) {
      OO.log(LOG_ERROR_PREFIX, 'Mute request failed:', error);
    }, this);
    /**
     * Callback for OO.EVENTS.PLAYHEAD_TIME_CHANGED. Record the lastest playhead
     * from the chromecast or the local player.
     * @method Chromecast#onPlayheadUpdated
     * @private
     * @param  {string} event    Event name OO.EVENTS.CHANGE_MUTE_STATE
     * @param  {number} playhead The position of the video in seconds
     * @param  {number} duration The total duration of the current video
     */


    var onPlayheadUpdated = function onPlayheadUpdated(event, playhead, duration) {
      localPlayer.playhead = playhead;
      localPlayer.duration = duration;
    };
    /**
     * Send the current video's embedcode and params over to the chromecast to play.
     * @method Chromecast#loadEmbedCodeOntoChromecast
     * @private
     * @param  {string} embedCode   The ooyala embed code
     * @param  {object} params      The player params for this video.
     * @param  {number} initialTime The time, in seconds, to start the video at.
     */


    var loadEmbedCodeOntoChromecast = function loadEmbedCodeOntoChromecast(embedCode, params, initialTime) {
      var mediaInfo = new chrome.cast.media.MediaInfo(embedCode, 'video/mp4');
      var authToken = OO.localStorage.getItem('oo_auth_token');
      mediaInfo.customData = {
        ec: localPlayer.embedCode,
        params: JSON.parse(JSON.stringify(params))
      };

      if (initialTime && initialTime !== 0) {
        mediaInfo.customData.params.initialTime = initialTime;
      } // attach the authToken, if available


      if (authToken) {
        mediaInfo.customData.params.authToken = authToken;
      }

      var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
      var request = new chrome.cast.media.LoadRequest(mediaInfo);
      castSession.loadMedia(request).then(onCastMovieLoadSuccess, onCastMovieLoadError); // make sure the main video element is in focus on the local player.

      mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, OO.VIDEO.MAIN);
    };
    /**
     * Callback when a video is successfully loaded onto the chromecast
     * @method Chromecast#onCastMovieLoadSuccess
     * @private
     */


    var onCastMovieLoadSuccess = function onCastMovieLoadSuccess() {
      syncCastPlayerToLocalPlayer();
    };
    /**
     * Callback when a video is successfully loaded onto the chromecast
     * @method Chromecast#onCastMovieLoadSuccess
     * @private
     * @param {object} error A chrome.cast.Error object containing the error
     */


    var onCastMovieLoadError = function onCastMovieLoadError(error) {
      OO.log(LOG_ERROR_PREFIX, error);
    };
    /**
     * Callback when a connection is established with a chromecast
     * @method Chromecast#onCastingStarted
     * @private
     */


    var onCastingStarted = function onCastingStarted() {
      var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
      var receiverData = null;

      if (!castSession) {
        OO.log(LOG_ERROR_PREFIX, 'Error connecting to the chromecast.');
        return;
      }

      castSession.setVolume(localPlayer.volume).then(onCastVolumeChanged, onCastVolumeChangeError);
      receiverData = castSession.getCastDevice(); // if the player is playing then we should pause the content so it doesn't
      // play while we are casting.

      if (localPlayer.state === PLAYER_STATE.PLAYING) {
        mb.publish(OO.EVENTS.PAUSE, OO.VIDEO.MAIN);
      }

      castSession.addMessageListener(OOYALA_NAMESPACE, onEventFromChromecast);
      castSession.addEventListener(cast.framework.SessionEventType.VOLUME_CHANGED, onCastSessionVolumeChanged);
      var mediaSession = castSession.getMediaSession();

      if (!mediaSession) {
        // There is a way to start casting using Chrome context menu's 'Cast...' option
        // Following lines added to prevent casting until user clicks play button
        var sessionResumed = castSession.getSessionState() === cast.framework.SessionState.SESSION_RESUMED;

        if (!localPlayer.playbackStarted && !sessionResumed) {
          // End the session and pass 'true' to indicate
          // that receiver application should be stopped.
          castSession.endSession(true);
          return;
        } // if we just connected to the chromecast and the player is still at
        // the start screen, then don't load the video. Wait till user clicks play.


        if (localPlayer.state !== PLAYER_STATE.START) {
          loadEmbedCodeOntoChromecast(localPlayer.embedCode, localPlayer.params, localPlayer.playhead);
        }
      } else {
        if (!mediaSession.media || !mediaSession.media.contentId) {
          loadEmbedCodeOntoChromecast(localPlayer.embedCode, localPlayer.params, localPlayer.playhead);
        } else if (mediaSession.media && mediaSession.media.contentId === localPlayer.embedCode) {
          if (localPlayer.state === PLAYER_STATE.START) {
            // If we are on the start screen, and if the chromecast is already
            // casting this player's video then we need to transition the player
            // to the correct state.
            mb.publish(OO.EVENTS.INITIAL_PLAY, OO.VIDEO.MAIN);
            mb.publish(OO.EVENTS.PAUSE, OO.VIDEO.MAIN);

            if (mediaSession.playerState === chrome.cast.media.PlayerState.PLAYING) {
              notifyLocalPlayerPlaying();
            }

            if (mediaSession.playerState === chrome.cast.media.PlayerState.PAUSED) {
              notifyLocalPlayerPaused();
              var playheadData = {
                playhead: mediaSession.currentTime,
                duration: mediaSession.media.duration,
                videoElement: OO.VIDEO.MAIN
              };
              notifyLocalPlayerPlayheadTimeChanged(playheadData);
            }
          }
        } else {
          // if the chromecast is playing a different movie then load the one we have.
          loadEmbedCodeOntoChromecast(localPlayer.embedCode, localPlayer.params, localPlayer.playhead);
        }
      } // notify about cast session started


      isCasting = true;
      mb.publish(OO.EVENTS.CHROMECAST_START_CAST, receiverData.friendlyName);
    };
    /**
     * Callback when the chromecast session triggers any volume change.
     * @method Chromecast#onCastSessionVolumeChanged
     * @private
     * @param {cast.framework.VolumeEventData} event - event object
     * @see https://developers.google.com/cast/docs/reference/chrome/cast.framework.VolumeEventData
     */


    var onCastSessionVolumeChanged = function onCastSessionVolumeChanged(event) {
      notifyLocalPlayerMuteChanged(event.isMute);
      notifyLocalPlayerVolumeChanged(event.volume);
    };
    /**
     * Callback when the chromecast disconnects.
     * @method Chromecast#onCastingEnded
     * @private
     */


    var onCastingEnded = function onCastingEnded() {
      isCasting = false;

      if (localPlayer.state === PLAYER_STATE.PLAYING) {
        mb.publish(OO.EVENTS.CHROMECAST_END_CAST);
        syncLocalPlayerToCastPlayer();
      }
    };
    /**
     * Callback when the player receives an event or message from the chromecast
     * @method Chromecast#onEventFromChromecast
     * @private
     * @param  {string} namespace Which chromecast app is sending this message
     * @param  {object} message   A json object containing the message data
     */


    var onEventFromChromecast = function onEventFromChromecast(namespace, message) {
      // make sure we are getting messages from our chromecast app.
      if (namespace !== OOYALA_NAMESPACE) {
        return;
      }

      var data;

      try {
        data = JSON.parse(message);
      } catch (error) {
        OO.log(LOG_ERROR_PREFIX, 'event from chromecast was badly formatted', message);
        return;
      }

      if (data.length === 0) {
        return;
      }

      var event = data[0] || data.action;

      if (debugCast) {
        OO.log(LOG_PREFIX, 'EVENT ', event);
      }

      switch (event) {
        case CHROMECAST_EVENT.PLAYHEAD_TIME_CHANGED:
          var playhead = data[1];
          var duration = data[2];

          if (_.isNumber(playhead) && _.isFinite(playhead) && playhead >= 0 && _.isNumber(duration) && _.isFinite(duration) && duration > 0) {
            var bufferedTime = data[3] || 0;
            var minMaxSeekTime = data[4] || {
              min: 0,
              max: duration
            };
            var videoElement = data[5] || OO.VIDEO.MAIN;
            var playheadData = {
              playhead: playhead,
              duration: duration,
              bufferedTime: bufferedTime,
              minMaxSeekTime: minMaxSeekTime,
              videoElement: videoElement
            };
            notifyLocalPlayerPlayheadTimeChanged(playheadData);
          }

          break;

        case CHROMECAST_EVENT.STATUS_UPDATE:
          if (data.isCompleted) {
            notifyLocalPlayerPlaybackEnded();
          }

          break;

        case CHROMECAST_EVENT.PLAYING:
          getReceiverStatus();
          notifyLocalPlayerPlaying();
          break;

        case CHROMECAST_EVENT.PAUSED:
          getReceiverStatus();
          notifyLocalPlayerPaused();
          break;

        case CHROMECAST_EVENT.SEEK:
          // update the playhead so the user sees the timeline change.
          var seekTime = data[1];
          notifyLocalPlayerSeek(seekTime);
          break;

        case CHROMECAST_EVENT.PLAYED:
          notifyLocalPlayerPlaybackEnded();
          break;

        default:
          break;
      }
    };
    /**
     * Relay to the local player that the playhead time has changed on the
     * chromecast
     * @method Chromecast#notifyLocalPlayerPlayheadTimeChanged
     * @private
     * @param  {object} playheadData Object containing all the data associated with a playhead updated.
                                      {
                                        {number} playheadIn       The current playhead of the video(seconds)
                                        {number} durationIn       The duration of the video(seconds)
                                        {number} bufferedTimeIn   (optional)The time(seconds) the video is buffered till
                                        {object} minMaxSeekTimeIn (optional)Object contain the min and max seekable time(seconds) in this video
                                        {string} videoElementIn   (optional)The video element the update is for. Defined in OO.VIDEO
                                      }
     */


    var notifyLocalPlayerPlayheadTimeChanged = function notifyLocalPlayerPlayheadTimeChanged(playheadData) {
      if (_.isNumber(playheadData.playhead) && _.isFinite(playheadData.playhead) && playheadData.playhead >= 0 && _.isNumber(playheadData.duration) && _.isFinite(playheadData.duration) && playheadData.duration > 0) {
        localPlayer.playhead = playheadData.playhead;
        localPlayer.duration = playheadData.duration;
        var bufferedTime = playheadData.bufferedTime || 0;
        var minMaxSeekTime = playheadData.minMaxSeekTime || {
          min: 0,
          max: localPlayer.duration
        };
        var videoElement = playheadData.videoElement || OO.VIDEO.MAIN;
        mb.publish(OO.EVENTS.PLAYHEAD_TIME_CHANGED, localPlayer.playhead, localPlayer.duration, bufferedTime, minMaxSeekTime, videoElement);
      }
    };
    /**
     * Notify the local player that the chromecast has paused.
     * @method Chromecast#notifyLocalPlayerPaused
     * @private
     */


    var notifyLocalPlayerPaused = function notifyLocalPlayerPaused() {
      localPlayer.state = PLAYER_STATE.PAUSED;
      mb.publish(OO.EVENTS.VC_PAUSED, OO.VIDEO.MAIN);
      setNotificationBarStatus(PLAYER_STATE.PAUSED);
    };
    /**
     * Notify the local player that the chromecast is playing.
     * @method Chromecast#notifyLocalPlayerPlaying
     * @private
     */


    var notifyLocalPlayerPlaying = function notifyLocalPlayerPlaying() {
      localPlayer.state = PLAYER_STATE.PLAYING;
      mb.publish(OO.EVENTS.VC_PLAYING, OO.VIDEO.MAIN);
      setNotificationBarStatus(PLAYER_STATE.PLAYING);
    };
    /**
     * Notify the local player that the chromecast is trying to seek.
     * @method Chromecast#notifyLocalPlayerSeek
     * @private
     * @param  {number} time The time in seconds being seeked to
     */


    var notifyLocalPlayerSeek = function notifyLocalPlayerSeek(time) {
      if (_.isNumber(time) && _.isFinite(time) && time >= 0) {
        localPlayer.playhead = time;
        var playheadData = {
          playhead: localPlayer.playhead,
          duration: localPlayer.duration
        };
        mb.publish(OO.EVENTS.SEEKED);
        notifyLocalPlayerPlayheadTimeChanged(playheadData);
      }
    };
    /**
     * Notify the local player that the video has finished playing
     * @method Chromecast#notifyLocalPlayerPlaybackEnded
     * @private
     */


    var notifyLocalPlayerPlaybackEnded = function notifyLocalPlayerPlaybackEnded() {
      localPlayer.state = PLAYER_STATE.END;
      mb.publish(OO.EVENTS.VC_PLAYED, OO.VIDEO.MAIN);
      mb.publish(OO.EVENTS.PLAYED);
    };
    /**
     * Notify the local player that the chromecast mute state has changed.
     * @method Chromecast#notifyLocalPlayerMuteChanged
     * @private
     * @param  {boolean} muted The new mute state
     */


    var notifyLocalPlayerMuteChanged = function notifyLocalPlayerMuteChanged(muted) {
      localPlayer.isMuted = muted;
      mb.publish(OO.EVENTS.MUTE_STATE_CHANGED, muted);
    };
    /**
     * Notify the local player that the chromecast volume has changed.
     * @method Chromecast#notifyLocalPlayerVolumeChanged
     * @private
     * @param  {number} volume The new volume. 0 to 1
     */


    var notifyLocalPlayerVolumeChanged = function notifyLocalPlayerVolumeChanged(volume) {
      localPlayer.volume = volume;
      mb.publish(OO.EVENTS.VOLUME_CHANGED, volume);
    };
    /**
     * Notify the current status of the player to the mobile notification bar.
     * @method Chromecast#setNotificationBarStatus
     * @private
     * @param  {string} status PLAYER_STATE value
     */


    var setNotificationBarStatus = function setNotificationBarStatus(status) {
      if (!notificationBarEnabled) {
        return;
      }

      navigator.mediaSession.playbackState = status;
    };
    /**
     * Callback when the connection status with a chromecast has changed. Can
     * be connected or disconnected. Can be called when chromecast is already
     * connected and you create the player.
     * @method Chromecast#onCastConnectionChanged
     * @private
     * @param  {object} status cast.framework.RemotePlayerChangedEvent with the connection value
     */


    var onCastConnectionChanged = function onCastConnectionChanged(status) {
      if (status.castState === cast.framework.CastState.CONNECTED) {
        onCastingStarted();
        setNotificationControls();
      }

      if (status.castState === cast.framework.CastState.NOT_CONNECTED) {
        onCastingEnded(); // Restore the notification bar to a 'default' state to allow control the media once
        // the castSession ends

        unsetNotificationControls();
      }
    };
    /**
     * Callback which reacts to session state changes.
     * @method Chromecast#onSessionStateChanged
     * @private
     * @param  {object} event cast.framework.SessionStateEventData Data for session state changed event.
     */


    var onSessionStateChanged = function onSessionStateChanged(event) {
      if (event.sessionState === cast.framework.SessionState.SESSION_RESUMED) {
        event.session.sendMessage(OOYALA_NAMESPACE, {
          action: CHROMECAST_ACTION.RECEIVER_STATUS_LOSS
        });
      }
    };
    /**
     * Handle the interaction with notification bars (Android + chrome).
     * @method Chromecast#setNotificationControls
     * @private
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaSession
     */


    var setNotificationControls = function setNotificationControls() {
      // Right now only on android along with chrome the notification bars are supported
      if (!notificationBarEnabled) {
        return;
      }

      if (localPlayer.metadata !== null) {
        navigator.mediaSession.metadata = new window.MediaMetadata({
          title: localPlayer.metadata.title
        });
      }

      navigator.mediaSession.setActionHandler('play', loadOrPlayVideo);
      navigator.mediaSession.setActionHandler('pause', onPause);
    };
    /**
     * Disable the custom action on notification bars (Android + chrome).
     * @method Chromecast#unsetNotificationControls
     * @private
     * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaSession
     */


    var unsetNotificationControls = function unsetNotificationControls() {
      // Right now only on android along with chrome the notification bars are supported
      if (!notificationBarEnabled) {
        return;
      }

      navigator.mediaSession.metadata = null;
      navigator.mediaSession.playbackState = 'none';
      navigator.mediaSession.setActionHandler('play', null);
      navigator.mediaSession.setActionHandler('pause', null);
    };
    /**
     * Callback when the chromecast has changed it's mute state.
     * @method Chromecast#onCastMuteChanged
     * @private
     */


    var onCastMuteChanged = function onCastMuteChanged() {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        notifyLocalPlayerMuteChanged(castSession.isMute());
      }
    };
    /**
     * Callback when the chromecast has changed it's volume.
     * @method Chromecast#onCastVolumeChanged
     * @private
     */


    var onCastVolumeChanged = function onCastVolumeChanged() {
      if (isCasting) {
        var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
        notifyLocalPlayerVolumeChanged(castSession.getVolume());
      }
    };
    /**
     * Sync the chromecast to the state of the local player.
     * @method Chromecast#syncCastPlayerToLocalPlayer
     * @private
     */


    var syncCastPlayerToLocalPlayer = function syncCastPlayerToLocalPlayer() {
      var castSession = cast.framework.CastContext.getInstance().getCurrentSession();
      var mediaSession = castSession.getMediaSession();

      if (mediaSession) {
        if (localPlayer.state === PLAYER_STATE.PLAYING && mediaSession.playerState === chrome.cast.media.PlayerState.PAUSED) {
          // request for the play event. We don't need to store the playRequest since we're not sending any custom data
          mediaSession.play(new chrome.cast.media.PlayRequest(), onPlayRequestSuccess, onPlayRequestError);
        }
      } // Sender needs to reflect the volume of the receiver


      notifyLocalPlayerVolumeChanged(castSession.getVolume());
      notifyLocalPlayerMuteChanged(castSession.isMute());
    };
    /**
     * Sync the local player to the state of the chromecast
     * @method Chromecast#syncLocalPlayerToCastPlayer
     * @private
     */


    var syncLocalPlayerToCastPlayer = function syncLocalPlayerToCastPlayer() {
      switch (localPlayer.state) {
        case PLAYER_STATE.PAUSED:
          mb.publish(OO.EVENTS.SEEK, localPlayer.playhead);
          mb.publish(OO.EVENTS.PAUSE, OO.VIDEO.MAIN);
          break;

        case PLAYER_STATE.PLAYING:
          mb.publish(OO.EVENTS.SEEK, localPlayer.playhead);
          mb.publish(OO.EVENTS.PLAY, OO.VIDEO.MAIN);
          break;

        default:
          // do nothing
          break;
      }
    };
    /**
     * Fetch the status from the receive and trigger any listener on media session.
     * Note. this is to force the mini-controller to update his state for play/pause state
     * @method Chromecast#getReceiverStatus
     * @private
     */


    var getReceiverStatus = function getReceiverStatus() {
      var req = new chrome.cast.media.GetStatusRequest();
      var castSession = cast.framework.CastContext.getInstance().getCurrentSession();

      if (castSession && castSession.getMediaSession()) {
        var mediaSession = castSession.getMediaSession();
        mediaSession.getStatus(req, onReceiverStatus, onStatusError);
      }
    };
    /**
     * Callback when the chromecast return his status.
     * @method Chromecast#onReceiverStatus
     * @private
     */


    var onReceiverStatus = function onReceiverStatus() {
      OO.log(LOG_PREFIX, 'Status done');
    };
    /**
     * Callback when the chromecast status request fails.
     * @method Chromecast#onStatusError
     * @param {String} error - an error msg
     * @private
     */


    var onStatusError = function onStatusError(error) {
      OO.log(LOG_ERROR_PREFIX, 'failed to get status:', error);
    };

    return Chromecast;
  });
}

},{}],72:[function(require,module,exports){
"use strict";

/* eslint no-magic-numbers: "off" */
(function (OO, $, _) {
  var elementResizeDetectorMaker = require('element-resize-detector');
  /*
   *  Defines a basic chromeless UI
   */


  var ChromelessUi = function ChromelessUi(messageBus, id) {
    this.id = id;
    this.mb = messageBus;
    this.width = 0;
    this.height = 0;
    this.useCustomControls = !OO.uiParadigm.match(/mobile/);
    this.useNativeControls = !!OO.uiParadigm.match(/native/);
    this.originalZ = null;
    this.originalOverflow = null;
    this.playbackReady = false;
    OO.StateMachine.create({
      initial: 'Init',
      messageBus: this.mb,
      moduleName: 'ChromelessUi',
      target: this,
      events: [{
        name: OO.EVENTS.PLAYER_CREATED,
        from: 'Init',
        to: 'PlayerCreated'
      }, {
        name: OO.EVENTS.EMBED_CODE_CHANGED,
        from: '*',
        to: 'WaitingPlaybackReady'
      }, {
        name: OO.EVENTS.ASSET_CHANGED,
        from: '*',
        to: 'WaitingPlaybackReady'
      }, {
        name: OO.EVENTS.PLAYBACK_READY,
        from: 'WaitingPlaybackReady',
        to: 'Ready'
      }, {
        name: OO.EVENTS.INITIAL_PLAY,
        from: '*'
      }, {
        name: OO.EVENTS.WILL_PLAY,
        from: ['Ready', 'Paused'],
        to: 'StartingToPlay'
      }, {
        name: OO.EVENTS.PLAYING,
        from: ['StartingToPlay', 'Paused'],
        to: 'Playing'
      }, {
        name: OO.EVENTS.ERROR,
        from: '*'
      }, {
        name: OO.EVENTS.PLAY,
        from: '*'
      }, {
        name: OO.EVENTS.WILL_CHANGE_FULLSCREEN,
        from: '*'
      }, {
        name: OO.EVENTS.FULLSCREEN_CHANGED,
        from: '*'
      }, {
        name: OO.EVENTS.VC_PLAYING,
        from: '*'
      }, {
        name: OO.EVENTS.INITIAL_PLAY,
        from: '*'
      }, {
        name: OO.EVENTS.REPLAY,
        from: '*'
      }, {
        name: OO.EVENTS.WILL_PLAY_ADS,
        from: '*'
      }, {
        name: OO.EVENTS.PLAY_MIDROLL_STREAM,
        from: '*'
      }, {
        name: OO.EVENTS.PLAYING,
        from: '*'
      }]
    });
  };

  _.extend(ChromelessUi.prototype, {
    onInitialPlay: function onInitialPlay() {
      if (!this.playbackReady) {}
    },
    onPlayerCreated: function onPlayerCreated(event, elementId, params) {
      this.elementId = elementId;
      this.topMostElement = $('#' + this.elementId);
      this.topMostElement.append('<div class="innerWrapper" style="width:inherit; height:inherit"></div>');
      this.rootElement = this.topMostElement.find('div.innerWrapper');
      this.params = params; // plugins placeholder

      this.rootElement.append('<div class="plugins" style="position: absolute; width: 100%; height: 100%;"></div>'); // bind UI events.

      var fullscreenEvents = ['fullscreenchange', 'webkitfullscreenchange'];

      var onBrowserOriginatedFullscreenChange = _.bind(this._onBrowserOriginatedFullscreenChange, this);

      var rootElement = this.rootElement;

      _.each(fullscreenEvents, function (event) {
        rootElement.on(event, onBrowserOriginatedFullscreenChange);
      }); // https://developer.mozilla.org/en/DOM/Using_full-screen_mode
      // Mozilla is dispatching the fullscreen event to the document object instead of the dom object that
      // change to full screen.
      // TODO, keep an eye on the doc if they change the notification to the dom element instead.


      $(document).on('mozfullscreenchange', onBrowserOriginatedFullscreenChange);
      document.onwebkitfullscreenchange = onBrowserOriginatedFullscreenChange;
      $(document).on('MSFullscreenChange', onBrowserOriginatedFullscreenChange); // $(document).on("webkitfullscreenchange", onBrowserOriginatedFullscreenChange);

      $(window).resize(_.bind(this._onResize, this)); // Using library from: https://www.npmjs.com/package/element-resize-detector

      var erd = elementResizeDetectorMaker({
        strategy: 'scroll'
      });
      erd.listenTo(rootElement[0], this._onResize.bind(this)); // BeforeUnload Event

      $(window).on('beforeunload', _.bind(this._onBeforeUnload, this));
      this.mb.publish(OO.EVENTS.PLAYER_EMBEDDED, {
        videoWrapperClass: 'innerWrapper',
        pluginsClass: 'plugins'
      });
    },
    onEmbedCodeChanged: function onEmbedCodeChanged() {
      this._assetChanged();
    },
    onAssetChanged: function onAssetChanged() {
      this._assetChanged();
    },
    _assetChanged: function _assetChanged() {
      this.playbackReady = false;
    },
    onPlaybackReady: function onPlaybackReady(event, playbackPackage) {
      this.playbackReady = true;
    },
    _isFullscreen: function _isFullscreen() {
      if (this.rootElement.hasClass('fullscreen')) {
        return true;
      }

      var isFullscreen = document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen || document.webkitDisplayingFullscreen || document.msFullscreenElement;
      return !!isFullscreen;
    },
    _onBrowserOriginatedFullscreenChange: function _onBrowserOriginatedFullscreenChange() {
      OO.debug('Fullscreen Changed', this._isFullscreen());
      this.mb.publish(OO.EVENTS.SIZE_CHANGED, this.rootElement.innerWidth(), this.rootElement.innerHeight());
      this.mb.publish(OO.EVENTS.FULLSCREEN_CHANGED, this._isFullscreen());
    },
    onFullscreenChanged: function onFullscreenChanged(event, isFullscreen) {
      if (isFullscreen && !this.originalZ && !this.originalOverflow) {
        // increase the z-index of the player before going to fullscreen, to make sure it won't be behind other players
        // some browsers unfortunately show through elements with higher z-index even when in fullscreen mode
        this.originalZ = this.rootElement.css('z-index');
        this.originalOverflow = this.rootElement.css('overflow');
        this.rootElement.css('z-index', this.originalZ + 1000);
        this.rootElement.css('overflow', 'visible');
      } else if (!isFullscreen) {
        // reset the z-index of the player before exiting fullscreen, to make sure it is back to same level as other players
        // some browsers unfortunately show through elements with higher z-index even when in fullscreen mode
        this.rootElement.css('z-index', '');
        this.rootElement.css('overflow', this.originalOverflow);
        this.originalZ = null;
        this.originalOverflow = null;
      }
    },
    _onResize: function _onResize() {
      if (this.width !== this.rootElement.innerWidth() || this.height !== this.rootElement.innerHeight()) {
        this.width = this.rootElement.innerWidth();
        this.height = this.rootElement.innerHeight();
        this.mb.publish(OO.EVENTS.SIZE_CHANGED, this.width, this.height);
      }
    },
    onPlay: function onPlay() {
      if (!this.useCustomControls && !this.useNativeControls) {
        this.mb.publish(OO.EVENTS.WILL_CHANGE_FULLSCREEN, true);
      }
    },
    onWillChangeFullscreen: function onWillChangeFullscreen(event, shouldEnterFullscreen) {
      if (!this.useNativeControls && !this.useCustomControls) {
        return;
      }

      if (shouldEnterFullscreen) {
        this._showFullscreen();
      } else {
        this._hideFullscreen();
      }
    },
    _getActiveVideo: function _getActiveVideo() {
      var mainVideo = this.rootElement.find('video.video');
      var activeVideo = mainVideo.get(0);
      var pluginVideo = this.rootElement.find('div.plugins video').get(0);

      if (pluginVideo && !this._isVideoDomVisible('video.video')) {
        activeVideo = pluginVideo;
      }

      return activeVideo;
    },
    _showFullscreen: function _showFullscreen() {
      var el = this.rootElement[0];

      var activeVideo = this._getActiveVideo();

      var fullscreenApi = el.requestFullScreen || el.requestFullscreen || el.mozRequestFullScreen || el.webkitRequestFullScreen || el.msRequestFullscreen;

      if ((!fullscreenApi || OO.isAndroid && !OO.isChrome) && activeVideo && activeVideo.webkitEnterFullscreen) {
        // this uglyness is cause mobile chrome on android claims to support full screen on divs (next method), but doesn't actually work
        // however we still prefer to use div fullscreen on anything else so we only try this if android is detected
        // update: Chrome on Android looks to properly support the fullscreen API for divs, so now we check
        // specifically for the native browser which still does not.
        activeVideo.isFullScreenMode = true;
        activeVideo.webkitEnterFullscreen();
      } else if (fullscreenApi) {
        $(activeVideo).css('background-color', 'black');
        fullscreenApi.call(el);
      } else {
        this.rootElement.addClass('fullscreen');
      }

      this.mb.publish(OO.EVENTS.FULLSCREEN_CHANGED, true);
    },
    _hideFullscreen: function _hideFullscreen() {
      var activeVideo = this._getActiveVideo();

      if (document.cancelFullScreen) {
        document.cancelFullScreen();
      } else if (document.mozCancelFullScreen) {
        document.mozCancelFullScreen();
      } else if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      } else if (activeVideo && activeVideo.webkitExitFullscreen) {
        activeVideo.isFullScreenMode = false;
        activeVideo.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      } else {
        this.rootElement.removeClass('fullscreen');
      }

      $(activeVideo).css('background-color', '');
      this.mb.publish(OO.EVENTS.FULLSCREEN_CHANGED, false);
    },
    _isVideoDomVisible: function _isVideoDomVisible(domSelector) {
      return this.rootElement.find(domSelector).css('display') === OO.CSS.VISIBLE_DISPLAY;
    },
    _onBeforeUnload: function _onBeforeUnload(event) {
      // A still user-cancellable page unload request has been made.
      this.mb.publish(OO.EVENTS.PAGE_UNLOAD_REQUESTED, true);
    },
    __placeholder: true
  });

  OO.registerModule('chromeless_ui', function (messageBus, id) {
    return new ChromelessUi(messageBus, id);
  });
})(OO, OO.$, OO._);

},{"element-resize-detector":27}],73:[function(require,module,exports){
"use strict";

/* eslint no-magic-numbers: "off" */
(function (OO, _, $) {
  var callbackQueue = [];
  var guidHasBeenSet = false;
  /**
   * Initializes the OO.GUID property depending on the analytics tracking level
   * that is currently configured.
   * @method DeviceId#init
   * @private
   */

  var init = function init() {
    switch (OO.trackingLevel) {
      case OO.TRACKING_LEVEL.DISABLED:
        // Make sure GUID is not available in OO namespace. Note: Any existing
        // local storage GUIDs are preserved (but not used)
        delete OO.GUID;
        notifyGetGuidSubscribers();
        break;

      case OO.TRACKING_LEVEL.ANONYMOUS:
        // Generate a new GUID on each session and store it in memory only. Note:
        // Any existing local storage GUIDs are preserved (but not used)
        OO.GUID = generateDeviceId();
        notifyGetGuidSubscribers();
        break;

      case OO.TRACKING_LEVEL.DEFAULT:
      default:
        // Full tracking enabled, create GUID or load from local storage if it
        // already exists
        loadOrCreateGuid(notifyGetGuidSubscribers);
        break;
    }
  };
  /**
   * Sets the OO.GUID value from local storage or creates a new GUID if doesn't
   * currently exist. If a new GUID is created, it will be copied to local storage.
   * @param {function} callback A callback to execute when the operation is complete
   * @method DeviceId#loadOrCreateGuid
   * @private
   */


  var loadOrCreateGuid = function loadOrCreateGuid(callback) {
    OO.ooyalaStorage.getItem(OO.CONSTANTS.GUID_STORAGE_KEY, function (value) {
      if (value) {
        OO.GUID = value;
      } else {
        OO.GUID = generateDeviceId();
        OO.ooyalaStorage.setItem(OO.CONSTANTS.GUID_STORAGE_KEY, OO.GUID);
      }

      if (_.isFunction(callback)) {
        callback();
      }
    });
  };
  /**
   * Executes all the callbacks registered by OO.getGuid(). This should be called
   * when the value of OO.GUID has been updated.
   * @method DeviceId#notifyGetGuidSubscribers
   * @private
   */


  var notifyGetGuidSubscribers = function notifyGetGuidSubscribers() {
    guidHasBeenSet = true;
    var callback = callbackQueue.shift();

    while (callback) {
      if (_.isFunction(callback)) {
        callback(OO.GUID);
      }

      callback = callbackQueue.shift();
    }
  };

  OO.publicApi.getGuid = OO.getGuid = function (callback) {
    if (guidHasBeenSet) {
      if (typeof callback === 'function') {
        try {
          callback(OO.GUID);
        } catch (error) {// do nothing on error
        }
      }
    } else {
      callbackQueue.push(callback);
    }
  };
  /**
   * Generates a new random GUID based on the current timestamp and user agent.
   * @method DeviceId#generateDeviceId
   * @private
   * @returns {string} A string with a new GUID
   */


  var generateDeviceId = function generateDeviceId() {
    var randomString = new Date().getTime() + window.navigator.userAgent + Math.random().toString(16).split('.')[1];
    return new OO.jsSHA(randomString, 'ASCII').getHash('SHA-256', 'B64'); // eslint-disable-line new-cap
  };

  OO.plugin('DeviceId', function (OO, _, $, Window) {
    return function (mb, id) {
      mb.subscribe(OO.EVENTS.PLAYER_CREATED, 'DeviceId', function () {
        OO.publicApi.getGuid(function (guid) {
          mb.publish(OO.EVENTS.GUID_SET, guid);
        });
      });
    };
  });
  init();
})(OO, OO._, OO.$);

},{}],74:[function(require,module,exports){
"use strict";

OO.plugin('ExternalId', function (OO, _, $, Window) {
  /*
   * Channel Module:  Intercept all CONTENT_TREE_FETCHED events.
   *   If the player is a flash player, and ExternalId are enabled, play the flash player v2 style
   *   If the player is a flash player, and ExternalId are disabled, publish an error
   *   If the player is html5 and ExternalId are enabled, play the first video of the channel
   *   If the player is html5 and ExternalId are disabled, publish an error
   */
  var ExternalId = function ExternalId(mb, id) {
    this.id = id;
    this.mb = mb;
    this.mb.intercept(OO.EVENTS.SET_EMBED_CODE, 'ExternalId', _.bind(this._checkExternalId, this));
  };

  _.extend(ExternalId.prototype, {
    /*
     *  External ID lookup
     */
    _checkExternalId: function _checkExternalId(event, embedCode, options, isExternalApiCall) {
      var externalId = embedCode.match('^extId:(.*)');

      if (externalId && externalId[1]) {
        this.externalId = externalId[1];
        this.options = options || {};
        this.isExternalApiCall = isExternalApiCall;

        this._fetchExternalId({
          externalId: this.externalId,
          pcode: OO.playerParams.pcode || '1kNG061cgaoolOncv54OAO1ceO-I',
          server: OO.SERVER.API
        });

        return false;
      }

      return [embedCode, options, isExternalApiCall];
    },
    _fetchExternalId: function _fetchExternalId(request) {
      this._contentAjax = $.ajax({
        url: OO.URLS.EXTERNAL_ID(request),
        type: 'GET',
        dataType: 'json',
        crossDomain: true,
        cache: false,
        success: _.bind(this._onExternalIdFetched, this),
        error: _.bind(this._onExternalIdError, this)
      });
    },
    _onExternalIdFetched: function _onExternalIdFetched(response) {
      var embedCode = null;
      var safeResponse = OO.HM.safeObject('playbackControl.contentTree', response, {});

      if (safeResponse.errors && +safeResponse.errors.code === 0) {
        _.each(safeResponse.content_tree, _.bind(function (value, ec) {
          if (value['external_id'] === this.externalId) {
            embedCode = ec;
          }
        }, this));
      } // save the external Id in the option hash (in case it's needed for analytics and such)


      _.extend(this.options, {
        'originalId': this.externalId
      });

      if (embedCode) {
        this.mb.publish(OO.EVENTS.SET_EMBED_CODE, embedCode, this.options, this.isExternalApiCall);
      } else {
        this.mb.publish(OO.EVENTS.ERROR, {
          code: OO.ERROR.INVALID_EXTERNAL_ID
        });
      }
    },
    _onExternalIdError: function _onExternalIdError(response) {
      this.mb.publish(OO.EVENTS.ERROR, {
        code: OO.ERROR.INVALID_EXTERNAL_ID
      });
    }
  }); // Return class definition.


  return ExternalId;
});

},{}],75:[function(require,module,exports){
"use strict";

/* eslint no-magic-numbers: "off" */

/**
 * HAFailoverMechanism
 * Plugin that designed to handle failure scenario for HA (High Availability) enabled live channels.
 * If stream failure is detected, it will initiate a reload of the manifest.
 * @fires OO.EVENTS.HA_WILL_FAILOVER
 * @fires OO.EVENTS.HA_FAILOVER_COMPLETE
 * @fires OO.EVENTS.VC_RELOAD_AND_PLAY
 * @fires OO.EVENTS.HA_FAILOVER_ERROR
 */
OO.plugin('HAFailoverMechanism', function (OO, _, $) {
  var log = function log() {
    OO.log.apply(this, $.merge(['HAFailoverMechanism:'], arguments));
  };

  var dummy = {
    feed: function feed() {},
    feedSegments: function feedSegments() {},
    updateConfig: function updateConfig() {},
    isEnabled: function isEnabled() {
      return false;
    },
    isDummy: true
  };
  /**
   * @class HAFailoverMechanism
   * @param {object} mb Message Bus
   * @returns {object} Return instance of itself. In case if setup was wrong return dummy placeholder.
   *
   * @public
   */

  var HAFailoverMechanism = function HAFailoverMechanism(mb) {
    if (!mb) {
      log('Wrong configuration. Returning dummy object', mb, dummy);
      OO.exposeStaticApi('ha', dummy);
      return dummy;
    }

    var _this = this;

    var config = {};
    var DEFAULT_CONFIG = Object.freeze({
      failRatio: 0.4,
      maxSegmentsToCheck: 20,
      segmentsBuffered: 3,
      timeoutCheckFrequencyMs: 500,
      manifestFailureTimeoutMs: 3 * 1000,
      failoverErrorTimeoutMs: 6 * 1000,
      plugin: 'bit-wrapper'
    }); // constants

    _this.CONSTANTS = Object.freeze({
      HA_ASSET_FLAG: 'ha_enabled',
      HA_IGNORE_MAX_FLAG: 'ha_ignore_max_timeout',
      DEFAULT_SEGMENT_LENGTH: 4,
      PROXY_REFRESH_TIME: 6
    }); // it is turned off by default

    var enabled = false;
    var ignoreMax = false;
    var failingOver = false;
    var bitrates = [];
    var currentBitrateID = '';
    var initialPlay = false;
    var segmentsInfo = [];
    var startTime = null;
    var avgSegmentLength = config.segmentLength || 0;
    var segmentsChecked = 0;
    var bitratesFailed = {};
    var bitratesFailedCount = 0;
    var topLevelManifestFailure = false;
    var paused = false;
    var dvrPosition = 0;
    var dvrLength = 0;
    var pauseStartTime = 0;
    var currentTime = 0;
    var bufferedTime = 0;
    var lastTimeDownload = 0;
    var workerInterval = null;

    if (OO.TEST_TEST_TEST) {
      _this.failover = failover;
      _this.reset = reset;
      _this.isEnabled = isEnabled;
      _this.feed = feed;
      _this.feedSegments = feedSegments;
      _this._getTimeoutTimeMs = _getTimeoutTimeMs;
      _this._getSegmentLength = _.bind(_getSegmentLength, this);
      _this._updateAvgSegmentLength = _.bind(_updateAvgSegmentLength, this);
      _this.pluginSupportsNativeEventsOnly = _.bind(pluginSupportsNativeEventsOnly, this);
    }

    initialize();
    /**
     * @method HAFailoverMechanism#initialize
     * @description Subscribing to mb events and building config, creating worker
     */

    function initialize() {
      config = buildConfig(config); // events subscribe

      mb.subscribe(OO.EVENTS.INITIAL_PLAY, 'HAFailoverMechanism', _onInitialPlay);
      mb.subscribe(OO.EVENTS.HA_FAILOVER_NOW, 'HAFailoverMechanism', _onHaFailoverNow);
      mb.subscribe(OO.EVENTS.HA_CONFIG_UPDATE, 'HAFailoverMechanism', _onHaUpdateConfig);
      mb.subscribe(OO.EVENTS.HA_NOTIFY, 'HAFailoverMechanism', _onHaNotify);
      mb.subscribe(OO.EVENTS.BITRATE_CHANGED, 'HAFailoverMechanism', _onBitrateChanged);
      mb.subscribe(OO.EVENTS.BITRATE_INFO_AVAILABLE, 'HAFailoverMechanism', _onBitrateInfoAvailable);
      mb.subscribe(OO.EVENTS.ASSET_CHANGED, 'HAFailoverMechanism', _onAssetChanged);
      mb.subscribe(OO.EVENTS.METADATA_FETCHED, 'HAFailoverMechanism', _onMetadataFetched);
      mb.subscribe(OO.EVENTS.DESTROY, 'HAFailoverMechanism', destroy);
      mb.subscribe(OO.EVENTS.DOWNLOADING, 'HAFailoverMechanism', _onDownloading);
      mb.subscribe(OO.EVENTS.PAUSED, 'HAFailoverMechanism', _onPaused);
      mb.subscribe(OO.EVENTS.PLAY, 'HAFailoverMechanism', _onPlay);
      mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, 'HAFailoverMechanism', _onPlayheadTimeChanged);
      log('initialization completed', config);
    }
    /**
     * @method HAFailoverMechanism#_onInitialPlay
     * @description Callback function for OO.EVENTS.INITIAL_PLAY
     * @param  {string} event Event name
     * @private
     */


    function _onInitialPlay(event) {
      initialPlay = true;
    }
    /**
     * @method HAFailoverMechanism#_onHaFailoverNow
     * @description Callback function for OO.EVENTS.HA_FAILOVER_NOW
     * @param  {string} event Event name
     * @private
     */


    function _onHaFailoverNow(event) {
      log('Failover due to event', event);
      failover();
    }
    /**
     * @method HAFailoverMechanism#_onBitrateChanged
     * @description Callback for OO.EVENTS.BITRATE_CHANGED
     * @param  {string} event Event name
     * @param  {object} data  Bitrate data
     * @private
     */


    function _onBitrateChanged(event, data) {
      if (!data) {
        return;
      }

      currentBitrateID = data.id || ''; // debug

      log('_onBitrateChanged', event, data);
    }
    /**
     * @method HAFailoverMechanism#_onBitrateInfoAvailable
     * @description Callback for OO.EVENTS.BITRATE_INFO_AVAILABLE
     * @param  {string} event Event name
     * @param  {object} data  Bitrates data.
     * @private
     */


    function _onBitrateInfoAvailable(event, data) {
      if (!data) {
        return;
      }

      bitrates = data.bitrates || []; // debug

      log('_onBitrateInfoAvailable', event, data);
    }
    /**
     * @method HAFailoverMechanism#_onAssetChanged
     * @description Fired by the message bus when a new Standalone Player asset is set.
     * @private
     * @param {String} event The event name.
     * @param {Object} asset The OSP asset json that was passed to setAsset().
     * @param {Object} params The page-level parameters associated with the new asset.
     */


    function _onAssetChanged(event, asset, params) {
      var haConfig = asset && asset.highAvailability || {}; // We extract the HA config values and mimic the METADATA_FETCHED data structure in
      // order to process these with the same code path

      var metadata = {
        base: {}
      };

      if (typeof haConfig.enabled !== 'undefined') {
        metadata.base[_this.CONSTANTS.HA_ASSET_FLAG] = _parseBoolStringProperty(haConfig.enabled);
      }

      if (typeof haConfig.ignoreMaxTimeout !== 'undefined') {
        metadata.base[_this.CONSTANTS.HA_IGNORE_MAX_FLAG] = _parseBoolStringProperty(haConfig.ignoreMaxTimeout);
      }

      _processMetadata(event, metadata);
    }
    /**
     * @method HAFailoverMechanism#parseBoolStringProperty
     * @description Used as a workaround in order to mimic some of the metadata values passed by the backend,
     * which are boolean but are provided as strings. For consistency with the rest of the
     * code, we convert the boolean values provided in the asset json to string.
     * @private
     * @param {*} property A property usually taken from the asset json (Stand Alone Player) which we want to convert to the format used by the backend.
     * @returns {String} The string representation of a boolean (either 'true' or 'false'). Note:
     * always returns 'false' when the property is falsy.
     */


    function _parseBoolStringProperty(property) {
      if (!property) {
        return 'false';
      }

      if (property === true || property === 'true') {
        return 'true';
      } else {
        // Default to false any values that can't be recognized as true
        return 'false';
      }
    }
    /**
     * @method HAFailoverMechanism#_onMetadataFetched
     * @description Callback for OO.EVENTS.METADATA_FETCHED
     * @param  {string} event Event name
     * @param  {object} data  Metadata object.
     * @fires OO.EVENTS.HA_ENABLED
     * @private
     */


    function _onMetadataFetched(event, data) {
      _processMetadata(event, data);
    }
    /**
     * @method HAFailoverMechanism#_processMetadata
     * @description Called after either OO.EVENTS.METADATA_FETCHED or OO.EVENTS.ASSET_CHANGED in order to
     * apply the external HA config values.
     * @private
     * @param {event} event The object of event with which data arrived
     * @param {Object} data The metadata object from the OO.EVENTS.METADATA_FETCHED or a similarly
     * formatted object constructed from the values from the asset json passed in OO.EVENTS.ASSET_CHANGED.
     */


    function _processMetadata(event, data) {
      if (!data) {
        return;
      } // every time metadata fetched we need to reset


      reset();
      var haEnabledAsset = data.base ? data.base[_this.CONSTANTS.HA_ASSET_FLAG] || '' : '';
      enabled = String(haEnabledAsset).toLowerCase() === 'true'; // this flag is useful if customer need Live Low Latency and Live HA

      var ignoreMaxAttrValue = data.base ? data.base[_this.CONSTANTS.HA_IGNORE_MAX_FLAG] || '' : '';
      ignoreMax = String(ignoreMaxAttrValue).toLowerCase() === 'true';
      clearInterval(workerInterval);

      if (enabled) {
        workerInterval = setInterval(timeoutCheck, config.timeoutCheckFrequencyMs);
      }

      mb.publish(OO.EVENTS.HA_ENABLED, enabled); // debug

      log('_onMetadataFetched', event, data);
    }
    /**
     * @method HAFailoverMechanism#_onVcWillPlay
     * @description Callback for OO.EVENTS.VC_WILL_PLAY
     * @private
     * @fires OO.EVENTS.HA_FAILOVER_COMPLETE
     */


    function _onVcWillPlay() {
      if (failingOver) {
        failingOver = false;
        mb.publish(OO.EVENTS.HA_FAILOVER_COMPLETE);
      }

      mb.unsubscribe(OO.EVENTS.VC_WILL_PLAY, 'HAFailoverMechanism');
    }
    /**
     * @method HAFailoverMechanism#_onDownloading
     * @description Callback for OO.EVENTS.DOWNLOADING
     * @param {string} event Event name
     * @param {number} currentTimeArg Current time in seconds
     * @param {number} duration Current duration
     * @param {number} bufferedTimeArg Time buffered in seconds
     * @private
     */


    function _onDownloading(event, currentTimeArg, duration, bufferedTimeArg) {
      if (!isEnabled()) {
        return;
      }

      if (!pluginSupportsNativeEventsOnly()) {
        return;
      }

      if (!initialPlay) {
        return;
      }

      if (segmentsChecked >= config.maxSegmentsToCheck) {
        return;
      }

      var timeNow = _nowTimestamp();

      bufferedTime = bufferedTimeArg;
      lastTimeDownload = timeNow;
    }
    /**
     * @method HAFailoverMechanism#_onPaused
     * @description Callback for OO.EVENTS.PAUSED
     * @param {string} event Event name
     * @private
     */


    function _onPaused(event) {
      paused = true;
      pauseStartTime = _nowTimestamp();
    }
    /**
     * @method HAFailoverMechanism#_onPlay
     * @description Callback for OO.EVENTS.PLAY
     * @param {string} event Event name
     * @private
     */


    function _onPlay(event) {
      var pauseTime = _getTimeSincePause();

      var checkTime = currentTime + pauseTime;

      if (dvrPosition - pauseTime < 0) {
        checkTime += dvrLength - dvrPosition;
      }

      if (pluginSupportsNativeEventsOnly()) {
        if (_checkForBufferingIssues(checkTime)) {
          log('failover due to buffering issues after resume');
          failover();
          return;
        }
      }

      paused = false;
      pauseStartTime = 0;
    }
    /**
     * @method HAFailoverMechanism#_onPlayheadTimeChanged
     * @description Callback for OO.EVENTS.PLAYHEAD_TIME_CHANGED
     * @param {string} event Event name
     * @param {number} currentTimeArg  Current time in seconds
     * @param {number} duration Current duration
     * @param {number} bufferedTimeAgr Time buffered in seconds
     * @param {object} seeked Seek range
     * @param {string} videoId Id of the currently playing video element
     * @param {number} liveTime Current live time in seconds
     * @private
     */


    function _onPlayheadTimeChanged(event, currentTimeArg, duration, bufferedTimeAgr, seeked, videoId, liveTime) {
      if (!isEnabled()) {
        return;
      }

      if (!pluginSupportsNativeEventsOnly()) {
        return;
      }

      currentTime = liveTime;
      dvrLength = duration;
      dvrPosition = currentTimeArg;
    }
    /**
     * @method HAFailoverMechanism#_onHaUpdateConfig
     * @description Callback for OO.EVENTS.HA_CONFIG_UPDATE. Updates current config.
     * @param  {string} event Event name
     * @param  {object} newConfig New config that will be merged with existed. It will override fields.
     *
     * @fires OO.EVENTS.HA_CONFIG_UPDATED
     * @private
     */


    function _onHaUpdateConfig(event, newConfig) {
      config = buildConfig(newConfig || {});
      log('Config updated', config);
      mb.publish(OO.EVENTS.HA_CONFIG_UPDATED, config);
    }
    /**
     * @method HAFailoverMechanism#_onHaNotify
     * @description Callback for OO.EVENTS.HA_NOTIFY. Pass over data to appropriate functions
     * @param  {string} event Event name
     * @param  {string} type of data
     * @param  {object} data that needs to be processed
     *
     * @private
     */


    function _onHaNotify(event, type, data) {
      switch (type) {
        case 'requestCompleted':
          feed(data);
          break;

        case 'segmentLoaded':
          feedSegments(data);
          break;

        default:
          break;
      }
    }
    /**
     * @method HAFailoverMechanism#buildConfig
     * @description Updating config with fields from default config.
     * @param  {object} configuration Config that needs to be modified and updated with default data.
     * @returns {object}               Returns back updated config
     * @public
     */


    function buildConfig(configuration) {
      var _config = $.extend($.extend({}, DEFAULT_CONFIG), configuration);

      if (!_config.segmentLength) {
        _config.maxSegmentsToCheck = _config.maxSegmentsToCheck || DEFAULT_CONFIG.maxSegmentsToCheck;
      } else {
        _config.maxSegmentsToCheck = -1;
      }

      return _config;
    }
    /**
     * @method HAFailoverMechanism#_nowTimestamp
     * @description Returns current UTC timestamp
     * @returns {number} current date in ms /amount of milliseconds (from midnight January 1, 1970 UTC).
     * @example 1504642484388
     *
     * @private
     */


    function _nowTimestamp() {
      return new Date().valueOf();
    }
    /**
     * @method HAFailoverMechanism#_getSegmentLength
     * @description Return average segments length in seconds
     * @returns {number} avgSegmentLength if avgSegmentLength is defined, otherwise default length for segment
     * @example 10
     *
     * @private
     */


    function _getSegmentLength() {
      return avgSegmentLength || _this.CONSTANTS.DEFAULT_SEGMENT_LENGTH;
    }
    /**
     * @method HAFailoverMechanism#_getTimeoutTimeMs
     * @description Returns timeout time in ms based on segments length
     * @returns {number} Greater value between the buffering time and
     * the segment length (taking into the buffering time)
     * @example 6000
     *
     * @private
     */


    function _getTimeoutTimeMs() {
      var timeoutMs = _getSegmentLength() * config.segmentsBuffered * 1000 / 2;

      if (ignoreMax) {
        return timeoutMs;
      }

      return Math.max(timeoutMs, _this.CONSTANTS.PROXY_REFRESH_TIME * 1000);
    }
    /**
     * @method HAFailoverMechanism#_getPlaybackURL
     * @description Returns playback url from a streams for current encoding
     * @returns {string} playback URL or empty string
     *
     * @private
     */


    function _getPlaybackURL() {
      return config.streams && config.chosenEncoding && config.streams[config.chosenEncoding] && (config.streams[config.chosenEncoding].url || '') || '';
    }
    /**
     * @method HAFailoverMechanism#isEnabled
     * @description Returns true if HAFailoverMechanism enabled and setup correctly.
     * @returns {Boolean} true if an enabled and valid video will be playing, otherwise false
     *
     * @private
     */


    function isEnabled() {
      return initialPlay && enabled && valid();
    }
    /**
     * @method HAFailoverMechanism#pluginSupportSegmentsData
     * @description Returns true if current plugin bit-wrapper.
     * @returns {Boolean} true if the plugin is bitwrapper, otherwise false
     *
     * @private
     */


    function pluginSupportSegmentsData() {
      return config.plugin === 'bit-wrapper';
    }
    /**
     * @method HAFailoverMechanism#pluginSupportSegmentsData
     * @description Returns true if current plugin ooyalaHtml5VideoTech.
     * @returns {Boolean} true if the plugin is html5, otherwise false
     *
     * @private
     */


    function pluginSupportsNativeEventsOnly() {
      return config.plugin === 'ooyalaHtml5VideoTech';
    }
    /**
     * @method HAFailoverMechanism#feed
     * @description Feed download info. Based on that info HAFailoverMechanism will detect
     * failures and initiate failover if it is required.
     * @param  {object} data Download info
     * @returns {boolean} Returns true if data was accepted and processed
     *
     * @public
     */


    function feed(data) {
      if (!data || !data.downloadType) {
        log('invalid data provided to feed method', data);
        return false;
      }

      if (!isEnabled() || !pluginSupportSegmentsData()) {
        log('disabled feed ignored');
        return false;
      } // collect only data that indicate failures


      if (!data.success && data.attempt > 0) {
        segmentsInfo.push(data);

        if (!startTime) {
          startTime = _nowTimestamp();
        }

        log('data type is ', data.downloadType);
      } else {
        // if sequence interacted by success data, reset.
        reset();
      }

      processCollectedData();
      checkProcessedData();
      return true;
    }
    /**
     * @method HAFailoverMechanism#failover
     * @description Trigger failover manually. Can be triggered by firing OO.EVENTS.HA_FAILOVER_NOW
     *
     * @fires OO.EVENTS.HA_WILL_FAILOVER
     * @fires OO.EVENTS.VC_RELOAD_AND_PLAY
     * @fires OO.EVENTS.HA_FAILOVER_ERROR
     *
     * @public
     */


    function failover() {
      if (!isEnabled()) {
        log('disabled. failover ignored');
        log(initialPlay, enabled, valid());
        return;
      }

      if (failingOver) {
        log('video stream is in a process of fail over');
        return;
      }

      mb.publish(OO.EVENTS.HA_WILL_FAILOVER);
      log('trying to failover');
      failingOver = true;
      mb.subscribe(OO.EVENTS.VC_WILL_PLAY, 'HAFailoverMechanism', _onVcWillPlay);
      mb.publish(OO.EVENTS.VC_RELOAD_AND_PLAY, config.streams || {});
      log('failover initiated');
      setTimeout(function () {
        if (failingOver) {
          mb.publish(OO.EVENTS.HA_FAILOVER_ERROR);
          failingOver = false;
        }
      }, config.failoverErrorTimeoutMs);
      reset(true);
    }
    /**
     * @method HAFailoverMechanism#feedSegments
     * @description Feed HAFailoverMechanism with segments info, so it can calculate more accurate timeout for failover
     * This is optional by default. The algorithm will count the segment duration as 4 seconds
     * @param  {object} data Loaded segments info
     *
     * @optional
     * @public
     */


    function feedSegments(data) {
      if (!data || !data.duration) {
        log('invalid data provided to feedSegments method', data);
        return;
      }

      if (config.maxSegmentsToCheck === -1) {
        log('segments check disabled');
        return;
      }

      if (!pluginSupportSegmentsData()) {
        log('segments check disabled due to unsupported plugin', config.plugin);
        return;
      }

      if (segmentsChecked > config.maxSegmentsToCheck) {
        return;
      }

      if (data.duration) {
        var duration = parseFloat(data.duration);

        if (duration) {
          _updateAvgSegmentLength(duration);
        }
      }

      log('Average segments length', avgSegmentLength);
    }

    ;
    /**
     * @method HAFailoverMechanism#_updateAvgSegmentLength
     * @description Update the calculated average of the segment lengths that have been played so far.
     * Result is stored in avgSegmentLength.
     * @param  {number} newSegmentLength Segment length in seconds.
     *
     * @private
     */

    function _updateAvgSegmentLength(newSegmentLength) {
      if (segmentsChecked >= 0) {
        avgSegmentLength = (avgSegmentLength * segmentsChecked + newSegmentLength) / (segmentsChecked + 1);
        segmentsChecked++;
      }
    }
    /**
     * @method HAFailoverMechanism#destroy
     * @description Unsubscribe from all events, reset data, stop worker
     *
     * @private
     */


    function destroy() {
      reset(true);
      mb.unsubscribe(OO.EVENTS.INITIAL_PLAY, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.BITRATE_CHANGED, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.BITRATE_INFO_AVAILABLE, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.ASSET_CHANGED, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.METADATA_FETCHED, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.VC_WILL_PLAY, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.DESTROY, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.DOWNLOADING, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.DOWNLOADING, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.HA_FAILOVER_NOW, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.HA_CONFIG_UPDATE, 'HAFailoverMechanism');
      mb.unsubscribe(OO.EVENTS.HA_NOTIFY, 'HAFailoverMechanism');
      clearInterval(workerInterval);
      log('destroy');
    }
    /**
     * Check if a config includes a stream
     * @method HAFailoverMechanism#valid
     * @description Returns true if config contains required data for failover
     * @returns {boolean} true if a config includes a stream, otherwise false
     *
     * @private
     */


    function valid() {
      return !!config.streams;
    }
    /**
     * @method HAFailoverMechanism#processCollectedData
     * @description Processing collected data
     *
     * @private
     */


    function processCollectedData() {
      if (!segmentsInfo.length || !isEnabled()) {
        return;
      }

      var item = segmentsInfo[segmentsInfo.length - 1];
      topLevelManifestFailure = item.downloadType === 'manifest' && item.url === _getPlaybackURL();

      if (!topLevelManifestFailure && item.attempt >= 2 && !bitratesFailed[currentBitrateID]) {
        bitratesFailedCount++;
        bitratesFailed[currentBitrateID] = true;
        log('Bitrate failure', currentBitrateID);
      }
    }
    /**
     * Check results of collected and processed data.
     * Can trigger failover if failures detected
     * @method HAFailoverMechanism#checkProcessedData
     * @private
     */


    function checkProcessedData() {
      if (!isEnabled()) {
        return;
      }

      if (bitrates.length > 0 && bitratesFailedCount >= Math.round(bitrates.length * config.failRatio)) {
        log('failover due to check of bitrates', bitratesFailedCount);
        failover();
      }
    }
    /**
     * @method HAFailoverMechanism#reset
     * @description Resets information to it's origin values. Perfect to use after failures recovers on it's own.
     * Recommended to use hard reset after failover.
     * Hard reset will reset everything to pure origin state
     * Soft reset is reseting data that was recently processed.
     * @param  {boolean} hard True if you want to do hard reset of the plugin
     *
     * @private
     */


    function reset(hard) {
      segmentsInfo = [];
      startTime = null;
      bitratesFailedCount = 0;
      topLevelManifestFailure = false;
      bitratesFailed = {};
      avgSegmentLength = config.segmentLength || 0;
      segmentsChecked = 0;

      if (hard) {
        bitrates = [];
        currentBitrateID = '';
        lastTimeDownload = 0;
      }

      if (OO.TEST_TEST_TEST && hard === 'hard') {
        failingOver = false;
      }
    }
    /**
     * Get the time since the last segment file was downloaded. In seconds
     * @private
     * @method HAFailoverMechanism#_getTimeSinceLastSegmentDownload
     * @returns {number} Number of seconds since last segment was downloaded.
     */


    function _getTimeSinceLastSegmentDownload() {
      var timeSinceLastDownload = (_nowTimestamp() - lastTimeDownload) / 1000;
      return timeSinceLastDownload;
    }
    /**
     * Get the time since a pause event occurred. In seconds
     * @private
     * @method HAFailoverMechanism#_getTimeSincePause
     * @returns {number} Number of seconds since pause started.
     */


    function _getTimeSincePause() {
      if (paused) {
        return (_nowTimestamp() - pauseStartTime) / 1000;
      } else {
        return 0;
      }
    }
    /**
     * Helper function to check if we have enough buffer time
     * @private
     * @method HAFailoverMechanism#_checkForBufferingIssues
     * @param  {number} checkTime player time to check.
     * May include time paused if this check is done on resume from a pause.
     * @returns {boolean} true if a buffering failure is detected, otherwise false
     */


    function _checkForBufferingIssues(checkTime) {
      var segmentLength = _getSegmentLength();

      if (lastTimeDownload && bufferedTime && checkTime) {
        var MAX_TIME_SINCE_LAST_SEGMENT = segmentLength * 5;
        var BUFFER_MIN_LENGTH = segmentLength / 2;

        var lastSegmentDownloadTime = _getTimeSinceLastSegmentDownload();

        var bufferTimeLeft = bufferedTime - checkTime;
        var bufferCheck = bufferTimeLeft < BUFFER_MIN_LENGTH;
        var segmentLastTimeCheck = lastSegmentDownloadTime > MAX_TIME_SINCE_LAST_SEGMENT;

        if (bufferCheck && segmentLastTimeCheck) {
          return true;
        }
      }

      return false;
    }
    /**
     * @method HAFailoverMechanism#timeoutCheck
     * @description Worker that check every so often (configured by config.timeoutCheckFrequencyMs) if failover is required or not
     * @private
     */


    function timeoutCheck() {
      if (!isEnabled()) {
        return;
      }

      if (pluginSupportsNativeEventsOnly()) {
        if (_checkForBufferingIssues(currentTime)) {
          log('failover due to buffering issues');
          failover();
          return;
        }
      }

      if (pluginSupportSegmentsData()) {
        if (topLevelManifestFailure) {
          if (_nowTimestamp() - startTime > config.manifestFailureTimeoutMs) {
            log('failover due to manifest failure');
            failover();
            return;
          }
        }

        if (bitratesFailedCount) {
          if (_nowTimestamp() - startTime > _getTimeoutTimeMs()) {
            log('failover due to timeout');
            failover();
          }
        }
      }
    }

    if (OO.TEST_TEST_TEST) {
      // expose to other part of the player for unit tests only
      OO.exposeStaticApi('ha', _this);
    }
  };

  return HAFailoverMechanism;
});

},{}],76:[function(require,module,exports){
"use strict";

/* eslint no-magic-numbers: "off" */
(function (OO, _, $) {
  // local constants
  var IFRAME_URL = _.template('<%=server%>/ooyala_storage.html')({
    server: OO.SERVER.API
  });

  var DOMAIN = OO.SERVER.API;
  var IFRAME_LOAD_MESSAGE = 'LOADED';
  var IFRAME_LOAD_TIMEOUT = 3000;
  var IFRAME_STATE_INIT = 0;
  var IFRAME_STATE_ERROR = 1;
  var IFRAME_STATE_READY = 2;
  var iframeState = IFRAME_STATE_INIT; // state of iframe

  var postMessageQueue = []; // messages waiting until iframe ready

  var callbacks = {}; // Store Callback functions

  var errorTimeout = null; // add iframe

  var iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  iframe.src = IFRAME_URL;

  var onReady = function onReady() {
    document.body.appendChild(iframe);
    errorTimeout = setTimeout(function () {
      onIframeLoaded(IFRAME_STATE_ERROR);
    }, IFRAME_LOAD_TIMEOUT);
  };

  if (OO.TEST_TEST_TEST) {
    onReady();
  } else {
    $(document).ready(onReady);
  } // add event listener


  if (window.addEventListener) {
    window.addEventListener('message', onMessage, false);
  } else if (window.attachEvent) {
    window.attachEvent('onmessage', onMessage);
  }
  /**
   *
   * @param {Event} event - event object
   */


  function onMessage(event) {
    if (event.origin !== DOMAIN) {
      return;
    } // listen for loaded message


    if (event.data === IFRAME_LOAD_MESSAGE) {
      clearTimeout(errorTimeout);
      onIframeLoaded(IFRAME_STATE_READY);
      return;
    }

    var msg = null;

    try {
      msg = JSON.parse(event.data);
    } catch (error) {} // do nothing, will be caught by next line


    if (!msg || !msg.callback) {
      return;
    } // result can be null


    if (callbacks[msg.callback]) {
      callbacks[msg.callback](msg.result);
      delete callbacks[msg.callback];
    }
  }
  /**
   *
   * @param {String} state - name of a state
   */


  function onIframeLoaded(state) {
    var array;
    iframeState = state;

    while ((array = postMessageQueue.pop()) !== undefined) {
      callPostMessage(array[0], array[1], array[2]);
    }
  }
  /**
   *
   * @param {String} method a name of a function you want t0 call
   * @param {Array} args - arguments for the function
   * @param {Function} callback - a callback for the function
   */


  function callPostMessage(method, args, callback) {
    if (iframeState === IFRAME_STATE_INIT) {
      postMessageQueue.push(arguments);
      return;
    }

    if (iframeState === IFRAME_STATE_ERROR || !iframe.contentWindow.postMessage) {
      var result;

      if (method === 'setItem') {
        result = OO[method].apply(OO.localStorage, args);
      } else {
        result = OO.localStorage[method].apply(OO.localStorage, args);
      }

      if (callback) {
        callback(result);
      }
    } else {
      var msg = {
        method: method,
        arguments: args,
        callback: Math.random().toString(36).substring(7) // random id

      };
      callbacks[msg.callback] = callback;
      iframe.contentWindow.postMessage(JSON.stringify(msg), DOMAIN);
    }
  }

  OO.ooyalaStorage = {
    getItem: function getItem(key, callback) {
      callPostMessage('getItem', [key], callback);
    },
    key: function key(keyId, callback) {
      callPostMessage('key', [keyId], callback);
    },
    setItem: function setItem(key, value, callback) {
      callPostMessage('setItem', [key, value], callback);
    },
    removeItem: function removeItem(key, callback) {
      callPostMessage('removeItem', [key], callback);
    },
    hasOwnProperty: function hasOwnProperty(key, callback) {
      callPostMessage('hasOwnProperty', [key], callback);
    }
  };

  if (OO.TEST_TEST_TEST) {
    OO.ooyalaStorage._getIframeState = function () {
      return iframeState;
    };
  }
})(OO, OO._, OO.$);

},{}],77:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/*
 * Playback Controller
 */

/* eslint no-magic-numbers: "off" */
(function (OO, _, $) {
  /**
   * Events raised by the Ad Managers. Currently identical to IMA events since IMA is
   * the only ad manager that reports them. These should be used as a base for other
   * ad manager SDK events.
   * @private
   * @member AdManagerController#SDK_AD_EVENTS
   */
  var SDK_AD_EVENTS = {
    AD_BREAK_READY: 'adBreakReady',
    AD_CAN_PLAY: 'adCanPlay',
    AD_METADATA: 'adMetadata',
    ALL_ADS_COMPLETED: 'allAdsCompleted',
    CLICK: 'click',
    COMPLETE: 'complete',
    CONTENT_PAUSE_REQUESTED: 'contentPauseRequested',
    CONTENT_RESUME_REQUESTED: 'contentResumeRequested',
    DURATION_CHANGE: 'durationChange',
    EXPANDED_CHANGED: 'expandedChanged',
    FIRST_QUARTILE: 'firstquartile',
    IMPRESSION: 'impression',
    INTERACTION: 'interaction',
    LINEAR_CHANGED: 'linearChanged',
    LOADED: 'loaded',
    LOG: 'log',
    MIDPOINT: 'midpoint',
    PAUSED: 'pause',
    RESUMED: 'resume',
    SKIPPABLE_STATE_CHANGED: 'skippableStateChanged',
    SKIPPED: 'skip',
    STARTED: 'start',
    THIRD_QUARTILE: 'thirdquartile',
    USER_CLOSE: 'userClose',
    VIEWABLE_IMPRESSION: 'viewable_impression',
    VOLUME_CHANGED: 'volumeChange',
    VOLUME_MUTED: 'mute'
  };
  /**
   * @class PlaybackController
   * @classdesc The playback controller main class.  This class is registered as a module with the player.
   * @private
   * @param {object} messageBus The player message bus
   * @param {string} id The ID of the player module
   */

  var PlaybackController = function PlaybackController(messageBus, id) {
    this.toString = function () {
      return 'playback-controller';
    }; // TODO: Move into constants. Until then, these values should match the
    // ones defined in video_controller.js


    this.IOS_PLAY_MODE_OPTIONS = {
      INLINE: 'inline',
      FULLSCREEN: 'fullscreen'
    };
    this.BITRATE_TIMERS = {
      FIVE_SEC: 5000,
      STABLE: 30000
    };
    this.mb = messageBus;
    this.id = id; // elements
    // TODO: Will this controller ever manage multiple playback elements?

    this.playbackElements = {};
    this.currentPlaybackElement = null; // state

    this.publishedPlaybackReady = false;
    this.willPlayFromBeginning = true;
    this.metadataHasFetched = false;
    this.playedAtLeastOnce = false;
    this.hasPlayed = false;
    this.endScreenShown = false;
    this.mobileContinuousPlayDisabled = {};
    this.previousWasOoyalaAd = false;
    this.initialPlayHasOccurred = false;
    this.initialPlaybackHasStarted = false;
    this.currentBitrate = -1;
    this.mainVideoElementCreated = false;
    this.currentPlaybackElementCreated = false;
    this.amcAllReady = false;
    this.playingAds = false;
    this.prerollsDone = false;
    this.currentPodSize = 0;
    this.finalPreroll = false;
    this.reachedPrerollThresholdForPreloading = false;
    this.preloaded = false;
    this.requestedThumbnails = false;
    this.totalPrerollPods = 0;
    this.currentPrerollPod = 0;
    this.fiveSecBitrateTimer = null;
    this.bitrateTimerPassed = 0;
    this.refreshTimers = false;
    this.thirtySecBitrateTimer = null;
    this.hasContentSet = false;
    this.contentChangeRequestedExternally = false; // properties

    this.bitrateTimerStartTime = -1;
    this.playerParams = null;
    this.shouldPreload = false;
    this.initialTime = 0;
    this.playerCreatedTime = -1;
    this.closedCaptions = null;
    this.autoplayed = false;
    this.contentStarted = false;
    this.elementId = null;
    this.iosPlayMode = this.IOS_PLAY_MODE_OPTIONS.FULLSCREEN;
    this.runningAutoplayCheck = false;
    this.autoplayChecked = false;
    this.autoplayCapabilities = {};
    this.delayForPreroll = false;
    this.isAudioOnlyAsset = false; // Default values for initialBitrate Override.
    // bitrateProperty.level a fraction from 0 to 1 from max_bitrate to choose, or "auto" to defer to video plugin ABR
    // bitrateProperty.duration a number (sec) to hold the level until ABR is set back to "auto"

    this.bitrateProperty = {
      level: OO.CONSTANTS.AUTO_BITRATE,
      duration: Infinity
    };
    this.bitrateOverrideFunction = null;
    this.bitrateOverrideTimer = null;
    this.chosenBitrateIndex = OO.CONSTANTS.AUTO_BITRATE;
    this.isBitrateOverrideReady = {
      'isBitrateInfoAvailable': false,
      'isBitrateOverridden': false
    };
    this.isVr = false;
    this.isVideoTypeChanged = false; // Determines which event to use when preloading main content during preroll.
    // Should be either FIRST_QUARTILE, MIDPOINT or THIRD_QUARTILE.

    this.PRELOAD_THRESHOLD_EVENT = SDK_AD_EVENTS.THIRD_QUARTILE; // subscribes

    this.mb.subscribe(OO.EVENTS.PLAYER_CREATED, 'playback', _.bind(this.playerCreated, this));
    this.mb.subscribe(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, 'playback', _.bind(this.autoplayCheckComplete, this));
    this.mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED, 'playback', _.bind(this.embedCodeChanged, this));
    this.mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD, 'playback', _.bind(this.embedCodeChanged, this));
    this.mb.subscribe(OO.EVENTS.SET_EMBED_CODE, 'playback', _.bind(this.setEmbedCode, this));
    this.mb.subscribe(OO.EVENTS.SET_ASSET, 'playback', _.bind(this.setAsset, this));
    this.mb.subscribe(OO.EVENTS.CONTENT_TREE_FETCHED, 'playback', _.bind(this.contentTreeFetched, this));
    this.mb.subscribe(OO.EVENTS.METADATA_FETCHED, 'playback', _.bind(this.metadataFetched, this));
    this.mb.subscribe(OO.EVENTS.AUTHORIZATION_FETCHED, 'playback', _.bind(this.authorizationFetched, this));
    this.mb.subscribe(OO.EVENTS.INITIAL_PLAY, 'playback', _.bind(this.initialPlay, this));
    this.mb.subscribe(OO.EVENTS.WILL_PLAY_FROM_BEGINNING, 'playback', _.bind(this.onWillPlayFromBeginning, this));
    this.mb.subscribe(OO.EVENTS.PLAYED, 'playback', _.bind(this.played, this));
    this.mb.subscribe(OO.EVENTS.ASSET_CHANGED, 'playback', _.bind(this.assetChanged, this));
    this.mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'playback', _.bind(this.vcVideoElementCreated, this));
    this.mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, 'playback', _.bind(this.videoControllerVideoElementInFocus, this));
    this.mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_DISPOSED, 'playback', _.bind(this.vcVideoElementDisposed, this));
    this.mb.subscribe(OO.EVENTS.VC_PLAYED, 'playback', _.bind(this.vcPlayed, this));
    this.mb.subscribe(OO.EVENTS.VC_PLAYING, 'playback', _.bind(this.vcPlaying, this));
    this.mb.subscribe(OO.EVENTS.VC_CAN_PLAY, 'playback', _.bind(this.vcCanPlay, this));
    this.mb.subscribe(OO.EVENTS.VC_PAUSED, 'playback', _.bind(this.vcPaused, this));
    this.mb.subscribe(OO.EVENTS.VC_SEEKED, 'playback', _.bind(this.vcSeeked, this));
    this.mb.subscribe(OO.EVENTS.VC_PLAY_FAILED, 'playback', _.bind(this.vcPlayFailed, this));
    this.mb.subscribe(OO.EVENTS.VC_ERROR, 'playback', _.bind(this.vcError, this));
    this.mb.subscribe(OO.EVENTS.VC_WILL_PLAY, 'playback', _.bind(this.vcWillPlay, this));
    this.mb.subscribe(OO.EVENTS.REPLAY, 'playback', _.bind(this.replay, this));
    this.mb.subscribe(OO.EVENTS.PLAYBACK_READY, 'playback', _.bind(this.playbackReady, this));
    this.mb.subscribe(OO.EVENTS.BITRATE_CHANGED, 'playback', _.bind(this.bitrateChanged, this));
    this.mb.subscribe(OO.EVENTS.BITRATE_INFO_AVAILABLE, 'playback', _.bind(this.bitrateInfoAvailable, this));
    this.mb.subscribe(OO.EVENTS.SET_TARGET_BITRATE, 'playback', _.bind(this.setTargetBitrate, this)); // Ad events

    this.mb.subscribe(OO.EVENTS.AMC_ALL_READY, 'playback', _.bind(this.onAmcAllReady, this));
    this.mb.subscribe(OO.EVENTS.AMC_PREROLLS_DONE, 'playback', _.bind(this.onAmcPrerollsDone, this));
    this.mb.subscribe(OO.EVENTS.SDK_AD_EVENT, 'playback', _.bind(this.onSdkAdEvent, this));
    this.mb.subscribe(OO.EVENTS.WILL_PLAY_ADS, 'playback', _.bind(this.onWillPlayAds, this));
    this.mb.subscribe(OO.EVENTS.ADS_PLAYED, 'playback', _.bind(this.onAdsPlayed, this));
    this.mb.subscribe(OO.EVENTS.WILL_PLAY_SINGLE_AD, 'playback', _.bind(this.onWillPlaySingleAd, this));
    this.mb.subscribe(OO.EVENTS.AD_POD_STARTED, 'playback', _.bind(this.onAdPodStarted, this)); // TODO: Can we deprecate this event?

    this.mb.subscribe(OO.EVENTS.WILL_RESUME_MAIN_VIDEO, 'playback', _.bind(this.willResume, this));
    this.mb.subscribe(OO.EVENTS.CANCEL_GEO_CHECKING, 'playback', _.bind(this.onCancelGeoChecking, this));
  };

  _.extend(PlaybackController.prototype, {
    // ************
    // Helpers
    // ************

    /**
     * Extracts the playable streams from the auth response.
     * @method PlaybackController#getStreams
     * @protected
     * @param {object} playbackAuth The autorization response containing stream information
     * @returns {object} The streams associated with the current asset denoted by encoding type
     */
    getStreams: function getStreams(playbackAuth) {
      if (!playbackAuth) {
        return null;
      }

      if (_.isEmpty(playbackAuth.streams)) {
        return null;
      }

      var streams = {};
      this.isAudioOnlyAsset = playbackAuth.streams.every(function (stream) {
        return OO.isAudioOnlyStream(stream.delivery_type);
      });

      for (var streamIndex = 0; streamIndex < playbackAuth.streams.length; streamIndex++) {
        var deliveryType = playbackAuth.streams[streamIndex].delivery_type; // In the case of youtube there is only one playbackAuth.streams object i.e only one stream hence the number of iteration is one and the object won't be lost or recreated.

        if (deliveryType === 'youtube') {
          streams = {
            'deliveryType': deliveryType,
            'youtube': {
              'url': playbackAuth.streams[streamIndex].youtube_id
            }
          };
          return streams;
        }

        if (!playbackAuth.streams[streamIndex].url || !deliveryType || playbackAuth.streams[streamIndex].drm && _.isEmpty(playbackAuth.streams[streamIndex].drm)) {
          continue; // eslint-disable-line no-continue
        }

        var drmData = playbackAuth.streams[streamIndex].drm || {};

        if (!_.isEmpty(drmData) && deliveryType !== 'remote_asset') {
          deliveryType = deliveryType.concat('_drm');
        }

        streams[deliveryType] = {
          url: OO.decode64(playbackAuth.streams[streamIndex].url.data)
        };

        if (!_.isEmpty(drmData)) {
          streams[deliveryType].drm = drmData;
        } // [PBW-5096]: pass akamai secure content metadata information to video plugin


        var akamaiSecureHd = playbackAuth.streams[streamIndex].akamai_secure_hd || null;

        if (typeof akamaiSecureHd === 'boolean') {
          streams[deliveryType].contentMetadata = {
            'assetId': this.currentEmbedCode,
            'accountId': this.playerParams.pcode,
            'secureContent': akamaiSecureHd
          };
        }

        streams.isLive = playbackAuth.streams[streamIndex].is_live_stream || false;
      }

      if (streams['remote_asset']) {
        streams[OO.VIDEO.ENCODING.UNKNOWN] = streams['remote_asset'];
        delete streams['remote_asset'];
      }

      return streams;
    },

    /**
     * Extracts the playable streams from the auth response.
     * @method PlaybackController#getAssets
     * @protected
     * @param {object} asset The JSON object containing stream information
     * @returns {object} The streams associated with the current asset denoted by encoding type
     */
    getAssets: function getAssets(asset) {
      if (!asset || !asset.content || _.isEmpty(asset.content.streams)) {
        return null;
      }

      var streams = {};
      var assetStreams = asset.content.streams;

      for (var index = 0; index < assetStreams.length; index++) {
        var currentStream = assetStreams[index];

        if (!currentStream.url || !currentStream.delivery_type) {
          continue; // eslint-disable-line no-continue
        }

        streams[currentStream.delivery_type] = {
          url: currentStream.url
        };
        streams.isLive = currentStream.is_live_stream || false;
      }

      return streams;
    },

    /**
     * Checks if all of the metadata has been raised.
     * @method PlaybackController#checkDataReady
     * @param {Boolean} ooyalaAds - ?
     * @protected
     */
    checkDataReady: function checkDataReady(ooyalaAds) {
      if (this.contentTree != null && this.metadataHasFetched && this.authorization != null) {
        this.dataReady(ooyalaAds); // TODO: consider making a timeout to fire playback ready in case the video element is never created
        // Note that having the video element never created while not raising an error event is not an
        // expected scenario.
      }
    },

    /**
     * Called when all playback metadata has been fetched.  Creates the main video element.
     * @method PlaybackController#dataReady
     * @param {Boolean} ooyalaAds - ?
     * @protected
     * @fires OO.EVENTS.VC_CREATE_VIDEO_ELEMENT
     */
    dataReady: function dataReady(ooyalaAds) {
      var mainVideoId = ooyalaAds ? OO.VIDEO.ADS : OO.VIDEO.MAIN;
      this.playbackElements[mainVideoId] = {
        'streams': this.streams
      };
      this.currentPlaybackElement = mainVideoId;
      this.publishClosedCaptionInfo(mainVideoId, this.closedCaptions);
      var platform = this.playerParams ? this.playerParams.platform : void 0;
      var crossorigin = this.playerParams ? this.playerParams.crossorigin : void 0;
      var pcode = this.playerParams ? this.playerParams.pcode : void 0;
      var params = {
        closedCaptions: this.playbackElements[mainVideoId].closedCaptions,
        platform: platform,
        crossorigin: crossorigin,
        authenticationData: {
          pcode: pcode
        },
        initialTime: this.initialTime,
        // Obtain bit_wrapper configuration options from either the global player params
        // (i.e. set by Valhalla using OO.__internal.playerParams) or the page-level params
        pluginParams: _.extend({}, OO.playerParams, this.playerParams) // ^^ IMPORTANT!
        // If the user sets their own 'bit-wrapper' property it will override the internal
        // 'bit-wrapper' property set by Valhalla which contains the location of the Bitmovin
        // files. There is currently no use case for the user adding 'bit-wrapper' to their config
        // for a purpose other than setting the Bitmovin files location, so this is currently not a problem.
        // This might change in the future though.

      };

      if (this.isVr) {
        var vrParams = this.getPlayerVrParams(); // Extend BitWrapper plugin parameters with VR source settings.
        // NOTE:
        // Existing player params will override VR params. The extend below is shallow,
        // so nested properties will also be overriden/lost if not properly specified.
        // TODO:
        // Find a more generic way of setting plugin settings without referencing BitWrapper specifcially.

        params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER] = _.extend({}, vrParams, params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER]); // PLAYER-3731
        // 360 video requires crossorigin set to anonymous on iOS 11. Even though playback might
        // be possible without it, Bitmovin will set this value on its own, and if the core tries
        // to change it, it will trigger a bug on iOS that causes playback to fail with a black screen.

        if (OO.isIos && OO.iosMajorVersion >= 11) {
          params.crossorigin = 'anonymous';
        }
      }

      this.mb.publish(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, mainVideoId, this.streams, null, params);
    },

    /**
     * Resets internal data associated with a stream.
     * @method PlaybackController#resetStreamData
     * @protected
     */
    resetStreamData: function resetStreamData() {
      // data
      this.contentTree = null;
      this.metadataHasFetched = false;
      this.authorization = null;
      this.streams = null;
      this.currentEmbedCode = null;
      this.endScreenShown = false;
      this.mainVideoElementCreated = false;
      this.currentPlaybackElementCreated = false; // AMC does not reinitialize after an Ooyala ad

      if (!this.previousWasOoyalaAd) {
        this.amcAllReady = false;
      }

      this.playingAds = false;
      this.prerollsDone = false;
      this.currentPodSize = 0;
      this.finalPreroll = false;
      this.reachedPrerollThresholdForPreloading = false;
      this.preloaded = false;
      this.totalPrerollPods = 0;
      this.currentPrerollPod = 0;
      this.publishedPlaybackReady = false;
      this.autoplayed = false;
      this.contentStarted = false;
      this.requestedThumbnails = false;
      this.playedAtLeastOnce = false; // Clear initial time unless we just played an Ooyala ad, in which
      // case we'll need to keep it for use with the actual content

      if (!this.previousWasOoyalaAd && !this.playerParams.ooyalaAds) {
        this.initialTime = 0;
      }

      if (this.playerParams && this.playerParams.ooyalaAds) {
        this.previousWasOoyalaAd = true;
      } else {
        this.previousWasOoyalaAd = false;
      } // Clear initialBitrate state


      this.bitrateProperty = {
        level: OO.CONSTANTS.AUTO_BITRATE,
        duration: Infinity
      };
      this.chosenBitrateIndex = OO.CONSTANTS.AUTO_BITRATE;
      this.isBitrateOverrideReady = {
        isBitrateInfoAvailable: false,
        isBitrateOverridden: false
      };
    },

    /**
     * Triggers stream preloading if should preload.
     * @method PlaybackController#preloadStream
     * @protected
     * @fires OO.EVENTS.VC_PRELOAD;
     */
    preloadStream: function preloadStream() {
      // preload the stream if the following conditions are met:
      // 1. the "preload" page level parameter is set to true (tracked by this.shouldPreload)
      //    OR if we are autoplaying
      // 2. we have not already preloaded this stream
      // 3. the main video element has been created
      // 4. Either we have been notified that prerolls have finished, or we have reached
      //    the preload threshold for preloading (default is 3rd quartile of the final preroll)
      // Do not preload after reaching preroll threshold if we are on iOS, since it requires a single
      // video element.
      // Alex: Note that I am not using OO.requiresSingleVideoElement because that returns true
      // for all Android versions. Android versions >= 4 and Chrome versions >= 40 all can handle
      // multiple video elements, and we still want to enable preloading for those. We need to revisit
      // OO.requiresSingleVideoElement
      if ((this.shouldPreload || this.shouldAutoplay()) && !this.preloaded && this.mainVideoElementCreated && (this.prerollsDone || this.reachedPrerollThresholdForPreloading && !OO.isIos)) {
        this.preloaded = true;
        this.mb.publish(OO.EVENTS.VC_PRELOAD, this.currentPlaybackElement);
      }
    },

    /**
     * Checks to see if we can autoplay in the browser based on the autoplay check. If check has not
     * completed, assumes we can autoplay.
     * @method PlaybackController#canAutoplay
     * @protected
     * @returns {boolean} True if we can autoplay in the browser, false otherwise
     */
    canAutoplay: function canAutoplay() {
      return !(this.autoplayCapabilities.muted === false && this.autoplayCapabilities.unmuted === false);
    },

    /**
     * Checks to see if we should trigger autoplay based on environment
     * and page level parameters.
     * @method PlaybackController#shouldAutoplay
     * @protected
     * @returns {boolean} True if we should autoplay, false otherwise
     */
    shouldAutoplay: function shouldAutoplay() {
      // Samsung Internet browser currently does not support autoplay
      if (OO.isSamsungBrowser) {
        return false;
      }

      var autoPlay = this.autoplayEnabled() && (this.canAutoplay() || this.initialPlayHasOccurred); // When a video element is disposed (such as when switching from one video plugin to another)
      // we shouldn't attempt to auto play it on mobile, otherwise browser restrictions might cause it to get stuck

      var mobileContinuousPlayDisabled = this.mobileContinuousPlayDisabled[this.currentPlaybackElement];
      var mobileContinuousPlay = !mobileContinuousPlayDisabled && autoPlay && this.hasPlayed;
      var autoplayOoyalaAds = false; // In order to make auto play of ooyala ad without user gesture,
      // mobileContinuousPlay should be always set to true if ooyalaAds is true

      if (this.playerParams && this.playerParams.ooyalaAds) {
        autoplayOoyalaAds = true;
      } // On iPhone, we don't want to autoplay unless we are playing inline since autoplay is not supported
      // outside of inline playback
      // Due to how mobile continuous ads and ooyala ads work (they have an embed code change and expect autoplay true),
      // we will allow them to autoplay since a user click has already happened or they are muted


      if (OO.isIphone && this.iosPlayMode !== this.IOS_PLAY_MODE_OPTIONS.INLINE && !mobileContinuousPlay && !autoplayOoyalaAds) {
        return false;
      } else if (mobileContinuousPlay || this.playedAtLeastOnce === false && autoPlay || autoplayOoyalaAds) {
        return true;
      } else {
        return false;
      }
    },

    /**
     * Triggers autoplay if required.
     * @method PlaybackController#triggerAutoplay
     * @protected
     * @fires OO.EVENTS.INITIAL_PLAY
     */
    triggerAutoplay: function triggerAutoplay() {
      if (this.shouldAutoplay()) {
        this.autoplayed = true;
        this.mb.publish(OO.EVENTS.INITIAL_PLAY, Date.now(), this.autoplayed);
      }
    },

    /**
     * Sets and normalizes the autoPlay param according to the playerParams that were passed,
     * as well as the current controller state. This will normally be called by
     * embedCodeChanged or assetChanged in order to reset this value when a new video is set.
     * @private
     * @method PlaybackController#setAutoPlayParam
     */
    setAutoPlayParam: function setAutoPlayParam() {
      if (!this.playerParams) {
        return;
      }

      this.playerParams.autoPlay = this.playerParams.autoPlay === 'true' || this.playerParams.autoPlay === true || this.playerParams.autoplay === 'true' || this.playerParams.autoplay === true; // The only time we want autoplay to be false after the initial content has played is when playerParams.autoPlay is false
      // and is playerParams.autoPlayUpNextVideosOnly is defined and false.

      if (this.initialPlayHasOccurred) {
        if (typeof this.playerParams.autoPlayUpNextVideosOnly === 'undefined' || this.playerParams.autoPlayUpNextVideosOnly === 'true' || this.playerParams.autoPlayUpNextVideosOnly === true) {
          this.playerParams.autoPlay = true;
        }
      }
    },

    /**
     * Triggers playback if should loop playback.
     * @method PlaybackController#triggerLoopPlay
     * @protected
     * @fires OO.EVENTS.REPLAY
     */
    triggerLoopPlay: function triggerLoopPlay() {
      var loop = !this.playerParams ? false : this.playerParams['loop'] === 'true' || this.playerParams['loop'] === true;

      if (loop) {
        this.mb.publish(OO.EVENTS.REPLAY);
      }
    },
    // **************
    // Callbacks
    // **************

    /**
     * Called when the player is created.  Initializes locale and settings, and configures the system
     * to pause the stream if visibility changes.
     * @method PlaybackController#playerCreated
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} elementId The element id of the player instance
     * @param {object} params Page-level player parameters
     * @param {object} persistentSettings Parsed local settings
     * @param {string} embedCode The asset / embed code
     * @param {number} createdTime Timestamp for when the player was created
     * @fires OO.EVENTS.PAUSE
     */
    playerCreated: function playerCreated(eventName, elementId, params, persistentSettings, embedCode, createdTime) {
      var _this = this;

      this.elementId = elementId;
      this.playerParams = params;
      this.playerCreatedTime = createdTime;

      if (OO.isIos && OO.iosMajorVersion === 7) {
        // [pbw-1832] iOS 7's visibilitychange event is different/bad, so use pageshow
        window.addEventListener('pageshow', _.bind(function () {
          this.mb.publish(OO.EVENTS.PAUSE);
        }, this));
      } else if (OO.isAndroid || OO.isIos) {
        // [pbw-1832] on other mobile, pause when the tab is switched or the browser is backgrounded
        document.addEventListener('visibilitychange', _.bind(function (evt) {
          if (document.hidden) {
            this.mb.publish(OO.EVENTS.PAUSE);
          }
        }, this));
      } // Test autoplay options here if autoplay is enabled


      if (this.autoplayEnabled()) {
        this.runningAutoplayCheck = true;
        OO.checkAutoplay.runTest(function (results, autoplayState) {
          OO.log('Autoplay check complete', results);

          _this.mb.publish(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, results);

          OO.log('Autoplay state checked', autoplayState);

          _this.mb.publish(OO.EVENTS.AUTOPLAY_STATE_CHECKED, autoplayState);
        });
      }
    },

    /**
     * Updates the state of the Playback controller using the values from the playerParams
     * (page-level settings) that were provided during player creation or passed to the
     * setEmbedCode() or setAsset() API calls.
     * @private
     * @method PlaybackController#applyPlayerParams
     */
    applyPlayerParams: function applyPlayerParams() {
      if (!this.playerParams) {
        return;
      } // Set HTML5 locale


      if (typeof this.playerParams.locale !== 'undefined') {
        OO.setLocale(this.playerParams.locale);
      } // Initial time only applies to the first video unless explicitly provided for
      // a subsequent video via an API call to setEmbedCode() or setAsset()


      var shouldUpdateInitialTime = !this.hasContentSet || this.contentChangeRequestedExternally; // Parse and save initial time

      if (shouldUpdateInitialTime && typeof this.playerParams.initialTime !== 'undefined') {
        var time = parseFloat(this.playerParams.initialTime);

        if (!isNaN(time) && time > 0) {
          this.initialTime = time;
        }
      } // Preloading is pointless when initialTime is set because it is applied right before the PLAY event,
      // which means that we would be preloading the wrong part of the video (i.e. the beginning)


      if (this.playerParams.preload === false || this.initialTime) {
        this.shouldPreload = false;
      } else if (this.playerParams.preload === true) {
        this.shouldPreload = true;
      } // iOS playback options


      if (typeof this.playerParams.iosPlayMode !== 'undefined') {
        this.iosPlayMode = this.playerParams.iosPlayMode;
      }

      if (typeof this.playerParams['delayForPreroll'] === 'boolean') {
        this.delayForPreroll = this.playerParams['delayForPreroll'];
      }

      this.initialBitrateOverride(this.playerParams);
    },

    /**
     * Checks to see if autoplay is enabled by looking at the player parameters.
     * @method PlaybackController#autoplayEnabled
     * @protected
     * @returns {boolean} True if autoplay is enabled, false otherwise
     */
    autoplayEnabled: function autoplayEnabled() {
      var params = this.playerParams;
      return params && (params.autoPlay === 'true' || params.autoPlay === true || params.autoplay === 'true' || params.autoplay === true);
    },

    /**
     * Callback for when the autoplay check has finished.
     * @method PlaybackController#autoplayCheckComplete
     * @protected
     * @param {string} event The event name
     * @param {object} results Object containing muted and unmuted autoplay capabilities
     */
    autoplayCheckComplete: function autoplayCheckComplete(event, results) {
      this.autoplayChecked = true;
      this.autoplayCapabilities = results;
      this.tryPublishPlaybackReady();
    },

    /**
     * Requests thumbnails.
     * @method PlaybackController#fetchThumbnails
     * @protected
     */
    fetchThumbnails: function fetchThumbnails() {
      if (!this.requestedThumbnails) {
        this.requestedThumbnails = true;
        var urlParams = {
          server: OO.SERVER.API,
          embedCode: this.currentEmbedCode
        };
        $.ajax({
          url: OO.URLS.THUMBNAILS(urlParams),
          type: 'GET',
          dataType: 'json',
          cache: true,
          success: _.bind(this.thumbnailsFetched, this),
          error: _.bind(this._thumbnailsFailed, this)
        });
      }
    },

    /**
     * Callback for thumbnails API response.
     * @method Api#_thumbnailsFetched
     * @param {Object} data The data from the AJAX request success
     * @private
     */
    thumbnailsFetched: function thumbnailsFetched(data) {
      if (data && data.data && !_.isEmpty(data.data.thumbnails)) {
        this.mb.publish(OO.EVENTS.THUMBNAILS_FETCHED, data);
      }
    },

    /**
     * Error callback for thumbnails API.
     * @method Api#_thumbnailsFailed
     * @param {Object} request The request object
     * @param {String} status The text status
     * @param {String} error The error thrown
     * @private
     */
    _thumbnailsFailed: function _thumbnailsFailed(request, status, error) {
      OO.log('Failed to fetch thumbnails');
    },

    /**
     * Check if the 'markers' player param it's a boolean and false, otherwise
     * it will return true and let the player to try get the marker information
     * @method PlaybackController#shouldDisplayMarkers
     * @private
     * @returns {Boolean} true if markers are allowed to be rendered, otherwise false
     */
    shouldDisplayMarkers: function shouldDisplayMarkers() {
      return typeof this.playerParams.markers === 'undefined' || typeof this.playerParams.markers !== 'boolean' || this.playerParams.markers.valueOf() !== false;
    },

    /**
     * Called when playback is created.
     * @method PlaybackController#playbackReady
     * @protected
     */
    playbackReady: function playbackReady() {
      if (!this.shouldAutoplay() && !this.isAudioOnlyAsset) {
        this.fetchThumbnails();

        if (this.shouldDisplayMarkers()) {
          this.loadMarkers();
        }
      }

      this.triggerAutoplay();
    },

    /**
     * Will try to fetch the markers information from contentTree or inline params
     * @method PlaybackController#loadMarkers
     * @private
     */
    loadMarkers: function loadMarkers() {
      var markersURL = this.getMarkersURL();

      if (markersURL !== '') {
        $.ajax({
          url: markersURL,
          type: 'GET',
          dataType: 'json',
          cache: true,
          success: _.bind(this.publishMarkerData, this),
          error: _.bind(this.onMarkersFailed, this)
        });
      } else {
        this.publishMarkerData();
      }
    },

    /**
     * Will publish any available marker information into the message bus.
     * Before publish the data it will be merged with any inline information.
     * Fires the OO.EVENTS.MARKER_DATA_AVAILABLE event
     * @method PlaybackController#publishMarkerData
     * @private
     * @param {Object} data the data from Ajax request of marker
     */
    publishMarkerData: function publishMarkerData(data) {
      var markers = {
        list: []
      };
      var inlineMarkers = this.getInlineMarkers();
      var globalType = data && data.type && data.type !== '' ? data.type : null;

      if (data && Array.isArray(data.markerList) && data.markerList.length > 0) {
        inlineMarkers.forEach(function (inlineMarker) {
          var markerIndex = data.markerList.findIndex(function (marker) {
            return marker.start === inlineMarker.start;
          });

          if (markerIndex >= 0) {
            data.markerList[markerIndex] = Object.assign({}, data.markerList[markerIndex], inlineMarker);
          } else {
            data.markerList.push(inlineMarker);
          }
        });
        markers.list = data.markerList;
      } else if (inlineMarkers.length > 0) {
        markers.list = inlineMarkers;
      } // Let's set the globalType for those markers that does not have a type defined.
      // Also add the globalType as part of the final result


      if (globalType) {
        markers.type = globalType;
        markers.list = markers.list.map(function (marker) {
          if (marker.type === undefined || marker.type === '') {
            marker.type = globalType;
          }

          return marker;
        });
      }

      if (markers.list.length > 0) {
        markers.list = markers.list.sort(function (firstMarker, secondMarker) {
          return firstMarker.start > secondMarker.start ? 1 : -1;
        });
        this.mb.publish(OO.EVENTS.MARKER_DATA_AVAILABLE, markers);
      }
    },

    /**
     * looks in the player params for any marker information
     * @method PlaybackController#getInlineMarkers
     * @protected
     * @returns {Array} list of markers at player params
     */
    getInlineMarkers: function getInlineMarkers() {
      if (this.playerParams.markers && Array.isArray(this.playerParams.markers.inline) && this.playerParams.markers.inline.length > 0) {
        return this.playerParams.markers.inline;
      }

      return [];
    },

    /**
     * Error callback for markers request.
     * @method PlaybackController#onMarkersFailed
     * @param {Object} request The request object
     * @param {String} status The text status
     * @param {String} error The error thrown
     * @private
     */
    onMarkersFailed: function onMarkersFailed(request, status, error) {
      OO.log('Error: Failed to fetch markers data');
    },

    /**
     * Get the URL of markers to be fetched. This value can be obtained from content tree
     * or page level param
     * @method PlaybackController#getMarkersURL
     * @private
     * @returns {String} Url of markers file
     */
    getMarkersURL: function getMarkersURL() {
      if (this.playerParams && this.playerParams.markers && this.playerParams.markers.config) {
        return this.playerParams.markers.config;
      }

      if (this.contentTree && this.contentTree.markers_url) {
        return this.contentTree.markers_url;
      }

      return '';
    },

    /**
     * Clears all bitrate-related timers (the ones used for both analytics and
     * initialBitrate feature).
     * @method PlaybackController#resetBitrateState
     * @private
     */
    clearBitrateTimers: function clearBitrateTimers() {
      // Clear analytics bitrate timers
      clearTimeout(this.fiveSecBitrateTimer);
      this.fiveSecBitrateTimer = null;
      clearTimeout(this.thirtySecBitrateTimer);
      this.thirtySecBitrateTimer = null; // Clear initialBitrate timer

      clearTimeout(this.bitrateOverrideTimer);
      this.bitrateOverrideTimer = null;
    },

    /**
     * Called when a new video is set. Store any bitrateOverride params and callback
     * @method PlaybackController#initialBitrateOverride
     * @param {Object} params The bitrate information provided by the video plugin
     * @protected
     */
    initialBitrateOverride: function initialBitrateOverride(params) {
      if (params && params.initialBitrate) {
        var level = params.initialBitrate.level;

        if (level === OO.CONSTANTS.AUTO_BITRATE || $.isNumeric(level) && level >= 0 && level <= 1) {
          this.bitrateProperty.level = level;
        }

        var duration = params.initialBitrate.duration;

        if ($.isNumeric(duration) && duration > 0) {
          this.bitrateProperty.duration = duration;
        }
      }

      if (params && params.bitrateOverrideFunction && typeof params.bitrateOverrideFunction === 'function') {
        this.bitrateOverrideFunction = params.bitrateOverrideFunction;
      }
    },

    /**
     * Called when BITRATE_INFO_AVAILABLE is published. Execute any bitrate override.
     * @method PlaybackController#bitrateInfoAvailable
     * @param {String} eventName Event identifier
     * @param {Object} params The bitrate information provided by the video plugin
     * @param {String} videoId The id of the video whose bitrate info is available
     * @protected
     */
    bitrateInfoAvailable: function bitrateInfoAvailable(eventName, params, videoId) {
      if (this.isAudioOnlyAsset && params && params.bitrates) {
        var videoStreamFound = false;

        for (var index = 0; index < params.bitrates.length; index++) {
          if (params.bitrates[index].width || params.bitrates[index].height) {
            videoStreamFound = true;
            break;
          }
        }

        if (videoStreamFound) {
          var errorDetails = {
            ooyalaErrorCode: OO.ERROR.PLAYBACK.GENERIC
          };
          errorDetails.ooyalaErrorMessage = 'Audio only asset contains video streams.';
          errorDetails.mediaErrorMessage = 'Source is unsupported.';
          this.mb.publish(OO.EVENTS.ERROR, {
            code: OO.ERROR.PLAYBACK.GENERIC
          });
          this.mb.publish(OO.EVENTS.PLAYBACK_START_ERROR, errorDetails);
          return;
        }
      }

      if (params && params.bitrates && this.bitrateProperty.level !== OO.CONSTANTS.AUTO_BITRATE && videoId === OO.VIDEO.MAIN // Initial bitrate override is for main element only. Avoid choosing bitrates from other video elements
      ) {
          // Form and sort array of bitrates
          var bitrateArray = [];
          var bitrateMap = {};

          for (var _index = 0; _index < params.bitrates.length; _index++) {
            if (params.bitrates[_index].id !== OO.CONSTANTS.AUTO_BITRATE) {
              bitrateArray.push(params.bitrates[_index].bitrate);
              bitrateMap[params.bitrates[_index].bitrate] = params.bitrates[_index].id;
            }
          }

          bitrateArray.sort(function (prevElem, nextElem) {
            return prevElem - nextElem;
          }); // Choose the bitrate, closes to the level * maxBitrateAvailable

          if (bitrateArray.length > 0) {
            var preferredBitrate = this.bitrateProperty.level * bitrateArray[bitrateArray.length - 1];
            var chosenBitrate = bitrateArray[0];

            for (var _index2 = 0; _index2 < bitrateArray.length; _index2++) {
              if (bitrateArray[_index2] <= preferredBitrate) {
                chosenBitrate = bitrateArray[_index2];
              } else {
                break;
              }
            }

            this.chosenBitrateIndex = bitrateMap[chosenBitrate];
            this.isBitrateOverrideReady.isBitrateInfoAvailable = true;
          }

          this.publishInitialBitrateOverride();
        }
    },

    /**
     * Called everytime VC_PLAYING is published. Execute any bitrate override once.
     * @method PlaybackController#publishInitialBitrateOverride
     * @protected
     */
    publishInitialBitrateOverride: function publishInitialBitrateOverride() {
      if (!this.isBitrateOverrideReady.isBitrateOverridden) {
        if (typeof this.bitrateOverrideFunction === 'function') {
          this.bitrateOverrideFunction();
          this.isBitrateOverrideReady.isBitrateOverridden = true;
        } else if (this.isBitrateOverrideReady.isBitrateInfoAvailable && this.bitrateProperty.level !== OO.CONSTANTS.AUTO_BITRATE && this.chosenBitrateIndex !== OO.CONSTANTS.AUTO_BITRATE) {
          // Only trigger this Once every initial playback and after replay
          this.mb.publish(OO.EVENTS.SET_TARGET_BITRATE, this.chosenBitrateIndex, {
            setTimer: true
          }, OO.VIDEO.MAIN);
          this.mb.publish(OO.EVENTS.SEND_QUALITY_CHANGE, this.chosenBitrateIndex, {
            setTimer: true
          }, OO.VIDEO.MAIN);
          this.isBitrateOverrideReady.isBitrateOverridden = true;
        }
      }
    },

    /**
     * Called everytime VC_VIDEO_ELEMENT_IN_FOCUS is published. For now is used if initialBitrateOverride is needed
     * @method PlaybackController#videoControllerVideoElementInFocus
     * @param {String} eventName The name of the event raised
     * @protected
     */
    videoControllerVideoElementInFocus: function videoControllerVideoElementInFocus(eventName) {
      this.publishInitialBitrateOverride();
    },

    /**
     * Called when SET_TARGET_BITRATE is published.
     * @method PlaybackController#setTargetBitrate
     * @param {String} eventName The name of the event raised
     * @param {Object} param Authorization data
     * @param {Object} timer - ?
     * @protected
     */
    setTargetBitrate: function setTargetBitrate(eventName, param, timer) {
      // Set a timer to disable bitrate Override, once duration is reached.
      if (!!timer && timer.setTimer) {
        this.bitrateOverrideTimer = setTimeout(_.bind(function () {
          this.mb.publish(OO.EVENTS.SET_TARGET_BITRATE, OO.CONSTANTS.AUTO_BITRATE, {}, OO.VIDEO.MAIN);
        }, this), this.bitrateProperty.duration * 1000);
      } else if (this.bitrateOverrideTimer) {
        // Clear timer if another SET_TARGET_BITRATE is called, including self
        clearTimeout(this.bitrateOverrideTimer);
        this.bitrateOverrideTimer = null;
      }
    },

    /**
     * Called to set timers for the bitrate reporting events.
     * @method PlaybackController#startBitrateTimers
     * @private
     */
    startBitrateTimers: function startBitrateTimers() {
      var _this2 = this;

      this.bitrateTimerStartTime = Date.now();

      if (this.refreshTimers) {
        this.refreshTimers = false;
        this.bitrateTimerPassed = 0;
      }

      if (this.bitrateTimerPassed < this.BITRATE_TIMERS.FIVE_SEC && !this.fiveSecBitrateTimer) {
        this.fiveSecBitrateTimer = setTimeout(function () {
          _this2.fiveSecBitrateSent = true;

          _this2.mb.publish(OO.EVENTS.BITRATE_FIVE_SEC, _this2.currentBitrate);
        }, this.BITRATE_TIMERS.FIVE_SEC - this.bitrateTimerPassed);
      }

      this.startBitrateStableTimer();
    },

    /**
     * Called to initiate timer to report bitrate stable.
     * @method PlaybackController#startBitrateStableTimer
     * @private
     */
    startBitrateStableTimer: function startBitrateStableTimer() {
      var _this3 = this;

      if (!this.thirtySecBitrateTimer) {
        this.thirtySecBitrateTimer = setTimeout(function () {
          _this3.publishBitrateInfo();
        }, this.BITRATE_TIMERS.STABLE);
      }
    },

    /**
     * Called to set timers for the bitrate stable event.
     * @method PlaybackController#publishBitrateInfo
     * @private
     */
    publishBitrateInfo: function publishBitrateInfo() {
      var _this4 = this;

      this.mb.publish(OO.EVENTS.BITRATE_STABLE, this.currentBitrate);
      this.thirtySecBitrateTimer = setTimeout(function () {
        _this4.publishBitrateInfo();
      }, this.BITRATE_TIMERS.STABLE);
    },

    /**
     * Called when BITRATE_CHANGED is published.
     * @method PlaybackController#bitrateChanged
     * @param {string} eventName The name of the event raised
     * @param {object} params Authorization data
     * @protected
     */
    bitrateChanged: function bitrateChanged(eventName, params) {
      this.currentBitrate = params.bitrate; // The following should not generally execute

      if (!this.initialPlaybackHasStarted) {
        this.initialPlaybackHasStarted = true;
        this.mb.publish(OO.EVENTS.BITRATE_INITIAL, this.currentBitrate);
        this.bitrateTimerPassed = 0;
        this.startBitrateTimers();
      }

      this.startBitrateStableTimer();
    },

    /**
     * Called when authorization has been fetched.  Checks if the player is ready.
     * @method PlaybackController#authorizationFetched
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {object} params Authorization data
     * @param {boolean} ooyalaAds - ?
     */
    authorizationFetched: function authorizationFetched(eventName, params, ooyalaAds) {
      this.authorization = params;
      this.streams = this.getStreams(params);
      this.checkDataReady(ooyalaAds);
    },

    /**
     * Called when the content metadata has been fetched.  Checks if the player is ready.
     * @method PlaybackController#contentTreeFetched
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {object} tree Movie metadata
     * @param {boolean} ooyalaAds - ?
     */
    contentTreeFetched: function contentTreeFetched(eventName, tree, ooyalaAds) {
      this.contentTree = tree;

      if (tree) {
        this.closedCaptions = {
          'closed_captions': tree.closed_captions,
          'closed_captions_vtt': tree.closed_captions_vtt
        };
      }

      var isVr = !!this.hasVrParams();
      this.isVideoTypeChanged = this.isVr !== isVr;

      if (this.isVideoTypeChanged) {
        this.mb.publish(OO.EVENTS.VIDEO_TYPE_CHANGED);
        this.isVr = isVr;
        this.recreateUi(isVr);
      }

      if (isVr) {
        var vrParams = this.getPlayerVrParams();
        this.mb.publish(OO.EVENTS.VIDEO_VR, {
          videoId: ooyalaAds ? OO.VIDEO.ADS : OO.VIDEO.MAIN,
          source: (vrParams || {}).source
        });
      }

      this.checkDataReady(ooyalaAds);
    },

    /**
     * Called to publish the possible closed caption languages from content tree.
     * @method PlaybackController#publishClosedCaptionInfo
     * @protected
     * @param {string} videoId The id of the video element to which the caption info belongs
     * @param {object} captions - ?
     */
    publishClosedCaptionInfo: function publishClosedCaptionInfo(videoId, captions) {
      if (captions) {
        var closedCaptions = {}; // Check if the object contains either form of closed captions and that they have the correct info needed

        if (captions.closed_captions_vtt && captions.closed_captions_vtt.captions && _.size(captions.closed_captions_vtt.captions) > 0) {
          closedCaptions.closed_captions_vtt = captions.closed_captions_vtt.captions;
          closedCaptions.availableLanguages = captions.closed_captions_vtt.languages;
          closedCaptions.locale = {};

          for (var closedCaptionIndex = 0; closedCaptionIndex < closedCaptions.availableLanguages.length; closedCaptionIndex++) {
            var language = closedCaptions.availableLanguages[closedCaptionIndex];
            closedCaptions.locale[language] = closedCaptions.closed_captions_vtt[language].name;
          }
        }

        if (captions.closed_captions && captions.closed_captions.length > 0) {
          closedCaptions.closed_captions_dfxp = captions.closed_captions[0];
          closedCaptions.availableLanguages = captions.closed_captions[0].languages;
        } // Make sure the object contains at least one form of closed captions


        if (_.size(closedCaptions) > 0) {
          var availableLanguages = {
            videoId: videoId
          };
          availableLanguages.languages = captions.closed_captions_vtt && captions.closed_captions_vtt.languages || closedCaptions.closed_captions_dfxp && closedCaptions.closed_captions_dfxp.languages;
          availableLanguages.locale = {}; // Make sure we have available languages

          if (availableLanguages.languages && availableLanguages.languages.length > 0) {
            for (var availableLanguageIndex = 0; availableLanguageIndex < availableLanguages.languages.length; availableLanguageIndex++) {
              var _language = availableLanguages.languages[availableLanguageIndex];

              if (closedCaptions.closed_captions_vtt && closedCaptions.closed_captions_vtt[_language]) {
                availableLanguages.locale[_language] = closedCaptions.closed_captions_vtt[_language].name;
              }
            }

            _.extend(this.playbackElements[this.currentPlaybackElement], {
              'closedCaptions': closedCaptions
            });

            this.mb.publish(OO.EVENTS.CLOSED_CAPTIONS_INFO_AVAILABLE, availableLanguages);
          }
        }
      }
    },

    /**
     * Called when the playback metadata has been fetched.  Checks if the player is ready.
     * @method PlaybackController#metadataFetched
     * @protected
     * @param {string} event The name of the event raised
     * @param {object} metadata from backlot
     * @param {boolean} ooyalaAds - ?
     */
    metadataFetched: function metadataFetched(event, metadata, ooyalaAds) {
      this.metadataHasFetched = true;
      this.checkDataReady(ooyalaAds);
    },

    /**
     * @description Check if contentTree has movie attributes and vr360type
     * @private
     * @method PlaybackController#hasVrParams
     * @returns {boolean} true if vr360type == "mono" or mobile, else return false
     */
    hasVrParams: function hasVrParams() {
      var vr360type = this.contentTree && this.contentTree.movie_attributes && this.contentTree.movie_attributes.vr360type; // ToDo:supported only mode "mono"

      return vr360type === 'mono';
    },

    /**
     * @description if metadata has vr params RECREATING_UI event need to be published
     * @private
     * @param {Boolean} isVr true if the video is vr
     * @returns {Boolean} true if the video was vr, otherwise false
     */
    recreateUi: function recreateUi(isVr) {
      if (isVr) {
        var persistentSettings = {
          'closedCaptionOptions': {}
        };
        this.mb.publish(OO.EVENTS.RECREATING_UI, this.elementId, this.playerParams, persistentSettings);
        return true;
      }

      return false;
    },

    /**
     * Builds and returns the Bitmovin VR source config object using values extracted from the
     * content tree and other default settings. Necessary for Bitmovin VR360 playback.
     * TODO:
     * Decouple this logic from BitWrapper/Bitmovin. Parameters that are specific to a certain
     * plugin should be generated at the plugin level.
     * @method PlaybackController#getPlayerVrParams
     * @protected
     * @returns {Object|null} config object for video vr (bit_wrapper)
     */
    getPlayerVrParams: function getPlayerVrParams() {
      var vrParams = {
        stereo: OO.PLAYER_VR.DEFAULT_SETTINGS.STEREO,
        contentType: OO.PLAYER_VR.DEFAULT_SETTINGS.CONTENT_TYPE,
        startPosition: OO.PLAYER_VR.DEFAULT_SETTINGS.START_POSITION,
        viewWindow: OO.PLAYER_VR.DEFAULT_SETTINGS.VIEW_WINDOW
      };

      if (this.hasVrParams()) {
        var formattedVrParams = null;
        vrParams = this._correctParametersName(vrParams);

        if (vrParams) {
          formattedVrParams = {
            source: {
              vr: vrParams
            }
          };
        }

        return formattedVrParams;
      } else {
        return null;
      }
    },

    /**
     * Validates property names for correct plugins operation
     * @param {Object} vrParams parameters for vr 360
     * @returns {object} updated object with valid property names
     * @private
     */
    _correctParametersName: function _correctParametersName(vrParams) {
      switch (this.contentTree.movie_attributes.vr360type) {
        case 'stereo_lr':
          vrParams.stereo = true;
          vrParams.contentType = 'sbs';
          break;

        case 'stereo_tb':
          vrParams.stereo = true;
          vrParams.contentType = 'tab';
          break;

        default:
          break;
      }

      return vrParams;
    },

    /**
     * Called when playback is started.  Triggers intention to start playback of the main video.
     * @method PlaybackController#initialPlay
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {number} unixTimeMs The unix timestamp of the initial playtime
     * @param {boolean} wasAutoplayed True if the video was autoplayed, false otherwise
     * @fires OO.EVENTS.WILL_PLAY_FROM_BEGINNING
     */
    initialPlay: function initialPlay(eventName, unixTimeMs, wasAutoplayed) {
      this.initialPlayHasOccurred = true;

      if (this.willPlayFromBeginning) {
        this.mb.publish(OO.EVENTS.WILL_PLAY_FROM_BEGINNING);
      }

      this.willPlayFromBeginning = false;
    },

    /**
     * Called when playback on the content video should be started.
     * Brings the main video element into focus and triggers playback.
     * @method PlaybackController#onWillPlayFromBeginning
     * @protected
     * @fires OO.EVENTS.PLAY
     * @fires OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT
     */
    onWillPlayFromBeginning: function onWillPlayFromBeginning() {
      // PLAYER-3465 We need to reset initialBitrateDataSent so we report to IQ
      // about initial bitrates.
      this.initialBitrateDataSent = false;

      if (!this.playerParams || !this.playerParams.ooyalaAds) {
        this.mb.publish(OO.EVENTS.VC_SET_INITIAL_TIME, OO.VIDEO.MAIN, this.initialTime);
      }

      if (!this.playingAds) {
        this.mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, this.currentPlaybackElement);
        this.mb.publish(OO.EVENTS.PLAY);
      }
    },

    /**
     * Called when the video element has been created.  Triggers preloading and autoplay.
     * @method PlaybackController#vcVideoElementCreated
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {object} elementParams Properties of the video element including its domId and supported encodings
     */
    vcVideoElementCreated: function vcVideoElementCreated(eventName, elementParams) {
      if (this.currentPlaybackElement && elementParams['videoId'] === this.currentPlaybackElement) {
        if (this.currentPlaybackElement === OO.VIDEO.MAIN) {
          this.mainVideoElementCreated = true;
        }

        this.currentPlaybackElementCreated = true;
        this.tryPublishPlaybackReady();
      }
    },

    /**
     * Tries to publish the playback ready message. Will wait until the main video element has been created
     * and that the autoplay check has completed, if necessary.
     * @method PlaybackController#tryPublishPlaybackReady
     * @protected
     * @fires OO.EVENTS.PLAYBACK_READY
     */
    tryPublishPlaybackReady: function tryPublishPlaybackReady() {
      // PLAYER-3440: We only want to wait for the autoplay check if the autoplay check was performed
      var waitForAutoplayCheck = this.totalPrerollPods > 0 && this.autoplayEnabled() && this.runningAutoplayCheck && !this.delayForPreroll;
      var autoplayCheckDone = this.autoplayChecked || !waitForAutoplayCheck;

      if (!this.publishedPlaybackReady && this.currentPlaybackElementCreated && autoplayCheckDone && this.amcAllReady) {
        this.publishedPlaybackReady = true;
        OO.log('playbackready publishing, wait for autoplay check', waitForAutoplayCheck);
        var timeSincePlayerCreated = new Date().valueOf() - this.playerCreatedTime;
        this.mb.publish(OO.EVENTS.PLAYBACK_READY, timeSincePlayerCreated, {
          willAutoplay: this.shouldAutoplay()
        });
        this.preloadStream();
      }
    },

    /**
     * Called when a video element has been disposed.
     * @method PlaybackController#vcVideoElementDisposed
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} videoId The id of the video that was disposed
     */
    vcVideoElementDisposed: function vcVideoElementDisposed(eventName, videoId) {
      // On mobile web, we can't programmatically trigger a 'play' on a video element
      // that hasn't been previously started by a user gesture. If the element was just re-created,
      // it is a sure sign that it hasn't been played before and we need to make sure that we
      // don't attempt to autoplay it by mistake (on Android this will freeze the video)
      this.mobileContinuousPlayDisabled[videoId] = true;
    },

    /**
     * Fires when a new embed code is about to be set.
     * @method PlaybackController#setEmbedCode
     * @private
     * @param {string} eventName The name of the event that triggered this handler
     * @param {string} embedCode The new embed code (id) of the content to be set
     * @param {object} params The page-level parameters passed when SET_EMBED_CODE was triggered
     * @param {boolean} isExternalApiCall Determines whether or not this operation was started by an external API call (i.e. was requested by a user)
     */
    setEmbedCode: function setEmbedCode(eventName, embedCode, params, isExternalApiCall) {
      this.contentChangeRequestedExternally = !!isExternalApiCall;
    },

    /**
     * Fires when a new Standalone Player asset is about to be set.
     * @method PlaybackController#setAsset
     * @private
     * @param {string} eventName The name of the event that triggered this handler
     * @param {object} asset The asset metadata object passed when SET_ASSET was triggered
     * @param {object} params The page-level parameters passed when SET_ASSET was triggered
     * @param {boolean} isExternalApiCall Determines whether or not this operation was started by an external API call (i.e. was requested by a user)
     */
    setAsset: function setAsset(eventName, asset, params, isExternalApiCall) {
      this.contentChangeRequestedExternally = !!isExternalApiCall;
    },

    /**
     * Called when the stream is changed. Resets playback data and applies new parameters.
     * @method PlaybackController#embedCodeChanged
     * @private
     * @param {string} eventName The name of the event that triggered this handler
     * @param {object} embedCode The new embed code that was set
     * @param {object} params The page-level player parameters to be used for the new embed code
     */
    embedCodeChanged: function embedCodeChanged(eventName, embedCode, params) {
      // NOTE:
      // Any logic common to both embedCodeChanged and assetChanged should be added
      // to prepareForContentChange() instead of this handler
      this.prepareForContentChange(params);
      this.currentEmbedCode = embedCode;
    },

    /**
     * The Standalone Player equivalent to embedCodeChanged. Sets new content provided via the
     * setAsset() API, resets playback data and applies new parameters.
     * @method PlaybackController#assetChanged
     * @private
     * @param {string} eventName The name of the event that triggered this handler
     * @param {object} asset The asset metadata object passed when SET_ASSET was triggered
     * @param {object} params The page-level player parameters to be used for the new content
     */
    assetChanged: function assetChanged(eventName, asset, params) {
      // NOTE:
      // Any logic common to both embedCodeChanged and assetChanged should be added
      // to prepareForContentChange() instead of this handler
      this.prepareForContentChange(params); // Mimic fetching of Metadata, Content Tree, etc., by extracting user-provided
      // properties and manually calling dataReady()

      this.streams = this.getAssets(asset);
      this.closedCaptions = {
        'closed_captions': asset.content.captions.closed_captions,
        'closed_captions_vtt': asset.content.captions.closed_captions_vtt
      };
      this.dataReady();
    },

    /**
     * Initializes and resets the state of the Playback controller in preparation for new
     * content about to be set as a result of either a SET_EMBED_CODE or SET_ASSET
     * operation.
     * @method PlaybackController#prepareForContentChange
     * @private
     * @param {object} params The page-level params passed to either SET_EMBED_CODE or SET_ASSET events
     */
    prepareForContentChange: function prepareForContentChange(params) {
      this.playerParams = (0, _typeof2.default)(params) === 'object' ? params : {};
      this.clearBitrateTimers();
      this.resetStreamData();
      this.applyPlayerParams();
      this.setAutoPlayParam();
      this.willPlayFromBeginning = true;
      this.hasContentSet = true;

      if (this.initialPlayHasOccurred) {
        this.mb.publish(OO.EVENTS.MARKER_DATA_AVAILABLE, {
          list: []
        });
      }
    },

    /**
     * Called when the stream should resume.  Tells the video controller to play the stream.
     * @method PlaybackController#willResume
     * @protected
     * @fires OO.EVENTS.VC_PLAY
     */
    willResume: function willResume() {
      this.mb.publish(OO.EVENTS.VC_PLAY, this.currentPlaybackElement);
    },

    /**
     * Called when the video controller reports playback failure.  Raises playback error events.
     * @method PlaybackController#vcPlayFailed
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} videoId The id of the video element on which playback failed
     * @param {Object} errorDetails - The details of the error including the error code
     * @fires OO.EVENTS.PLAY_FAILED
     * @fires OO.EVENTS.ERROR
     */
    vcPlayFailed: function vcPlayFailed(eventName, videoId, errorDetails) {
      if (!this.currentPlaybackElement || videoId !== this.currentPlaybackElement) {
        return;
      }

      this.clearBitrateTimers();
      var mediaErrorAborted = window.MediaError ? window.MediaError.MEDIA_ERR_ABORTED : 1;
      var mediaErrorNetwork = window.MediaError ? window.MediaError.MEDIA_ERR_NETWORK : 2;
      var mediaErrorSourceNotSupported = window.MediaError ? window.MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED : 4; // Ooyala extension to window.MediaError codes indicating DRM error

      var mediaErrorDrm = 6;
      var mediaErrorNonRegisteredDevice = 22;
      var mediaErrorDeviceLimitReached = 29;
      this.mb.publish(OO.EVENTS.PLAY_FAILED, errorDetails.mediaErrorCode);
      var mediaErrorCode = parseInt(errorDetails.mediaErrorCode);
      var mediaErrorMessage;

      switch (mediaErrorCode) {
        case -1:
          mediaErrorMessage = 'An unknown error has occurred.';
          break;

        case 0:
          mediaErrorMessage = 'No stream found.';
          break;

        case 1:
          mediaErrorMessage = 'Aborted by user.';
          break;

        case 2:
          mediaErrorMessage = 'A network error occurred retrieving the video source.';
          break;

        case 3:
          mediaErrorMessage = 'Error decoding source.';
          break;

        case 4:
          mediaErrorMessage = 'Source is unsupported.';
          break;

        case 5:
          mediaErrorMessage = 'Source could not be decrypted.';
          break;

        case 6:
          mediaErrorMessage = 'A DRM server error has occurred.';
          break;

        case mediaErrorNonRegisteredDevice:
          mediaErrorMessage = 'Device not registered to viewer account.';
          break;

        case mediaErrorDeviceLimitReached:
          mediaErrorMessage = 'Device limit reached.';
          break;

        default:
          break;
      }

      var ooyalaErrorCode;
      var ooyalaErrorMessage; // TODO: Should mediaErrorAborted associate to it's own message?

      if (mediaErrorCode === mediaErrorAborted || mediaErrorCode === mediaErrorSourceNotSupported) {
        ooyalaErrorCode = OO.ERROR.PLAYBACK.GENERIC;
        ooyalaErrorMessage = 'Could not play the content.';
      } else if (mediaErrorCode === mediaErrorNetwork) {
        ooyalaErrorCode = OO.ERROR.PLAYBACK.NETWORK;
        ooyalaErrorMessage = 'The network connection was temporarily lost.';
      } else if (mediaErrorCode === mediaErrorDrm) {
        ooyalaErrorCode = OO.ERROR.API.SAS.ERROR_DRM_RIGHTS_SERVER_ERROR;
        ooyalaErrorMessage = 'DRM server error.';
      } else if (mediaErrorCode === mediaErrorNonRegisteredDevice) {
        ooyalaErrorCode = OO.ERROR.API.SAS.ERROR_NON_REGISTERED_DEVICE;
        ooyalaErrorMessage = 'Device not registered to viewer account.';
      } else if (mediaErrorCode === mediaErrorDeviceLimitReached) {
        ooyalaErrorCode = OO.ERROR.API.SAS.ERROR_DEVICE_LIMIT_REACHED;
        ooyalaErrorMessage = 'Device limit reached.';
      } else {
        if (this.contentTree) {
          switch (this.contentTree.content_type) {
            case 'Video':
              ooyalaErrorCode = OO.ERROR.VC.UNSUPPORTED_ENCODING;
              ooyalaErrorMessage = 'This video encoding is not supported on your device';
              break;

            case 'LiveStream':
              ooyalaErrorCode = OO.ERROR.PLAYBACK.LIVESTREAM;
              ooyalaErrorMessage = 'Live stream is off air.';
              break;

            default:
              ooyalaErrorCode = OO.ERROR.PLAYBACK.GENERIC;
              ooyalaErrorMessage = 'Could not play the content.';
          }
        }
      }

      errorDetails.ooyalaErrorCode = ooyalaErrorCode;
      errorDetails.ooyalaErrorMessage = ooyalaErrorMessage;
      errorDetails.mediaErrorMessage = mediaErrorMessage;
      this.mb.publish(OO.EVENTS.ERROR, {
        code: ooyalaErrorCode
      });

      if (errorDetails.playhead > 0) {
        this.mb.publish(OO.EVENTS.PLAYBACK_MIDSTREAM_ERROR, errorDetails);
      } else {
        this.mb.publish(OO.EVENTS.PLAYBACK_START_ERROR, errorDetails);
      }
    },

    /**
     * Called when the video controller encountered an error configuring a video element.  Raises error if
     * the video element was a main video element.
     * @protected
     * @param {string} eventName The name of the event raised.
     * @param {string} videoId The id of the video element which encountered a video controller error.
     * @param {object} error The details of the error including the error code.
     * @fires OO.EVENTS.ERROR
     */
    vcError: function vcError(eventName, videoId, error) {
      if (!this.currentPlaybackElement || videoId !== this.currentPlaybackElement) {
        return;
      }

      this.clearBitrateTimers();
      var errorDetails = {};

      if (error.ooyalaErrorCode === OO.ERROR.VC.UNSUPPORTED_ENCODING) {
        error.ooyalaErrorMessage = 'This device does not have an available decoder for this stream type.';
        errorDetails.code = error.ooyalaErrorCode;
      } else if (error.ooyalaErrorCode === OO.ERROR.VC.UNABLE_TO_CREATE_VIDEO_ELEMENT) {
        error.ooyalaErrorMessage = 'A video element to play the given stream could not be created.';
        errorDetails.code = error.ooyalaErrorCode;
      } else {
        errorDetails = error;
      }

      if (error.playhead > 0) {
        this.mb.publish(OO.EVENTS.PLAYBACK_MIDSTREAM_ERROR, error);
      } else {
        this.mb.publish(OO.EVENTS.PLAYBACK_START_ERROR, error);
      }

      this.mb.publish(OO.EVENTS.ERROR, errorDetails);
    },

    /**
     * Called when the video element received a play command and will be acting on it.  Raises willPlay if
     * the video element was a main video element.
     * @method PlaybackController#vcWillPlay
     * @protected
     * @param {string} event The name of the event raised
     * @param {string} videoId The id of the video element which reported willPlay
     * @fires OO.EVENTS.WILL_PLAY
     */
    vcWillPlay: function vcWillPlay(event, videoId) {
      if (this.playbackElements[videoId]) {
        this.mb.publish(OO.EVENTS.WILL_PLAY); // [pbw-1734] iOS fullscreen blocks the replay button, so mimic functionality here

        if (OO.isIos && this.endScreenShown) {
          this.mb.publish(OO.EVENTS.REPLAY);
        }

        this.endScreenShown = false; // We resume publishing bitrate info

        this.startBitrateStableTimer();
      }
    },

    /**
     * Called when the content video is replayed.
     * @method PlaybackController#replay
     * @param {String} event - eent name
     * @param {Number} initialTime - time to start playing
     * @protected
     * @fires OO.EVENTS.SEEK
     * @fires OO.EVENTS.WILL_PLAY_FROM_BEGINNING
     */
    replay: function replay(event, initialTime) {
      this.endScreenShown = false;

      if (this.bitrateOverrideTimer) {
        clearTimeout(this.bitrateOverrideTimer);
        this.bitrateOverrideTimer = null;
      }

      this.isBitrateOverrideReady.isBitrateOverridden = false;
      this.initialTime = initialTime || 0; // PBI-1736 Do not send 'seek' here.  WILL_PLAY_FROM_BEGINNING will take care
      // of setting the time back to the beginning of the video. Otherwise there
      // may be problems on Android w/ ads.

      this.mb.publish(OO.EVENTS.WILL_PLAY_FROM_BEGINNING);

      if (this.isVr) {
        this.mb.publish(OO.EVENTS.MOVE_VR_TO_DIRECTION, OO.VIDEO.MAIN, true, 'init');
      }
    },

    /**
     * Called when the video controller reports playback completion.  Raises played event.
     * @method PlaybackController#vcPlayed
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} videoId The id of the video element which reported played
     * @fires OO.EVENTS.PLAYED
     */
    vcPlayed: function vcPlayed(eventName, videoId) {
      if (!this.currentPlaybackElement || videoId !== this.currentPlaybackElement) return;
      this.clearBitrateTimers();
      this.endScreenShown = true;
      this.playedAtLeastOnce = true;
      this.mb.publish(OO.EVENTS.PLAYED);
    },

    /**
     * Called when the video controller reports playback in progress.  Raises playing event.
     * @method PlaybackController#vcPlaying
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} videoId The id of the video element which reported playing
     * @fires OO.EVENTS.PLAYING
     */
    vcPlaying: function vcPlaying(eventName, videoId) {
      if (!this.currentPlaybackElement || videoId !== this.currentPlaybackElement) {
        return;
      }

      if (!this.initialBitrateDataSent) {
        this.initialBitrateDataSent = true;
        this.mb.publish(OO.EVENTS.BITRATE_INITIAL, this.currentBitrate);
        this.startBitrateTimers();
      }

      if (videoId === OO.VIDEO.MAIN) {
        if (this.autoplayed && !this.contentStarted && !this.isAudioOnlyAsset) {
          this.fetchThumbnails();

          if (this.shouldDisplayMarkers()) {
            this.loadMarkers();
          }
        }

        this.contentStarted = true;
      }

      this.hasPlayed = true; // Once a video has been played by the user, we are allowed to trigger
      // "play" programmatically in order to achieve continuous playback on mobile

      this.mobileContinuousPlayDisabled[videoId] = false; // used to check this.userRequest before raising

      this.mb.publish(OO.EVENTS.PLAYING);
    },
    vcCanPlay: function vcCanPlay(eventName, videoId) {
      if (this.currentPlaybackElement === videoId) {
        this.mb.publish(OO.EVENTS.CAN_PLAY);
      }
    },

    /**
     * Called when the video controller reports playback paused.  Raises paused event.
     * @method PlaybackController#vcPaused
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} videoId The id of the video element which reported paused
     * @fires OO.EVENTS.PAUSED
     */
    vcPaused: function vcPaused(eventName, videoId) {
      this.clearBitrateTimers();
      this.bitrateTimerPassed += Date.now() - this.bitrateTimerStartTime;
      if (!this.currentPlaybackElement || videoId !== this.currentPlaybackElement) return;
      this.mb.publish(OO.EVENTS.PAUSED);
    },

    /**
     * Called when the video controller reports video seeked.  Raises seeked event.
     * method PlaybackController#vcSeeked
     * @protected
     * @param {string} eventName The name of the event raised
     * @param {string} videoId The id of the video element which reported paused
     * @param {number} playhead The current time of the video after seeking
     * @fires OO.EVENTS.SEEKED
     */
    vcSeeked: function vcSeeked(eventName, videoId, playhead) {
      if (!this.currentPlaybackElement || videoId !== this.currentPlaybackElement) return;
      this.mb.publish(OO.EVENTS.SEEKED, playhead);
    },

    /**
     * Called when the main video playback is completed.  Preloads the stream and checks for loop play.
     * @method PlaybackController#played
     * @protected
     */
    played: function played() {
      this.playedAtLeastOnce = true;
      this.preloaded = false;
      this.preloadStream(); // re-initiate the playback ready for replay.

      this.triggerLoopPlay();
    },

    /**
     * Callback to the AMC_ALL_READY message bus event. Checks to see if we can preload the stream.
     * @method PlaybackController#onAmcAllReady
     * @protected
     * @param {string} eventName The name of the event
     * @param {object} params Ad manager controller params
     */
    onAmcAllReady: function onAmcAllReady(eventName, params) {
      this.amcAllReady = true;

      if (params) {
        this.totalPrerollPods = params.prerolls;

        if (!this.totalPrerollPods) {
          this.prerollsDone = true;
          this.preloadStream();
        }
      }

      this.tryPublishPlaybackReady();
    },

    /**
     * Callback to the AMC_PREROLLS_DONE message bus event. Checks to see if we can preload the stream.
     * @method PlaybackController#onAmcPrerollsDone
     * @protected
     */
    onAmcPrerollsDone: function onAmcPrerollsDone() {
      this.prerollsDone = true;
      this.preloadStream();
    },

    /**
     * Callback to the SDK_AD_EVENT message bus event. Checks to see if we can preload the stream.
     * @method PlaybackController#onSdkAdEvent
     * @protected
     * @param {string} event Core message bus event name
     * @param {string} adPluginName The name of the ad plugin that sent this event
     * @param {string} adEventName The name of this event from the ad plugin
     * @param {object} adEventData An object containing details of the ad event. This may vary
     *                               between ad plugin to ad plugin.
     */
    onSdkAdEvent: function onSdkAdEvent(event, adPluginName, adEventName, adEventData) {
      var thresholdEvent = (OO.playerParams || {}).preloadThresholdEvent || this.PRELOAD_THRESHOLD_EVENT;

      if (this.finalPreroll && adEventName === thresholdEvent) {
        this.reachedPrerollThresholdForPreloading = true;
        this.preloadStream();
      }
    },

    /**
     * Callback to the AD_POD_STARTED message bus event. Keeps track of
     * how many ads there are in an ad pod.
     * @method PlaybackController#onAdPodStarted
     * @protected
     * @param {string} event The event name
     * @param {number} numberOfAds The number of ads in the ad pod
     */
    onAdPodStarted: function onAdPodStarted(event, numberOfAds) {
      // Set refreshTimers to ensure the timers reset (instead of resume) after ad pod end
      // We do this to allow the stream some time to rebuffer after the ads end
      this.refreshTimers = true;
      this.clearBitrateTimers();
      this.currentPodSize = numberOfAds;
      this.currentPrerollPod++;
    },

    /**
     * Callback to the WILL_PLAY_SINGLE_AD message bus event. Checks to see if
     * the current ad is the final ad in an ad pod
     * @method PlaybackController#onWillPlaySingleAd
     * @protected
     * @param {string} event The event name
     * @param {object} properties The ad properties
     */
    onWillPlaySingleAd: function onWillPlaySingleAd(event, properties) {
      if (properties && this.currentPrerollPod === this.totalPrerollPods && properties.indexInPod === this.currentPodSize && !this.contentStarted) {
        this.finalPreroll = true;
      }
    },

    /**
     * Callback to the WILL_PLAY_ADS message bus event. Will store that
     * we are currently playing ads.
     * @method PlaybackController#onWillPlayAds
     * @protected
     * @param {string} event The event name
     */
    onWillPlayAds: function onWillPlayAds(event) {
      this.playingAds = true;
    },

    /**
     * Callback to the ADS_PLAYED message bus event. Will store that
     * we are no longer playing ads.
     * @method PlaybackController#onAdsPlayed
     * @protected
     * @param {string} event The event name
     */
    onAdsPlayed: function onAdsPlayed(event) {
      this.playingAds = false;
    },

    /**
     * Callback to the CANCEL_GEO_CHECKING message bus event.
     * Cancel SetInterval() for geochecking
     * @method PlaybackController#onCancelGeoChecking
     * @protected
     */
    onCancelGeoChecking: function onCancelGeoChecking() {
      if (typeof OO.geoCheckingInterval === 'number') {
        clearInterval(OO.geoCheckingInterval);
        OO.geoCheckingInterval = null;
      }
    }
  });

  OO.registerModule('playbackController', function (messageBus, id) {
    return new PlaybackController(messageBus, id);
  });
})(OO, OO._, OO.$);

},{"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":18}],78:[function(require,module,exports){
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

/*
 * Video Controller
 * Controls and manages video player plugins. Acts as an interface between CORE and the actual video player.
 * Handles transition between main video player and ads player
 */

/* eslint no-magic-numbers: "off" */
(function (OO, _, $) {
  /**
   * Logs data to the browser console in debug mode.
   * @private
   * @method log
   */
  var log = function log() {
    OO.log.apply(this, $.merge(['VC:'], arguments));
  };
  /**
   * The list of registered plugins
   * key: video plugin name (string)
   * value: video plugin (object)
   * @private
   * @field registeredPlugins
   */


  var registeredPlugins = {};
  /**
   * The list of encodings to a videoPlugin name.
   * key: encoding (ex: OO.VIDEO.ENCODING.MP4) (string)
   * value: video plugin names (Queue or Array)
   * @private
   * @field encodingToPlugins
   */

  var encodingToPlugins = {};
  /**
   * Retrieves a list of the supported encodings.
   * @private
   * @method getSupportedEncodings
   */

  var getSupportedEncodings = _.bind(function () {
    var encodings = [];

    _.each(encodingToPlugins, function (value, index) {
      if (value && value.length > 0) encodings.push(index);
    });

    return encodings;
  }, this);
  /**
   * @class OO.Video
   * @classdesc Provides the ability to register, verify, and unregister video plugins within the Ooyala player.
   * @public
   */


  OO.Video = {
    /**
     * Registers a new video plugin. The format of the video plugin is validated, and
     * the video plugin is only registered if it defines the required functions and properties.
     * @public
     * @method OO.Video#register
     * @param {object} videoPlugin The video plugin object to be registered.
     */
    plugin: function plugin(videoPlugin) {
      if (!this.validate(videoPlugin)) {
        return;
      }

      log('Registering video plugin:', videoPlugin.name);

      for (var index = 0; index < videoPlugin.encodings.length; index++) {
        var encoding = videoPlugin.encodings[index];

        if (encodingToPlugins[encoding]) {
          encodingToPlugins[encoding].push(videoPlugin.name);
        } else {
          encodingToPlugins[encoding] = [videoPlugin.name];
        }
      }

      registeredPlugins[videoPlugin.name] = videoPlugin;
    },

    /**
     * Unregisters a video plugin.
     * @public
     * @method OO.Video#unregister
     * @memberOf OO.Video
     * @param {string} name The name of the video plugin to unregister, traditionally represented by
     *                      <code>videoPlugin.name</code>.
     */
    unregister: function unregister(name) {
      log('Removing a video plugin:', name);

      if (name && registeredPlugins[name]) {
        // Removes plugin from encodingToPlugin
        for (var index = 0; index < registeredPlugins[name].encodings.length; index++) {
          var encoding = registeredPlugins[name].encodings[index];
          var priorityIndex = encodingToPlugins[encoding] ? encodingToPlugins[encoding].indexOf(name) : -1;

          if (priorityIndex > -1) {
            encodingToPlugins[encoding].splice(priorityIndex, 1);
          }
        } // Removes plugin from registeredPlugins


        if (_.isFunction(registeredPlugins[name].destroy)) {
          try {
            registeredPlugins[name].destroy();
          } catch (err) {
            log('Error destroying a video plugin', name, '.', err);
          }
        }

        delete registeredPlugins[name];
      }
    },

    /**
     * Validates the format of a video plugin and checks if it is already registered.<br/>
     * The video plugin must define the following functions:<br/>
     * <ul>
     *    <li><code>create()</code></li>
     * </ul>
     * The video plugin must define the following properties:
     * <ul>
     *     <li><code>name (string)</code></li>
     *     <li><code>encodings (array)</code></li>
     *     <li><code>features (array)</code></li>
     *     <li><code>technology (string)</code></li>
     * </ul>
     * @public
     * @method validate
     * @memberOf OO.Video
     * @instance
     * @param {object} videoPlugin The video plugin object.
     * @returns {boolean} <code>true</code> if the video plugin meets the template requirements,
     * <code>false</code> otherwise.
     */
    validate: function validate(videoPlugin) {
      // TODO: Enhance this to support type array
      var properties = {
        'name': 'string',
        'encodings': 'object',
        'features': 'object',
        'technology': 'string'
      };
      var functions = ['create'];
      /**
       *
       * @param {String} errorString - text for error log
       */

      function raiseValidationError(errorString) {
        log(errorString); // TODO - raise real error
      }
      /**
       *
       * @param {String} propertyName - ?
       * @param {String} propertyType - ?
       * @param {String} managerName - ?
       * @returns {boolean} - ?
       */


      function checkForProperty(propertyName, propertyType, managerName) {
        if (!_.has(videoPlugin, propertyName)) {
          raiseValidationError("The video plugin '" + managerName + "' requires a '" + propertyName + "' property");
          return false;
        }

        if ((0, _typeof2.default)(videoPlugin[propertyName]) !== propertyType) {
          // eslint-disable-line valid-typeof
          raiseValidationError("The video plugin '" + managerName + "' property '" + propertyName + "' should be type '" + propertyType + "'");
          return false;
        }

        return true;
      }
      /**
       *
       * @param {String} functionName - ?
       * @param {String} managerName - ?
       * @returns {boolean} - ?
       */


      function checkForFunction(functionName, managerName) {
        if (!_.isFunction(videoPlugin[functionName])) {
          raiseValidationError("The video plugin '" + managerName + "' requires a '" + functionName + "' function");
          return false;
        }

        return true;
      }

      if (!videoPlugin) {
        raiseValidationError('The video plugin must be defined');
        return false;
      }

      if (!_.isObject(videoPlugin)) {
        raiseValidationError('The video plugin must be an object');
        return false;
      }

      for (var key in properties) {
        if (!checkForProperty(key, properties[key], videoPlugin.name)) return false;
      }

      for (var functionIndex = 0; functionIndex < functions.length; functionIndex++) {
        if (!checkForFunction(functions[functionIndex], videoPlugin.name)) return false;
      }

      if (registeredPlugins[videoPlugin.name]) {
        raiseValidationError("The video plugin '" + videoPlugin.name + "' has already been registered");
        return false;
      }

      return true;
    },

    /**
     * Returns a list of all registered video plugins.  This is primarily used in testing.
     * @private
     * @method OO.Video#getRegisteredPlugins
     * @returns {object} All registered video plugins, referenced by name.
     */
    getRegisteredPlugins: function getRegisteredPlugins() {
      return registeredPlugins;
    }
  };
  OO.exposeStaticApi('Video', OO.Video);
  /**
   * @class OO.VideoControllerInterface
   * @classdesc The interface to the controller provided to a plugin.
   * @public
   * @param {Object} vtc The video tech controller instance
   * @param {String} videoId The id of the video instance
   * @param {String} electedPlugin The plugin from which the video element is built
   */

  var VideoControllerInterface = function VideoControllerInterface(vtc, videoId, electedPlugin) {
    this.videoId = videoId;
    /**
     * Event types accepted by the video controller from video plugins for the <code>notify()</code> method.
     * See VideoController#EVENTS for the full list of events and associated parameters.
     * @field VideoControllerInterface#EVENTS
     * @public
     */

    this.EVENTS = vtc.EVENTS;
    /**
     * Notifies the Video Controller of an event from the video.
     * @method VideoControllerInterface#notify
     * @public
     * @param {string} eventName The event name (see VideoController#EVENTS).
     * @param {object} eventparams The event parameters.
     *                             See VideoController#EVENTS for the required parameters for each event.
     */

    this.notify = _.bind(function (eventName, eventparams) {
      return vtc.notify(this.videoId, electedPlugin, eventName, eventparams);
    }, this);
    /**
     * Notifies the Video Controller that the video element is not ready to receive play commands.  This
     * will only have an effect if called before returning the element in the create API.
     * This should only be used in cases when the video wrapper will not be able to handle play events
     * in a synchronous fashion on devices such as Android that require playback directly upon user click.
     * @method VideoControllerInterface#markNotReady
     * @public
     */

    this.markNotReady = _.bind(vtc.markNotReady, vtc, this.videoId);
    /**
     * Notifies the Video Controller that the video element is ready to receive play commands.  This function
     * should only be called if VideoControllerInterface.markNotReady was called.
     * @method VideoControllerInterface#markReady
     * @public
     */

    this.markReady = _.bind(vtc.markReady, vtc, this.videoId); // temp placeholder, required by bitmovin plugin

    this.PLUGIN_MAGIC = '087d2ef5-9d39-43ed-a57a-16a312c87c0b';
  };
  /**
   * @class VideoController
   * @classdesc The video controller main class.  This class is registered as a module with the player.
   * @private
   * @param {object} messageBus The player message bus
   * @param {string} id The ID of the player module
   * @property {object} activeInstances An object of active video instances referenced by unique video ids
   * @property {string} focusVideoId The id of the video currently in focus
   * @property {string} elementId The id of the root element this video controller will interact with
   */


  var VideoController = function VideoController(messageBus, id) {
    // constants
    var READY_TIMEOUT = 3000; // TODO: Move into constants. Until then, these values should match the
    // ones defined in playback_controller.js

    this.IOS_PLAY_MODE_OPTIONS = {
      INLINE: 'inline',
      FULLSCREEN: 'fullscreen'
    }; // module variables

    var mb = messageBus;
    var readyTimer = null;
    var elementsNotReady = []; // element variables

    var activeElements = [];
    var rootElement = null; // element properties

    this.activeInstances = {};
    this.focusVideoId = null;
    var activeLanguage = '';
    var ccMode = OO.CONSTANTS.CLOSED_CAPTIONS.SHOWING;
    this.elementId = null;
    this.currentPlayhead = 0;
    this.currentDuration = 0;
    this.failoverPlayhead = 0;
    this.handleFailover = false;
    this.paused = true;
    this.pauseAfterReload = false;
    this.initialPlayTime = -1;
    this.hasPlayedAd = false;
    this.isVideoTypeChanged = false;
    this.startPositionVr = 0;
    this.isVr = false;
    this.initialPlayHasStarted = false;
    this.defaultAudioTracks = {};
    this.desiredPlaybackSpeed = 1.0;
    this.vrVideoId = OO.VIDEO.MAIN; // multiaudio

    this.ALLOWED_MULTI_AUDIO_ENCODINGS = [OO.VIDEO.ENCODING.DASH, OO.VIDEO.ENCODING.HLS, OO.VIDEO.ENCODING.DRM.HLS, OO.VIDEO.ENCODING.DRM.DASH];

    this.toString = function () {
      return 'video-controller';
    };
    /**
     * A wrapper for video elements.
     * @constructor
     * @private
     * @param {object} params The parameters for the video element.
     *                        It must contain the following fields:<br/>
     *   plugin {object} The plugin that created the video element<br />
     *   parentContainer {object} The parent element of the video element<br />
     *   wrapper {object} The video wrapper
     * @property {string} plugin The name of the plugin used to create this element
     * @property {string} domId The DOM ID of the video element
     * @property {object} supportedEncodings A list of encodings supported by the element
     * @property {object} parentContainer The parent element of the video element
     * @property {object} wrapper The element wrapper created by the video plugin
     * @property {string} sharedObjectToInstance The name of the instance that shares the video object with
     *   this element (usually null)
     * @property {boolean} isControllingObject True if the wrapper is currently controlling the video element
     * @property {boolean} primedForUnmutedAutoPlayback True if the video element has been primed for unmuted auto-
     *                                                  playback, false otherwise.
     */


    var VideoElement = function VideoElement(params) {
      this.plugin = params.plugin && params.plugin.name;
      this.domId = _generateUniqueName();
      this.supportedEncodings = params.plugin.encodings || [];
      this.parentContainer = params.parentContainer || rootElement && rootElement.find('.innerWrapper') || null;
      this.wrapper = params.wrapper;
      this.sharedObjectToInstance = params.sharedObjectToInstance;
      this.isControllingObject = params.isControllingObject === undefined ? true : params.isControllingObject;
      this.primedForUnmutedAutoPlayback = false;
    };
    /**
     * A wrapper object for video instances.
     * @constructor
     * @private
     * @param {object} params The parameters for the video instance.
     *                        It must contain the following fields:<br/>
     *   plugin {object} The plugin that created the video element<br />
     *   parentContainer {object} The parent element of the video element<br />
     *   element {object} The video element object<br />
     *   isControllingElement {boolean} True if the instance is controlling the video element<br />
     *   stream {object} The stream url and drm associated with the instance<br />
     *   vtcInterface {object} The instance's interface with the vtc<br />
     *   closedCaptions {object} The closed captions object that contains the possible closed captions<br />
     *   crossorigin {string} The crossorigin attribute value if there is one to be set<br />
     *   params {string} The full list of instance parameters<br />
     * @property {object} element Points to the element wrapped by this object
     * @property {boolean} isControllingElement True if the actual element is controlled by this instance.
     *                                          Instances that share existing elements initialize to false.
     * @property {number} playhead The last saved playhead value of the stream, used to resume after unloading
     * @property {string} encoding The encoding of the last stream used
     * @property {object} stream The last stream used
     * @property {object} vtcInterface The interface to the vtc used by the element
     * @property {object} closedCaptions The closed captions object that contains the possible closed captions
     * @property {object} crossorigin The crossorigin attribute value
     * @property {boolean} isLive True if it is a live asset, false otherwise
     * @property {boolean} playing True if the video is current playing
     * @property {boolean} disableNativeSeek True if the video element should disable seeks that come from the
     *                                       native video element.
     */


    var VideoInstance = function VideoInstance(params) {
      this.plugin = params.plugin && params.plugin.name;
      this.parentContainer = params.parentContainer;
      this.element = params.element || null;
      this.isControllingElement = !!params.isControllingElement;
      this.playhead = 0;
      this.encoding = params.encoding || null;
      this.stream = params.stream || null;
      this.vtcInterface = params.vtcInterface || {};
      this.closedCaptions = params.closedCaptions || {};
      this.crossorigin = params.crossorigin || null;
      this.isLive = params.isLive || false;
      this.params = params.params || {};
      this.playing = false;
      this.disableNativeSeek = false;
    }; // state variables
    // TODO: Just use the replay event directly


    var pageLevelParams = {};
    var contentTree = {};
    var skinConfig = {};
    var errorTimer = null;
    var shouldEmitErrors = true;
    var unemittedErrors = [];
    var currentVolume = 1;
    var currentMuteState = false;
    var muteFirstPlay = false;
    var savedMainVolume = null;
    var isPlaybackReady = false;
    var csaiMode = false;
    var iosPlayMode = this.IOS_PLAY_MODE_OPTIONS.FULLSCREEN;
    var isHAFailoverMechanismEnabled = false;
    var currentEmbedCode = null;
    var movieAttributes = {};
    var embedCodeMetadata = {}; // autoplay state variables

    var autoplayed = false;
    var mutingForAutoplay = false;
    var playbackVideoAfterMute = null;
    var primeVideosOnPlay = false;
    var canAutoplay = {};
    var isChromeCasting = false;
    /**
     * Event types accepted by the Video Controller from video plugins for the notify API
     * @public
     * @field VideoController#EVENTS
     */

    this.EVENTS = {
      /**
       * @constant VideoController.EVENTS.PLAY
       * @type {string}
       * @description <code>VideoController.EVENTS.PLAY ('play')</code>:
       *   The video will begin to play.
       *   It should meet the following guidelines:<br />
       *    - It should be raised each time a play command is going to be executed.<br />
       *    - It need not be raised before the play occurs<br />
       *   Expected params: {url:string}
       */
      PLAY: 'play',

      /**
       * @constant VideoController.EVENTS.CAN_PLAY
       * @type {string}
       * @description <code>VideoController.EVENTS.CAN_PLAY ('canPlay')</code>:
       *   Play can be called because the video renderer is ready.
       *   It should meet the following guidelines:<br />
       *    - It should be raised each time a stream is loaded and becomes ready to receive play commands<br />
       *    - It does not need to be called after a seek<br />
       *    - It does not need to be called after an underflow<br />
       *   Expected params: none
       */
      CAN_PLAY: 'canPlay',

      /**
       * @constant VideoController.EVENTS.PLAYING
       * @type {string}
       * @description <code>VideoController.EVENTS.PLAYING ('playing')</code>:
       *   The video has begun to play
       *   It should meet the following guidelines:<br />
       *    - It should be raised each time a play is initiated, whether coming from seek, paused, or initial play<br />
       *    - It need not be raised after an underflow<br />
       *   Expected params: none
       */
      PLAYING: 'playing',

      /**
       * @constant VideoController.EVENTS.ENDED
       * @type {string}
       * @description <code>VideoController.EVENTS.ENDED ('ended')</code>:
       *   The video has ended.
       *   It should meet the following guidelines:<br />
       *    - It should be raised once each time a stream reaches the end<br />
       *    - It should mark the end of the play session<br />
       *    - It should be raised at the end of a replayed stream<br />
       *   Expected params: none
       */
      ENDED: 'ended',

      /**
       * @constant VideoController.EVENTS.ERROR
       * @type {string}
       * @description <code>VideoController.EVENTS.ERROR ('error')</code>:
       *   The video has encountered an error.
       *   It should meet the following guidelines:<br />
       *    - It should <br />
       *   Expected params: {errorcode:object}
       */
      ERROR: 'error',

      /**
       * @constant VideoController.EVENTS.SEEKING
       * @type {string}
       * @description <code>VideoController.EVENTS.SEEKING ('seeking')</code>:
       *   The video is being seeked.
       *   It should meet the following guidelines:<br />
       *    - It should be raised as soon as seeking has begun<br />
       *    - It may be raised any number of times during a seek<br />
       *    - It should not be raised after SEEKED<br />
       *    - It should not be raised if attempting to seek outside of the seek range
       *      (if seeking is not possible or will not succeed)<br />
       *   Expected params: none
       */
      SEEKING: 'seeking',

      /**
       * @constant VideoController.EVENTS.SEEKED
       * @type {string}
       * @description <code>VideoController.EVENTS.SEEKED ('seeked')</code>:
       *   The video has seeked.
       *   It should meet the following guidelines:<br />
       *    - It should be raised before time updates at the new position are raised<br />
       *   Expected params: none
       */
      SEEKED: 'seeked',

      /**
       * @constant VideoController.EVENTS.PAUSED
       * @type {string}
       * @description <code>VideoController.EVENTS.PAUSED ('paused')</code>:
       *   The video has paused.
       *   It should meet the following guidelines:<br />
       *    - It should be raised when the paused state is entered<br />
       *    - It should not be raised when the video has stopped playing due to underflow<br />
       *    - It does not need to be raised when a stream is loaded; the state will be assumed to be paused
       *      until PLAYING is raised<br />
       *   Expected params: none
       */
      PAUSED: 'paused',

      /**
       * @constant VideoController.EVENTS.PLAYBACK_RATE_CHANGE
       * @type {string}
       * @description <code>VideoController.EVENTS.PLAYBACK_RATE_CHANGE ('playbackRateChange')</code>:
       *   The video speed has changed.
       *   Expected params: {playbackRate:number}
       */
      PLAYBACK_RATE_CHANGE: 'playbackRateChange',

      /**
       * @constant VideoController.EVENTS.STALLED
       * @type {string}
       * @description <code>VideoController.EVENTS.STALLED ('stalled')</code>:
       *   The stream is attempting to fetch new data but is not receiving the expected data.
       *   It should meet the following guidelines:<br />
       *    - It can be raised while the stream is still playing<br />
       *   Expected params: {url:string}
       */
      STALLED: 'stalled',

      /**
       * @constant VideoController.EVENTS.TIME_UPDATE
       * @type {string}
       * @description <code>VideoController.EVENTS.TIME_UPDATE ('timeupdate')</code>:
       *   The stream has changed time position.
       *   It should meet the following guidelines:<br />
       *    - It should be raised at least twice per second while the video is playing.<br />
       *    - It need not be raised while the video is paused.<br />
       *    - It should not be raised after and video has raised the ENDED event.<br />
       *    - Once the seeking event has been raised, this event should not be raised until the seek has completed.<br />
       *    - It should not be raised before initial time has been reached.<br />
       *   Expected params:
       *   {currentTime:number, duration:number, buffer:number, seekRange:{end:number, start:number}
       */
      TIME_UPDATE: 'timeupdate',

      /**
       * @constant VideoController.EVENTS.VOLUME_CHANGE
       * @type {string}
       * @description <code>VideoController.EVENTS.VOLUME_CHANGE ('volumechange')</code>:
       *   The stream has changed volume.
       *   Expected params: {volume:number}
       */
      VOLUME_CHANGE: 'volumechange',

      /**
       * @constant VideoController.EVENTS.MUTE_STATE_CHANGE
       * @type {string}
       * @description <code>VideoController.EVENTS.MUTE_STATE_CHANGE ('mutestatechange')</code>:
       *   The stream has changed muted state>
       *   Expected params: {muted:boolean}
       */
      MUTE_STATE_CHANGE: 'mutestatechange',

      /**
       * @constant VideoController.EVENTS.BUFFERING
       * @type {string}
       * @description <code>VideoController.EVENTS.BUFFERING ('buffering')</code>:
       *   The stream is buffering.
       *   It should meet the following guidelines:<br />
       *    - It should be raised when buffering state is entered<br />
       *    - It can be raised any number of times during buffering but only once is required<br />
       *    - It should not be raised after BUFFERED unless buffering state has been entered again<br />
       *   Expected params: {url:string}
       */
      BUFFERING: 'buffering',

      /**
       * @constant VideoController.EVENTS.BUFFERED
       * @type {string}
       * @description <code>VideoController.EVENTS.BUFFERED ('buffered')</code>:
       *   The stream has buffered.
       *   It should meet the following guidelines:<br />
       *    - It should be raised when buffering state has exited<br />
       *   Expected params: {url:string}
       */
      BUFFERED: 'buffered',

      /**
       * @constant VideoController.EVENTS.DURATION_CHANGE
       * @type {string}
       * @description <code>VideoController.EVENTS.DURATION_CHANGE ('durationchange')</code>:
       *   The stream duration has changed.
       *   Expected params:
       *     {currentTime:number, duration:number, buffer:number, seekRange:{end:number, start:number}}
       */
      DURATION_CHANGE: 'durationchange',

      /**
       * @constant VideoController.EVENTS.PROGRESS
       * @type {string}
       * @description <code>VideoController.EVENTS.PROGRESS ('progress')</code>:
       *   Data is being fetched from the network.
       *   It should meet the following guidelines:<br />
       *    - It should <br />
       *   Expected params:
       *     {currentTime:number, duration:number, buffer:number, seekRange:{end:number, start:number}}
       */
      PROGRESS: 'progress',

      /**
       * @constant VideoController.EVENTS.WAITING
       * @type {string}
       * @description <code>VideoController.EVENTS.WAITING ('waiting')</code>:
       *   The playback buffer is empty but the player is attempting to stream.
       *   It should meet the following guidelines:<br />
       *    - It should be raised when playback stops due to buffer underflow<br />
       *   Expected params: {url:string}
       */
      WAITING: 'waiting',

      /**
       * @constant VideoController.EVENTS.FULLSCREEN_CHANGED
       * @type {string}
       * @description <code>VideoController.EVENTS.FULLSCREEN_CHANGED ('fullScreenChanged')</code>:
       *   The fullscreen state has changed.
       *   Expected params: {isFullScreen:boolean, paused:boolean}
       */
      FULLSCREEN_CHANGED: 'fullScreenChanged',

      /**
       * @constant VideoController.EVENTS.CAPTIONS_FOUND_ON_PLAYING
       * @type {string}
       * @description <code>VideoController.EVENTS.CAPTIONS_FOUND_ON_PLAYING ('captionsFoundOnPlaying')</code>:
       *   The video has detected captions on the video while playing.
       *   Expected params: {languages:[string], locale:{string:string}}
       */
      CAPTIONS_FOUND_ON_PLAYING: 'captionsFoundOnPlaying',

      /**
       * @constant VideoController.EVENTS.CAPTIONS_LANGUAGE_CHANGE
       * @type {string}
       * @description <code>VideoController.EVENTS.CAPTIONS_LANGUAGE_CHANGE ('captionsLanguageChange')</code>:
       *   The closed captions language has been changed by a process external to the player,
       *   such as the native fullscreen UI on iOS devices.
       *   Expected params: {language:string}
       */
      CAPTIONS_LANGUAGE_CHANGE: 'captionsLanguageChange',

      /**
       * @constant VideoController.EVENTS.ASSET_DIMENSION
       * @type {string}
       * @description <code>VideoController.EVENTS.ASSET_DIMENSION ('assetDimension')</code>:
       *   New video dimension information has been received.
       *   It should meet the following guidelines:<br />
       *    - It should be raised when video dimensions are first determined<br />
       *    - It should be raised any time the video dimensions change<br />
       *    - The dimensions should be specified in pixels<br />
       *   Expected params: {width:number,height:number}
       */
      ASSET_DIMENSION: 'assetDimension',

      /**
       * @constant VideoController.EVENTS.BITRATE_CHANGED
       * @type {string}
       * @description <code>VideoController.EVENTS.BITRATE_CHANGED ('bitrateChanged')</code>:
       *   The bitrate being played has changed.
       *   It should meet the following guidelines:<br />
       *    - It should be raised once when entering and exiting ABR mode<br />
       *    - It should not be raised while in ABR mode<br />
       *    - When entering ABR mode, the bitrate property should be set to the string "auto"<br />
       *    - The bitrate property should be specified in bits per second<br />
       *    - The height and width properties should indidicate the vertical and horizontal resolution of the
       *       stream<br />
       *   Expected params: {height:number, width:number, bitrate:(number|string)}
       */
      BITRATE_CHANGED: 'bitrateChanged',

      /**
       * @constant VideoController.EVENTS.BITRATES_AVAILABLE
       * @type {string}
       * @description <code>VideoController.EVENTS.BITRATES_AVAILABLE ('bitratesAvailable')</code>:
       *   There are multiple bitrates available to be played.
       *   It should meet the following guidelines:<br />
       *    - If ABR is available, parameters should contain an object whose bitrate property is set to the
       *       string "auto".<br />
       *    - The bitrate property should be specified in bits per second<br />
       *    - The height and width properties should indidicate the vertical and horizontal resolution of the
       *       stream<br />
       *   Expected params: [{height:number, width:number, bitrate:(number|string)}]
       */
      BITRATES_AVAILABLE: 'bitratesAvailable',

      /**
       * @constant VideoController.EVENTS.CLOSED_CAPTION_CUE_CHANGED
       * @type {string}
       * @description <code>VideoController.EVENTS.CLOSED_CAPTION_CUE_CHANGED ('closedCaptionCueChanged')</code>:
       *   The active closed captions text has changed.
       *   It should meet the following guidelines:<br />
       *    - The parameter should contain the text of the new closed caption cue<br />
       *    - Empty string parameter signifies no active cue<br />
       *   Expected params: string
       */
      CLOSED_CAPTION_CUE_CHANGED: 'closedCaptionCueChanged',

      /**
       * @constant VideoController.EVENTS.METADATA_FOUND
       * @type {string}
       * @description <code>VideoController.EVENTS.METADATA_FOUND ('metadataFound')</code>:
       *   A metadata tag, such as an ID3 tag, was found in the movie.
       *   It should meet the following guidelines:<br />
       *    - The type field indicates the data type, such as ID3<br />
       *    - The data field contains the tag data<br />
       *   Expected params: [{type:string, data:[object|string]}]
       */
      METADATA_FOUND: 'metadataFound',

      /**
       * @constant VideoController.EVENTS.PLUGIN_LOADED
       * @type {string}
       * @description <code>VideoController.EVENTS.PLUGIN_LOADED ('pluginLoaded')</code>:
       *   The video plugin wrapper has been loaded and registered.
       *    - The name field contains the name of the plugin loaded <br />
       *    - The time field contains the time taken to load the plugin
       *        in milliseconds<br />
       *   Expected params: [{name:string, time:number}]
       */
      PLUGIN_LOADED: 'pluginLoaded',

      /**
       * @constant VideoController.EVENTS.TOUCH_MOVE
       * @description <code>VideoController.EVENTS.TOUCH_MOVE ('touchMove')</code>:
       * Set video viewing direction
       * Gets 3 params:
       *  - yaw - rotation around the vertical axis
       *  - roll - rotation around the front-to-back axis
       *  - pitch - rotation around the side-to-side axis
       * type Expected params: [{yaw:number, roll: number, pitch: number}]
       */
      TOUCH_MOVE: 'touchMove',

      /**
       * @constant VideoController.EVENTS.CHECK_VR_DIRECTION
       * @description <code>VideoController.EVENTS.CHECK_VR_DIRECTION ('checkVrDirection')</code>:
       * Gets current video viewing direction and pass this value
       */
      CHECK_VR_DIRECTION: 'checkVrDirection',

      /**
       * @constant VideoController.EVENTS.ON_DOWNLOAD_FINISHED
       * @type {string}
       * @description <code>VideoController.EVENTS.ON_DOWNLOAD_FINISHED ('onDownloadFinished')</code>:
       *   Download of segment/manifest was finished.
       *   Expected params: [{type:string, data:[object]}]
       */
      ON_DOWNLOAD_FINISHED: 'onDownloadFinished',

      /**
       * @constant VideoController.EVENTS.ON_SEGMENT_LOADED
       * @type {string}
       * @description <code>VideoController.EVENTS.ON_SEGMENT_LOADED ('onSegmentLoaded')</code>:
       *   Segment was loaded.
       *   Expected params: [{type:string, data:[object]}]
       */
      ON_SEGMENT_LOADED: 'onSegmentLoaded',

      /**
       * @constant VideoController.EVENTS.UNMUTED_PLAYBACK_FAILED
       * @type {string}
       * @description <code>VideoController.EVENTS.UNMUTED_PLAYBACK_FAILED ('unmutedPlaybackFailed')</code>:
       *   The video attempted to play unmuted but failed to do so.
       *   Expected params: [error:[object]}]
       */
      UNMUTED_PLAYBACK_FAILED: 'unmutedPlaybackFailed',

      /**
       * @constant VideoController.EVENTS.UNMUTED_PLAYBACK_SUCCEEDED
       * @type {string}
       * @description <code>VideoController.EVENTS.UNMUTED_PLAYBACK_SUCCEEDED ('unmutedPlaybackSucceeded')</code>:
       *   The video attempted to play unmuted and succeeded.
       *   Expected params: []
       */
      UNMUTED_PLAYBACK_SUCCEEDED: 'unmutedPlaybackSucceeded',

      /**
       * @constant VideoController.EVENTS.MUTED_PLAYBACK_FAILED
       * @type {string}
       * @description <code>VideoController.EVENTS.MUTED_PLAYBACK_FAILED ('mutedPlaybackFailed')</code>:
       *   The video attempted to play muted but failed to do so.
       *   Expected params: [error:[object]}]
       */
      MUTED_PLAYBACK_FAILED: 'mutedPlaybackFailed',

      /**
       * @constant VideoController.EVENTS.MUTED_PLAYBACK_SUCCEEDED
       * @type {string}
       * @description <code>VideoController.EVENTS.MUTED_PLAYBACK_SUCCEEDED ('mutedPlaybackSucceeded')</code>:
       *   The video attempted to play muted and succeeded.
       *   Expected params: []
       */
      MUTED_PLAYBACK_SUCCEEDED: 'mutedPlaybackSucceeded',

      /**
       * Lists the available audio.
       * Includes id, kind, label, lang, enabled :
       * id - id of the audio track
       * kind - the type of the audio track (can be: "alternative", "description", "main", "translation", "commentary", or "" (empty string))
       * label - the label of the audio track
       * lang - the language of the audio track
       * enabled - the track is active (true|false)
       *
       * @event VideoController#EVENTS.MULTI_AUDIO_AVAILABLE
       * @public
       */
      MULTI_AUDIO_AVAILABLE: 'multiAudioAvailable',

      /**
       * Fires when the current track has been changed.
       * Provide the following arguments:
       * <ul>
       *   <li>list of multiaudio data with 'multiAudio' as a key</li>
       * </ul>
       *
       * @event VideoController#EVENTS.MULTI_AUDIO_CHANGED
       * @public
       */
      MULTI_AUDIO_CHANGED: 'multiAudioChanged',

      /**
       * Fires when need to set new audio as current
       * @event VideoController.#EVENTS.SET_CURRENT_AUDIO
       * @public
       */
      SET_CURRENT_AUDIO: 'setCurrentAudio'
    };
    var SETTINGS = {
      ENCODING_PRIORITY: 'encodingPriority',
      INITIAL_VOLUME: 'initialVolume',
      PAUSE_ON_LIVE_ADS: 'pauseOnLiveAds',
      IOS_PLAY_MODE: 'iosPlayMode',
      MUTE_FIRST_PLAY: 'muteFirstPlay',
      INITIAL_PLAYBACK_SPEED: 'initialPlaybackSpeed'
    };
    /**
     * List of encoding priority in-order. Can be managed by backlot/backdoor/page level params
     * The priority order is: pageLevel > backlot > backdoor > default
     * @private
     * @field VideoController#settingLevels
     */

    var settingLevels = {
      DEFAULT: 'default',
      PAGE: 'pageLevel',
      BACKLOT: 'backlot',
      BACKDOOR: 'backdoor',
      OOYALA_ADS: 'ooyalaAds'
    };
    var encodingPriority = {};
    encodingPriority[settingLevels.DEFAULT] = [OO.VIDEO.ENCODING.DRM.DASH, OO.VIDEO.ENCODING.DRM.HLS, OO.VIDEO.ENCODING.DASH, OO.VIDEO.ENCODING.HLS, OO.VIDEO.ENCODING.AKAMAI_HD2_VOD_HLS, OO.VIDEO.ENCODING.AKAMAI_HD2_HLS, OO.VIDEO.ENCODING.MP4, OO.VIDEO.ENCODING.YOUTUBE, OO.VIDEO.ENCODING.HDS, OO.VIDEO.ENCODING.WEBM, OO.VIDEO.ENCODING.IMA, OO.VIDEO.ENCODING.PULSE, OO.VIDEO.ENCODING.AUDIO_HLS, OO.VIDEO.ENCODING.AUDIO_M4A, OO.VIDEO.ENCODING.AUDIO_OGG];
    encodingPriority[settingLevels.OOYALA_ADS] = [OO.VIDEO.ENCODING.MP4];
    var chosenEncodingPriority = settingLevels.DEFAULT;
    var formerChosenEncodingPriority = null; // Record of the last set encoding priority if there was one.

    var initialCss = {
      'width': '100%',
      'height': '100%',
      'position': 'absolute',
      'visibility': 'hidden',
      'z-index': OO.CSS.VIDEO_Z_INDEX
    };

    if (OO.isIos) {
      initialCss['display'] = OO.CSS.INVISIBLE_DISPLAY;
    } else {
      initialCss['left'] = '-100000px';
    }

    var initialize = _.bind(function () {
      mb.subscribe(OO.EVENTS.PLAYER_CREATED, 'vtc', playerCreated);
      mb.subscribe(OO.EVENTS.AD_SDK_IMPRESSION, 'vtc', adSdkImpression);
      mb.subscribe(OO.EVENTS.INITIAL_PLAY, 'vtc', initialPlay);
      mb.subscribe(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, 'vtc', autoplayCheckComplete);
      mb.subscribe(OO.EVENTS.EMBED_CODE_METADATA_FETCHED, 'vtc', onEmbedCodeMetadataFetched);
      mb.subscribe(OO.EVENTS.METADATA_FETCHED, 'vtc', onMetadataFetched);
      mb.subscribe(OO.EVENTS.CONTENT_TREE_FETCHED, 'vtc', onContentTreeFetched);
      mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED, 'vtc', embedCodeChanged);
      mb.subscribe(OO.EVENTS.EMBED_CODE_CHANGED_AFTER_OOYALA_AD, 'vtc', embedCodeChanged);
      mb.subscribe(OO.EVENTS.ASSET_CHANGED, 'vtc', assetChanged);
      mb.subscribe(OO.EVENTS.PLAYBACK_READY, 'vtc', playbackReady);
      mb.subscribe(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, 'vtc', vcCreateVideoElement);
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'vtc', vcVideoElementCreated);
      mb.subscribe(OO.EVENTS.VC_UPDATE_ELEMENT_STREAM, 'vtc', vcUpdateElementStream);
      mb.subscribe(OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT, 'vtc', vcDisposeVideoElement);
      mb.subscribe(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, 'vtc', vcFocusVideoElement);
      mb.subscribe(OO.EVENTS.WILL_PLAY_ADS, 'vtc', willPlayAds);
      mb.subscribe(OO.EVENTS.ADS_PLAYED, 'vtc', adsPlayed);
      mb.subscribe(OO.EVENTS.VC_PRELOAD, 'vtc', vcPreload);
      mb.subscribe(OO.EVENTS.VC_RELOAD, 'vtc', vcReload);
      mb.subscribe(OO.EVENTS.VC_SET_INITIAL_TIME, 'vtc', vcSetInitialTime);
      mb.subscribe(OO.EVENTS.VC_SET_VIDEO_STREAMS, 'vtc', vcSetVideoStreams);
      mb.subscribe(OO.EVENTS.PLAY, 'vtc', play);
      mb.subscribe(OO.EVENTS.VC_PLAY, 'vtc', vcPlay);
      mb.subscribe(OO.EVENTS.PLAY_VIDEO_ELEMENT, 'vtc', playVideoElement);
      mb.subscribe(OO.EVENTS.PAUSE, 'vtc', pause);
      mb.subscribe(OO.EVENTS.VC_PAUSE, 'vtc', vcPause);
      mb.subscribe(OO.EVENTS.SEEK, 'vtc', seek);
      mb.subscribe(OO.EVENTS.VC_SEEK, 'vtc', vcSeek);
      mb.subscribe(OO.EVENTS.CHANGE_VOLUME, 'vtc', changeVolume);
      mb.subscribe(OO.EVENTS.CHANGE_MUTE_STATE, 'vtc', changeMuteState);
      mb.subscribe(OO.EVENTS.PAGE_UNLOAD_REQUESTED, 'vtc', pageUnloadRequested);
      mb.subscribe(OO.EVENTS.DISABLE_SEEKING, 'vtc', disableSeeking);
      mb.subscribe(OO.EVENTS.ENABLE_SEEKING, 'vtc', enableSeeking);
      mb.subscribe(OO.EVENTS.SET_CLOSED_CAPTIONS_LANGUAGE, 'vtc', setClosedCaptionsLanguage);
      mb.subscribe(OO.EVENTS.SET_TARGET_BITRATE, 'vtc', setTargetBitrate);
      mb.subscribe(OO.EVENTS.DESTROY, 'vtc', _.bind(this.onDestroy, this));
      mb.subscribe(OO.EVENTS.LIVE_BUTTON_CLICKED, 'vtc', onLiveClicked);
      mb.subscribe(OO.EVENTS.HA_WILL_FAILOVER, 'vtc', onHAWillFailover);
      mb.subscribe(OO.EVENTS.HA_FAILOVER_ERROR, 'vtc', onHAFailoverError);
      mb.subscribe(OO.EVENTS.HA_ENABLED, 'vtc', onHAEnabled);
      mb.subscribe(OO.EVENTS.VC_RELOAD_AND_PLAY, 'vtc', onReloadAndPlay);
      mb.subscribe(OO.EVENTS.TOGGLE_STEREO_VR, 'vtc', toggleStereoVr);
      mb.subscribe(OO.EVENTS.TOGGLE_FULLSCREEN_VR, 'vtc', toggleFullscreenVr);
      mb.subscribe(OO.EVENTS.TOUCH_MOVE, 'vtc', touchMove);
      mb.subscribe(OO.EVENTS.END_VR_MOVE, 'vtc', onEndVrMove);
      mb.subscribe(OO.EVENTS.CHECK_VR_DIRECTION, 'vtc', checkVrDirection);
      mb.subscribe(OO.EVENTS.MOVE_VR_TO_DIRECTION, 'vtc', moveVrToDirection);
      mb.subscribe(OO.EVENTS.VIDEO_VR, 'vtc', setVideoVr);
      mb.subscribe(OO.EVENTS.VIDEO_TYPE_CHANGED, 'vtc', onVideoTypeChanged);
      mb.subscribe(OO.EVENTS.SET_CURRENT_AUDIO, 'vtc', setCurrentAudio);
      mb.subscribe(OO.EVENTS.SKIN_CONFIG_LOADED, 'vtc', onSkinConfigLoaded);
      mb.subscribe(OO.EVENTS.SET_PLAYBACK_SPEED, 'vtc', onSetPlaybackSpeed);
      mb.subscribe(OO.EVENTS.CHROMECAST_START_CAST, 'vtc', onChromecastStartCast);
      mb.subscribe(OO.EVENTS.CHROMECAST_END_CAST, 'vtc', onChromecastEndCast);
    }, this); // ********************
    // Playback setup
    // ********************


    var playerCreated = _.bind(function (eventName, elementId, params, persistentSettings, embedCode, createdTime) {
      this.elementId = elementId;
      currentEmbedCode = embedCode;
      rootElement = $('#' + elementId);
      pageLevelParams = params;

      if (pageLevelParams) {
        // Check if encoding priority is set at page level
        if (pageLevelParams[SETTINGS.ENCODING_PRIORITY]) {
          encodingPriority[settingLevels.PAGE] = pageLevelParams[SETTINGS.ENCODING_PRIORITY]; // Update chosenSteamPriority to settingLevels.PAGE

          chosenEncodingPriority = settingLevels.PAGE;
        } // Collect initial volume


        if (pageLevelParams[SETTINGS.INITIAL_VOLUME] !== undefined) {
          currentVolume = parseFloat(pageLevelParams[SETTINGS.INITIAL_VOLUME]);
        } // csai


        if (pageLevelParams[SETTINGS.PAUSE_ON_LIVE_ADS] !== undefined) {
          csaiMode = !pageLevelParams[SETTINGS.PAUSE_ON_LIVE_ADS];
        } // ios playback options


        if (pageLevelParams[SETTINGS.IOS_PLAY_MODE] !== undefined) {
          iosPlayMode = pageLevelParams[SETTINGS.IOS_PLAY_MODE];
        }

        if (pageLevelParams[SETTINGS.MUTE_FIRST_PLAY] === true || pageLevelParams[SETTINGS.MUTE_FIRST_PLAY] === 'true') {
          muteFirstPlay = true;
        }
      }

      OO.debug_tools = OO.debug_tools || {};

      if (!OO.debug_tools[elementId]) {
        OO.debug_tools[elementId] = {};
      }

      OO.debug_tools[elementId].video = videoDebugging;
    }, this);
    /**
     * @method VideoController#adSdkImpression
     * @description Callback for OO.EVENTS.AD_SDK_IMPRESSION.
     * Used to set the hasPlayedAd in the video controller, which
     * is passed to the OO.EVENTS.INITIAL_PLAY_STARTING event to indicate
     * an ad has played before the initial video playback began.
     *
     * @private
     */


    var adSdkImpression = _.bind(function () {
      this.hasPlayedAd = true;
    }, this);
    /**
     * @method VideoController#onHAFailoverError
     * @description Callback for OO.EVENTS.HA_FAILOVER_ERROR.
     * In case if HA will failed to reload manifest, we will trigger error.
     *
     * @fires OO.EVENTS.VC_ERROR with error code OO.ERROR.PLAYBACK.LIVESTREAM
     * @private
     */


    var onHAFailoverError = _.bind(function () {
      mb.publish(OO.EVENTS.VC_ERROR, this.focusVideoId, {
        code: OO.ERROR.PLAYBACK.LIVESTREAM
      });
    }, this);
    /**
     * @method VideoController#onHAWillFailover
     * @description Callback for OO.EVENTS.HA_WILL_FAILOVER.
     * Notifies us that HA failover will happen. Used to ensure seemless
     * playhead transition to the stream we are failing over to and avoid playhead jumping
     * back to the live position
     * @private
     */


    var onHAWillFailover = _.bind(function () {
      this.failoverPlayhead = this.currentPlayhead;
      this.handleFailover = true;
    }, this);
    /**
     * @method VideoController#onHAEnabled
     * @description Callback for OO.EVENTS.HA_ENABLED.
     * Notifies us that HA is enabled
     * @param {string} eventName The name of the event that triggered this function
     * @param {boolean} enabled True if ha is enabled
     * @private
     */


    var onHAEnabled = _.bind(function (eventName, enabled) {
      isHAFailoverMechanismEnabled = !!enabled;
    }, this);
    /**
     * @method VideoController#onEmbedCodeMetadataFetched
     * @description Callback for OO.EVENTS.EMBED_CODE_METADATA_FETCHED
     * Embed code metadata has been retrieved.
     * @param {string} eventName The name of the event that triggered this function
     * @param {object} data Embed code metadata
     * @private
     */


    var onEmbedCodeMetadataFetched = _.bind(function (eventName, data) {
      embedCodeMetadata = data;
    }, this);
    /**
     * @method VideoController#onMetadataFetched
     * @description Callback for OO.EVENTS.METADATA_FETCHED
     * Check if encoding priority is set at backlot level (it will be a string)
     * If so, add it to encodingPriority[settingLevels.BACKLOT],
     * and update chosenEncodingPriority to settingLevels.BACKLOT
     * if it was settingLevels.PAGE
     * @private
     */


    var onMetadataFetched = _.bind(function (eventName, backlotMetadata) {
      // TODO: Check if encoding priority is set at backdoor level (it will be a string)
      // If so, add it to encodingPriority[settingLevels.BACKDOOR], and update chosenSteamPriority to
      //    settingLevels.BACKDOOR if it was settingLevels.DEFAULT
      // Check if encoding priority is set at backlot movie level
      if (backlotMetadata && backlotMetadata['base'] && backlotMetadata['base'][SETTINGS.ENCODING_PRIORITY]) {
        var data = backlotMetadata['base'][SETTINGS.ENCODING_PRIORITY]; // strip out '&.*;' and spaces and parens

        data = data.replace(/(&.+?;)|[ \[\]]/g, ''); // eslint-disable-line no-useless-escape

        encodingPriority[settingLevels.BACKLOT] = data.split(','); // Update chosenSteamPriority to settingLevels.BACKLOT it it was anything other than PAGE

        if (chosenEncodingPriority !== settingLevels.PAGE) {
          chosenEncodingPriority = settingLevels.BACKLOT;
        }
      }

      isHAFailoverMechanismEnabled = false;
    }, this);
    /**
     * @method VideoController#onContentTreeFetched
     * @description Extend current contentTree with new content tree,
     * check for movie_attributes
     * @private
     */


    var onContentTreeFetched = _.bind(function (eventName, fetchedContentTree, params) {
      contentTree = _.extend(contentTree, fetchedContentTree);

      if (fetchedContentTree.movie_attributes) {
        movieAttributes = fetchedContentTree.movie_attributes;
      }
    }, this);
    /**
     * Called when the stream is changed.
     * @method VideoController#embedCodeChanged
     * @private
     * @param {string} eventName The name of the event that triggered this handler
     * @param {object} embedCode The new embed code that was set
     * @param {object} params The page-level player parameters to be used for the new embed code
     */


    var embedCodeChanged = _.bind(function (eventName, embedCode, params) {
      // Unload current video elements
      var url = '';
      var encoding = OO.VIDEO.ENCODING.MP4; // airplay workaround added because of this reset logic
      // see ignoreSecondConnectedEvent property in Airplay plugin

      for (var index = 0; index < activeElements.length; index++) {
        _safeFunctionCall(activeElements[index], 'setVideoUrl', [url, encoding, false]);
      }

      this.defaultAudioTracks = {};
      this.isVr = false;
      this.isVideoTypeChanged = false;
      currentEmbedCode = embedCode; // Remove backlot settings because they are specific to the movie

      encodingPriority[settingLevels.BACKLOT] = null; // Clear closed captions data associated with previous video

      for (var videoId in this.activeInstances) {
        activeLanguage = null;

        _setClosedCaptions(videoId, {
          availableLanguages: [],
          locale: {}
        });
      } // Update the chosenEncodingPriority if it was set to backlot


      if (params && params.ooyalaAds) {
        if (chosenEncodingPriority !== settingLevels.OOYALA_ADS) {
          formerChosenEncodingPriority = chosenEncodingPriority;
        }

        chosenEncodingPriority = settingLevels.OOYALA_ADS;
      } else {
        if (chosenEncodingPriority === settingLevels.BACKLOT) {
          chosenEncodingPriority = encodingPriority[settingLevels.BACKDOOR] ? settingLevels.BACKDOOR : settingLevels.DEFAULT;
        } else if (chosenEncodingPriority === settingLevels.OOYALA_ADS) {
          chosenEncodingPriority = encodingPriority[formerChosenEncodingPriority] ? formerChosenEncodingPriority : settingLevels.DEFAULT;
        }
      }

      if (params && typeof params[SETTINGS.INITIAL_PLAYBACK_SPEED] === 'number') {
        var speed = params[SETTINGS.INITIAL_PLAYBACK_SPEED];
        onSetPlaybackSpeed({}, speed);
      }

      isPlaybackReady = false;
      autoplayed = false;
      primeVideosOnPlay = false;
    }, this);

    var assetChanged = _.bind(function () {
      isPlaybackReady = false;
    }, this);

    var playbackReady = _.bind(function () {
      isPlaybackReady = true;
    }, this);
    /**
     * @method VideoController#_isSSAISupportedStream
     * @description Returns true if stream is supported by SSAI
     * @param {string} stream The stream to validate
     * @returns {boolean} True if hls or dash
     * @private
     */


    var _isSSAISupportedStream = _.bind(function (stream) {
      return stream === 'hls' || stream === 'dash';
    }, this);
    /**
     * @method VideoController#_isSSAILiveEnabled
     * @description Check if movie attributes has ssai_enabled
     * @returns {boolean} True if ssai_enabled is "1"
     * @private
     */


    var _isSSAILiveEnabled = _.bind(function () {
      if (_.isEmpty(movieAttributes)) {
        return false;
      }

      if (movieAttributes.ssai_enabled) {
        var ssaiEnabled = movieAttributes.ssai_enabled;
        return ssaiEnabled === '1';
      }

      return false;
    }, this);
    /**
     * @method VideoController#_isSSAIVODEnabled
     * @description Check the following:
     * If ssai_vod_enabled_movie_level, check at content level for ssai_vod_enabled
     * If ssai_vod_enabled for this provider, content will be served up via SSAI
     * @returns {boolean} True if SSAI VOD is enabled for the asset.
     * @private
     */


    var _isSSAIVODEnabled = _.bind(function () {
      if (_.isEmpty(embedCodeMetadata) || _.isUndefined(embedCodeMetadata.attributes) || _.isUndefined(embedCodeMetadata.attributes.provider)) {
        return false;
      }

      var embedCodeProvider = embedCodeMetadata.attributes.provider;
      var movieEnabled = embedCodeProvider.ssai_vod_enabled_movie_level;

      if (movieEnabled && movieEnabled !== 'false' && currentEmbedCode !== null) {
        var ssaiVODEnabled = embedCodeMetadata.metadata[currentEmbedCode].base.ssai_vod_enabled;

        if (ssaiVODEnabled) {
          return _isSSAISupportedStream(ssaiVODEnabled);
        }
      } else if (embedCodeProvider.ssai_vod_enabled) {
        return _isSSAISupportedStream(embedCodeProvider.ssai_vod_enabled);
      }

      return false;
    }, this);
    /**
     * @method VideoController#_isSSAIEnabled
     * @description Check if SSAI live or VOD is enabled for the asset
     * @param {boolean} isLive True if it is a live video
     * @returns {boolean} True if SSAI live or VOD is enabled.
     * @private
     */


    var _isSSAIEnabled = _.bind(function (isLive) {
      if (isLive) {
        return _isSSAILiveEnabled();
      } else {
        return _isSSAIVODEnabled();
      }
    }, this);
    /**
     * @method VideoController#_appendPlayerParams
     * @description Convert to json, encode and append player params
     * to the provided URL
     * @param {string} url True if it is a live video
     * @returns {string} URL with player params appended
     * @private
     */


    var _appendPlayerParams = _.bind(function (url) {
      if (_.isEmpty(pageLevelParams)) {
        return url;
      }

      var playerParams = JSON.stringify(pageLevelParams);
      var playerParamsEncoded = encodeURIComponent(playerParams);
      return url + '&player_params=' + playerParamsEncoded;
    }, this);
    /**
     * @method VideoController#initialPlay
     * @description Callback for OO.EVENTS.INITIAL_PLAY.
     * Sets the initial play time and if the video was autoplayed.
     * @param {string} eventName The name of the event that triggered this function
     * @param {number} unitTimeMs The unix timestamp of the initial playtime
     * @param {boolean} wasAutoplayed True if the video was autoplayed, false otherwise
     *
     * @private
     */


    var initialPlay = _.bind(
    /*#__PURE__*/
    function () {
      var _ref = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee(eventName, unixTimeMs, wasAutoplayed) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                isPlaybackReady = true;
                this.initialPlayTime = unixTimeMs;
                autoplayed = wasAutoplayed; // Load the video here on initial play if not autoplayed and we require muted autoplay.
                // Since this video was not autoplayed, we are on the user click thread and loading
                // the video is enough to ensure that a future play request will work without being muted

                if (wasAutoplayed) {
                  _context.next = 6;
                  break;
                }

                _context.next = 6;
                return Promise.all([loadVideoForUnmutedAutoplay(OO.VIDEO.MAIN), loadVideoForUnmutedAutoplay(OO.VIDEO.ADS)]);

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }(), this);
    /**
     * Callback for when the autoplay check has finished.
     * @method VideoController#autoplayCheckComplete
     * @protected
     * @param event {string} The event name
     * @param results {object} Object containing muted and unmuted autoplay capabilities
     */


    var autoplayCheckComplete = _.bind(function (eventName, results) {
      canAutoplay = results;

      if (canAutoplay.unmuted) {
        for (var index = 0; index < activeElements.length; index++) {
          _safeFunctionCall(activeElements[index], 'notifyUnmutedContentAutoPlaybackSucceeded');
        }
      }
    }, this);
    /**
     * Loads a video element. Should be called on a user click thread to be able to allow for unmuted
     * automatic playback in the future.
     * @private
     * @method VideoController#loadVideoForUnmutedAutoplay
     * @param {string} videoId The id of the video to load
     * @returns {promise} A promise that indicate if the video was created
     */


    var loadVideoForUnmutedAutoplay = _.bind(
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee2(videoId) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(this.activeInstances[videoId] && _isInControl(videoId) && !this.activeInstances[videoId].element.primedForUnmutedAutoPlayback)) {
                  _context2.next = 5;
                  break;
                }

                _safeFunctionCall(this.activeInstances[videoId].element, 'load', [true]);

                _context2.next = 4;
                return _setVideoStream(videoId, this.activeInstances[videoId].encoding, this.activeInstances[videoId].stream, this.activeInstances[videoId].isLive);

              case 4:
                this.activeInstances[videoId].element.primedForUnmutedAutoPlayback = true;

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      return function (_x4) {
        return _ref2.apply(this, arguments);
      };
    }(), this);

    var onLiveClicked = _.bind(function () {
      _callIfInControl(this.focusVideoId, 'onLiveClick');
    }, this);
    /**
     * Set flag about changing video type
     */


    var onVideoTypeChanged = _.bind(function () {
      this.isVideoTypeChanged = true;
    }, this); // ********************
    // Element creation and destroy
    // ********************

    /**
     * Selects an encoding and if required, creates a new element that can play this stream.
     * This is a callback to OO.EVENTS.VC_CREATE_VIDEO_ELEMENT
     * @private
     * @method VideoController#vcCreateVideoElement
     * @param {string} eventName The name of the event that triggered this function
     * @param {string} videoId The id to use for the new element
     * @param {object} streams An object with the encoding types as the keys and stream urls and drm object as the values
     * @param {object} parentContainer The parent container of the new element
     * @param {object} params An object with optional parameters to set on the new element
     * @param {boolean} isPlaylist - true if it is a playlist
     * @fires OO.EVENTS.VC_ERROR
     * @fires OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT
     */


    var vcCreateVideoElement = _.bind(
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee3(eventName, videoId, streams, parentContainer, params) {
        var validPlugins, currentController, pluginsForTechnology, pluginsForFeatures, chosenEncoding, wasInFocus, checkVrOnSafari, existInstance, possiblePlugins, electedPlugin;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                // Get the list of possible plugins
                if (params && (params.technology || params.features)) {
                  // Filter the list of usable plugins based on technology and feature restrictions
                  pluginsForTechnology = _filterPluginsByTechnology(params.technology);
                  pluginsForFeatures = _filterPluginsByFeatures(params.features);
                  validPlugins = _.pick(registeredPlugins, _.intersection(pluginsForTechnology, pluginsForFeatures));
                } else {
                  // For performance, avoid the logic of filtering if no filtering parameters are specified
                  validPlugins = registeredPlugins;
                } // Select an encoding.  If none are selected, raise an error


                chosenEncoding = _selectEncoding(streams, _getFilteredSupportedEncodings(validPlugins), _getEncodingPriorities());

                if (chosenEncoding) {
                  _context3.next = 5;
                  break;
                }

                mb.publish(OO.EVENTS.VC_ERROR, videoId, {
                  ooyalaErrorCode: OO.ERROR.VC.UNSUPPORTED_ENCODING,
                  playhead: this.currentPlayhead
                });
                return _context3.abrupt("return");

              case 5:
                if (_isSSAIEnabled(streams.isLive)) {
                  streams[chosenEncoding].url = _appendPlayerParams(streams[chosenEncoding].url);
                }

                log("For video '" + videoId + "', selected encoding '" + chosenEncoding + "', with stream url " + streams[chosenEncoding].url); // Check if the element already exists and if the element supports the chosen
                // encoding

                wasInFocus = !!(this.focusVideoId && this.focusVideoId === videoId);
                checkVrOnSafari = OO.isSafari && this.isVr;
                existInstance = !!this.activeInstances[videoId] && !!this.activeInstances[videoId].element;

                if (!existInstance) {
                  _context3.next = 26;
                  break;
                }

                if (!(!checkVrOnSafari && validPlugins[this.activeInstances[videoId].plugin] && _.contains(this.activeInstances[videoId].element.supportedEncodings, chosenEncoding) && !this.isVideoTypeChanged)) {
                  _context3.next = 23;
                  break;
                }

                // There is another element with the same videoId that supports the chosen
                // stream and is in the filtered list of plugins
                log('Element already existed and supports chosen encoding.  Setting new video url.');
                this.activeInstances[videoId].disableNativeSeek = false; // set params, closedCaptions, crossorigin

                _setVideoParams(videoId, params); // (PLAYER-3416) set video stream needs to be after set params due to potential
                // dependencies on new params


                _context3.next = 17;
                return _setVideoStream(videoId, chosenEncoding, streams[chosenEncoding], streams.isLive);

              case 17:
                // Secure content
                _setSecureContent(videoId, streams[chosenEncoding].contentMetadata); // Workaround for PBW-5179 to save the current playhead of the main video


                if (OO.isIos) {
                  currentController = this.activeInstances[videoId].element.sharedObjectToInstance;

                  if (currentController === 'main' && this.activeInstances[currentController].element) {
                    this.currentPlayhead = _safeFunctionCall(this.activeInstances[currentController].element, 'getCurrentTime');
                  }
                }

                _notifyElementCreated(videoId);

                return _context3.abrupt("return");

              case 23:
                // if we are in a playlist and video type changed
                if (this.isVideoTypeChanged) {
                  // save settings for new video in a playlist set params, closedCaptions,
                  // crossorigin
                  _setVideoParams(videoId, params);
                } // If we are on Safari and the video is Vr, or a plugin is invalid, or we have unsupported encoding,
                // or video type was changed dispose video element


                log('Destroying existing element because some of major factors were changed.');
                vcDisposeVideoElement(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, videoId);

              case 26:
                // Select a plugin
                possiblePlugins = _.intersection(encodingToPlugins[chosenEncoding] || [], _.keys(validPlugins));
                electedPlugin = null; // If we only have an unknown stream possible, try to use the first registered
                // plugin.

                if ((possiblePlugins == null || possiblePlugins.length < 1) && chosenEncoding === OO.VIDEO.ENCODING.UNKNOWN && _.size(validPlugins) > 0) {
                  electedPlugin = validPlugins[_.keys(validPlugins)[0]];
                } else if (possiblePlugins && possiblePlugins.length > 0 && _.size(validPlugins) > 0) {
                  electedPlugin = validPlugins[possiblePlugins[0]];
                }

                electedPlugin = _correctElectedPlugin(electedPlugin, {
                  videoId: videoId,
                  validPlugins: validPlugins,
                  encoding: chosenEncoding
                });

                if (electedPlugin) {
                  _context3.next = 33;
                  break;
                }

                mb.publish(OO.EVENTS.VC_ERROR, videoId, {
                  ooyalaErrorCode: OO.ERROR.VC.UNSUPPORTED_ENCODING,
                  playhead: this.currentPlayhead
                });
                return _context3.abrupt("return");

              case 33:
                log("For video '" + videoId + "', elected plugin '" + electedPlugin.name + "'"); // If the max number of elements reached on elected plugin, create a virtual
                // element

                _context3.next = 36;
                return _createInstance(electedPlugin, videoId, parentContainer, chosenEncoding, streams[chosenEncoding], streams.isLive, params);

              case 36:
                // TODO: Should we place the element in the parent ourselves?       Would
                // require a direct handle to the element Notify results
                if (this.activeInstances[videoId]) {
                  _notifyElementCreated(videoId);

                  if (wasInFocus) {
                    mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, videoId);
                  } // update config streams required


                  if (videoId === OO.VIDEO.MAIN || videoId === OO.VIDEO.RELOAD) {
                    mb.publish(OO.EVENTS.HA_CONFIG_UPDATE, {
                      focusVideoId: videoId,
                      streams: streams,
                      chosenEncoding: chosenEncoding,
                      plugin: electedPlugin.name
                    });
                  }
                } else {
                  mb.publish(OO.EVENTS.VC_ERROR, videoId, {
                    ooyalaErrorCode: OO.ERROR.VC.UNABLE_TO_CREATE_VIDEO_ELEMENT,
                    playhead: this.currentPlayhead
                  });
                }

              case 37:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      return function (_x5, _x6, _x7, _x8, _x9) {
        return _ref3.apply(this, arguments);
      };
    }(), this);
    /**
     * Refines the selected plugin.
     * Fixed cases that lead to incorrect selection of plugins and playback errors.
     * ToDo: The method will not be needed when the plugin selection logic is refactored
     * @private
     * @method VideoController#_correctElectedPlugin
     * @param electedPlugin {object} previously elected plug-in
     * @param videoInfo {object} info about the video
     * @param videoInfo.videoId {string} the id to use for the new element
     * @param videoInfo.validPlugins {array} list of valid plugins
     * @param videoInfo.encoding {string} the video encoding
     * @returns electedPlugin {object} - corrected elected plugin
     */


    var _correctElectedPlugin = _.bind(function (electedPlugin, videoInfo) {
      if (videoInfo) {
        // If content vr or encoding is hls, then use the bitmovin plugin.
        var isHls = videoInfo.encoding === OO.VIDEO.ENCODING.HLS || videoInfo.encoding === OO.VIDEO.ENCODING.DRM.HLS;
        var checkUseBitmovin = (this.isVr || OO.isAndroid4_4Plus && isHls) && videoInfo.videoId === OO.VIDEO.MAIN && videoInfo.validPlugins[OO.VIDEO_PLAYERS.BIT_WRAPPER];

        if (checkUseBitmovin) {
          // TODO we can reactivate this section of code once we have a better way to detect if the stream is VR instead of forcing it here.
          electedPlugin = videoInfo.validPlugins[OO.VIDEO_PLAYERS.BIT_WRAPPER]; // eslint-disable-line no-param-reassign
        }
      }

      return electedPlugin;
    }, this);

    var _filterPluginsByTechnology = _.bind(function (technology) {
      if (!technology) {
        return _.keys(registeredPlugins);
      }

      var plugins = [];

      for (var name in registeredPlugins) {
        if (registeredPlugins[name].technology === technology) {
          plugins.push(name);
        }
      }

      return plugins;
    }, this);

    var _filterPluginsByFeatures = _.bind(function (features) {
      if (!features || features.length < 1) {
        return _.keys(registeredPlugins);
      }

      var plugins = [];

      for (var name in registeredPlugins) {
        var unsupportedFeatures = _.difference(features, registeredPlugins[name].features);

        if (!unsupportedFeatures || unsupportedFeatures.length === 0) {
          plugins.push(name);
        }
      }

      return plugins;
    }, this);

    var _getFilteredSupportedEncodings = _.bind(function (subsetOfPlugins) {
      var encodings = [];

      for (var plugin in subsetOfPlugins) {
        encodings = encodings.concat(registeredPlugins[plugin].encodings);
      }

      return _.uniq(encodings);
    }, this);

    var _getEncodingPriorities = _.bind(function () {
      // TODO: could be calculated and stored when setting our current chosen encoding priority list
      // Calculate the priorities not included in our current encoding priorities.
      // These priorities will be appended to the end of the returned list
      var currentPriorites = encodingPriority[chosenEncodingPriority];
      var unprioritized = $(getSupportedEncodings()).not(currentPriorites).get();
      return currentPriorites.concat(unprioritized);
    }, this);

    var _selectEncoding = _.bind(function (streams, supportedList, priorityOrder) {
      if (!streams || _.size(streams) < 1) return;
      var encodings = {}; // Get the intersection of the streams we have and the streams we support

      for (var index = 0; index < supportedList.length; index++) {
        var encoding = supportedList[index];

        if (streams.hasOwnProperty(encoding)) {
          encodings[encoding] = streams[encoding];
        }
      }

      var chosenEncoding = null; // Select an encoding based on encodingPriority[chosenEncodingPriority]

      for (var _index = 0; _index < priorityOrder.length; _index++) {
        if (encodings.hasOwnProperty(priorityOrder[_index])) {
          chosenEncoding = priorityOrder[_index];
          break;
        }
      } // Check for unkown stream type if no other streams are supported


      if (chosenEncoding == null && streams.hasOwnProperty(OO.VIDEO.ENCODING.UNKNOWN)) {
        chosenEncoding = OO.VIDEO.ENCODING.UNKNOWN;
      }

      return chosenEncoding;
    }, this);

    var _notifyElementCreated = _.bind(function (videoId) {
      // If the element doesn't exist, return;
      if (!(this.activeInstances && this.activeInstances[videoId] && this.activeInstances[videoId].element)) {
        return;
      } // Get the true element


      var element = this.activeInstances[videoId].element;
      var videoElement = element.parentContainer && element.parentContainer.length > 0 ? element.parentContainer.find('#' + element.domId) : []; // Retrieve the stream url

      var streamUrl = this.activeInstances[videoId].stream ? this.activeInstances[videoId].stream.url : null; // Workaround. VC_VIDEO_ELEMENT_CREATED event is being fired before the <video> element is added to the DOM

      _.delay(function () {
        // raise an event denoting success
        mb.publish(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, {
          'videoId': videoId,
          'encodings': element.supportedEncodings,
          'parent': element.parentContainer,
          'domId': element.domId,
          'videoElement': videoElement,
          'streamUrl': streamUrl
        });
      }, 1);
    }, this);

    var vcUpdateElementStream = _.bind(function (event, videoId, newUrl) {
      // If the element doesn't exist, return;
      if (!(this.activeInstances && this.activeInstances[videoId] && this.activeInstances[videoId].element)) {
        return;
      } // Update the stream url


      if (this.activeInstances[videoId].stream) {
        this.activeInstances[videoId].stream.url = newUrl;

        _setVideoStream(videoId, this.activeInstances[videoId].encoding, this.activeInstances[videoId].stream, this.activeInstances[videoId].isLive);
      }
    }, this);
    /**
     * Callback function for event OO.EVENTS.VC_PLAYING
     * Used only while reloading of manifest. Reloading of manifest can be triggered by
     * OO.EVENTS.VC_RELOAD_AND_PLAY
     *
     * @private
     * @method VideoController#_onVCPlayingRP
     * @param  {string} event                     Event name
     * @param  {string} videoId                   Video ID that is playing
     * @fires OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT
     * @fires OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT
     */


    var _onVCPlayingRP = _.bind(function (event, videoId) {
      if (videoId === OO.VIDEO.RELOAD) {
        var tmpElement = this.activeInstances[OO.VIDEO.MAIN].element; // swapping elements between old video element instance and new

        this.activeInstances[OO.VIDEO.MAIN] = $.extend({}, this.activeInstances[OO.VIDEO.RELOAD]);
        this.activeInstances[OO.VIDEO.MAIN].vtcInterface.videoId = OO.VIDEO.MAIN;
        this.activeInstances[OO.VIDEO.RELOAD].element = tmpElement; // trick to make dispose element and focus element work correctly

        this.focusVideoId = OO.VIDEO.RELOAD; // focusing old video element back.
        // Because we swapped elements, element with updated manifest will be in focus.

        mb.publish(OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT, OO.VIDEO.MAIN); // disposing new video element

        mb.publish(OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT, OO.VIDEO.RELOAD);

        if (this.pauseAfterReload) {
          this.pauseAfterReload = false;
          mb.publish(OO.EVENTS.PAUSE);
        } // unsubscribe


        mb.unsubscribe(OO.EVENTS.VC_PLAYING, 'vtc_t', _onVCPlayingRP);
        mb.unsubscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'vtc_t', _onVideoElementCreatedRP);
      }
    }, this);
    /**
     * Callback function for event OO.EVENTS.VC_VIDEO_ELEMENT_CREATED
     * Used only while reloading of manifest. Reloading of manifest can be triggered by
     * OO.EVENTS.VC_RELOAD_AND_PLAY
     *
     * @private
     * @method VideoController#_onVideoElementCreatedRP
     * @param  {string} event           Event name
     * @param  {object} createdElement  Video element that was created
     * @fires OO.EVENTS.VC_PLAY
     */


    var _onVideoElementCreatedRP = _.bind(function (event, createdElement) {
      if (createdElement.videoId === OO.VIDEO.RELOAD) {
        mb.subscribe(OO.EVENTS.VC_PLAYING, 'vtc_t', _onVCPlayingRP); // trying to play freashly created video element

        mb.publish(OO.EVENTS.VC_PLAY, OO.VIDEO.RELOAD);
      }
    }, this);
    /**
     * Reload and Play. Reloads stream without losing playback. Old manifest will continue to play
     * and will be replaced once new manifest starts playing.
     * Triggered by OO.EVENTS.VC_RELOAD_AND_PLAY
     *
     * @method VideoController#reloadAndPlay
     *
     * @param {string} eventName Name of event.
     * @param {object} streams Object that contains different encoding playback urls. Like {"hls":{"url":"http://example.com/1.m3u8"}}
     *
     * @fires OO.EVENTS.VC_WILL_RELOAD
     * @fires OO.EVENTS.VC_PLAY
     * @fires OO.EVENTS.VC_FOCUS_VIDEO_ELEMENT
     * @fires OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT
     * @fires OO.EVENTS.VC_RELOAD
     * @fires OO.EVENTS.HA_CONFIG_UPDATE
     *
     * @private
     */


    var onReloadAndPlay = _.bind(function (eventName, streams) {
      var _this = this;

      if (!this.focusVideoId || !this.activeInstances || !this.activeInstances[this.focusVideoId] || !this.activeInstances[this.focusVideoId].element || !streams || !streams[this.activeInstances[this.focusVideoId].encoding]) {
        log('invalid data for reload and play');
        return;
      }

      if (this.focusVideoId !== OO.VIDEO.MAIN) {
        log('not supported videoId for reload', this.focusVideoId);
        return;
      }

      mb.publish(OO.EVENTS.VC_WILL_RELOAD_AND_PLAY);
      var chosenEncoding = this.activeInstances[this.focusVideoId].encoding;

      if (streams[chosenEncoding]) {
        streams[chosenEncoding].url = increaseCountForTryParam(streams[chosenEncoding].url);
      } // Delete a list of multiaudio


      mb.publish(OO.EVENTS.MULTI_AUDIO_CHANGED, {});

      if (OO.isIos || OO.isSafari) {
        log('Trying to hard reload for ios or safari');
        mb.publish(OO.EVENTS.VC_UPDATE_ELEMENT_STREAM, this.focusVideoId, streams[chosenEncoding].url); // We need to update the changes to the config in order to keep track of the
        // current state of the "try" parameter.
        // TODO
        // Doing partial updates to the HA config is currently problematic because the
        // default config will be used as a base without taking into account the
        // current config values. Ideally we should be able to update only the streams
        // even if we don't know the rest of these values.

        mb.publish(OO.EVENTS.HA_CONFIG_UPDATE, {
          focusVideoId: this.focusVideoId,
          streams: streams,
          chosenEncoding: chosenEncoding,
          plugin: this.activeInstances[this.focusVideoId].plugin
        }); // changing DOM element src attr is async process; wait for next event loop to get src applied

        setTimeout(function () {
          return mb.publish(OO.EVENTS.PLAY, _this.focusVideoId);
        });
        return;
      } // If we are paused in the current main video element, we will need to pause upon
      // starting the new element.


      this.pauseAfterReload = !!this.paused;
      mb.subscribe(OO.EVENTS.VC_VIDEO_ELEMENT_CREATED, 'vtc_t', _onVideoElementCreatedRP); // it is better to not publish OO.EVENTS.VC_CREATE_VIDEO_ELEMENT.
      // almost all components will not properly handle new element that
      // is not OO.VIDEO.MAIN or OO.VIDEO.ADS
      // creating video element silently and then swap it.
      // mb.publish(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, OO.VIDEO.RELOAD, streams, null, allParams)

      vcCreateVideoElement(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, OO.VIDEO.RELOAD, streams, this.activeInstances[this.focusVideoId].parentContainer, this.activeInstances[this.focusVideoId].params);
    }, this);
    /**
     * Creates a video element and instance.
     * @private
     * @method VideoController#_createInstance
     * @param {object} electedPlugin The plugin to use when creating a new instance.
     * @param {string} videoId The name of the new video instance.
     * @param {object} parentContainer The DOM object below which to append the new element
     * @param {string} encoding The encoding of video stream, possible values are found in OO.VIDEO.ENCODING
     * @param {object} stream The object contains url and drm to load on the new video element.
     * @param {boolean} isLive True if it is a live asset, false otherwise
     * @param {object} params Parameters that apply to the video element.  These include "crossorigin" and
     *                        closedCaptions settings.
     * @fires OO.EVENTS.VC_ERROR
     * @returns {Promise} promise that indicates whether or not the instance was created.
     */


    var _createInstance = _.bind(function (electedPlugin, videoId, parentContainer, encoding, stream, isLive, params) {
      if (!electedPlugin || !videoId) {
        return Promise.resolve(); // it seems that the test don't look at an error perse, just look up for event errors
      } // PLAYER-2148 workaround for HAFailoverMechanism


      if (electedPlugin.name === OO.VIDEO_PLAYERS.BIT_WRAPPER && isHAFailoverMechanismEnabled) {
        var _self = this;

        params = params || {}; // eslint-disable-line no-param-reassign

        params.pluginParams = params.pluginParams || {};
        params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER] = params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER] || {};
        params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER].network = params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER].network || {};

        params.pluginParams[OO.VIDEO_PLAYERS.BIT_WRAPPER].network.retryHttpRequest = function (type, response) {
          var responseStatus = 404;

          if (response && response.request && response.request.status) {
            responseStatus = response.request.status;
          }

          var eventparams = {
            type: 'onDownloadFinished',
            timestamp: Date.now(),
            httpStatus: responseStatus,
            url: response ? response.url || '' : '',
            size: 0,
            downloadTime: 0,
            // attempt must be > 1 && success = false in order to trigger HAFailoverMechanism
            // if retry was executed it means at least one attempt already happened and it failed
            attempt: 2,
            success: false,
            maxAttempts: type === 'media/video' ? 3 : Infinity,
            mimeType: type === 'media/video' ? 'video/mp4' : null,
            downloadType: type
          };

          _self.notify(videoId, electedPlugin, _self.EVENTS.ON_DOWNLOAD_FINISHED, eventparams); // delay the retry by 1 second


          return new Promise(function (resolve) {
            setTimeout(function () {
              resolve(response.request);
            }, 1000);
          });
        };
      } // Check if device limitations require that elements be shared


      if (_checkIfElementSharingRequired(electedPlugin)) {
        // Get the instance of the existing video element that the new element should share with
        var instanceToShare = _getInstanceToShare(electedPlugin.technology);

        if (instanceToShare && this.activeInstances[instanceToShare].plugin !== electedPlugin.name) {
          // An element must be shared, and the existing element was created by the same plugin as the
          // desired plugin for the new element.  Do inter-plugin sharing rather than creating a new element.
          if (_checkIfInterpluginSharingSupported(instanceToShare, electedPlugin)) {
            if (this.activeInstances[instanceToShare]) {
              return _createSharedElementBetweenPlugins(electedPlugin, videoId, encoding, stream, isLive, parentContainer, params, instanceToShare);
            }

            mb.publish(OO.EVENTS.VC_ERROR, videoId, {
              ooyalaErrorCode: OO.ERROR.VC.UNABLE_TO_CREATE_VIDEO_ELEMENT,
              playhead: this.currentPlayhead
            });
            return Promise.resolve();
          } else {// Video element sharing is required but not supported by the plugins in use.
            // Delete an element with the same technology to make space for a new element.
            // [update] After testing, we found that new elements require playback to be triggered by a user
            // click event.  To prevent users from needing to click, do not dispose the old video element.
            // _disposeElementKeepInstance(instanceToShare);
          }
        } else if (instanceToShare) {
          // An element must be shared, and the existing element was created by the same plugin as the
          // desired plugin for the new element.  Do intra-plugin sharing of the element rather than creating
          // a new element.
          return _createSharedElement(electedPlugin, videoId, encoding, stream, isLive, params);
        } else {// This is hit if an element allows sharing but is of technology MIXED (which can never be shared)
          // [update] After testing, we found that new elements require playback to be triggered by a user
          // click event.  To prevent users from needing to click, do not dispose the old video element.
          // this.disposeAnyElementKeepInstance();
        }
      }

      if (electedPlugin.maxSupportedElements > -1 && _countElements(electedPlugin.name) >= electedPlugin.maxSupportedElements) {
        // If limited number of elements and if we exceeded the limit, create shared element
        return _createSharedElement(electedPlugin, videoId, encoding, stream, isLive, params);
      } else {
        // If unlimited or if we didn't exceed the limit
        return _createRealElement(electedPlugin, videoId, parentContainer, encoding, stream, isLive, params);
      }
    }, this);
    /**
     * Returns true if device limitations state that the maximum number of elements of a given type have been
     * created.  This will indicate whether or not a new HTML5-based element can be created based on the
     * technology of the elected plugin and existing elements.
     * @private
     * @method VideoController#_checkIfElementSharingRequired
     * @param {object} electedPlugin The plugin to use when creating a new instance.
     * @returns {boolean} True if new video elements cannot be created.
     */


    var _checkIfElementSharingRequired = _.bind(function (electedPlugin) {
      // check if single element mode required and if it's an html5 video
      if (OO.requiresSingleVideoElement && (electedPlugin.technology === OO.VIDEO.TECHNOLOGY.HTML5 || electedPlugin.technology === OO.VIDEO.TECHNOLOGY.MIXED)) {
        // check if any other html5-based elements exist
        for (var instance in this.activeInstances) {
          if ((registeredPlugins[this.activeInstances[instance].plugin].technology === OO.VIDEO.TECHNOLOGY.HTML5 || registeredPlugins[this.activeInstances[instance].plugin].technology === OO.VIDEO.TECHNOLOGY.MIXED) && this.activeInstances[instance].element) {
            return true;
          }
        }
      }

      return false;
    }, this);
    /**
     * Returns true if the plugins of the existing video element and new video element support sharing.
     * @private
     * @method VideoController#_checkIfInterpluginSharingSupported
     * @param {object} instanceToShare The video instance that should be shared.
     * @param {object} electedPlugin The plugin to use when creating a new instance.
     * @returns {boolean} True if inter-plugin sharing is supported by the plugins.
     */


    var _checkIfInterpluginSharingSupported = _.bind(function (instanceToShare, electedPlugin) {
      // Check if existing plugin supports videoObjectSharingGive
      var giveSupported = _.contains(registeredPlugins[this.activeInstances[instanceToShare].plugin].features, OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_GIVE); // Check if electedPlugin supports feature videoObjectSharingTake


      var takeSupported = _.contains(electedPlugin.features, OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_TAKE);

      var sameTech = registeredPlugins[this.activeInstances[instanceToShare].plugin].technology === electedPlugin.technology;
      var isNotMixed = electedPlugin.technology !== OO.VIDEO.TECHNOLOGY.MIXED;
      return giveSupported && takeSupported && sameTech && isNotMixed;
    }, this);
    /**
     * Returns a reference to the instance that should be shared by new elements created with the same
     * technology.
     * @private
     * @method VideoController#_getInstanceToShare
     * @returns {object} A reference to the video instance to share.
     */


    var _getInstanceToShare = _.bind(function (technology) {
      var instanceToShare = null; // return first html5-based element with sharing capability

      for (var instance in this.activeInstances) {
        if (registeredPlugins[this.activeInstances[instance].plugin].technology !== technology) {
          continue; // eslint-disable-line no-continue
        } // Only share with an instance that has an element


        if (!this.activeInstances[instance].element) {
          continue; // eslint-disable-line no-continue
        } // Check if existing plugin supports videoObjectSharingGive
        // If it doesn't, only return it if no other eligible plugins support Give


        if (!_.contains(registeredPlugins[this.activeInstances[instance].plugin].features, OO.VIDEO.FEATURE.VIDEO_OBJECT_SHARING_GIVE)) {
          instanceToShare = instance;
          continue; // eslint-disable-line no-continue
        }

        return instance;
      }

      return instanceToShare;
    }, this);

    var _createSharedElementBetweenPlugins = _.bind(
    /*#__PURE__*/
    function () {
      var _ref4 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee4(electedPlugin, videoId, encoding, stream, isLive, parentContainer, params, instanceToShare) {
        var element, vtcInterface, domId, calculatedElementId;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!(!electedPlugin || !videoId)) {
                  _context4.next = 2;
                  break;
                }

                return _context4.abrupt("return");

              case 2:
                log("For video '" + videoId + "', sharing element with video '" + instanceToShare + "'");
                this.activeInstances[instanceToShare].element.sharedObjectToInstance = videoId; // Create the element object

                element = new VideoElement({
                  plugin: electedPlugin,
                  parentContainer: parentContainer,
                  sharedObjectToInstance: instanceToShare,
                  isControllingObject: false
                });
                activeElements.push(element); // Create the video instance object if it doesn't already exist

                vtcInterface = new VideoControllerInterface(this, videoId, electedPlugin);

                if (!this.activeInstances[videoId]) {
                  this.activeInstances[videoId] = new VideoInstance({
                    plugin: electedPlugin,
                    parentContainer: parentContainer,
                    element: element,
                    encoding: encoding,
                    stream: stream,
                    isLive: isLive,
                    vtcInterface: vtcInterface,
                    isControllingElement: true,
                    params: params
                  });
                } else {
                  this.activeInstances[videoId].element = element;
                }

                if (params) {
                  _setClosedCaptions(videoId, params.closedCaptions);

                  _setCrossorigin(videoId, params.crossorigin);

                  vtcInterface.authenticationData = params.authenticationData;
                } // Create the shared element


                domId = this.activeInstances[instanceToShare].element.domId;
                calculatedElementId = _getElementIdOfVideo(domId);
                element.wrapper = electedPlugin.createFromExisting(calculatedElementId, vtcInterface, this.elementId); // Set the stream

                _context4.next = 14;
                return _setVideoStream(videoId, encoding, stream, isLive);

              case 14:
                // Secure content
                _setSecureContent(videoId, stream.contentMetadata);

                if (canAutoplay.unmuted) {
                  _safeFunctionCall(this.activeInstances[videoId].element, 'notifyUnmutedContentAutoPlaybackSucceeded');
                }

              case 16:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      return function (_x10, _x11, _x12, _x13, _x14, _x15, _x16, _x17) {
        return _ref4.apply(this, arguments);
      };
    }(), this);

    var _countElements = _.bind(function (pluginName) {
      var count = 0;

      for (var index = 0; index < activeElements.length; index++) {
        if (activeElements[index].plugin === pluginName) {
          count++;
        }
      }

      return count;
    }, this);

    var _createSharedElement = _.bind(
    /*#__PURE__*/
    function () {
      var _ref5 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee5(electedPlugin, videoId, encoding, stream, isLive, params) {
        var element, index, vtcInterface;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(!electedPlugin || !videoId)) {
                  _context5.next = 2;
                  break;
                }

                return _context5.abrupt("return");

              case 2:
                // Find an element to wrap
                element = null;
                index = 0;

              case 4:
                if (!(index < activeElements.length)) {
                  _context5.next = 11;
                  break;
                }

                if (!(activeElements[index].plugin === electedPlugin.name)) {
                  _context5.next = 8;
                  break;
                }

                element = activeElements[index];
                return _context5.abrupt("break", 11);

              case 8:
                index++;
                _context5.next = 4;
                break;

              case 11:
                if (element) {
                  _context5.next = 13;
                  break;
                }

                return _context5.abrupt("return");

              case 13:
                log("For video '" + videoId + "', sharing existing element with index " + index); // Create the video instance object if it doesn't already exist

                vtcInterface = new VideoControllerInterface(this, videoId, electedPlugin);

                if (!this.activeInstances[videoId]) {
                  this.activeInstances[videoId] = new VideoInstance({
                    plugin: electedPlugin,
                    parentContainer: element.parentContainer,
                    element: element,
                    encoding: encoding,
                    stream: stream,
                    isLive: isLive,
                    vtcInterface: vtcInterface,
                    params: params
                  });
                } else {
                  this.activeInstances[videoId].element = element;
                }

                if (params) {
                  _setClosedCaptions(videoId, params.closedCaptions);

                  _setCrossorigin(videoId, params.crossorigin);

                  vtcInterface.authenticationData = params.authenticationData;
                } // Set the stream if we're creating a shared video for main and playback is not ready.
                // Otherwise the stream won't be set for the main video


                if (!(videoId === OO.VIDEO.MAIN && !isPlaybackReady)) {
                  _context5.next = 21;
                  break;
                }

                _prepareInstanceForAction(videoId);

                _context5.next = 21;
                return _setVideoStream(videoId, encoding, stream, isLive);

              case 21:
                // Secure content
                _setSecureContent(videoId, stream.contentMetadata);

                if (canAutoplay.unmuted) {
                  _safeFunctionCall(this.activeInstances[videoId].element, 'notifyUnmutedContentAutoPlaybackSucceeded');
                }

              case 23:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      return function (_x18, _x19, _x20, _x21, _x22, _x23) {
        return _ref5.apply(this, arguments);
      };
    }(), this);

    var _createRealElement = _.bind(
    /*#__PURE__*/
    function () {
      var _ref6 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee6(electedPlugin, videoId, parentContainer, encoding, stream, isLive, params) {
        var element, vtcInterface, pluginParams, electedPluginParams;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (!(!electedPlugin || !videoId)) {
                  _context6.next = 2;
                  break;
                }

                return _context6.abrupt("return");

              case 2:
                // Create the element object
                element = new VideoElement({
                  plugin: electedPlugin,
                  parentContainer: parentContainer
                });
                activeElements.push(element); // Create the video instance object if it doesn't already exist

                vtcInterface = new VideoControllerInterface(this, videoId, electedPlugin);

                if (!this.activeInstances[videoId]) {
                  this.activeInstances[videoId] = new VideoInstance({
                    plugin: electedPlugin,
                    parentContainer: element.parentContainer,
                    element: element,
                    encoding: encoding,
                    stream: stream,
                    isLive: isLive,
                    vtcInterface: vtcInterface,
                    isControllingElement: true,
                    params: params
                  });
                } else {
                  this.activeInstances[videoId].element = element;
                }

                pluginParams = {};

                if (params) {
                  _setClosedCaptions(videoId, params.closedCaptions);

                  _setCrossorigin(videoId, params.crossorigin);

                  vtcInterface.authenticationData = params.authenticationData;
                  pluginParams = params.pluginParams || {};
                }

                electedPluginParams = pluginParams[electedPlugin.name] || {}; // if inline playback is enabled then pass the parameter along to the plugin.

                if (this.isVr) {
                  iosPlayMode = this.IOS_PLAY_MODE_OPTIONS.INLINE;
                }

                electedPluginParams.iosPlayMode = iosPlayMode; // Create the real element

                element.wrapper = electedPlugin.create(element.parentContainer, element.domId, vtcInterface, initialCss, this.elementId, electedPluginParams); // Set the stream

                _context6.next = 14;
                return _setVideoStream(videoId, encoding, stream, isLive);

              case 14:
                // Secure content
                _setSecureContent(videoId, stream.contentMetadata); // set the playback speed for the video element


                _setPlaybackSpeed(videoId);

                if (canAutoplay.unmuted) {
                  _safeFunctionCall(this.activeInstances[videoId].element, 'notifyUnmutedContentAutoPlaybackSucceeded');
                }

              case 17:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      return function (_x24, _x25, _x26, _x27, _x28, _x29, _x30) {
        return _ref6.apply(this, arguments);
      };
    }(), this);
    /**
     * Mutes a video so that it can auto-playback.
     * @private
     * @method VideoController#muteForAutoPlayback
     * @param {string} videoId The id of the video to mute
     * @param {boolean} startPlayback True for the player to start playback after muting, false otherwise
     */


    var muteForAutoPlayback = _.bind(function (videoId, startPlayback) {
      var muted = true;
      mutingForAutoplay = true;

      if (startPlayback) {
        playbackVideoAfterMute = videoId;
      } // changing the mute attr of the DOM video element is async process, wait for next event loop to get it applied


      setTimeout(function () {
        return mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, true, videoId);
      });
      return muted;
    }, this);

    var vcVideoElementCreated = _.bind(function (eventName, elementParams) {
      var videoId = elementParams['videoId'];

      if (muteFirstPlay) {
        mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, true, videoId); // NOTE: setting mutingForAutoplay to true here is not necessarily for autoplay,
        // but we need to set it to make sure the unmute button shows
        // for the muted first play

        mutingForAutoplay = true;
      }

      _changeCrossorigin(videoId);
    }, this);
    /**
     * Disposes an entire video instance as well as a non-shared element.
     * @private
     * @method VideoController#vcDisposeVideoElement
     * @param {string} eventName The name of the event that triggered this instance disposal.
     * @param {string} videoId The name of the disposed video instance.
     * @fires OO.EVENTS.VC_VIDEO_ELEMENT_DISPOSED
     */


    var vcDisposeVideoElement = _.bind(function (eventName, videoId) {
      if (!videoId) return; // Remove focus

      if (this.focusVideoId === videoId) {
        // Note: this function attempts to pause the video, but this will take place after the destroy
        _removeFocusFromElement(videoId);
      } // Hand off element control


      _handoffElementControl(videoId); // Delete the instance


      if (this.activeInstances[videoId]) {
        var element = this.activeInstances[videoId].element; // if a video is vr need to use bit_wrapper method to destroy (not html5-main)

        if (this.isVr && OO.isIos && this.focusVideoId === OO.VIDEO.MAIN && videoId === OO.VIDEO.ADS) {
          element = this.activeInstances[this.focusVideoId].element;
        }

        delete this.activeInstances[videoId]; // Destroy orphaned elements

        if (element && !_hasInstances(element)) {
          // If not associated with virtual instances, destroy the element
          _safeFunctionCall(element, 'destroy', []);

          activeElements = _.without(activeElements, element);
          element = null;
        }
      } // Delete the instance and notify


      if (!this.isVideoTypeChanged) {
        mb.publish(OO.EVENTS.VC_VIDEO_ELEMENT_DISPOSED, videoId);
      }
    }, this);

    var _hasInstances = _.bind(function (element) {
      if (!element) {
        return false;
      }

      for (var instance in this.activeInstances) {
        if (this.activeInstances[instance] && this.activeInstances[instance].element && this.activeInstances[instance].element === element) {
          return true;
        }
      }

      return false;
    }, this);

    var willPlayAds = _.bind(function (eventName, params) {
      // Remove the closed captions prior to ad play on iOS
      if (OO.isIos && params && params.duration > 0) {
        setClosedCaptionsLanguage('', '', {
          'mode': ccMode
        });
      }
    }, this); // ********************
    // Element focus
    // ********************


    var vcFocusVideoElement = _.bind(function (eventName, videoId, ooyalaAds) {
      // If already in focus
      if (videoId && this.focusVideoId === videoId) {
        mb.publish(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, videoId);
        return;
      } // Defocus currently focused element
      // Don't necessarily need to do null check here
      // csai


      if (this.focusVideoId) {
        // if csai mode, the currently focused element is main, main video is live, and sharing is not required
        if (csaiMode && this.focusVideoId === OO.VIDEO.MAIN && this.activeInstances[this.focusVideoId] && this.activeInstances[this.focusVideoId].isLive && !_checkIfElementSharingRequired(registeredPlugins[this.activeInstances[this.focusVideoId].plugin])) {
          // just mute the volume, so we can continue receiving ID3 tags in the background
          savedMainVolume = currentVolume === null ? 1 : currentVolume;

          _callIfInControl(this.focusVideoId, 'setVolume', [0, currentMuteState]);
        } else {
          // else go with default behavior
          _removeFocusFromElement(this.focusVideoId);
        }
      }

      this.focusVideoId = null; // Check if we should focus anything

      if (!videoId || !this.activeInstances[videoId]) {
        return;
      }

      this.focusVideoId = videoId; // csai

      if (this.focusVideoId === OO.VIDEO.MAIN && savedMainVolume !== null) {
        _callIfInControl(this.focusVideoId, 'setVolume', [savedMainVolume, currentMuteState]);
      }
      /* PBF-790: In case of ooyala ads, _takeElementControl() is not called when ad is done playing in devices.
         Found that isControllingElement of main element is set to true when ad finishes playing.
         Tried setting the isControllingElement of main to false when ad starts playing on EMBED_CODE_CHANGED
         event in AMC but it didn't work. As we are not sure on the root cause of the problem below is the
         workaround to switch the control from ad element to main once ad is done playing in devices
      */


      if (ooyalaAds && videoId === OO.VIDEO.MAIN) {
        this.activeInstances[videoId].isControllingElement = false;
      }

      _prepareInstanceForAction(videoId); // Focus the element


      var css = {
        'visibility': 'visible'
      };

      if (OO.isIos) {
        css['display'] = OO.CSS.VISIBLE_DISPLAY;
      } else {
        css['left'] = '0px';
      }

      _safeFunctionCall(this.activeInstances[videoId].element, 'applyCss', [css]); // Workaround to allow iPhone to remove closed captions before switching the video element


      if (OO.isIos) {
        _.delay(function () {
          mb.publish(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, videoId);
        }, 1);
      } else {
        mb.publish(OO.EVENTS.VC_VIDEO_ELEMENT_IN_FOCUS, videoId);
      } // Set current audio track for the element in focus


      if (this.defaultAudioTracks[videoId]) {
        mb.publish(OO.EVENTS.SET_CURRENT_AUDIO, videoId, this.defaultAudioTracks[videoId]);
      } // Set the closed captions for the element in focus


      setClosedCaptionsLanguage('', activeLanguage, {
        'mode': ccMode
      });
    }, this);

    var _removeFocusFromElement = _.bind(function (videoId) {
      if (!(videoId && this.activeInstances && this.activeInstances[videoId] && this.activeInstances[videoId].element)) {
        return;
      } // csai


      if (this.focusVideoId === OO.VIDEO.ADS && savedMainVolume !== null) {
        _callIfInControl(OO.VIDEO.MAIN, 'setVolume', [savedMainVolume, currentMuteState]);
      } // Send the 'transition' parameter to indicate that the video is going into hiding
      // The skin should use this field to know not to show the pause animation
      // Only pause if there are multiple video elements
      // Pausing during a single video element could interfere with ad transitions


      if (!OO.requiresSingleVideoElement) {
        mb.publish(OO.EVENTS.VC_PAUSE, videoId, 'transition');
      }

      this.focusVideoId = null;
      var css = {
        'visibility': 'hidden'
      };

      if (OO.isIos) {
        css['display'] = OO.CSS.INVISIBLE_DISPLAY;
      } else {
        css['left'] = '-100000px';
      }

      _safeFunctionCall(this.activeInstances[videoId].element, 'applyCss', [css]);

      _safeFunctionCall(this.activeInstances[videoId].element, 'setClosedCaptionsMode', [OO.CONSTANTS.CLOSED_CAPTIONS.DISABLED]);

      mb.publish(OO.EVENTS.VC_VIDEO_ELEMENT_LOST_FOCUS, videoId);
    }, this); // ********************
    // Plugin control apis
    // ********************


    var adsPlayed = _.bind(function (eventName) {
      if (this.activeInstances[this.focusVideoId]) {
        _safeFunctionCall(this.activeInstances[this.focusVideoId].element, 'onAdsPlayed');
      }
    }, this);

    var vcSetVideoStreams = _.bind(function (eventName, videoId, streams, isLive) {
      if (!(videoId && this.activeInstances && this.activeInstances[videoId] && this.activeInstances[videoId].element)) {
        return;
      } // if streams parameter is empty, clear stream object from the video


      if (!streams) {
        _setVideoStream(videoId, '', {
          url: ''
        }, false);

        return;
      }

      var chosenEncoding = _selectEncoding(streams, this.activeInstances[videoId].element.supportedEncodings, _getEncodingPriorities());
      /*
        // TODO: Do we wish to select an encoding based on the full list of plugins or use the one we have?
        mb.publish(OO.EVENTS.VC_DISPOSE_VIDEO_ELEMENT, OO.VIDEO.ADS);
        mb.publish(OO.EVENTS.VC_CREATE_VIDEO_ELEMENT, OO.VIDEO.ADS, streams, this.pluginsElement);
        (if it was in focus, focus the new element)
      */
      // If none are selected, raise an error


      if (!chosenEncoding) {
        mb.publish(OO.EVENTS.VC_ERROR, videoId, {
          ooyalaErrorCode: OO.ERROR.VC.UNSUPPORTED_ENCODING,
          playhead: this.currentPlayhead
        });
        return;
      }

      _setVideoStream(videoId, chosenEncoding, streams[chosenEncoding], isLive || this.activeInstances[videoId].isLive);
    }, this);

    var vcPreload = _.bind(function (eventName, videoId) {
      OO.log('VTC: Video preload called.'); // [PLAYER-1323]
      // Preload might be called after the video is already playing. We should avoid
      // setting the rewind parameter to true so that the event just gets ignored if
      // the video is already playing.

      _callIfInControl(videoId, 'load', [false]);
    }, this);

    var vcReload = _.bind(function (eventName, videoId) {
      _callIfInControl(videoId, 'load', [false]);
    }, this);

    var vcSetInitialTime = _.bind(function (eventName, videoId, initialTime) {
      if (this.activeInstances && this.activeInstances[videoId] && this.activeInstances[videoId].element) {
        // NOTE: Each video technology may handle this differently.
        _safeFunctionCall(this.activeInstances[videoId].element, 'setInitialTime', [initialTime]);
      }
    }, this);
    /**
     * Primes a video element with a user click so that we can programaticaly control playback.
     * Needs to be called on a user click thread.
     * @private
     * @method VideoController#primeVideo
     * @param {string} videoId The id of the video to prime
     */


    var primeVideo = _.bind(function (videoId) {
      if (_isInControl(videoId)) {
        _safeFunctionCall(this.activeInstances[videoId].element, 'primeVideoElement', []);

        this.activeInstances[videoId].element.primedForUnmutedAutoPlayback = true;
      }
    }, this); // added videoId so we can specify which element we want play.
    // used in HA functionality to start a playback before swapping video elements
    // if videoId is not provided, currently focused video ID will be used instead


    var play = _.bind(function (event, videoId) {
      if (primeVideosOnPlay) {
        primeVideosOnPlay = false; // PLAYER-3090: If muted autoplay failed, prime videos here so that when user clicks on the play icon,
        // our video elements can be played programatically
        // TODO: Since this is not guaranteed to be triggered on the user click,
        // either trigger this on user clicks only (we'll need to add a fromUser flag to our
        // PLAY message bus events), or rework the flow such that if muted autoplay fails, we start
        // back at INITIAL_PLAY with wasAutoplayed set to false

        primeVideo(OO.VIDEO.MAIN);
      } // TODO: May need to take url as a parameter


      mb.publish(OO.EVENTS.VC_PLAY, videoId || this.focusVideoId);
    }, this);

    var vcPlay = _.bind(
    /*#__PURE__*/
    function () {
      var _ref7 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee7(eventName, videoId, url) {
        var autoplaying, requiresMutedAutoplay, requiresNoAutoplay, muting, isMuted, checkInstance;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this.activeInstances && this.activeInstances[videoId]) {
                  _context7.next = 2;
                  break;
                }

                return _context7.abrupt("return");

              case 2:
                autoplaying = !this.activeInstances[videoId].playing && autoplayed;
                requiresMutedAutoplay = autoplaying && canAutoplay.unmuted === false && !currentMuteState && (!this.activeInstances[videoId].element || !this.activeInstances[videoId].element.primedForUnmutedAutoPlayback);
                requiresNoAutoplay = autoplaying && canAutoplay.muted === false && (!this.activeInstances[videoId].element || !this.activeInstances[videoId].element.primedForUnmutedAutoPlayback);
                muting = false;
                isMuted = _safeFunctionCall(this.activeInstances[videoId].element, 'isMuted', []); // PBW-7054 + PBW-7044 : Setting the mute state after changing the volume
                // risks the volume getting reset to 1 in certain cases. Generally this
                // should never happen but keeping change mute state before change volume
                // will ensure it never does

                if (!this.activeInstances[videoId].playing) {
                  // attempt to restore user mute state if needed
                  if (!requiresMutedAutoplay && !requiresNoAutoplay) {
                    muting = currentMuteState && !isMuted;
                    mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, currentMuteState, videoId);
                  } // Set current volume


                  if (typeof currentVolume === 'number') {
                    mb.publish(OO.EVENTS.CHANGE_VOLUME, currentVolume, videoId);
                  }
                } else {
                  // TODO: Restore mute state of the video based on its current mute state rather than
                  // the current mute state of the player
                  // attempt to restore user mute state if needed
                  if (!requiresMutedAutoplay && !requiresNoAutoplay) {
                    muting = currentMuteState && !isMuted;
                    mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, currentMuteState, videoId);
                  } // if we're transitioning from a video element that needed to be muted (such as a midroll),
                  // we'll need to restore the proper mute state and current volume here


                  if (typeof currentVolume === 'number') {
                    mb.publish(OO.EVENTS.CHANGE_VOLUME, currentVolume, videoId);
                  }
                }

                if (url) {
                  if (this.activeInstances[videoId].stream) {
                    this.activeInstances[videoId].stream.url = url;
                  } else {
                    this.activeInstances[videoId].stream = {
                      url: url
                    };
                  }
                }

                _prepareInstanceForAction(videoId); // This value may be null in the case where a module will be controlling the url manually
                // This is true for freewheel


                checkInstance = this.activeInstances[videoId].stream && this.activeInstances[videoId].stream.url && this.activeInstances[videoId].plugin !== OO.VIDEO_PLAYERS.BIT_WRAPPER;

                if (!checkInstance) {
                  _context7.next = 15;
                  break;
                }

                _context7.next = 14;
                return _setVideoStream(videoId, this.activeInstances[videoId].encoding, this.activeInstances[videoId].stream, this.activeInstances[videoId].isLive);

              case 14:
                // If we don't sent playing to true here, then if we lose element control before playing is raised
                // we may not keep our current position.  This happens when switching to an ad after seeking if
                // we were paused.
                this.activeInstances[videoId].playing = true;

              case 15:
                if (requiresNoAutoplay) {
                  OO.log('VTC: notifying of muted playback failure on initial play ' + 'because test showed we cannot autoplay');
                  this.notify(videoId, '', this.EVENTS.MUTED_PLAYBACK_FAILED);
                } else if (requiresMutedAutoplay) {
                  OO.log('VTC: notifying of unmuted playback failure on initial play ' + 'because test showed we need to mute');
                  this.notify(videoId, '', this.EVENTS.UNMUTED_PLAYBACK_FAILED);
                } else {
                  if (muting) {
                    playbackVideoAfterMute = videoId;
                  } else {
                    mb.publish(OO.EVENTS.PLAY_VIDEO_ELEMENT, videoId);
                  }
                }

              case 16:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      return function (_x31, _x32, _x33) {
        return _ref7.apply(this, arguments);
      };
    }(), this);

    var playVideoElement = _.bind(function (event, videoId) {
      if (!(this.activeInstances && this.activeInstances[videoId])) {
        return;
      }

      var isStoredPlayheadLive = Math.abs(this.failoverPlayhead - this.currentDuration) < 1;

      if (this.handleFailover && !isStoredPlayheadLive) {
        _callIfInControl(videoId, 'handleFailover', [this.failoverPlayhead]);

        this.handleFailover = false;
      }

      _safeFunctionCall(this.activeInstances[videoId].element, 'play', []);

      _setPlaybackSpeed(videoId);
    }, this);

    var pause = _.bind(function (event, videoId) {
      mb.publish(OO.EVENTS.VC_PAUSE, videoId || this.focusVideoId);
    }, this);

    var vcPause = _.bind(function (eventName, videoId) {
      _callIfInControl(videoId, 'pause', []); // It is necessary to stop the rotation of the camera


      if (this.isVr) {
        moveVrToDirection(eventName, videoId, false);
      }
    }, this);
    /**
     * Set viewing directions for Vr video
     * @private
     * @param {string} event - the eventName
     * @param {string} videoId - the id of the video to set directions for
     * @param {number} yaw - rotation around the vertical axis
     * @param {number} roll - rotation around the front-to-back axis
     * @param {number} pitch - rotation around the side-to-side axis
     */


    var touchMove = _.bind(function (event, videoId, yaw, roll, pitch) {
      var currentVideoId = videoId;

      if (!videoId || videoId === OO.VIDEO.ADS) {
        currentVideoId = OO.VIDEO.MAIN;
      }

      _callIfInControl(currentVideoId, 'setVrViewingDirection', [{
        yaw: yaw,
        roll: roll,
        pitch: pitch
      }]);
    }, this);

    var onEndVrMove = _.bind(function (event, videoId) {
      var currentVideoId = videoId;

      if (!videoId) {
        currentVideoId = OO.VIDEO.MAIN;
      }

      _callIfInControl(currentVideoId, 'onEndVrMove');
    });
    /**
     * Publishes the VR direction
     * (viewing direction, if VR content is played
     * or current viewing direction if VR content is rotated)
     * to the message bus.
     * @private
     * @param {string} event The eventName
     * @param {string} videoId The id of the video to get directions for
     * @param {boolean} useVrViewingDirection flag says to use 'getVrViewingDirection'
     * @fires OO.EVENTS.VR_DIRECTION_CHANGED
     */


    var checkVrDirection = _.bind(function (event, videoId, useVrViewingDirection) {
      if (videoId !== OO.VIDEO.ADS) {
        // Should not use OO.VIDEO.ADS as videoId
        // videoId may be 'main', 'reload', etc
        this.vrVideoId = videoId;
      }

      var isVideoMoving = _callIfInControl(this.vrVideoId, 'getIsVideoMoving', []); // if the video is rotating now or we need to have exactly vrViewingDirection at the moment


      var getViewingDirectionFuncName = useVrViewingDirection || isVideoMoving ? 'getVrViewingDirection' : 'getCurrentDirection';
      var viewingDirection = _callIfInControl(this.vrVideoId, getViewingDirectionFuncName) || {
        yaw: 0,
        roll: 0,
        pitch: 0
      };
      mb.publish(OO.EVENTS.VR_DIRECTION_CHANGED, viewingDirection.yaw, viewingDirection.roll, viewingDirection.pitch);
    }, this);

    var seek = _.bind(function (eventName, time, videoIdIn) {
      var videoId = videoIdIn || this.focusVideoId;
      mb.publish(OO.EVENTS.VC_SEEK, videoId, time);
    }, this);

    var vcSeek = _.bind(function (eventName, videoId, time) {
      if (videoId && this.activeInstances[videoId] && this.activeInstances[videoId].element && this.activeInstances[videoId].element.wrapper) {
        _callIfInControl(videoId, 'seek', [time]);
      }
    }, this);

    var changeVolume = _.bind(function (eventName, newVolume, videoId) {
      if (typeof newVolume !== 'number' || newVolume < 0 || newVolume > 1) {
        log('Can not assign volume with invalid value', newVolume);
        return;
      }

      currentVolume = newVolume;

      if (videoId) {
        _callIfInControl(videoId, 'setVolume', [currentVolume, currentMuteState]);
      } else {
        // Change the volume on all active elements
        for (var index = 0; index < activeElements.length; index++) {
          _safeFunctionCall(activeElements[index], 'setVolume', [currentVolume, currentMuteState]);
        }
      }
    }, this);

    var changeMuteState = _.bind(
    /*#__PURE__*/
    function () {
      var _ref8 = (0, _asyncToGenerator2.default)(
      /*#__PURE__*/
      _regenerator.default.mark(function _callee8(eventName, muted, videoId, fromUser) {
        var oldMuteState, sharing, index;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                oldMuteState = currentMuteState;
                currentMuteState = muted; // If user unmutes, make sure subsequent transitions are unmuted

                if (muteFirstPlay && !muted && fromUser) {
                  muteFirstPlay = false;
                }

                if (!(autoplayed && !muted && oldMuteState && fromUser)) {
                  _context8.next = 12;
                  break;
                }

                // if unmuting preroll during muted autoplay, load the content so that we can transition into content
                // unmuted without an additional click
                // do not load if we are sharing video elements as that will disrupt the ad
                sharing = this.activeInstances && this.activeInstances[OO.VIDEO.MAIN] && this.activeInstances[OO.VIDEO.MAIN].plugin && _checkIfElementSharingRequired(registeredPlugins[this.activeInstances[OO.VIDEO.MAIN].plugin]);

                if (this.initialPlayHasStarted) {
                  _context8.next = 10;
                  break;
                }

                if (sharing) {
                  _context8.next = 10;
                  break;
                }

                _context8.next = 9;
                return loadVideoForUnmutedAutoplay(OO.VIDEO.MAIN);

              case 9:
                if (OO.isAndroid) {
                  // Workaround for PLAYER-2166 and PLAYER-2454. Android requires initial play() calls to be on the user click thread.
                  // We will prime the content on a user click here so that the content can start without a user click unmuted.
                  primeVideo(OO.VIDEO.MAIN);
                }

              case 10:
                // Unmuting on a user click is enough for Safari 11 to autoplay IMA ads unmuted based on investigation.
                // This line will allow IMA ads to autoplay midrolls unmuted if user unmuted during content
                if (this.activeInstances && this.activeInstances[OO.VIDEO.ADS] && this.activeInstances[OO.VIDEO.ADS].element) {
                  this.activeInstances[OO.VIDEO.ADS].element.primedForUnmutedAutoPlayback = true;
                }

                _callIfInControl(OO.VIDEO.ADS, 'unmute', [fromUser]);

              case 12:
                if (!muted) {
                  mutingForAutoplay = false;
                }

                if (videoId) {
                  if (muted) {
                    _callIfInControl(videoId, 'mute');
                  } else {
                    if (fromUser && this.activeInstances && this.activeInstances[videoId] && this.activeInstances[videoId].element) {
                      this.activeInstances[videoId].element.primedForUnmutedAutoPlayback = true;
                    }

                    _callIfInControl(videoId, 'unmute', [fromUser]);
                  }
                } else {
                  // Change the mute state on all active elements
                  for (index = 0; index < activeElements.length; index++) {
                    if (muted) {
                      _safeFunctionCall(activeElements[index], 'mute');
                    } else {
                      if (fromUser) {
                        activeElements[index].primedForUnmutedAutoPlayback = true;
                      }

                      _safeFunctionCall(activeElements[index], 'unmute', [fromUser]);
                    }
                  }
                }

              case 14:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      return function (_x34, _x35, _x36, _x37) {
        return _ref8.apply(this, arguments);
      };
    }(), this);

    var setVideoVr = _.bind(function (eventName, params) {
      this.isVr = true;

      if (params && params.source && params.source.vr && params.source.vr.startPosition) {
        this.startPositionVr = params.source.vr.startPosition;
      }

      _callIfInControl(OO.VIDEO.MAIN, 'setVrViewingDirection', [{
        yaw: this.startPositionVr
      }]);

      this.desiredPlaybackSpeed = 1.0; // VR videos should play in 1x speed.
    }, this);

    var toggleStereoVr = _.bind(function () {
      activeElements.forEach(function (el) {
        _safeFunctionCall(el, 'toggleStereoVr', []);
      });
    }, this);

    var toggleFullscreenVr = _.bind(function (eventName, videoId) {
      _callIfInControl(videoId, 'toggleFullscreen', []);
    }, this);

    var moveVrToDirection = _.bind(function (eventName, videoId, rotate, direction) {
      _callIfInControl(videoId, 'moveVrToDirection', [rotate, direction]);
    }, this);

    var pageUnloadRequested = _.bind(function () {
      _delayErrorPublishing();
    }, this);

    var enableSeeking = _.bind(function (eventName, videoId) {
      if (videoId && this.activeInstances[videoId]) {
        this.activeInstances[videoId].disableNativeSeek = false;

        if (this.activeInstances[videoId].isControllingElement && this.activeInstances[videoId].element && this.activeInstances[videoId].element.isControllingObject && this.activeInstances[videoId].element.wrapper) {
          this.activeInstances[videoId].element.wrapper.disableNativeSeek = false;
        }
      }
    }, this);

    var disableSeeking = _.bind(function (eventName, videoId) {
      if (videoId && this.activeInstances[videoId]) {
        this.activeInstances[videoId].disableNativeSeek = true;

        if (this.activeInstances[videoId].isControllingElement && this.activeInstances[videoId].element && this.activeInstances[videoId].element.isControllingObject && this.activeInstances[videoId].element.wrapper) {
          this.activeInstances[videoId].element.wrapper.disableNativeSeek = true;
        }
      }
    }, this);

    var setClosedCaptionsLanguage = _.bind(function (eventName, language, params) {
      var captionParams = params || {};

      if (captionParams.mode == null) {
        captionParams.mode = OO.CONSTANTS.CLOSED_CAPTIONS.SHOWING;
      }

      activeLanguage = language;
      ccMode = captionParams.mode;

      if (this.focusVideoId && captionParams.mode === OO.CONSTANTS.CLOSED_CAPTIONS.DISABLED) {
        _callIfInControl(this.focusVideoId, 'setClosedCaptionsMode', [captionParams.mode]);
      } else if (this.activeInstances[this.focusVideoId]) {
        var requiresNativeCaptions = (OO.isIphone || OO.isIpad) && (captionParams.isFullScreen || captionParams.isGoingFullScreen); // iPhone and iPad use their native video players when fullscreen so we must let them also render the captions, instead of our skin.

        if (requiresNativeCaptions && captionParams.mode === OO.CONSTANTS.CLOSED_CAPTIONS.HIDDEN) {
          captionParams.mode = OO.CONSTANTS.CLOSED_CAPTIONS.SHOWING;
        }

        _callIfInControl(this.focusVideoId, 'setClosedCaptions', [language, this.activeInstances[this.focusVideoId].closedCaptions, captionParams]);
      }
    }, this);
    /**
     * Set audio track by id as current (active) track
     * this method is the single source of truth when setting current (active) track
     * @method VideoController#setCurrentAudio
     * @private
     * @param {string} eventName The eventName
     * @param {string} videoId The id of the video to set the audio track for
     * @param {object} nextTrack The audio track information
     */


    var setCurrentAudio = _.bind(function (eventName, videoId, nextTrack) {
      if (nextTrack && nextTrack.id) {
        _callIfInControl(videoId, 'setAudio', [nextTrack.id]);

        this.defaultAudioTracks[videoId] = nextTrack;
      }
    }, this);
    /**
     * Extend current skinConfig with new skinConfig
     * @method VideoController#onSkinConfigLoaded
     * @private
     */


    var onSkinConfigLoaded = _.bind(function (event, loadedSkinConfig, params) {
      skinConfig = _.extend(skinConfig, loadedSkinConfig);
    }, this);

    var onSetPlaybackSpeed = _.bind(function (event, speed) {
      if (OO.isValidPlaybackSpeed(speed)) {
        var isLive = this.activeInstances[OO.VIDEO.MAIN] && this.activeInstances[OO.VIDEO.MAIN].isLive;

        if (this.isVr || isLive) {
          this.desiredPlaybackSpeed = 1.0;
        } else {
          this.desiredPlaybackSpeed = speed;
        } // try to set the speed immediately. But if the video element doesn't
        // exist, it will be set later.


        if (this.activeInstances[OO.VIDEO.MAIN] && this.activeInstances[OO.VIDEO.MAIN].element) {
          _safeFunctionCall(this.activeInstances[OO.VIDEO.MAIN].element, 'setPlaybackSpeed', [this.desiredPlaybackSpeed]);
        }

        ;
      } else {
        OO.log('Playback speed was not valid. Will be ignored.', speed);
      }
    }, this);

    var onChromecastStartCast = _.bind(function (event) {
      isChromeCasting = true;
      unsubscribeFromVideoEvents();
    }, this);

    var onChromecastEndCast = _.bind(function (event) {
      isChromeCasting = false;
      subscribeToVideoEvents();
    }, this);

    var unsubscribeFromVideoEvents = function unsubscribeFromVideoEvents() {
      mb.unsubscribe(OO.EVENTS.PLAY, 'vtc', play);
      mb.unsubscribe(OO.EVENTS.PAUSE, 'vtc', pause);
      mb.unsubscribe(OO.EVENTS.SEEK, 'vtc', seek);
    };

    var subscribeToVideoEvents = function subscribeToVideoEvents() {
      mb.subscribe(OO.EVENTS.PLAY, 'vtc', play);
      mb.subscribe(OO.EVENTS.PAUSE, 'vtc', pause);
      mb.subscribe(OO.EVENTS.SEEK, 'vtc', seek);
    };

    var setTargetBitrate = _.bind(function (eventName, targetBitrate, options, videoId) {
      var actualVideoId = videoId || this.focusVideoId; // check bitrate feature available and call setBitrate on plugin

      if (actualVideoId && _.contains(registeredPlugins[this.activeInstances[actualVideoId].plugin].features, OO.VIDEO.FEATURE.BITRATE_CONTROL)) {
        _callIfInControl(actualVideoId, 'setBitrate', [targetBitrate]);
      }
    }, this);
    /**
     * Destroy the Video Tech Controller, all elements, and all plugins.
     * @method VideoController#onDestroy
     * @public
     */


    this.onDestroy = function () {
      // Destroy all instances
      for (var videoId in this.activeInstances) {
        vcDisposeVideoElement(OO.EVENTS.DESTROY, videoId);
      } // TODO: Destroy self

    }; // ********************
    // Public Plugin APIs
    // ********************

    /**
     * Notify the Video Controller of an event from the video.  This is not called directly by the plugins.
     * @method VideoController#notify
     * @protected
     * @param {string} videoId The id of the video element
     * @param {string} plugin The plugin name
     * @param {string} eventName The event name as found in VideoController#EVENTS
     * @param {object} eventparams The event parameters.
     *                             Refer to VideoController#EVENTS for required parameters for each event.
     * @fires OO.EVENTS.VC_WILL_PLAY
     * @fires OO.EVENTS.SEEK
     * @fires OO.EVENTS.VC_CAN_PLAY
     * @fires OO.EVENTS.VC_PLAYING
     * @fires OO.EVENTS.VC_PLAYED
     * @fires OO.EVENTS.VC_ERROR
     * @fires OO.EVENTS.VC_SEEKING
     * @fires OO.EVENTS.VC_SEEKED
     * @fires OO.EVENTS.VC_PAUSED
     * @fires OO.EVENTS.PLAYHEAD_TIME_CHANGED
     * @fires OO.EVENTS.VOLUME_CHANGED
     * @fires OO.EVENTS.BUFFERING
     * @fires OO.EVENTS.BUFFERED
     * @fires OO.EVENTS.DOWNLOADING
     * @fires OO.EVENTS.FULLSCREEN_CHANGED
     * @fires OO.EVENTS.CLOSED_CAPTIONS_INFO_AVAILABLE
     * @fires OO.EVENTS.ASSET_DIMENSION
     * @fires OO.EVENTS.HA_FAILOVER_NOW
     * @fires OO.EVENTS.MULTI_AUDIO_FETCHED
     * @fires OO.EVENTS.SET_CURRENT_AUDIO
     */


    this.notify = function (videoId, plugin, eventName, eventparams) {
      if (isChromeCasting) {
        return;
      }

      var params = eventparams || {};

      switch (eventName) {
        case this.EVENTS.PLAY:
          mb.publish(OO.EVENTS.VC_WILL_PLAY, videoId, params['url']);
          break;

        case this.EVENTS.CAN_PLAY:
          mb.publish(OO.EVENTS.VC_CAN_PLAY, videoId);
          break;

        case this.EVENTS.PLAYING:
          OO.log('Video Id on play: ' + videoId);
          this.paused = false;

          if (!this.initialPlayHasStarted && videoId === OO.VIDEO.MAIN) {
            this.initialPlayHasStarted = true;
            var drm = this.activeInstances[videoId].stream.drm;
            var drmType = 'none';

            for (var key in drm) {
              if (drm[key] && !_.isEmpty(drm[key])) {
                drmType = key;
              }
            }

            var pluginUsed = this.activeInstances[videoId].element.plugin;
            mb.publish(OO.EVENTS.INITIAL_PLAY_STARTING, Date.now() - this.initialPlayTime, autoplayed, this.hasPlayedAd, this.currentPlayhead, pluginUsed, plugin.technology, this.activeInstances[videoId].encoding, this.activeInstances[videoId].stream.url, drmType, this.activeInstances[videoId].isLive);
          }

          if (this.activeInstances[videoId]) {
            this.activeInstances[videoId].playing = true;
          }

          mb.publish(OO.EVENTS.VC_PLAYING, videoId); // this used to have the stream url as a parameter

          break;

        case this.EVENTS.ENDED:
          if (this.activeInstances[videoId]) {
            this.activeInstances[videoId].playing = false;
          }

          mb.publish(OO.EVENTS.VC_PLAYED, videoId);
          mb.publish(OO.EVENTS.CANCEL_GEO_CHECKING);

          if (this.isVr) {
            // It is necessary to stop the rotation of the camera
            moveVrToDirection(eventName, videoId, false);
          }

          break;

        case this.EVENTS.ERROR:
          this.markReady(videoId);

          if (this.activeInstances[videoId]) {
            this.activeInstances[videoId].playing = false;
          }

          if (+params['errorcode'] === 0) {
            mb.publish(OO.EVENTS.HA_FAILOVER_NOW);
          }

          _handleErrors(params, videoId);

          break;

        case this.EVENTS.SEEKING:
          mb.publish(OO.EVENTS.VC_SEEKING, videoId);
          break;

        case this.EVENTS.SEEKED:
          if (this.activeInstances[videoId]) {
            var playhead = _safeFunctionCall(this.activeInstances[videoId].element, 'getCurrentTime');

            mb.publish(OO.EVENTS.VC_SEEKED, videoId, playhead);
          }

          break;

        case this.EVENTS.PAUSED:
          this.paused = true;
          mb.publish(OO.EVENTS.VC_PAUSED, videoId); // this event used to have the url as the parameter

          break;

        case this.EVENTS.PLAYBACK_RATE_CHANGE:
          mb.publish(OO.EVENTS.PLAYBACK_SPEED_CHANGED, videoId, params['playbackRate']);
          break;

        case this.EVENTS.TIME_UPDATE:
          if (typeof params.duration !== 'number') return;
          if (typeof params.currentTime !== 'number') return;
          var currentLiveTime;

          if (this.activeInstances[videoId].isLive) {
            currentLiveTime = params.currentLiveTime;
            this.currentDuration = params.duration;
          }

          this.currentPlayhead = params.currentTime;
          mb.publish(OO.EVENTS.PLAYHEAD_TIME_CHANGED, params.currentTime, params.duration, params.buffer, params.seekRange, videoId, currentLiveTime);
          break;

        case this.EVENTS.VOLUME_CHANGE:
          mb.publish(OO.EVENTS.VOLUME_CHANGED, params['volume'], videoId);
          break;

        case this.EVENTS.MUTE_STATE_CHANGE:
          // Detect native mute/unmute icon here on iOS Safari and go through the same flow
          // as if the click was on our skin mute/unmute icon
          if (OO.isIos && currentMuteState !== params['muted']) {
            mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, params['muted'], videoId, true);
          }

          mb.publish(OO.EVENTS.MUTE_STATE_CHANGED, params['muted'], videoId, mutingForAutoplay);

          if (playbackVideoAfterMute === videoId && params['muted'] === true) {
            playbackVideoAfterMute = null;
            mb.publish(OO.EVENTS.PLAY_VIDEO_ELEMENT, videoId);
          }

          break;

        case this.EVENTS.BUFFERING:
          mb.publish(OO.EVENTS.BUFFERING, params['url'], videoId, this.currentPlayhead);
          break;

        case this.EVENTS.BUFFERED:
          mb.publish(OO.EVENTS.BUFFERED, params['url'], videoId);
          break;

        case this.EVENTS.DURATION_CHANGE:
          if (typeof params['duration'] !== 'number') return;
          mb.publish(OO.EVENTS.PLAYHEAD_TIME_CHANGED, params['currentTime'], params['duration'], params['buffer'], params['seekRange'], videoId);
          break;

        case this.EVENTS.PROGRESS:
          mb.publish(OO.EVENTS.DOWNLOADING, params['currentTime'], params['duration'], params['buffer'], params['seekRange'], videoId);
          break;

        case this.EVENTS.STALLED:
          mb.publish(OO.EVENTS.STALLED);
          break;

        case this.EVENTS.WAITING:
          mb.publish(OO.EVENTS.BUFFERING, params['url'], videoId, this.currentPlayhead);
          break;

        case this.EVENTS.FULLSCREEN_CHANGED:
          mb.publish(OO.EVENTS.FULLSCREEN_CHANGED, params['isFullScreen'], params['paused'], videoId);
          setClosedCaptionsLanguage('', activeLanguage, {
            'mode': ccMode,
            'isFullScreen': params['isFullScreen']
          });
          break;

        case this.EVENTS.CAPTIONS_LANGUAGE_CHANGE:
          if (params.language) {
            mb.publish(OO.EVENTS.CHANGE_CLOSED_CAPTION_LANGUAGE, params.language, {
              forceEnabled: true
            });
          }

          break;

        case this.EVENTS.CAPTIONS_FOUND_ON_PLAYING:
          if (this.activeInstances[videoId] && eventparams) {
            // Set crossorigin so that we can load captions from outside sources
            _setCrossorigin(videoId, 'anonymous'); // Add the found plugins from the plugin to our existing available captions


            var availableClosedCaptions = {
              videoId: videoId,
              languages: [],
              locale: {}
            };

            if (this.activeInstances[videoId].closedCaptions && this.activeInstances[videoId].closedCaptions.availableLanguages && this.activeInstances[videoId].closedCaptions.locale) {
              availableClosedCaptions.languages = this.activeInstances[videoId].closedCaptions.availableLanguages;
              availableClosedCaptions.locale = this.activeInstances[videoId].closedCaptions.locale;
            }

            availableClosedCaptions.languages = _.union(availableClosedCaptions.languages, eventparams.languages);
            availableClosedCaptions.locale = _.extend(availableClosedCaptions.locale, eventparams.locale);
            mb.publish(OO.EVENTS.CLOSED_CAPTIONS_INFO_AVAILABLE, availableClosedCaptions);
          }

          break;

        case this.EVENTS.ASSET_DIMENSION:
          if (typeof params['width'] === 'number' && params['width'] > 0 && typeof params['height'] === 'number' && params['height'] > 0) {
            _.extend(params, {
              videoId: videoId
            });

            mb.publish(OO.EVENTS.ASSET_DIMENSION, params);
          }

          break;

        case this.EVENTS.BITRATES_AVAILABLE:
          // Avoid modifying array that was passed
          var bitrates = _.isArray(eventparams) ? eventparams.slice() : []; // Sort bitrates by resolution and then by bitrate in descending order

          bitrates.sort(function (prev, next) {
            var sanitizedPrev = prev || {};
            var sanitizedNext = next || {};
            var resolutionA = OO.ensureNumber(sanitizedPrev.width, 1) * OO.ensureNumber(sanitizedPrev.height, 1);
            var resolutionB = OO.ensureNumber(sanitizedNext.width, 1) * OO.ensureNumber(sanitizedNext.height, 1);
            var bitrateA = OO.ensureNumber(sanitizedPrev.bitrate, 0);
            var bitrateB = OO.ensureNumber(sanitizedNext.bitrate, 0); // When both resolutions are equal the difference will be falsy (zero) and
            // the second condition (bitrate) will be used instead

            return resolutionB - resolutionA || bitrateB - bitrateA;
          });
          mb.publish(OO.EVENTS.BITRATE_INFO_AVAILABLE, {
            bitrates: bitrates
          }, videoId);
          break;

        case this.EVENTS.BITRATE_CHANGED:
          if (_validateBitrate(eventparams)) {
            mb.publish(OO.EVENTS.BITRATE_CHANGED, eventparams);
          } else {
            log('Invalid bitrate object reported', eventparams);
          }

          break;

        case this.EVENTS.CLOSED_CAPTION_CUE_CHANGED:
          if (typeof eventparams !== 'string') return;
          mb.publish(OO.EVENTS.CLOSED_CAPTION_CUE_CHANGED, eventparams);
          break;

        case this.EVENTS.METADATA_FOUND:
          if (eventparams['type'] && eventparams['data']) {
            mb.publish(OO.EVENTS.VC_TAG_FOUND, videoId, eventparams['type'], eventparams['data']);
          }

          break;

        case this.EVENTS.PLUGIN_LOADED:
          if (eventparams['name'] && eventparams['time']) {
            mb.publish(OO.EVENTS.PLUGIN_LOADED, OO.PLUGINS.VIDEO, eventparams['name'], eventparams['time']);
          }

          break;

        case this.EVENTS.ON_DOWNLOAD_FINISHED:
          mb.publish(OO.EVENTS.HA_NOTIFY, 'requestCompleted', eventparams);
          break;

        case this.EVENTS.ON_SEGMENT_LOADED:
          mb.publish(OO.EVENTS.HA_NOTIFY, 'segmentLoaded', eventparams);
          break;

        case this.EVENTS.UNMUTED_PLAYBACK_FAILED:
          OO.log('Unmuted playback failed, attempting muted autoplay');

          if (autoplayed) {
            canAutoplay.unmuted = false;
            muteForAutoPlayback(videoId, true);
          }

          break;

        case this.EVENTS.UNMUTED_PLAYBACK_SUCCEEDED:
          if (videoId === OO.VIDEO.MAIN && autoplayed && !this.initialPlayHasStarted) {
            if (typeof canAutoplay.unmuted === 'undefined') {
              mb.publish(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, {
                unmuted: true,
                muted: true
              });
            }
          }

          break;

        case this.EVENTS.MUTED_PLAYBACK_FAILED:
          OO.log('Muted playback failed');

          if (videoId === OO.VIDEO.MAIN && autoplayed && !this.initialPlayHasStarted) {
            if (typeof canAutoplay.muted === 'undefined') {
              mb.publish(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, {
                muted: false,
                unmuted: false
              });
            }
          } // [PBW-6990]
          // There seems to be an issue on random Android devices that prevents muted
          // autoplay from working at all under certain (currently unknown) conditions.
          // As a workaround for these cases, we raise a PLAYING event followed by a PAUSE
          // event in order to force the player out its initial loading state and allow manual
          // playback with the control bar.


          if (autoplayed) {
            // since both unmuted and muted autoplays have failed, we are no longer autoplaying
            // and require a user click to proceed
            autoplayed = false; // Androids support multiple video elements and require video priming, so we'll need to prime
            // when the user clicks play

            primeVideosOnPlay = OO.isAndroid; // If autoplay fails but muteFirstPlay is set, we still set muted state to true

            if (!muteFirstPlay) {
              mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, false, videoId);
            } else {
              mb.publish(OO.EVENTS.CHANGE_MUTE_STATE, true, videoId);
              mutingForAutoplay = true;
            }

            this.notify(videoId, plugin, this.EVENTS.PAUSED);
          }

          break;

        case this.EVENTS.MUTED_PLAYBACK_SUCCEEDED:
          if (videoId === OO.VIDEO.MAIN && autoplayed && !this.initialPlayHasStarted) {
            if (typeof canAutoplay.muted === 'undefined') {
              mb.publish(OO.EVENTS.AUTOPLAY_CHECK_COMPLETE, {
                muted: true
              });
            }
          }

          break;

        case this.EVENTS.MULTI_AUDIO_AVAILABLE:
          var isCurrentEncoding = false;

          if (this.activeInstances[videoId] !== null) {
            isCurrentEncoding = _isCurrentEncoding(this.activeInstances[videoId].encoding, this.ALLOWED_MULTI_AUDIO_ENCODINGS);
          }

          if (isCurrentEncoding) {
            var _audioTracks = eventparams; // first we need to normalize all track langs -
            // search for language code in ISO-639/1/2/B/T
            // and return ISO-639-1 lang code

            var normalizedTracks = _audioTracks.map(function (track) {
              var lang = OO.normalizeLanguageCode(track.lang);
              var trackEntry = {
                id: track.id,
                lang: lang,
                label: track.label,
                enabled: track.enabled
              };
              return trackEntry;
            }); // instantiate the providers for default track data


            var providers = {
              localStorage: OO.localStorage,
              pageLevelParams: pageLevelParams,
              skinConfig: skinConfig,
              contentTree: contentTree
            }; // select the default track

            this.defaultAudioTracks[videoId] = OO.getDefaultTrack(normalizedTracks, providers);
            mb.publish(OO.EVENTS.MULTI_AUDIO_FETCHED, {
              tracks: _audioTracks,
              languageList: OO.LANGUAGE_LIST
            });
            mb.publish(OO.EVENTS.SET_CURRENT_AUDIO, videoId, this.defaultAudioTracks[videoId]);
          } else {
            _multiAudioTypeError();
          }

          break;

        case this.EVENTS.MULTI_AUDIO_CHANGED:
          var audioTracks = eventparams;
          mb.publish(OO.EVENTS.MULTI_AUDIO_CHANGED, {
            tracks: audioTracks
          });
          break;

        default:
          break;
      }
    };
    /**
     * Notifies the Video Controller that the video element is not ready to receive play commands.  This
     * will only have an effect if called before returning the element in the create API.
     * This should only be used in cases when the video wrapper will not be able to handle play events
     * in a synchronous fashion on devices such as Android that require playback directly upon user click.
     * @method VideoController#markNotReady
     * @protected
     * @param {string} videoId The videoId to mark as not ready.
     */


    this.markNotReady = function (videoId) {
      if (videoId && this.activeInstances[videoId] && !isPlaybackReady) {
        elementsNotReady.push(videoId);

        if (readyTimer === null) {
          mb.addDependent(OO.EVENTS.PLAYBACK_READY, OO.EVENTS.VC_READY, 'vtc', _restoreOrigParams);
          readyTimer = setTimeout(_declareReadyOnTimeout, READY_TIMEOUT);
        }
      }
    };
    /**
     * Notifies the Video Controller that the video element is ready to receive play commands.  This function
     * should only be called if VideoControllerInterface.markNotReady was called.
     * @method VideoController#markReady
     * @protected
     * @param {string|null} videoId The videoId to mark as ready.  If null is passed, marks all elements as ready.
     * @fires OO.EVENTS.VC_READY
     */


    this.markReady = function (videoId) {
      if (readyTimer === null && elementsNotReady.length === 0) {
        return;
      }

      if (!videoId) {
        elementsNotReady = [];
      } else {
        elementsNotReady = _.without(elementsNotReady, videoId);
      }

      if (elementsNotReady.length === 0) {
        if (readyTimer !== null) {
          clearTimeout(readyTimer);
          readyTimer = null;
        }

        mb.publish(OO.EVENTS.VC_READY);
      }
    }; // ********************
    // Helpers
    // ********************

    /**
     * This ensures that the parameters from the blocked event are maintained if it has a dependent
     * If nothing (or null) is returned, the blocked event would get raised with the parameters of
     * the blocker rather than the parameters which were specified by the caller.
     * This is required to ensure that VC_PLAY passes the stream url
     * This will change with PBW-2910 and can be removed at that time.
     * @private
     * @method VideoController#_restoreOrigParams
     * @param {String} eventName - name of the event
     * @param {String} dependentEvent - ?
     * @param {Object} origParams - ?
     * @param {Any} args - ?
     * @returns {Object} ?
     */


    var _restoreOrigParams = function _restoreOrigParams(eventName, dependentEvent, origParams, args) {
      return origParams;
    };
    /**
     * Marks all plugins as ready.
     * @private
     * @method VideoController#_declareReadyOnTimeout
     */


    var _declareReadyOnTimeout = _.bind(function () {
      this.markReady();
    }, this);
    /**
     * Safely triggers a function with the specified video wrapper.
     * @method VideoController#_safeFunctionCall
     * @private
     * @param {string} videoElement The element on which to call a function
     * @param {string} func The function to call
     * @param {object} params An array containing the function parameters
     * @returns {*} The return value of the function that was run or null
     */


    var _safeFunctionCall = function _safeFunctionCall(videoElement, func, params) {
      if (!videoElement) return;
      var videoWrapper = videoElement.wrapper;
      if (!videoWrapper) return;

      try {
        if (_.isFunction(videoWrapper[func])) {
          return videoWrapper[func].apply(videoWrapper, params);
        }
      } catch (err) {
        console.warn('Video tech plugin', videoElement && videoElement.plugin, "at function '" + func + "' threw exception - ", err);
      }

      return null;
    };
    /**
     * Check if encoding is one of the possible types
     * @method VideoController#_isCurrentEncoding
     * @private
     * @returns {Boolean} true if possible encoding, false otherwise
     */


    var _isCurrentEncoding = _.bind(function (encoding, encodingList) {
      if (_.isString(encoding) && _.isArray(encodingList)) {
        for (var index = 0; index < encodingList.length; index++) {
          if (encoding === encodingList[index]) {
            return true;
          }
        }
      }

      return false;
    }, this);
    /**
     * Throw error if stream type is not supported for multiaudio
     * @method VideoController#_multiAudioTypeError
     * @fires OO.EVENTS.MULTIAUDIO_ENCODING_ERROR
     * @private
     */


    var _multiAudioTypeError = _.bind(function () {
      mb.publish(OO.EVENTS.MULTIAUDIO_ERROR, this.focusVideoId, {
        code: OO.ERROR.MULTIAUDIO.UNSUPPORTED_ENCODING
      });
    }, this);
    /**
     * Checks to see if a video instance is in control of the video element.
     * When a virtual instance has control, the instance managing real element does not (and vice versa).
     * @private
     * @method VideoController#_isInControl
     * @param {string} videoId The id of the video instance to check
     * @returns {boolean} True if the video is in control, false otherwise
     */


    var _isInControl = _.bind(function (videoId) {
      if (!this.activeInstances[videoId] || !this.activeInstances[videoId].element || !this.activeInstances[videoId].isControllingElement) {
        return false;
      }

      return true;
    }, this);
    /**
     * Calls a function on a video element if the VideoInstance is controlling the video element.
     * When a virtual instance has control, the instance managing real element does not (and vice versa).
     * @private
     * @method VideoController#_callIfInControl
     * @param {string} videoId The id of the video instance to call a function on
     * @param {string} func The function to call on the video instance
     * @param {object} params A list of the parameters to pass to the function
     * @returns {*} The return value of the function that was run or undefined
     */


    var _callIfInControl = _.bind(function (videoId, func, params) {
      if (!_isInControl(videoId)) {
        return;
      }

      return _safeFunctionCall(this.activeInstances[videoId].element, func, params);
    }, this);
    /**
     * Sets crossorigin attribute based on the video instance.
     * @private
     * @method VideoController#_setCrossorigin
     * @param {string} videoId The id of the video to set the attribute
     * @param {object} crossorigin The crossorigin object to set on the element
     */


    var _setCrossorigin = _.bind(function (videoId, crossorigin) {
      if (!this.activeInstances[videoId]) return;
      this.activeInstances[videoId].crossorigin = crossorigin;

      _changeCrossorigin(videoId);
    }, this);
    /**
     * Changes crossorigin attribute based on the video instance.
     * @private
     * @method VideoController#_changeCrossorigin
     * @param {string} videoId The id of the video to set the attribute
     */


    var _changeCrossorigin = _.bind(function (videoId) {
      if (!this.activeInstances[videoId]) return;

      if (this.activeInstances[videoId].crossorigin) {
        _callIfInControl(videoId, 'setCrossorigin', [this.activeInstances[videoId].crossorigin]);
      } else {
        _callIfInControl(videoId, 'setCrossorigin', [null]);
      }
    }, this);
    /**
     * Switches playback sessions between unique instances of a single shared video element.
     * @private
     * @method VideoController#_switchElementBetweenInstances
     * @param {string} videoId The id of the video taking control
     */


    var _switchElementBetweenInstances = _.bind(function (videoId) {
      var oldController = _takeElementControl(videoId); // Set the crossorigin attribute


      _changeCrossorigin(videoId); // Update the vtc interface for the wrapper


      this.activeInstances[videoId].element.wrapper.controller = this.activeInstances[videoId].vtcInterface; // Reset the stream url and position

      _resetElementDataAfterSwitch(this.activeInstances[videoId], oldController);
    }, this);
    /**
     * Switch control from the instance currently in control of the shared element to the specified instance.
     * @private
     * @method VideoController#_takeElementControl
     * @param {string} videoId The id of the video taking control
     * @returns {object} The video instance that previously had control of the shared element
     */


    var _takeElementControl = _.bind(function (videoId) {
      var newController = this.activeInstances[videoId];
      if (newController.isControllingElement) return newController; // Find the instance currently in control

      var oldController = null;
      var instance;

      for (instance in this.activeInstances) {
        if (this.activeInstances[instance] && this.activeInstances[instance].element && this.activeInstances[instance].element === newController.element && this.activeInstances[instance].isControllingElement) {
          oldController = this.activeInstances[instance];
          break;
        }
      }

      log("Switching element between instances.  From: '" + instance + "', To: '" + videoId + "'"); // Swap Control

      newController.isControllingElement = true;

      if (oldController) {
        oldController.isControllingElement = false;
        return oldController;
      }
    }, this);
    /**
     * Switch control from the specified instance to another instance using the same element.
     * @private
     * @method VideoController#_handoffElementControl
     * @param {string} videoId The id of the video losing control
     */


    var _handoffElementControl = _.bind(function (videoId) {
      var oldController = this.activeInstances[videoId];

      if (!oldController || !oldController.isControllingElement) {
        return;
      } // Find an instance not currently in control


      var newController = null;

      for (var instance in this.activeInstances) {
        if (this.activeInstances[instance] && this.activeInstances[instance].element && this.activeInstances[instance].element === oldController.element && !this.activeInstances[instance].isControllingElement) {
          newController = this.activeInstances[instance];
          break;
        }
      } // Swap Control


      oldController.isControllingElement = false;

      if (newController) {
        newController.isControllingElement = true;
      }
    }, this);
    /**
     * If the video object is shared, switch control between element wrappers
     * @private
     * @method VideoController#_switchElementWrapperControl
     * @param {string} videoId The id of the video instance taking control
     */


    var _switchElementWrapperControl = _.bind(function (videoId) {
      if (!this.activeInstances[videoId].element.isControllingObject) {
        // Switch control
        var oldController = this.activeInstances[videoId].element.sharedObjectToInstance;
        log("Switching wrapper between elements.  From: '" + oldController + "', To: '" + videoId + "'");

        _safeFunctionCall(this.activeInstances[oldController].element, 'sharedElementGive', []);

        this.activeInstances[oldController].element.isControllingObject = false;

        _safeFunctionCall(this.activeInstances[videoId].element, 'sharedElementTake', []);

        this.activeInstances[videoId].element.isControllingObject = true; // Reset the stream url and position

        _resetElementDataAfterSwitch(this.activeInstances[videoId], this.activeInstances[oldController]);
      }
    }, this);
    /**
     * Sets the stream url and position to that of the newInstance and saves the playhead of the old instance.
     * @private
     * @method VideoController#_resetElementDataAfterSwitch
     * @param {object} newInstance The video instance taking control of the element
     * @param {object} oldInstance The video instance losing control of the element
     */


    var _resetElementDataAfterSwitch = _.bind(function (newInstance, oldInstance) {
      // Save the old playhead
      if (oldInstance) {
        // Check if the stream has finished playing or hasn't played at all, if so, save 0 as the playhead
        if (oldInstance.playing === true) {
          oldInstance.playhead = _safeFunctionCall(oldInstance.element, 'getCurrentTime');
          /* PBW-5179: In iOS, getCurrentTime() returns zero for the main video. Below is the workaround to set
             the playhead to the correct value */

          if (OO.isIos && oldInstance.playhead === 0) {
            oldInstance.playhead = this.currentPlayhead;
            this.currentPlayhead = 0;
          }
        } else {
          oldInstance.playhead = 0;
        }
      } // Set the new stream


      if (newInstance.stream) {
        var stream = newInstance.stream;
        var encoding = newInstance.encoding;
        var isLive = newInstance.isLive;

        _callIfInControl(newInstance.element, 'setPlatform', [newInstance.params.platform, encoding]);

        _safeFunctionCall(newInstance.element, 'setVideoUrl', [stream.url, encoding, isLive || false]);

        newInstance.playing = false; // Set DRM data if needed

        if (stream.drm && !_.isEmpty(stream.drm) && _isSupportedDRMEncoding(encoding)) {
          _safeFunctionCall(newInstance.element, 'setDRM', [stream.drm]);
        }
      } // Set initial time if required


      if (newInstance.playhead > 0) {
        _safeFunctionCall(newInstance.element, 'setInitialTime', [newInstance.playhead]);
      } // Restore native seeking state


      if (newInstance.element && newInstance.element.wrapper) {
        newInstance.element.wrapper.disableNativeSeek = newInstance.disableNativeSeek;
      }
    }, this);
    /**
     * Disposes a video element while keeping the video instance around.  Selects which video element to
     * dispose based on technology.
     * This function is not being called and might be deprecated.  It was made public to enable unit testing.
     * @protected
     * @method VideoController#_disposeAnyElementKeepInstance
     */


    this.disposeAnyElementKeepInstance = function () {
      // Favor disposal of an HTML5-based instance in case the mixed instance is not HTML5-based.
      var favoredTechnology = OO.VIDEO.TECHNOLOGY.HTML5;

      var videoId = _findElementToDispose(favoredTechnology);

      _disposeElementKeepInstance(videoId);
    };
    /**
     * Selects which video element to dispose based on technology.  If an element of this technology cannot
     * be found, an element of technology "mixed" will be selected (if available).
     * This function is not being called and might be deprecated.
     * @private
     * @method VideoController#_findElementToDispose
     * @param {string} desiredTechnology The technology of the video instance to select
     */


    var _findElementToDispose = _.bind(function (desiredTechnology) {
      var instanceToDispose = null;

      for (var instance in this.activeInstances) {
        if (this.activeInstances[instance] && this.activeInstances[instance].element) {
          var technology = registeredPlugins[this.activeInstances[instance].plugin].technology;

          if (technology === desiredTechnology) {
            return instance;
          } else if (technology === OO.VIDEO.TECHNOLOGY.MIXED) {
            instanceToDispose = instance;
          }
        }
      }

      return instanceToDispose;
    }, this);
    /**
     * Disposes a video element while keeping the video instance around.
     * This function is not being called and might be deprecated.
     * @private
     * @method VideoController#_disposeElementKeepInstance
     * @param {string} videoId The id of the video instance within which to dispose the video element
     */


    var _disposeElementKeepInstance = _.bind(function (videoId) {
      if (!videoId) return; // NOTE: Be careful here for ads.  We don't want a new ad to use the position of the previous stream.
      // Currently there is no issue here because ads will attempt to re-create the instance, thus not
      // hitting this line of code.
      // Check if the stream has finished playing or hasn't played at all, if so, save 0 as the playhead

      if (this.activeInstances[videoId].playing === true) {
        this.activeInstances[videoId].playhead = _safeFunctionCall(this.activeInstances[videoId].element, 'getCurrentTime');
      } else {
        this.activeInstances[videoId].playhead = 0;
      } // Remove focus


      if (this.focusVideoId === videoId) {
        // Note: this function attempts to pause the video, but this will take place after the destroy
        _removeFocusFromElement(videoId);
      } // Remove element from all shared instances


      var instance;

      for (instance in this.activeInstances) {
        if (instance !== videoId && this.activeInstances[instance] && this.activeInstances[instance].element && this.activeInstances[instance].element === this.activeInstances[videoId].element) {
          this.activeInstances[instance].isControllingElement = true;
          this.activeInstances[instance].element = null;
        }
      } // Quietly dispose the video element, do not raise an event to denote instance destroyal


      if (this.activeInstances[videoId].element) {
        _safeFunctionCall(this.activeInstances[videoId].element, 'destroy', []);

        activeElements = _.without(activeElements, this.activeInstances[videoId].element);
        this.activeInstances[instance].isControllingElement = true;
        this.activeInstances[videoId].element = null;
      }
    }, this);
    /**
     * Re-creates a video element for an existing instance.
     * @private
     * @method VideoController#_recreateDisposedElement
     * @param {string} videoId The id of the video instance within which to re-create the video element
     */


    var _recreateDisposedElement = _.bind(function (videoId) {
      // Grab the playhead before creating a new element
      var playhead = this.activeInstances[videoId].playhead;

      _createInstance(registeredPlugins[this.activeInstances[videoId].plugin], videoId, this.activeInstances[videoId].parentContainer, this.activeInstances[videoId].encoding, this.activeInstances[videoId].stream, this.activeInstances[videoId].isLive, this.activeInstances[videoId].params);

      vcVideoElementCreated('recreate', {
        'videoId': videoId
      }); // Set initial time if required

      if (playhead > 0) {
        _safeFunctionCall(this.activeInstances[videoId].element, 'setInitialTime', [playhead]);
      } // Restore native seeking state


      if (this.activeInstances[videoId].element && this.activeInstances[videoId].element.wrapper) {
        this.activeInstances[videoId].element.wrapper.disableNativeSeek = this.activeInstances[videoId].disableNativeSeek;
      }
    }, this);
    /**
     * Prepares and instance to take action.  Recreates dispose elements and takes element control.
     * @private
     * @method VideoController#_prepareInstanceForAction
     * @param {string} videoId The id of the video instance to prepare for action.
     */


    var _prepareInstanceForAction = _.bind(function (videoId) {
      if (this.activeInstances[videoId] && !this.activeInstances[videoId].element) {
        _recreateDisposedElement(videoId);
      } // If it's virtual, switch to this element


      if (!this.activeInstances[videoId].isControllingElement) {
        _switchElementBetweenInstances(videoId);
      } // If the video object is shared, switch control between element wrappers


      _switchElementWrapperControl(videoId);
    }, this);
    /**
     * Some plugins do not set the desired domId on the core video element.  Make a best-effort to find the
     * actual video element.  This won't be possible for flash-based videos.
     * @private
     * @method VideoController#_getElementIdOfVideo
     * @param {string} domId The dom id of the element to find
     */


    var _getElementIdOfVideo = _.bind(function (domId) {
      var element = $('#' + domId);

      if (element.length > 0 && !element.is('video')) {
        var foundElementId = element.find('video').attr('id');

        if (foundElementId) {
          return foundElementId;
        }
      }

      return domId;
    }, this);
    /**
     * Sets the video stream and DRM on the given element.
     * @private
     * @method VideoController#_setVideoStream
     * @param {string} videoId The id of the video instance
     * @param {string} encoding The encoding of video stream, possible values are found in OO.VIDEO.ENCODING
     * @param {object} stream The url and drm of the stream to set on the video element
     * @param {boolean} isLive True if it is a live asset, false otherwise
     * @returns {promise} a promise that indicates if the video stream was set
     */


    var _setVideoStream = _.bind(function (videoId, encoding, stream, isLive) {
      if (!this.activeInstances[videoId]) {
        return Promise.reject(new Error('No videoId was given'));
      }

      this.activeInstances[videoId].playhead = 0;
      this.activeInstances[videoId].playing = false;
      this.activeInstances[videoId].stream = stream;
      this.activeInstances[videoId].encoding = encoding;
      this.activeInstances[videoId].isLive = !!isLive;

      if (videoId === OO.VIDEO.MAIN && this.activeInstances[videoId].isLive === true) {
        this.desiredPlaybackSpeed = 1.0;
      }

      var initialTime = 0;

      if (this.activeInstances[videoId].params && this.activeInstances[videoId].params.initialTime) {
        initialTime = this.activeInstances[videoId].params.initialTime;
      }

      if (stream.drm && !_.isEmpty(stream.drm) && _isSupportedDRMEncoding(encoding)) {
        _callIfInControl(videoId, 'setDRM', [stream.drm]);
      }

      _callIfInControl(videoId, 'setPlatform', [this.activeInstances[videoId].params.platform, encoding]);

      if (pageLevelParams && pageLevelParams['adobe-ads']) {
        return _callIfInControl(videoId, 'setVideoUrl', [stream.url, encoding, isLive || false, pageLevelParams['adobe-ads']]);
      } else {
        return _callIfInControl(videoId, 'setVideoUrl', [stream.url, encoding, isLive || false, initialTime]);
      }
    }, this);
    /**
     * Check if the DRM encoding is currently supported
     * @private
     * @method VideoController#_isSupportedDRMEncoding
     * @param {string} encoding The encoding of video stream, possible values are found in OO.VIDEO.ENCODING
     * @return {boolean} True if DRM for the encoding is supported, otherwise false
     */


    var _isSupportedDRMEncoding = _.bind(function (encoding) {
      for (var key in OO.VIDEO.ENCODING.DRM) {
        if (OO.VIDEO.ENCODING.DRM[key] === encoding) return true;
      }

      return false;
    }, this);
    /**
     * Saves the closed captions object to the instance. If SSAI is enabled,
     * ignore closed captions from content tree.
     * @private
     * @method VideoController#_setClosedCaptions
     * @param {string} videoId The id of the video instance
     * @param {object} closedCaptions The closed captions to set on the video element
     */


    var _setClosedCaptions = _.bind(function (videoId, closedCaptions) {
      if (!this.activeInstances[videoId]) return;
      if (_isSSAIEnabled(this.activeInstances[videoId].isLive)) return;
      this.activeInstances[videoId].closedCaptions = closedCaptions;
    }, this);
    /**
     * Saves the params, closed captions object, crossorigin to the instance.
     * @private
     * @method VideoController#_setVideoParams
     * @param {string} videoId The id of the video instance
     * @param {object} params - params of the video
     */


    var _setVideoParams = _.bind(function (videoId, params) {
      if (!this.activeInstances[videoId]) return;

      if (params) {
        this.activeInstances[videoId].params = params;

        _setClosedCaptions(videoId, params.closedCaptions);

        _setCrossorigin(videoId, params.crossorigin);
      }
    }, this);
    /**
     * Sets the video stream secureContent
     * @private
     * @method VideoController#_setSecureContent
     * @param {string} videoId The id of the video instance
     * @param {object} contentMetadata the assetId and accountId of the content
     */


    var _setSecureContent = _.bind(function (videoId, contentMetadata) {
      if (!this.activeInstances[videoId] || !contentMetadata) return;

      _callIfInControl(videoId, 'setSecureContent', [contentMetadata]);
    }, this);
    /**
     * Emits errors if possible, otherwise saves errors in a list.
     * HTML5 Media Error Constants:
     *   MediaError.MEDIA_ERR_ABORTED = 1
     *   MediaError.MEDIA_ERR_NETWORK = 2
     *   MediaError.MEDIA_ERR_DECODE = 3
     *   MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED = 4
     *   MediaError.MEDIA_ERR_ENCRYPTED = 5 (Chrome only)
     *   Ooyala Extensions:
     *   NO_STREAM = 0
     *   UNKNOWN = -1
     *   DRM_ERROR = 6
     * @method VideoController#_handleErrors
     * @param {object} code The error code
     * @param {string} videoId The id of the video
     * @fires OO.EVENTS.PAGE_PROBABLY_UNLOADING
     * @fires OO.EVENTS.VC_PLAY_FAILED
     */


    var _handleErrors = _.bind(function (errorParams, videoId) {
      var eventData = {
        mediaErrorCode: errorParams.errorcode,
        pluginErrorCode: errorParams.pluginErrorCode,
        pluginErrorMessage: errorParams.pluginErrorMessage,
        playhead: this.currentPlayhead
      };
      var drmInfo = {}; // If the errorcode is 6 (DRM_ERROR) add any relevant drm info

      if (errorParams.errorcode === 6) {
        drmInfo = this.activeInstances[videoId].stream.drm;
      }

      eventData.drm = drmInfo;

      if (shouldEmitErrors) {
        _emitErrors();
      } else {
        // The error occurred when the page was probably unloading.
        // Happens more often on low bandwidth.
        OO.debug('Error not emitted: ' + errorParams.errorcode); // TODO: Store the videoId

        unemittedErrors.push(eventData);
        mb.publish(OO.EVENTS.PAGE_PROBABLY_UNLOADING);
        return;
      }

      mb.publish(OO.EVENTS.VC_PLAY_FAILED, videoId, eventData);
      mb.publish(OO.EVENTS.CANCEL_GEO_CHECKING);
    }, this);
    /**
     * Emits unemitted errors.
     * @method VideoController#_emitErrors
     * @private
     * @fires OO.EVENTS.VC_PLAY_FAILED
     */


    var _emitErrors = _.bind(function () {
      // Any errors that occurred after selecting to "stay" and before
      // the time limit are dispatched.
      shouldEmitErrors = true; // TODO: Get the videoId

      var videoId = '';

      _.each(unemittedErrors, function (error) {
        mb.publish(OO.EVENTS.VC_PLAY_FAILED, videoId, error);
      });

      unemittedErrors = [];
    }, this);
    /**
     * Delays error publishing by 5 seconds.
     * @method VideoController#_delayErrorPublishing
     * @private
     */


    var _delayErrorPublishing = _.bind(function () {
      // User-cancellable event beforeUnload has been dispatched to window.
      // Prevent errors to be dispatched due to the video element being destroyed.
      shouldEmitErrors = false; // Clear previous timeout in case the user selected "stay" and then
      // navigated away again, otherwise the error may get emitted on low bandwidth.

      clearTimeout(errorTimer); // Restore error dispatching after a timeout.
      // TODO: Can this be a defer?  Why do we need this?

      setTimeout(function () {
        // This will happen after the user clicks on "leave" or "stay" in case
        // the embedding webpage adds another listener which gives the option.
        // After 5 seconds it is assumed the user stayed on the page.
        errorTimer = _.delay(_emitErrors, 5000);
      }, 1);
    }, this);

    var _generateUniqueName = function _generateUniqueName() {
      // TODO: make more unique
      return Math.random().toString(36).substring(7);
    };
    /**
     * Increment number for try query param
     * If not exist in url, it will append it.
     * Count starts with 1.
     * @param {string} url URL that needs to be modified
     * @returns {string} modified url
     * @private
     */


    var increaseCountForTryParam = function increaseCountForTryParam(url) {
      var sanitizedUrl = url || '';
      var reg = new RegExp(/[&\?]try=(\d*)/); // eslint-disable-line no-useless-escape

      var result = reg.exec(sanitizedUrl);
      var toParse = result ? result[1] : 0;
      var count = (parseInt(toParse, 10) || 0) + 1;

      if (sanitizedUrl.indexOf('try=') !== -1) {
        return sanitizedUrl.replace(/try=(\d*)/, 'try=' + count);
      }

      if (sanitizedUrl.indexOf('?') !== -1) {
        return sanitizedUrl + '&try=1';
      }

      return sanitizedUrl + '?try=1';
    };
    /**
     * Validates a bitrate object before published to message bus.
     * Bitrate object needs the following properties:
     *   id: a String that uniquely identifies the object
     *   bitrate: a Number representing the bitrate
     *   height: a Number equal to vertical resolution
     *   width: a Number equal to the horizontal resolution
     * @method VideoController#_delayErrorPublishing
     * @param {Object} bitrate An object representing the bitrate switched to.
     * @private
     * @returns {Boolean} true if valid bitrate, otherwise false
     */


    var _validateBitrate = function _validateBitrate(bitrate) {
      if (!bitrate) {
        return false;
      }

      var idValid = bitrate.id !== undefined && typeof bitrate.id === 'string';
      var bitrateValid = bitrate.bitrate !== undefined && (typeof bitrate.bitrate === 'number' || typeof bitrate.bitrate === 'string');
      var heightValid = bitrate.height !== undefined && typeof bitrate.height === 'number';
      var widthValid = bitrate.width !== undefined && typeof bitrate.width === 'number';
      return idValid && bitrateValid && heightValid && widthValid;
    };
    /**
     * Set the playback speed for a particular videoid.  Ads will always be played
     * at 1x, while the main content can be changed.
     * @method VideoController#_setPlaybackSpeed
     * @param  {string} videoId The ID of the video who's playback speed is going to be changed.
     * @private
     */


    var _setPlaybackSpeed = _.bind(function (videoId) {
      if (!this.activeInstances || !this.activeInstances[videoId] || !this.activeInstances[videoId].element) {
        return;
      }

      if (videoId === OO.VIDEO.MAIN) {
        if (OO.isValidPlaybackSpeed(this.desiredPlaybackSpeed)) {
          _safeFunctionCall(this.activeInstances[videoId].element, 'setPlaybackSpeed', [this.desiredPlaybackSpeed]);
        }
      } else if (videoId === OO.VIDEO.ADS) {
        _safeFunctionCall(this.activeInstances[videoId].element, 'setPlaybackSpeed', [1.0]);
      }
    }, this); // ********************
    // Debugging
    // ********************


    var self = this;
    var videoDebugging = {
      getRegisteredPlugins: function getRegisteredPlugins() {
        return OO.Video.getRegisteredPlugins();
      },
      getEncodingPriority: function getEncodingPriority() {
        return _getEncodingPriorities();
      },
      getSupportedEncodings: function getSupportedEncodings() {
        return _getFilteredSupportedEncodings(this.getRegisteredPlugins());
      },
      getVideoInstances: function getVideoInstances() {
        return self.activeInstances;
      },
      getVideoElements: function getVideoElements() {
        return activeElements;
      }
    }; // ********************
    // Setup
    // ********************

    initialize();
  };

  OO.registerModule('videoController', function (messageBus, id) {
    return new VideoController(messageBus, id);
  });
})(OO, OO._, OO.$);

},{"@babel/runtime/helpers/asyncToGenerator":9,"@babel/runtime/helpers/interopRequireDefault":13,"@babel/runtime/helpers/typeof":18,"@babel/runtime/regenerator":20}],79:[function(require,module,exports){
"use strict";

/*
 * Librato Plugin
 *
 * owner: PLAYER
 * version: 0.2
 *
 * The Librato plugin utilizes the librato.com API to handle instrumentation
 * of various events within the player. Note: The allowed use of this plugin is only
 * under the condition that this plugin does not send/store any user information along with
 * each request.
 */
OO.plugin(OO.MODULE_NAMES.LIBRATO, function (OO, _, $, Window) {
  // Throttling for now...logic by @gregm ;)
  var THROTTLE = Math.floor(Math.random() * 10); // eslint-disable-line no-magic-numbers
  // Return an empty function or die

  if (!OO.runningUnitTests) {
    if (THROTTLE > 0) {
      return function () {};
    }
  }

  var RANGE_ABOVE_THRESHOLD_TEXT = '-above-range';
  var RANGE_BELOW_THRESHOLD_TEXT = '-below-range';
  var RANGE_WITHIN_THRESHOLD_TEXT = '-within-range';
  /**
   * The threshold configuration for each timed event
   * @private
   */

  var LibratoConfig = {
    'events': [{
      'name': 'v4-load-time',
      'low': 500,
      'high': 2000
    }, {
      'name': 'player.load.time',
      'low': 500,
      'high': 2000
    }, {
      'name': 'v4-playback-ready',
      'low': 500,
      'high': 2000
    }, {
      'name': 'player.playbackReady.time',
      'low': 500,
      'high': 2000
    }, {
      'name': 'v4-time-to-first-content-frame',
      'low': 1000,
      'high': 3000
    }, {
      'name': 'player.firstFrame.time',
      'low': 1000,
      'high': 3000
    }, {
      'name': 'v4-time-to-first-ad-frame',
      'low': 1000,
      'high': 3000
    }, {
      'name': 'player.adsFirstFrame.time',
      'low': 1000,
      'high': 3000
    }]
  };
  /**
   * @class LibratoHelper
   * @classdesc Helper class for Librato plugin; contains various helper methods like "reportSingleMetric", etc.
   * @public
   */

  var LibratoHelper = function LibratoHelper() {
    // calculate authorization header
    this.basic_auth_token = 'abelrios@ooyala.com' + ':' + '95d53e8841835839469f2a2f96fd95b564342ffadff759ad9d49f1897805db1b';

    if (window.btoa) {
      this.basic_auth_token = window.btoa(this.basic_auth_token);
    } else {
      this.basic_auth_token = window.base64.encode(this.basic_auth_token);
    } // form TAG JSON object for granular Librato Measurement


    this.tag = this._generateTagJSON(); // figure out the source string

    this.source = this._generateSourceString();
  };

  _.extend(LibratoHelper.prototype, {
    /**
     * Measures the millisecond difference from 2 millisecond values
     * @method _measureDurationMilli
     * @param {number} startTs Starting millisecond value
     * @param {number} endTs Ending millisecond value
     * @returns {number} The difference of endTs and startTs milliseconds
     */
    _measureDurationMilli: function _measureDurationMilli(startTs, endTs) {
      return endTs - startTs;
    },

    /**
     * Creates a measurement value object that is properly formatted for Librato
     * @method _addMeasurementValue
     * @param {object} measurement The measurement value object
     * @param {string} name The measurement name to track
     * @param {number} value The measurement value (some sort of measurement)
     * @returns {object} The modified measurement object
     */
    _addMeasurementValue: function _addMeasurementValue(measurement, name, value) {
      // get hold of the current measurements to add, or init currentMeasurement with empty array if no data exists yet.
      var currentMeasurement = [];

      if (measurement && measurement.measurements && measurement.measurements.length > 0) {
        currentMeasurement = measurement.measurements;
      } // Append new value object into measurement array


      currentMeasurement.push({
        'name': name,
        'value': value
      });
      return {
        'tags': this.tag,
        'measurements': currentMeasurement
      };
    },

    /**
     * Creates a metric value object that is properly formatted for Librato
     * @method _addMetricValue
     * @param {object}  metrics The metrics value object
     * @param {string} name The metric name to track
     * @param {number} value The metric value (some sort of measurement)
     * @returns {object} The modified metrics object
     */
    _addMetricValue: function _addMetricValue(metrics, name, value) {
      metrics[name] = {
        'value': value,
        'source': this.source
      };
      return metrics;
    },

    /**
     * Creates and sends a single measurement value to Librato API
     * @method _reportSingleMeasurement
     * @param {string} name The measurement name
     * @param {number} value The measurement value (some sorf of measurement)
     */
    _reportSingleMeasurement: function _reportSingleMeasurement(name, value) {
      var measurement = {};
      measurement = this._addMeasurementValue(measurement, name, value);

      this._sendMeasurement(measurement);
    },

    /**
     * Creates and sends a single metric value to Librato API
     * @method _reportSingleMetric
     * @param {string} name The metric name
     * @param {number} value The metric value (some sorf of measurement)
     */
    _reportSingleMetric: function _reportSingleMetric(name, value) {
      var metrics = {};
      metrics = this._addMetricValue(metrics, name, value);

      this._sendReport(metrics);
    },

    /**
     * AJAX request to send measurement call to Librato API
     * https://www.librato.com/docs/api/#measurements
     * @method _sendMeasurement
     * @param {Object} measurement The measurement object
     */
    _sendMeasurement: function _sendMeasurement(measurement) {
      // send the ping
      $.ajax({
        url: 'https://metrics-api.librato.com/v1/measurements',
        type: 'post',
        data: JSON.stringify(measurement),
        contentType: 'application/json',
        headers: {
          'Authorization': 'Basic ' + this.basic_auth_token
        },
        success: function success(data) {}
      });
    },

    /**
     * AJAX request to send metric call to Librato API
     * @method _sendReport
     * @param {Object} metrics The metrics object
     */
    _sendReport: function _sendReport(metrics) {
      // send the ping
      $.ajax({
        url: 'https://metrics-api.librato.com/v1/metrics',
        type: 'post',
        data: {
          gauges: metrics
        },
        dataType: 'json',
        headers: {
          'Authorization': 'Basic ' + this.basic_auth_token
        },
        success: function success(data) {}
      });
    },

    /**
     * Evaluates where a counting measurement falls within a defined threshold
     * @method _getThresholdText
     * @param {number} value The metric value
     * @param {object} item The configuration item that contains the threshold data
     * @returns {string} The the threshold value result
     */
    _getThresholdText: function _getThresholdText(value, item) {
      var text = RANGE_WITHIN_THRESHOLD_TEXT;

      if (value > item.high) {
        text = RANGE_ABOVE_THRESHOLD_TEXT;
      } else if (value < item.low) {
        text = RANGE_BELOW_THRESHOLD_TEXT;
      }

      return item.name + text;
    },

    /**
     * Matches a given event name with a name in configuration
     * @method _matchEvent
     * @param {string} name The event name to use as a key
     * @returns {object} The matched configuration object
     */
    _matchEvent: function _matchEvent(name) {
      var match;

      _.each(LibratoConfig.events, function (item, idx) {
        if (item.name === name) {
          match = item;
        }
      });

      return match;
    },

    /**
     * Generates the Tag JSON object to use in each measurement call
     * @method _generateTagJSON
     * @returns {Object} The properly formatted JSON object for measurement call
     *
     * platform: player product offering. Example: web, ios-sdk, android-sdk, etc.
     * os: underlying OS
     * browser: underlying browser, if applicable
     * customer: critical customers only. Example: CustomerName_PCODE
     * version: player version
     * source: source of the player code, if applicable. Example: static (static JS files), api (backend SaaS API: Valhalla)
     */
    _generateTagJSON: function _generateTagJSON() {
      var tag = {
        'platform': 'web',
        'os': 'generic',
        'browser': 'generic',
        'customer': 'undefined',
        'version': 'undefined',
        'source': 'api'
      }; // version

      if (OO.VERSION && OO.VERSION.core && OO.VERSION.core.releaseVersion && OO.VERSION.core.releaseVersion !== '<CORE_VERSION>') {
        tag.version = OO.VERSION.core.releaseVersion;
      } // OS


      if (OO.isIos) {
        tag.os = 'ios';
      } else if (OO.isAndroid) {
        tag.os = 'android';
      } else if (OO.isMacOs) {
        tag.os = 'macosx';
      } else if (OO.isWinPhone) {
        tag.os = 'winphone';
      } else if (OO.isWindows) {
        tag.os = 'windows';
      } else {
        tag.os = 'generic';
      } // browser


      if (OO.isChrome) {
        tag.browser = 'chrome';
      } else if (OO.isFirefox) {
        tag.browser = 'firefox';
      } else if (OO.isEdge) {
        tag.browser = 'edge';
      } else if (OO.isIE11Plus) {
        tag.browser = 'ie11plus';
      } else if (OO.isIE) {
        tag.browser = 'ieold';
      } else if (OO.isSafari) {
        tag.browser = 'safari';
      } else {
        tag.browser = 'generic';
      } // source


      if (!!window.performance && !!window.performance.getEntriesByType) {
        var regex = 'player.*ooyala.*core.*js';

        var v4Source = _.find(window.performance.getEntriesByType('resource'), function (elem) {
          return elem.name.match(regex);
        }); // v4Source from static files are found, higher probability the origin source of player is from static files, rather than backend API.


        if (v4Source) {
          tag.source = 'static';
        }
      }

      return tag;
    },

    /**
     * Generates the source string to use in each metric call
     * @method _generateSourceString
     * @returns {string} The properly formatted source string
     */
    _generateSourceString: function _generateSourceString() {
      var sourceData = {};

      var sourceTemplate = _.template('<%= version %>-<%= os %>-<%= browser %>'); // version


      sourceData.version = 'undefined';

      if (OO.VERSION && OO.VERSION.core && OO.VERSION.core.releaseVersion && OO.VERSION.core.releaseVersion !== '<CORE_VERSION>') {
        sourceData.version = OO.VERSION.core.releaseVersion;
      } // OS


      if (OO.isIos) {
        sourceData.os = 'ios';
      } else if (OO.isAndroid) {
        sourceData.os = 'android';
      } else if (OO.isMacOs) {
        sourceData.os = 'macosx';
      } else if (OO.isWinPhone) {
        sourceData.os = 'winphone';
      } else if (OO.isWindows) {
        sourceData.os = 'windows';
      } else {
        sourceData.os = 'generic';
      } // browser


      if (OO.isChrome) {
        sourceData.browser = 'chrome';
      } else if (OO.isFirefox) {
        sourceData.browser = 'firefox';
      } else if (OO.isIE11Plus) {
        sourceData.browser = 'ie11plus';
      } else if (OO.isIE) {
        sourceData.browser = 'ieold';
      } else if (OO.isSafari) {
        sourceData.browser = 'safari';
      } else {
        sourceData.browser = 'generic';
      }

      return sourceTemplate(sourceData);
    },

    /**
     * Plugin Initializer
     * @method start
     */
    start: function start() {
      var metrics = {};
      var measurements = {};

      this._addMetricValue(metrics, 'v4-load', 1);

      measurements = this._addMeasurementValue(measurements, 'player.display', 1); // measure v4 load performance data

      if (!!window.performance && !!window.performance.getEntries) {
        // regex for core server and static/v4/<PATH>/core file
        var regex = 'player.*ooyala.*core';

        var v4Performance = _.find(window.performance.getEntriesByType('resource'), function (elem) {
          return elem.name.match(regex);
        }); // timing data found


        if (v4Performance) {
          if (v4Performance.duration > 0) {
            // We have the load time, so let's log that
            this._addMetricValue(metrics, this._getThresholdText(v4Performance.duration, this._matchEvent('v4-load-time')), 1);

            measurements = this._addMeasurementValue(measurements, this._getThresholdText(v4Performance.duration, this._matchEvent('player.load.time')), 1);
            measurements = this._addMeasurementValue(measurements, 'player.load.time', v4Performance.duration);
          }
        }
      }

      this._sendReport(metrics);

      this._sendMeasurement(measurements);
    }
  }); // We must defer measuring player load times until after this script is processed
  // Since when this code is executed initially, it's part of the loading sequence


  var libratoHelper = new LibratoHelper();

  _.defer(_.bind(libratoHelper.start, libratoHelper)); // ------------------------------- Instance Functions ----------------------


  var Librato = function Librato(messageBus, id) {
    this.id = id;
    this.mb = messageBus;
    this.initializationTs = this._takeTimestamp(); // LibratoHelper holder for unit test accessibility. Do not remove

    this.helper = libratoHelper; // initialized timingMetric

    this.setEmbedCodeTs = 0;
    this.playbackReadyTs = 0;
    this.lastStateChangeTs = 0;
    this.firstFrameTs = 0;
    this.errorTs = 0; // track important events

    this.mb.subscribe(OO.EVENTS.SET_EMBED_CODE, 'librato', _.bind(this._onSetEmbedCode, this));
    this.mb.subscribe(OO.EVENTS.SET_EMBED_CODE_AFTER_OOYALA_AD, 'librato', _.bind(this._onSetEmbedCode, this));
    this.mb.subscribe(OO.EVENTS.PLAYBACK_READY, 'librato', _.bind(this._onPlaybackReady, this));
    this.mb.subscribe(OO.EVENTS.INITIAL_PLAY, 'librato', _.bind(this._onInitialPlay, this));
    this.mb.subscribe(OO.EVENTS.PLAY, 'librato', _.bind(this._onInitialPlay, this));
    this.mb.subscribe(OO.EVENTS.PLAYING, 'librato', _.bind(this._onInitialPlay, this));
    this.mb.subscribe(OO.EVENTS.ADS_PLAYED, 'librato', _.bind(this._onAdsPlayed, this));
    this.mb.subscribe(OO.EVENTS.PLAYHEAD_TIME_CHANGED, 'librato', _.bind(this._onPlayheadTimeChanged, this));
    this.mb.subscribe(OO.EVENTS.PLAY_FAILED, 'librato', _.bind(this._onPlayerPlayFailure, this));
    this.mb.subscribe(OO.EVENTS.ERROR, 'librato', _.bind(this._onPlayerError, this));
    this.mb.subscribe(OO.EVENTS.WILL_PLAY_ADS, 'librato', _.bind(this._willPlayAds, this));
  };

  _.extend(Librato.prototype, {
    /**
     * Creates a timestamp
     * @method _takeTimestamp
     * @returns {object} A date object
     */
    _takeTimestamp: function _takeTimestamp() {
      return new Date().getTime();
    },

    /**
     * Set Embed Code Event Handler
     * @method _onSetEmbedCode
     */
    _onSetEmbedCode: function _onSetEmbedCode() {
      this.setEmbedCodeTs = this._takeTimestamp();
      this.wasPlayStartReported = false;
      this.wasTimeToFirstFrameReported = false;
      this.wasTimeToFirstAdFrameReported = false;
      this.adsPlaying = false;
      this.wasErrorReported = false;
      this.playbackReadyTs = 0;
      this.lastStateChangeTs = 0;
      this.firstFrameTs = 0;
      this.errorTs = 0;
    },

    /**
     * Playback Ready Event Handler
     * @method _onPlaybackReady
     */
    _onPlaybackReady: function _onPlaybackReady() {
      var measurements = {};

      libratoHelper._reportSingleMetric('v4-playback-ready', 1);

      this.playbackReadyTs = this._takeTimestamp();

      var diff = libratoHelper._measureDurationMilli(this.setEmbedCodeTs, this.playbackReadyTs);

      libratoHelper._reportSingleMetric(libratoHelper._getThresholdText(diff, libratoHelper._matchEvent('v4-playback-ready')), 1);

      measurements = libratoHelper._addMeasurementValue(measurements, libratoHelper._getThresholdText(diff, libratoHelper._matchEvent('player.playbackReady.time')), 1);
      measurements = libratoHelper._addMeasurementValue(measurements, 'player.playbackReady.time', diff);

      libratoHelper._sendMeasurement(measurements);
    },

    /**
     * Initial Play Event Handler
     * @method _onInitialPlay
     */
    _onInitialPlay: function _onInitialPlay() {
      if (this.wasPlayStartReported) {
        return;
      }

      this.lastStateChangeTs = this._takeTimestamp();
      this.wasPlayStartReported = true;

      libratoHelper._reportSingleMetric('v4-play', 1);

      libratoHelper._reportSingleMeasurement('player.playRequested', 1);
    },

    /**
     * Will Play Ads Event Handler
     * @method _willPlayAds
     */
    _willPlayAds: function _willPlayAds() {
      this.lastStateChangeTs = this._takeTimestamp(); // reset the state timestamp

      this.adsPlaying = true;

      libratoHelper._reportSingleMetric('v4-play-ad', 1);

      libratoHelper._reportSingleMeasurement('player.adsRequested', 1);
    },

    /**
     * Ads Played Event Handler
     * @method _onAdsPlayed
     */
    _onAdsPlayed: function _onAdsPlayed() {
      this.lastStateChangeTs = this._takeTimestamp(); // reset the state timestamp

      this.adsPlaying = false;
    },

    /**
     * Playhead Time Changed Event Handler
     * @method _onPlayheadTimeChanged
     * @param {String} name - name of the event
     * @param {Number} playhead - ?
     */
    _onPlayheadTimeChanged: function _onPlayheadTimeChanged(name, playhead) {
      if (this.wasTimeToFirstFrameReported && this.wasTimeToFirstAdFrameReported) {
        return;
      }

      if (!playhead || playhead <= 0) {
        return;
      } // first frame appeared playhead seconds ago...


      this.firstFrameTs = this._takeTimestamp(); // TODO do we need to account for already played frames?

      var diff = libratoHelper._measureDurationMilli(this.lastStateChangeTs, this.firstFrameTs);

      if (!this.wasTimeToFirstFrameReported && !this.adsPlaying) {
        libratoHelper._reportSingleMetric(libratoHelper._getThresholdText(diff, libratoHelper._matchEvent('v4-time-to-first-content-frame')), 1);

        this.wasTimeToFirstFrameReported = true;
        var measurements = {};
        measurements = libratoHelper._addMeasurementValue(measurements, libratoHelper._getThresholdText(diff, libratoHelper._matchEvent('player.firstFrame.time')), 1);
        measurements = libratoHelper._addMeasurementValue(measurements, 'player.firstFrame.time', diff);
        measurements = libratoHelper._addMeasurementValue(measurements, 'player.playStarted', 1);

        libratoHelper._sendMeasurement(measurements);
      }

      if (this.adsPlaying && !this.wasTimeToFirstAdFrameReported) {
        libratoHelper._reportSingleMetric(libratoHelper._getThresholdText(diff, libratoHelper._matchEvent('v4-time-to-first-ad-frame')), 1);

        this.wasTimeToFirstAdFrameReported = true;
        var _measurements = {};
        _measurements = libratoHelper._addMeasurementValue(_measurements, libratoHelper._getThresholdText(diff, libratoHelper._matchEvent('player.adsFirstFrame.time')), 1);
        _measurements = libratoHelper._addMeasurementValue(_measurements, 'player.adsFirstFrame.time', diff);

        libratoHelper._sendMeasurement(_measurements);
      }
    },

    /**
     * Player Play Failure Event Handler
     * @method _onPlayerPlayFailure
     */
    _onPlayerPlayFailure: function _onPlayerPlayFailure() {
      libratoHelper._reportSingleMetric('v4-play-fail', 1);

      libratoHelper._reportSingleMeasurement('player.playFail', 1);
    },

    /**
     * Player Error Event Handler
     * @method _onPlayerError
     * @param {Any} type - ?
     * @param {Any} error - ?
     */
    _onPlayerError: function _onPlayerError(type, error) {
      if (this.wasErrorReported) {
        return;
      }

      this.errorTs = this._takeTimestamp(); // We essentially want to handle errors on a case by case basis to determine
      // which errors have more weight

      libratoHelper._reportSingleMetric('v4-error', 1);

      libratoHelper._reportSingleMeasurement('player.error', 1);

      this.wasErrorReported = true;
    }
  });

  return Librato;
});

},{}],80:[function(require,module,exports){
"use strict";

(function (OO, _, $) {
  /*
  * ValhallaCacheModule used to temporary store data, in memory.
  * Publicly accessible via interface OO.cache
  * Internally accessible via OO.publicApi.cache or OO.__internal.publicApi.cache
  */
  var ValhallaCacheModule = function ValhallaCacheModule() {
    var cache = {};
    /*
    * Save data to ValhallaCacheModule
    * @param {string} key - Storage key like 'my_data'
    * @param {object} data - Object to store, can be anything
    * @return {bool}
    */

    this.set = function (key, data) {
      if (key && data) {
        cache[key] = data;
      }
    };
    /*
    * Get data that stored in ValhallaCacheModule
    * @param {string} key - Storage key to pull like 'my_data'
    * @param {bool} remove - Remove data from cache, before returning it back. Helps if you want to access your data only once
    * @return {object} Object that was stored in ValhallaCacheModule. If not exist will be null
    */


    this.get = function (key, remove) {
      var result = cache[key] || null;

      if (remove) {
        this.remove(key);
      }

      return result;
    };
    /*
    * Check if data exists in ValhallaCacheModule
    * @param {string} key - Storage key to check like 'my_data'
    * @return {bool} True if data exist, false if not
    */


    this.exists = function (key) {
      return !!cache[key];
    };
    /*
    * Remove data that stored in ValhallaCacheModule
    * @param {string} key - Storage key to remove like 'my_data'
    * @return {bool} True if removed, false if not or data wasn't there
    */


    this.remove = function (key) {
      if (this.exists(key)) {
        return delete cache[key];
      }

      return false;
    };

    this.flushAll = function () {
      cache = {};
    };
  };

  var serverCache = new ValhallaCacheModule();
  OO.exposeStaticApi('cache', serverCache);
})(OO, OO._, OO.$);

},{}]},{},[62]);
/* eslint-disable */
(function(OO, $, _) {
  //Reporter.js pulled from http://player.ooyala.com/static/cacheable/e2cf372a6253740de642bd014b679bfc/reporter.js on 5/10/17
  (function(){var a=typeof process!=="undefined"&&process.versions&&process.versions.node?global:window;if(typeof a.Ooyala=="undefined")a.Ooyala={};Ooyala.Util={};var b=function(c){if(typeof c!="string")throw"The namespace name must be a string.";var d=c.split(".");if(!(d.length>0))throw"The namespace '"+c+"' is not valid.";for(var e=a,f=0;f<d.length;f++){var h=d[f];if(!(h.length>0))throw"The namespace '"+c+"' is not valid.";if(e[h]){var i=d.slice(0,f).join(".");if(typeof e[h]!="object")throw"Namespace error: the name '"+
  i+"' already exists and is not a namespace.";}else e[h]={};e=e[h]}};b("Ooyala.Util");Ooyala.Util.createNamespace=b})();Ooyala.Util.getOwnProperties=function(a){var b=[];for(var c in a)a.hasOwnProperty(c)&&b.push(c);return b};Ooyala.Util.extend=function(a,b){for(var c in b)if(b.hasOwnProperty(c)&&a[c]==undefined)a[c]=b[c]};Ooyala.Util.createNamespace("Ooyala.Util");Ooyala.Util.bind=function(a,b){var c=Array.prototype.slice.call(arguments,2);return function(){return a.apply(b,c.concat(Array.prototype.slice.call(arguments)))}};Ooyala.Util.createNamespace("Ooyala.Util.Enumerable");
  Ooyala.Util.extend(Ooyala.Util.Enumerable,{_checkFunction:function(a){if(typeof a!="function")throw new TypeError;},foreach:function(a,b){this._checkFunction(b);for(var c=0;c<a.length;c++)b.call(undefined,a[c])},map:function(a,b){this._checkFunction(b);var c=[];Ooyala.Util.Enumerable.foreach(a,function(d){c.push(b.call(undefined,d))});return c},select:function(a,b){this._checkFunction(b);var c=[];Ooyala.Util.Enumerable.foreach(a,function(d){b.call(undefined,d)&&c.push(d)});return c},reject:function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          b){return this.select(a,function(c){return!b.call(undefined,c)})}});Ooyala.Util.createNamespace("Ooyala.Util.Http");Ooyala.Util.Http._XMLHttpRequestFactories=[function(){return new XMLHttpRequest},function(){return new ActiveXObject("Microsoft.XMLHTTP")},function(){return new ActiveXObject("MSXML2.XMLHTTP.3.0")},function(){return new ActiveXObject("MSXML2.XMLHTTP")}];Ooyala.Util.Http._XMLHttpRequestFactory=null;
  Ooyala.Util.Http.createXMLHttpRequest=function(){if(Ooyala.Util.Http._XMLHttpRequestFactory!=null)return Ooyala.Util.Http._XMLHttpRequestFactory();for(var a=0;a<Ooyala.Util.Http._XMLHttpRequestFactories.length;a++)try{var b=Ooyala.Util.Http._XMLHttpRequestFactories[a],c=b();if(c!=null){Ooyala.Util.Http._XMLHttpRequestFactory=b;return c}}catch(d){}Ooyala.Util.Http._XMLHttpRequestFactory=function(){throw"XMLHttpRequest not supported.";};Ooyala.Util.Http._XMLHttpRequestFactory()};Ooyala.Util.CookieManager=function(a,b,c){this._cookieName=a;this._daysToLive=b;this._compareFn=c;this._keysValuesHash={};this._cookiesEnabled=window.navigator.cookieEnabled;Ooyala.Util.CookieManager.cookieNames.push(a)};Ooyala.Util.CookieManager.MAX_COOKIE_SIZE=2048;Ooyala.Util.CookieManager.cookieNames=[];
  Ooyala.Util.CookieManager.prototype={deDupe:function(){for(var a=this._readAllCookies(this._cookieName),b=0;b<a.length;b++)this._updateHashFromString(a[b]);this._writeCookie(this._cookieName,this._updateStringFromHash());this._destroyCookies(this._cookieName)},get:function(a){if(!this._cookiesEnabled)return null;this._updateHashFromString(this._readCookie(this._cookieName));return(a=this._keysValuesHash[a])?a:null},set:function(a,b){if(this._cookiesEnabled){this._keysValuesHash[a]=b.toString();this._writeCookie(this._cookieName,
    this._updateStringFromHash())}},_compare:function(a,b){return this._compareFn(this._keysValuesHash[b],this._keysValuesHash[a])},_updateHashFromString:function(a){if(a){a=a.split("&");for(var b=0;b<a.length;b++){var c=a[b],d=c.indexOf(":");if(d!=-1){var e=c.substring(0,d);c=c.substring(d+1);if(this._compareFn(this._keysValuesHash[e],c)<0)this._keysValuesHash[e]=c}}}},_updateStringFromHash:function(){for(var a=Ooyala.Util.getOwnProperties(this._keysValuesHash).sort(Ooyala.Util.bind(this._compare,this)),
                                                                                                                                                                                                                                                                                                                                                                                                                            b="",c=this._cookieOverhead(this._cookieName),d=0;d<Ooyala.Util.CookieManager.cookieNames.length;d++){var e=Ooyala.Util.CookieManager.cookieNames[d];if(e!=this._cookieName)c+=this._cookieOverhead(e)+(this._readCookie(e)||"").length}for(d=0;d<a.length;d++){e=a[d];var f=this._keysValuesHash[e];if(c+b.length+e.length+f.length+(d==0?1:2)>Ooyala.Util.CookieManager.MAX_COOKIE_SIZE)break;b+=(d==0?"":"&")+e+":"+f}return b},_writeCookie:function(a,b){document.cookie=a+"="+b+"; expires="+this._getExpiryDate()+
    "; path=/;"},_readCookie:function(a){var b=document.cookie;if(!b)return null;a=a+"=";b=b.split(";");for(var c=0;c<b.length;c++){for(var d=b[c];d.charAt(0)==" ";)d=d.substring(1);if(d.indexOf(a)==0){a=d.substring(a.length,d.length);return a.length>0?a:null}}return null},_readAllCookies:function(a){var b=document.cookie,c=[];if(!b)return c;a=a+"=";b=b.split(";");for(var d=0;d<b.length;d++){for(var e=b[d];e.charAt(0)==" ";)e=e.substring(1);if(e.indexOf(a)==0){e=e.substring(a.length,e.length);e.length>
  0&&c.push(e)}}return c},_destroyCookies:function(a,b){if(a){b||(b=false);for(var c=document.location.pathname;;){var d=c.lastIndexOf("/");if(d===-1)break;if(d===0&&c.length===1)break;document.cookie=a+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path="+c+";";c=c.substring(0,d)}if(b)document.cookie=a+"=; expires=Thu, 01 Jan 1970 00:00:01 GMT; path=/;"}},_cookieOverhead:function(a){return a.length+this._getExpiryDate().length+10+9},_getExpiryDate:function(){var a=(new Date).getTime();return(new Date(a+
    this._daysToLive*24*60*60*1E3)).toGMTString()}};Ooyala.Util.createNamespace("Ooyala.Util");
  Ooyala.Util.extend(Ooyala.Util,{base64Encode:function(a){for(var b="",c,d,e,f,h,i,g=0;g<a.length;){c=a[g++];d=a[g++];e=a[g++];f=c>>2;c=(c&3)<<4|d>>4;h=(d&15)<<2|e>>6;i=e&63;if(isNaN(d))h=i=64;else if(isNaN(e))i=64;b=b+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(f)+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(c)+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(h)+"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt(i)}return b},utf8Encode:function(a){a=
    a.replace(/\r\n/g,"\n");for(var b="",c=0;c<a.length;c++){var d=a.charCodeAt(c);if(d<128)b+=String.fromCharCode(d);else{if(d>127&&d<2048)b+=String.fromCharCode(d>>6|192);else{b+=String.fromCharCode(d>>12|224);b+=String.fromCharCode(d>>6&63|128)}b+=String.fromCharCode(d&63|128)}}return b},encodeDouble:function(a){var b=Array(8),c=a,d={len:8,mLen:52,rt:0},e,f,h,i,g,j;h=d.mLen;i=d.len*8-d.mLen-1;j=(1<<i)-1;g=j>>1;a=c<0?1:0;c=Math.abs(c);if(isNaN(c)||c==Infinity){c=isNaN(c)?1:0;e=j}else{e=Math.floor(Math.log(c)/
    Math.LN2);if(c*(f=Math.pow(2,-e))<1){e--;f*=2}c+=e+g>=1?d.rt/f:d.rt*Math.pow(2,1-g);if(c*f>=2){e++;f/=2}if(e+g>=j){c=0;e=j}else if(e+g>=1){c=(c*f-1)*Math.pow(2,h);e+=g}else{c=c*Math.pow(2,g-1)*Math.pow(2,h);e=0}}for(d=d.len-1;h>=8;b[0+d]=c&255,d+=-1,c/=256,h-=8);e=e<<h|c;for(i+=h;i>0;b[0+d]=e&255,d+=-1,e/=256,i-=8);b[0+d- -1]|=a*128;return b}});(function(){var a={Type:{STOP:0,VOID:1,BOOL:2,BYTE:3,I08:3,DOUBLE:4,I16:6,I32:8,I64:10,STRING:11,UTF7:11,STRUCT:12,MAP:13,SET:14,LIST:15,UTF8:16,UTF16:17},MessageType:{CALL:1,REPLY:2,EXCEPTION:3}};a.TException={};a.TException.prototype={initialize:function(b,c){this.message=b;this.code=c==null?0:c}};a.TApplicationExceptionType={UNKNOWN:0,UNKNOWN_METHOD:1,INVALID_MESSAGE_TYPE:2,WRONG_METHOD_NAME:3,BAD_SEQUENCE_ID:4,MISSING_RESULT:5};a.TApplicationException=function(b,c){this.message=b;this.code=c==
  null?0:c};a.TApplicationException.prototype={read:function(b){var c,d=b.readStructBegin(fname);for(this.fname=d.fname;;){d=b.readFieldBegin();if(d.ftype==TType.STOP)break;c=d.fid;switch(c){case 1:if(d.ftype==Type.STRING){d=b.readString();this.message=d.value}else b.skip(d.ftype);break;case 2:if(d.ftype==Type.I32){d=b.readI32();this.code=d.value}else b.skip(d.ftype);break;default:b.skip(d.ftype);break}b.readFieldEnd()}b.readStructEnd()},write:function(b){b.writeStructBegin("TApplicationException");
    if(this.message){b.writeFieldBegin("message",Type.STRING,1);b.writeString(this.getMessage());b.writeFieldEnd()}if(this.code){b.writeFieldBegin("type",Type.I32,2);b.writeI32(this.code);b.writeFieldEnd()}b.writeFieldStop();b.writeStructEnd()},getCode:function(){return this.code},getMessage:function(){return this.message}};a.Transport=function(b){this.url=b;this.rpos=this.wpos=0;this.recv_buf=this.send_buf=""};a.Transport.prototype={getXmlHttpRequestObject:function(){try{return new XMLHttpRequest}catch(b){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(c){}try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(d){}throw"Your browser doesn't support the XmlHttpRequest object.  Try upgrading to Firefox.";
  },flush:function(){if(this.url==undefined||this.url=="")return this.send_buf;var b=this.getXmlHttpRequestObject();b.overrideMimeType&&b.overrideMimeType("application/json");b.open("POST",this.url,false);b.send(this.send_buf);if(b.readyState!=4)throw"encountered an unknown ajax ready state: "+b.readyState;if(b.status!=200)throw"encountered a unknown request status: "+b.status;this.recv_buf=b.responseText;this.wpos=this.recv_buf_sz=this.recv_buf.length;this.rpos=0},setRecvBuffer:function(b){this.recv_buf=
    b;this.wpos=this.recv_buf_sz=this.recv_buf.length;this.rpos=0},isOpen:function(){return true},open:function(){},close:function(){},read:function(b){var c=this.wpos-this.rpos;if(c==0)return"";var d=b;if(c<b)d=c;b=this.read_buf.substr(this.rpos,d);this.rpos+=d;return b},readAll:function(){return this.recv_buf},write:function(b){this.send_buf=b},getSendBuffer:function(){return this.send_buf}};a.Protocol=function(b){this.transport=b};a.Protocol.Type={};a.Protocol.Type[a.Type.BOOL]='"tf"';a.Protocol.Type[a.Type.BYTE]=
    '"i8"';a.Protocol.Type[a.Type.I16]='"i16"';a.Protocol.Type[a.Type.I32]='"i32"';a.Protocol.Type[a.Type.I64]='"i64"';a.Protocol.Type[a.Type.DOUBLE]='"dbl"';a.Protocol.Type[a.Type.STRUCT]='"rec"';a.Protocol.Type[a.Type.STRING]='"str"';a.Protocol.Type[a.Type.MAP]='"map"';a.Protocol.Type[a.Type.LIST]='"lst"';a.Protocol.Type[a.Type.SET]='"set"';a.Protocol.RType={};a.Protocol.RType.tf=a.Type.BOOL;a.Protocol.RType.i8=a.Type.BYTE;a.Protocol.RType.i16=a.Type.I16;a.Protocol.RType.i32=a.Type.I32;a.Protocol.RType.i64=
    a.Type.I64;a.Protocol.RType.dbl=a.Type.DOUBLE;a.Protocol.RType.rec=a.Type.STRUCT;a.Protocol.RType.str=a.Type.STRING;a.Protocol.RType.map=a.Type.MAP;a.Protocol.RType.lst=a.Type.LIST;a.Protocol.RType.set=a.Type.SET;a.Protocol.Version=1;a.Protocol.prototype={getTransport:function(){return this.transport},writeMessageBegin:function(b,c,d){this.tstack=[];this.tpos=[];this.tstack.push([a.Protocol.Version,'"'+b+'"',c,d])},writeMessageEnd:function(){var b=this.tstack.pop();this.wobj=this.tstack.pop();this.wobj.push(b);
    this.wbuf="["+this.wobj.join(",")+"]";this.transport.write(this.wbuf)},writeStructBegin:function(){this.tpos.push(this.tstack.length);this.tstack.push({})},writeStructEnd:function(){var b=this.tpos.pop(),c=this.tstack[b],d="{",e=true;for(var f in c){if(e)e=false;else d+=",";d+=f+":"+c[f]}d+="}";this.tstack[b]=d},writeFieldBegin:function(b,c,d){this.tpos.push(this.tstack.length);this.tstack.push({fieldId:'"'+d+'"',fieldType:a.Protocol.Type[c]})},writeFieldEnd:function(){var b=this.tstack.pop(),c=this.tstack.pop();
    this.tstack[this.tstack.length-1][c.fieldId]="{"+c.fieldType+":"+b+"}";this.tpos.pop()},writeFieldStop:function(){},writeMapBegin:function(b,c){this.tpos.push(this.tstack.length);this.tstack.push([a.Protocol.Type[b],a.Protocol.Type[c],0])},writeMapEnd:function(){var b=this.tpos.pop();if(b!=this.tstack.length){(this.tstack.length-b-1)%2!=0&&this.tstack.push("");this.tstack[b][this.tstack[b].length-1]=(this.tstack.length-b-1)/2;for(var c="{",d=true;this.tstack.length>b+1;){var e=this.tstack.pop(),f=
    this.tstack.pop();if(d)d=false;else c+=",";c+='"'+f+'":'+e}c+="}";this.tstack[b].push(c);this.tstack[b]="["+this.tstack[b].join(",")+"]"}},writeListBegin:function(b,c){this.tpos.push(this.tstack.length);this.tstack.push([a.Protocol.Type[b],c])},writeListEnd:function(){for(var b=this.tpos.pop();this.tstack.length>b+1;){var c=this.tstack[b+1];this.tstack.splice(b+1,1);this.tstack[b].push(c)}this.tstack[b]="["+this.tstack[b].join(",")+"]"},writeSetBegin:function(b,c){this.tpos.push(this.tstack.length);
    this.tstack.push([a.Protocol.Type[b],c])},writeSetEnd:function(){for(var b=this.tpos.pop();this.tstack.length>b+1;){var c=this.tstack[b+1];this.tstack.splice(b+1,1);this.tstack[b].push(c)}this.tstack[b]="["+this.tstack[b].join(",")+"]"},writeBool:function(b){this.tstack.push(b?1:0)},writeByte:function(b){this.tstack.push(b)},writeI16:function(b){this.tstack.push(b)},writeI32:function(b){this.tstack.push(b)},writeI64:function(b){this.tstack.push(b)},writeDouble:function(b){this.tstack.push(b)},writeString:function(b){this.tstack.push('"'+
    encodeURIComponent(b)+'"')},writeBinary:function(b){this.writeString(b)},readMessageBegin:function(){this.rstack=[];this.rpos=[];this.robj=eval(this.transport.readAll());var b={},c=this.robj.shift();if(c!=a.Protocol.Version)throw"Wrong thrift protocol version: "+c;b.fname=this.robj.shift();b.mtype=this.robj.shift();b.rseqid=this.robj.shift();this.rstack.push(this.robj.shift());return b},readMessageEnd:function(){},readStructBegin:function(){var b={};b.fname="";this.rstack[this.rstack.length-1]instanceof
  Array&&this.rstack.push(this.rstack[this.rstack.length-1].shift());return b},readStructEnd:function(){this.rstack[this.rstack.length-2]instanceof Array&&this.rstack.pop()},readFieldBegin:function(){var b={},c=-1,d=a.Type.STOP;for(var e in this.rstack[this.rstack.length-1])if(e!=null){c=parseInt(e);this.rpos.push(this.rstack.length);var f=this.rstack[this.rstack.length-1][c];delete this.rstack[this.rstack.length-1][c];this.rstack.push(f);break}if(c!=-1)for(e in this.rstack[this.rstack.length-1])if(a.Protocol.RType[e]!=
    null){d=a.Protocol.RType[e];this.rstack[this.rstack.length-1]=this.rstack[this.rstack.length-1][e]}b.fname="";b.ftype=d;b.fid=c;return b},readFieldEnd:function(){for(var b=this.rpos.pop();this.rstack.length>b;)this.rstack.pop()},readMapBegin:function(){var b=this.rstack.pop(),c={};c.ktype=a.Protocol.RType[b.shift()];c.vtype=a.Protocol.RType[b.shift()];c.size=b.shift();this.rpos.push(this.rstack.length);this.rstack.push(b.shift());return c},readMapEnd:function(){this.readFieldEnd()},readListBegin:function(){var b=
    this.rstack[this.rstack.length-1],c={};c.etype=a.Protocol.RType[b.shift()];c.size=b.shift();this.rpos.push(this.rstack.length);this.rstack.push(b);return c},readListEnd:function(){this.readFieldEnd()},readSetBegin:function(b,c){return this.readListBegin(b,c)},readSetEnd:function(){return this.readListEnd()},readBool:function(){var b=this.readI32();b.value=b!=null&&b.value=="1"?true:false;return b},readByte:function(){return this.readI32()},readI16:function(){return this.readI32()},readI32:function(b){if(b==
    undefined)b=this.rstack[this.rstack.length-1];var c={};if(b instanceof Array)c.value=b.length==0?undefined:b.shift();else if(b instanceof Object)for(var d in b){if(d!=null){this.rstack.push(b[d]);delete b[d];c.value=d;break}}else c.value=b;return c},readI64:function(){return this.readI32()},readDouble:function(){return this.readI32()},readString:function(){var b=this.readI32();b.value=decodeURIComponent(b.value);return b},readBinary:function(){return this.readString()},skip:function(){throw"skip not supported yet";
  }};Ooyala.Thrift=a})();Ooyala.Thrift.BinaryProtocol=function(a){this.transport=a};Ooyala.Thrift.BinaryProtocol.VERSION_MASK=4294901760;Ooyala.Thrift.BinaryProtocol.VERSION_1=2147549184;Ooyala.Thrift.BinaryProtocol.TYPE_MASK=255;
  Ooyala.Thrift.BinaryProtocol.prototype={getTransport:function(){return this.transport},writeMessageBegin:function(a,b,c){this.writeI16(Ooyala.Thrift.BinaryProtocol.VERSION_1>>16);this.writeI16(b);this.writeString(a);this.writeI32(c)},writeMessageEnd:function(){},writeStructBegin:function(){},writeStructEnd:function(){},writeFieldBegin:function(a,b,c){this.writeByte(b);this.writeI16(c)},writeFieldEnd:function(){},writeFieldStop:function(){this.writeByte(Ooyala.Thrift.Type.STOP)},writeMapBegin:function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            b,c){this.writeByte(a);this.writeByte(b);this.writeI32(c)},writeMapEnd:function(){},writeListBegin:function(a,b){this.writeByte(a);this.writeI32(b)},writeListEnd:function(){},writeSetBegin:function(a,b){this.writeByte(a);this.writeI32(b)},writeSetEnd:function(){},writeBool:function(a){this.writeByte(a?1:0)},writeByte:function(a){this.transport.write([a])},writeI16:function(a){this.transport.write([(a&65280)>>8,a&255])},writeI32:function(a){var b=a&65535;this.writeI16((a&4294901760)>>16);this.writeI16(b)},
    writeI64:function(a){var b=a&4294967295;this.writeI32(a/4294967296&4294967295);this.writeI32(b)},writeDouble:function(a){this.transport.write(Ooyala.Util.encodeDouble(a))},writeString:function(a){a=Ooyala.Util.utf8Encode(a);this.writeI32(a.length);for(var b=0;b<a.length;b++)this.writeByte(a.charCodeAt(b))},readMessageBegin:function(){},readMessageEnd:function(){},readStructBegin:function(){},readStructEnd:function(){},readFieldBegin:function(){},readFieldEnd:function(){},readMapBegin:function(){},
    readMapEnd:function(){},readListBegin:function(){},readListEnd:function(){},readSetBegin:function(){},readSetEnd:function(){},readBool:function(){},readByte:function(){},readI16:function(){},readI32:function(){},readI64:function(){},readDouble:function(){},readString:function(){},skip:function(){throw"skip not supported yet";}};Ooyala.Thrift.MemoryBufferTransport=function(a){this.buf=a||[];this.index=0};Ooyala.Thrift.MemoryBufferTransport.prototype={isOpen:function(){return true},open:function(){},close:function(){},read:function(a){var b=this.buf.slice(this.index,this.index+a);this.index+=a;if(this.index>this.buf.length)this.index=this.buf.length;return b},readAll:function(){return this.buf},write:function(a){this.buf=this.buf.concat(a)},flush:function(){},resetBuffer:function(){this.buf=[];this.index=0}};Ooyala.Thrift.Serializer=function(){this.transport=new Ooyala.Thrift.MemoryBufferTransport(null);this.protocol=new Ooyala.Thrift.BinaryProtocol(this.transport)};Ooyala.Thrift.Serializer.prototype={serialize:function(a){this.transport.resetBuffer();a.write(this.protocol);return this.transport.readAll()}};if(typeof Ooyala==="undefined")Ooyala={};if(typeof Ooyala.AdsLogging==="undefined")Ooyala.AdsLogging={};Ooyala.AdsLogging.AdFormat={VIDEO:1,OVERLAY:2,ENDCAP:3,COMPANION:4};Ooyala.AdsLogging.AdSourceId={OOYALA:1,DOUBLECLICK:2,LIGHTNINGCAST:3,YUME:4,TREMOR:5,ADSENSE:6,TV2N:7,OAS:8,ADTECH:9,SCANSCOUT:10,ATLAS:11,FREEWHEEL:12,OPENX:13,LIVERAIL:14,VAST:15,ADIFY:16,DART_ENTERPRISE:17,CBSI:18,BRIGHTROLL:19,UNKNOWN:20,ADAPTV:21,VIDEOPLAZA:22,SPOTXCHANGE:23};
  Ooyala.AdsLogging.AdPositionType={PREROLL:1,MIDROLL:2,POSTROLL:3,OVERLAY_POSITION:4,ENDSLATE:5,STANDALONE:6};Ooyala.AdsLogging.AdFailureReason={LOAD_ERROR:1,LOAD_TIMEOUT:2,LOAD_IO_ERROR:3,PREFETCH_ERROR:4,PREFETCH_TIMEOUT:5,PREFETCH_IO_ERROR:6,PLAY_ERROR:7,PLAY_TIMEOUT:8,PLAY_IO_ERROR:9,INVALID_PLAYER_CONFIGURATION:10,INVALID_AD_CONFIGURATION:11,AD_NOT_FOUND:12,EXCEPTION:13,AD_ERROR:14,INVALID_AD_RESPONSE:15,CONNECTION_ERROR:16,BUFFERING_TIMEOUT:17,POLICY_RESTRICTION:18};
  Ooyala.AdsLogging.AD_FORMAT_MAP={1:"video",2:"overlay",3:"endcap",4:"companion"};Ooyala.AdsLogging.AD_SOURCE_MAP={1:"ooyala",2:"doubleclick",3:"lightningcast",4:"yume",5:"tremor",6:"adsense",7:"tv2n",8:"oas",9:"adtech",10:"scanscout",11:"atlas",12:"freewheel",13:"openx",14:"liverail",15:"vast",16:"adify",17:"dart_enterprise",18:"cbsi",19:"brightroll",21:"adap-tv",22:"videoplaza",23:"spotxchange",20:"[unknown]"};
  Ooyala.AdsLogging.AD_POSITION_TYPE_MAP={1:"preroll",2:"midroll",3:"postroll",4:"overlay",5:"endslate",6:"standalone"};Ooyala.AdsLogging.AD_FAILURE_REASON_MAP={1:"loadError",2:"loadTimeout",3:"loadIOError",4:"prefetchError",5:"prefetchTimeout",6:"prefetchIOError",7:"playError",8:"playTimeout",9:"playIOError",10:"invalidPlayerConfiguration",11:"invalidAdConfiguration",12:"adNotFound",13:"exception",14:"adError",15:"invalidAdResponse",16:"connectionError",17:"bufferingTimeout",18:"policyRestriction"};
  Ooyala.AdsLogging.AdParams=function(a){this.string_key="";this.integer_key=0;this.value="";if(a!=null){if(null!=a.string_key)this.string_key=a.string_key;if(null!=a.integer_key)this.integer_key=a.integer_key;if(null!=a.value)this.value=a.value}};Ooyala.AdsLogging.AdParams.prototype={};
  Ooyala.AdsLogging.AdParams.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.string_key=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.integer_key=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.value=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.AdsLogging.AdParams.prototype.write=function(a){a.writeStructBegin("AdParams");if(null!=this.string_key){a.writeFieldBegin("string_key",Ooyala.Thrift.Type.STRING,1);a.writeString(this.string_key);a.writeFieldEnd()}if(null!=this.integer_key){a.writeFieldBegin("integer_key",Ooyala.Thrift.Type.I32,2);a.writeI32(this.integer_key);a.writeFieldEnd()}if(null!=this.value){a.writeFieldBegin("value",Ooyala.Thrift.Type.STRING,3);a.writeString(this.value);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.AdsLogging.AdClick=function(a){this.clickUrl="";this.realTime=this.playheadTimeMillis=0;if(a!=null){if(null!=a.clickUrl)this.clickUrl=a.clickUrl;if(null!=a.playheadTimeMillis)this.playheadTimeMillis=a.playheadTimeMillis;if(null!=a.realTime)this.realTime=a.realTime}};Ooyala.AdsLogging.AdClick.prototype={};
  Ooyala.AdsLogging.AdClick.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.clickUrl=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.playheadTimeMillis=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.realTime=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.AdsLogging.AdClick.prototype.write=function(a){a.writeStructBegin("AdClick");if(null!=this.clickUrl){a.writeFieldBegin("clickUrl",Ooyala.Thrift.Type.STRING,1);a.writeString(this.clickUrl);a.writeFieldEnd()}if(null!=this.playheadTimeMillis){a.writeFieldBegin("playheadTimeMillis",Ooyala.Thrift.Type.I32,2);a.writeI32(this.playheadTimeMillis);a.writeFieldEnd()}if(null!=this.realTime){a.writeFieldBegin("realTime",Ooyala.Thrift.Type.I32,3);a.writeI32(this.realTime);a.writeFieldEnd()}a.writeFieldStop();
    a.writeStructEnd()};
  Ooyala.AdsLogging.AdSpot=function(a){this.adSourceContentId=this.parentContentReportingIdIndex=this.adPositionInMillis=this.ooyalaAdReportingIdIndex=this.adPositionType=this.adFormat=this.adSource=0;this.passthroughParameters=this.tagUrl="";this.adId=0;if(a!=null){if(null!=a.adSource)this.adSource=a.adSource;if(null!=a.adFormat)this.adFormat=a.adFormat;if(null!=a.adPositionType)this.adPositionType=a.adPositionType;if(null!=a.ooyalaAdReportingIdIndex)this.ooyalaAdReportingIdIndex=a.ooyalaAdReportingIdIndex;
    if(null!=a.adPositionInMillis)this.adPositionInMillis=a.adPositionInMillis;if(null!=a.parentContentReportingIdIndex)this.parentContentReportingIdIndex=a.parentContentReportingIdIndex;if(null!=a.adSourceContentId)this.adSourceContentId=a.adSourceContentId;if(null!=a.tagUrl)this.tagUrl=a.tagUrl;if(null!=a.passthroughParameters)this.passthroughParameters=a.passthroughParameters;if(null!=a.adId)this.adId=a.adId}};Ooyala.AdsLogging.AdSpot.prototype={};
  Ooyala.AdsLogging.AdSpot.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.adSource=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.adFormat=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.adPositionType=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.BYTE){b=
    a.readByte();this.ooyalaAdReportingIdIndex=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.adPositionInMillis=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.parentContentReportingIdIndex=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.adSourceContentId=b.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.tagUrl=b.value}else a.skip(c);break;case 9:if(c==
    Ooyala.Thrift.Type.STRING){b=a.readString();this.passthroughParameters=b.value}else a.skip(c);break;case 10:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.adId=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.AdsLogging.AdSpot.prototype.write=function(a){a.writeStructBegin("AdSpot");if(null!=this.adSource){a.writeFieldBegin("adSource",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.adSource);a.writeFieldEnd()}if(null!=this.adFormat){a.writeFieldBegin("adFormat",Ooyala.Thrift.Type.BYTE,2);a.writeByte(this.adFormat);a.writeFieldEnd()}if(null!=this.adPositionType){a.writeFieldBegin("adPositionType",Ooyala.Thrift.Type.BYTE,3);a.writeByte(this.adPositionType);a.writeFieldEnd()}if(null!=this.ooyalaAdReportingIdIndex){a.writeFieldBegin("ooyalaAdReportingIdIndex",
    Ooyala.Thrift.Type.BYTE,4);a.writeByte(this.ooyalaAdReportingIdIndex);a.writeFieldEnd()}if(null!=this.adPositionInMillis){a.writeFieldBegin("adPositionInMillis",Ooyala.Thrift.Type.I32,5);a.writeI32(this.adPositionInMillis);a.writeFieldEnd()}if(null!=this.parentContentReportingIdIndex){a.writeFieldBegin("parentContentReportingIdIndex",Ooyala.Thrift.Type.BYTE,6);a.writeByte(this.parentContentReportingIdIndex);a.writeFieldEnd()}if(null!=this.adSourceContentId){a.writeFieldBegin("adSourceContentId",Ooyala.Thrift.Type.I32,
    7);a.writeI32(this.adSourceContentId);a.writeFieldEnd()}if(null!=this.tagUrl){a.writeFieldBegin("tagUrl",Ooyala.Thrift.Type.STRING,8);a.writeString(this.tagUrl);a.writeFieldEnd()}if(null!=this.passthroughParameters){a.writeFieldBegin("passthroughParameters",Ooyala.Thrift.Type.STRING,9);a.writeString(this.passthroughParameters);a.writeFieldEnd()}if(null!=this.adId){a.writeFieldBegin("adId",Ooyala.Thrift.Type.I32,10);a.writeI32(this.adId);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.AdsLogging.AdTracking=function(a){this.playThroughCompletion=this.adSpotIndex=0;this.clickToVideo=false;this.clickUrl="";this.failureAfterAdImpression=this.dupClick=false;this.failureReason=0;if(a!=null){if(null!=a.adSpotIndex)this.adSpotIndex=a.adSpotIndex;if(null!=a.playThroughCompletion)this.playThroughCompletion=a.playThroughCompletion;if(null!=a.clickToVideo)this.clickToVideo=a.clickToVideo;if(null!=a.clickUrl)this.clickUrl=a.clickUrl;if(null!=a.dupClick)this.dupClick=a.dupClick;if(null!=
    a.failureAfterAdImpression)this.failureAfterAdImpression=a.failureAfterAdImpression;if(null!=a.failureReason)this.failureReason=a.failureReason}};Ooyala.AdsLogging.AdTracking.prototype={};
  Ooyala.AdsLogging.AdTracking.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.adSpotIndex=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.playThroughCompletion=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.clickToVideo=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.STRING){b=
    a.readString();this.clickUrl=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.dupClick=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.failureAfterAdImpression=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.failureReason=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.AdsLogging.AdTracking.prototype.write=function(a){a.writeStructBegin("AdTracking");if(null!=this.adSpotIndex){a.writeFieldBegin("adSpotIndex",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.adSpotIndex);a.writeFieldEnd()}if(null!=this.playThroughCompletion){a.writeFieldBegin("playThroughCompletion",Ooyala.Thrift.Type.I16,2);a.writeI16(this.playThroughCompletion);a.writeFieldEnd()}if(null!=this.clickToVideo){a.writeFieldBegin("clickToVideo",Ooyala.Thrift.Type.BOOL,3);a.writeBool(this.clickToVideo);
    a.writeFieldEnd()}if(null!=this.clickUrl){a.writeFieldBegin("clickUrl",Ooyala.Thrift.Type.STRING,4);a.writeString(this.clickUrl);a.writeFieldEnd()}if(null!=this.dupClick){a.writeFieldBegin("dupClick",Ooyala.Thrift.Type.BOOL,5);a.writeBool(this.dupClick);a.writeFieldEnd()}if(null!=this.failureAfterAdImpression){a.writeFieldBegin("failureAfterAdImpression",Ooyala.Thrift.Type.BOOL,6);a.writeBool(this.failureAfterAdImpression);a.writeFieldEnd()}if(null!=this.failureReason){a.writeFieldBegin("failureReason",
    Ooyala.Thrift.Type.BYTE,7);a.writeByte(this.failureReason);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};if(typeof Ooyala==="undefined")Ooyala={};if(typeof Ooyala.CustomEventsLogging==="undefined")Ooyala.CustomEventsLogging={};Ooyala.CustomEventsLogging.Callee={AS:1,JS:2,OPF:3,OTHER:4};Ooyala.CustomEventsLogging.CalleeFormat={1:"actionscript api",2:"javascript api",3:"OPF api",4:"unknown api"};
  Ooyala.CustomEventsLogging.CustomEvent=function(a){this.event="";this.operations=[];this.callee=0;this.process=false;this.value=0;if(a!=null){if(null!=a.event)this.event=a.event;if(null!=a.operations)this.operations=a.operations;if(null!=a.callee)this.callee=a.callee;if(null!=a.process)this.process=a.process;if(null!=a.value)this.value=a.value}};Ooyala.CustomEventsLogging.CustomEvent.prototype={};
  Ooyala.CustomEventsLogging.CustomEvent.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING){var d=a.readString();this.event=d.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.LIST){b=0;this.operations=[];b=a.readListBegin().size;for(c=0;c<b;++c){d=null;d=a.readString();d=d.value;this.operations.push(d)}a.readListEnd()}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.BYTE){d=
    a.readByte();this.callee=d.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.BOOL){d=a.readBool();this.process=d.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.I32){d=a.readI32();this.value=d.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.CustomEventsLogging.CustomEvent.prototype.write=function(a){a.writeStructBegin("CustomEvent");if(null!=this.event){a.writeFieldBegin("event",Ooyala.Thrift.Type.STRING,1);a.writeString(this.event);a.writeFieldEnd()}if(null!=this.operations){a.writeFieldBegin("operations",Ooyala.Thrift.Type.LIST,2);a.writeListBegin(Ooyala.Thrift.Type.STRING,this.operations.length);for(var b=0;b<this.operations.length;b++)a.writeString(this.operations[b]);a.writeListEnd();a.writeFieldEnd()}if(null!=this.callee){a.writeFieldBegin("callee",
    Ooyala.Thrift.Type.BYTE,3);a.writeByte(this.callee);a.writeFieldEnd()}if(null!=this.process){a.writeFieldBegin("process",Ooyala.Thrift.Type.BOOL,4);a.writeBool(this.process);a.writeFieldEnd()}if(null!=this.value){a.writeFieldBegin("value",Ooyala.Thrift.Type.I32,5);a.writeI32(this.value);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};if(typeof Ooyala==="undefined")Ooyala={};if(typeof Ooyala.MetricsLogging==="undefined")Ooyala.MetricsLogging={};
  Ooyala.MetricsLogging.MetricsKey={TIME_TO_UI_READY:1,TIME_TO_PLAYBACK_READY:2,TIME_TO_START_SCREEN_IMAGE_DISPLAYED:3,TIME_FROM_PLAY_CLICK_TO_PLAY:4,TIME_TO_START_PLAY_WITH_AUTOPLAY:5,TIME_TO_LOAD_AD:6,TIME_TO_PREFETCH_AD:7,TIME_TO_PLAY_AD:8,USER_VIEWABLE_LATENCY_FOR_AD:9,TIME_TO_LOAD_AD_FAILURE:10,TIME_TO_PREFETCH_AD_FAILURE:11,TIME_TO_PLAY_AD_FAILURE:12,USER_VIEWABLE_LATENCY_FOR_AD_FAILURE:13,TIME_SPENT_BUFFERING:20,TIME_FROM_LOAD_TO_API_READY:30,TIME_FROM_PLAY_TO_PLAYBACK_STARTED:31};
  Ooyala.MetricsLogging.METRICS_KEY_TYPENAMES={1:"timeToUIReady",2:"timeToPlaybackReady",3:"timeToStartScreenImageDisplayed",5:"timeToStartPlayWithAutoplay",4:"timeFromPlayClickToPlay",6:"timeToLoadAd",7:"timeToPrefetchAd",8:"timeToPlayAd",9:"userViewableLatencyForAd",10:"timeToLoadAdFailure",11:"timeToPrefetchAdFailure",12:"timeToPlayAdFailure",13:"userViewableLatencyForAdFailure",20:"timeSpentBuffering",30:"timeFromLoadToAPIReady",31:"timeFromPlayToPlaybackStarted"};
  Ooyala.MetricsLogging.Metric=function(a){this.key=0;this.values=[];if(a!=null){if(null!=a.key)this.key=a.key;if(null!=a.values)this.values=a.values}};Ooyala.MetricsLogging.Metric.prototype={};
  Ooyala.MetricsLogging.Metric.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.I16){var d=a.readI16();this.key=d.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.LIST){b=0;this.values=[];b=a.readListBegin().size;for(c=0;c<b;++c){d=null;d=a.readI32();d=d.value;this.values.push(d)}a.readListEnd()}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.MetricsLogging.Metric.prototype.write=function(a){a.writeStructBegin("Metric");if(null!=this.key){a.writeFieldBegin("key",Ooyala.Thrift.Type.I16,1);a.writeI16(this.key);a.writeFieldEnd()}if(null!=this.values){a.writeFieldBegin("values",Ooyala.Thrift.Type.LIST,2);a.writeListBegin(Ooyala.Thrift.Type.I32,this.values.length);for(var b=0;b<this.values.length;b++)a.writeI32(this.values[b]);a.writeListEnd();a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};if(typeof Ooyala==="undefined")Ooyala={};if(typeof Ooyala.Logging==="undefined")Ooyala.Logging={};
  Ooyala.Logging.PlayerEventType={UNKNOWN:0,DISPLAY:1,PLAY:2,PERCENTAGE_WATCHED:3,SEEK:4,REPLAY:5,PAUSE:6,BUCKETS_WATCHED:7,TOTAL_TIME_PLAYED:8,BITRATE_PLAYED:9,DOWNLOAD:10,CHUNK_FAILOVER:11,BUFFER:12,CV_INFO:13,AD_CLICK:14,AD_IMPRESSION:15,AD_PLAYTHROUGH:16,AD_PLAY_FAILED:17,METRIC:18,PLAYER_LOAD:19,BITRATE_TRANSITION:20,BITRATES_AVAILABLE:21,SHARE:22,PAY_PER_VIEW:23,SAS_AUTHORIZE:24,SAS_AUTHORIZE_V2:25,AD_REQUESTED:26,AD_MOUSEOVER:27,VIDEO_START:28,CUSTOM:29,RELATED_VIDEO_SELECTED:30,RELATED_VIDEOS_DISPLAYED:31,
    PLAYTHROUGH_PERCENT:32};Ooyala.Logging.FileType={VIDEO_FILE:1,IMAGE:2,PLAYER:3,MODULE:4,XML:5};Ooyala.Logging.ChunkFailoverReason={UNKNOWN_REASON:0,READ_TIMEOUT:1,CONNECTION_TIMEOUT:2,CONNECTION_ERROR:3,CLOSE:4,DISCONNECTED:5};Ooyala.Logging.StreamFormat={VP6:1,H264:2,OTHER:3};Ooyala.Logging.PlayerEmbedType={JS:1,OBJECT:2,FLASH_IN_FLASH:3,EXTERNAL_ANALYTICS:4};Ooyala.Logging.BufferType={UNKNOWN_BUFFER_TYPE:0,LOW_BANDWIDTH:1,USER_INITIATED:2,CONNECTION_LOST:3};Ooyala.Logging.Gateway={PAYPAL:1,PAYMO:2};
  Ooyala.Logging.PayPerViewCheckoutType={CHECKOUT_PRESENTED:1,CHECKOUT_STARTED:2,CHECKOUT_FINISHED:3,CHECKOUT_CANCELLED:4,CHECKOUT_FAILED:5};Ooyala.Logging.ReportingIdType={GLOBAL:1,VIDEO:2,CHANNEL:3,CHANNEL_SET:4,PROVIDER:5};Ooyala.Logging.UserInfoSource={AKAMAI:1,MAXMIND:2,ENCRYPTED_SAS:3};
  Ooyala.Logging.PLAYER_EVENT_TYPENAMES={0:"unknown",1:"display",2:"play",3:"percentageWatched",4:"seek",5:"replay",6:"pause",7:"bucketsWatched",8:"totalTimePlayed",9:"bitratePlayed",10:"download",11:"chunkFailover",12:"buffer",13:"cvInfo",14:"adClick",27:"adMouseover",26:"adRequested",15:"adImpression",16:"adPlaythrough",17:"adPlayFailed",18:"metric",19:"playerLoad",20:"bitrateTransition",21:"bitratesAvailable",22:"share",23:"payPerView",24:"sasAuthorize",25:"sasAuthorizeV2",28:"videoStart",29:"customEvent",
    30:"relatedVideoSelected",31:"relatedVideoDisplayed",32:"playthroughPercent"};Ooyala.Logging.FILE_TYPENAMES={1:"video",2:"image",3:"player",4:"module",5:"xml"};Ooyala.Logging.STREAM_FORMAT_TYPENAMES={1:"vp6",2:"h264",3:"other"};Ooyala.Logging.PLAYER_EMBED_TYPENAMES={1:"js",2:"object",3:"flashInFlash",4:"externalAnalytics"};Ooyala.Logging.BUFFER_TYPENAMES={0:"unknown",1:"lowBandwidth",2:"userInitiated",3:"connectionLost"};Ooyala.Logging.GATEWAY_TYPENAMES={1:"paypal",2:"paymo"};
  Ooyala.Logging.PAY_PER_VIEW_CHECKOUT_TYPENAMES={1:"checkoutPresented",2:"checkoutStarted",3:"checkoutFinished",4:"checkoutCancelled",5:"checkoutFailed"};Ooyala.Logging.REPORTING_ID_TYPE_MAP={1:"global",2:"video",3:"channel",4:"channelSet",5:"provider"};
  Ooyala.Logging.DownloadStats=function(a){this.servingDomainId=0;this.fileTypeToBytesDownloaded={};this.servingDomain="";this.timesToFirstByte=[];this.avgTimeToFirstByte=this.numLatencyPoints=this.downloadTime=0;this.percentSingleConnection=100;this.totalSingleStreamPlayTime=this.totalSingleStreamBytes=this.bytesDownloadedFromSingleConnection=0;this.filetype=1;this.timeToFirstByte=this.bytesDownloaded=0;if(a!=null){if(null!=a.servingDomainId)this.servingDomainId=a.servingDomainId;if(null!=a.fileTypeToBytesDownloaded)this.fileTypeToBytesDownloaded=
    a.fileTypeToBytesDownloaded;if(null!=a.servingDomain)this.servingDomain=a.servingDomain;if(null!=a.timesToFirstByte)this.timesToFirstByte=a.timesToFirstByte;if(null!=a.downloadTime)this.downloadTime=a.downloadTime;if(null!=a.numLatencyPoints)this.numLatencyPoints=a.numLatencyPoints;if(null!=a.avgTimeToFirstByte)this.avgTimeToFirstByte=a.avgTimeToFirstByte;if(null!=a.percentSingleConnection)this.percentSingleConnection=a.percentSingleConnection;if(null!=a.bytesDownloadedFromSingleConnection)this.bytesDownloadedFromSingleConnection=
    a.bytesDownloadedFromSingleConnection;if(null!=a.totalSingleStreamBytes)this.totalSingleStreamBytes=a.totalSingleStreamBytes;if(null!=a.totalSingleStreamPlayTime)this.totalSingleStreamPlayTime=a.totalSingleStreamPlayTime;if(null!=a.filetype)this.filetype=a.filetype;if(null!=a.bytesDownloaded)this.bytesDownloaded=a.bytesDownloaded;if(null!=a.timeToFirstByte)this.timeToFirstByte=a.timeToFirstByte}};Ooyala.Logging.DownloadStats.prototype={};
  Ooyala.Logging.DownloadStats.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.servingDomainId=b.value}else a.skip(c);break;case 11:if(c==Ooyala.Thrift.Type.MAP){c=0;this.fileTypeToBytesDownloaded={};b=a.readMapBegin();c=b.size;for(var d=0;d<c;++d){val6=key5=0;b=a.readByte();key5=b.value;b=a.readI32();val6=b.value;this.fileTypeToBytesDownloaded[key5]=
    val6}a.readMapEnd()}else a.skip(c);break;case 15:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.servingDomain=b.value}else a.skip(c);break;case 12:if(c==Ooyala.Thrift.Type.LIST){c=0;this.timesToFirstByte=[];b=a.readListBegin();c=b.size;for(d=0;d<c;++d){b=null;b=a.readI16();b=b.value;this.timesToFirstByte.push(b)}a.readListEnd()}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.downloadTime=b.value}else a.skip(c);break;case 13:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();
    this.numLatencyPoints=b.value}else a.skip(c);break;case 14:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.avgTimeToFirstByte=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.percentSingleConnection=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.bytesDownloadedFromSingleConnection=b.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.totalSingleStreamBytes=b.value}else a.skip(c);break;case 9:if(c==
    Ooyala.Thrift.Type.I32){b=a.readI32();this.totalSingleStreamPlayTime=b.value}else a.skip(c);break;case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.filetype=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.bytesDownloaded=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.timeToFirstByte=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.DownloadStats.prototype.write=function(a){a.writeStructBegin("DownloadStats");if(null!=this.servingDomainId){a.writeFieldBegin("servingDomainId",Ooyala.Thrift.Type.I32,2);a.writeI32(this.servingDomainId);a.writeFieldEnd()}if(null!=this.fileTypeToBytesDownloaded){a.writeFieldBegin("fileTypeToBytesDownloaded",Ooyala.Thrift.Type.MAP,11);var b=0;for(key in this.fileTypeToBytesDownloaded)this.fileTypeToBytesDownloaded.hasOwnProperty(key)&&b++;a.writeMapBegin(Ooyala.Thrift.Type.BYTE,Ooyala.Thrift.Type.I32,
    b);for(var c in this.fileTypeToBytesDownloaded){b=this.fileTypeToBytesDownloaded[c];a.writeByte(c);a.writeI32(b)}a.writeMapEnd();a.writeFieldEnd()}if(null!=this.servingDomain){a.writeFieldBegin("servingDomain",Ooyala.Thrift.Type.STRING,15);a.writeString(this.servingDomain);a.writeFieldEnd()}if(null!=this.timesToFirstByte){a.writeFieldBegin("timesToFirstByte",Ooyala.Thrift.Type.LIST,12);a.writeListBegin(Ooyala.Thrift.Type.I16,this.timesToFirstByte.length);for(c=0;c<this.timesToFirstByte.length;c++)a.writeI16(this.timesToFirstByte[c]);
    a.writeListEnd();a.writeFieldEnd()}if(null!=this.downloadTime){a.writeFieldBegin("downloadTime",Ooyala.Thrift.Type.I32,5);a.writeI32(this.downloadTime);a.writeFieldEnd()}if(null!=this.numLatencyPoints){a.writeFieldBegin("numLatencyPoints",Ooyala.Thrift.Type.I16,13);a.writeI16(this.numLatencyPoints);a.writeFieldEnd()}if(null!=this.avgTimeToFirstByte){a.writeFieldBegin("avgTimeToFirstByte",Ooyala.Thrift.Type.I16,14);a.writeI16(this.avgTimeToFirstByte);a.writeFieldEnd()}if(null!=this.percentSingleConnection){a.writeFieldBegin("percentSingleConnection",
    Ooyala.Thrift.Type.BYTE,6);a.writeByte(this.percentSingleConnection);a.writeFieldEnd()}if(null!=this.bytesDownloadedFromSingleConnection){a.writeFieldBegin("bytesDownloadedFromSingleConnection",Ooyala.Thrift.Type.I32,7);a.writeI32(this.bytesDownloadedFromSingleConnection);a.writeFieldEnd()}if(null!=this.totalSingleStreamBytes){a.writeFieldBegin("totalSingleStreamBytes",Ooyala.Thrift.Type.I32,8);a.writeI32(this.totalSingleStreamBytes);a.writeFieldEnd()}if(null!=this.totalSingleStreamPlayTime){a.writeFieldBegin("totalSingleStreamPlayTime",
    Ooyala.Thrift.Type.I32,9);a.writeI32(this.totalSingleStreamPlayTime);a.writeFieldEnd()}if(null!=this.filetype){a.writeFieldBegin("filetype",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.filetype);a.writeFieldEnd()}if(null!=this.bytesDownloaded){a.writeFieldBegin("bytesDownloaded",Ooyala.Thrift.Type.I32,3);a.writeI32(this.bytesDownloaded);a.writeFieldEnd()}if(null!=this.timeToFirstByte){a.writeFieldBegin("timeToFirstByte",Ooyala.Thrift.Type.I32,4);a.writeI32(this.timeToFirstByte);a.writeFieldEnd()}a.writeFieldStop();
    a.writeStructEnd()};Ooyala.Logging.ChunkFailoverInfo=function(a){this.servingDomainId=this.reason=0;this.chunkShortUrl="";this.firstForUrl=this.firstForChunk=false;if(a!=null){if(null!=a.reason)this.reason=a.reason;if(null!=a.servingDomainId)this.servingDomainId=a.servingDomainId;if(null!=a.chunkShortUrl)this.chunkShortUrl=a.chunkShortUrl;if(null!=a.firstForChunk)this.firstForChunk=a.firstForChunk;if(null!=a.firstForUrl)this.firstForUrl=a.firstForUrl}};Ooyala.Logging.ChunkFailoverInfo.prototype={};
  Ooyala.Logging.ChunkFailoverInfo.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.reason=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.servingDomainId=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.chunkShortUrl=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.BOOL){b=
    a.readBool();this.firstForChunk=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.firstForUrl=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.ChunkFailoverInfo.prototype.write=function(a){a.writeStructBegin("ChunkFailoverInfo");if(null!=this.reason){a.writeFieldBegin("reason",Ooyala.Thrift.Type.I32,1);a.writeI32(this.reason);a.writeFieldEnd()}if(null!=this.servingDomainId){a.writeFieldBegin("servingDomainId",Ooyala.Thrift.Type.I32,2);a.writeI32(this.servingDomainId);a.writeFieldEnd()}if(null!=this.chunkShortUrl){a.writeFieldBegin("chunkShortUrl",Ooyala.Thrift.Type.STRING,3);a.writeString(this.chunkShortUrl);a.writeFieldEnd()}if(null!=
    this.firstForChunk){a.writeFieldBegin("firstForChunk",Ooyala.Thrift.Type.BOOL,4);a.writeBool(this.firstForChunk);a.writeFieldEnd()}if(null!=this.firstForUrl){a.writeFieldBegin("firstForUrl",Ooyala.Thrift.Type.BOOL,5);a.writeBool(this.firstForUrl);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.PlayheadStatus=function(a){this.fromSeekTimeMillis=this.lastSeekTimeMillis=this.playheadTimeMillis=0;this.DEPRECATED_firstForVideo=this.DEPRECATED_firstForUser=false;if(a!=null){if(null!=a.playheadTimeMillis)this.playheadTimeMillis=a.playheadTimeMillis;if(null!=a.lastSeekTimeMillis)this.lastSeekTimeMillis=a.lastSeekTimeMillis;if(null!=a.fromSeekTimeMillis)this.fromSeekTimeMillis=a.fromSeekTimeMillis;if(null!=a.DEPRECATED_firstForUser)this.DEPRECATED_firstForUser=a.DEPRECATED_firstForUser;
    if(null!=a.DEPRECATED_firstForVideo)this.DEPRECATED_firstForVideo=a.DEPRECATED_firstForVideo}};Ooyala.Logging.PlayheadStatus.prototype={};
  Ooyala.Logging.PlayheadStatus.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.playheadTimeMillis=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.lastSeekTimeMillis=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.fromSeekTimeMillis=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.BOOL){b=
    a.readBool();this.DEPRECATED_firstForUser=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.DEPRECATED_firstForVideo=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.PlayheadStatus.prototype.write=function(a){a.writeStructBegin("PlayheadStatus");if(null!=this.playheadTimeMillis){a.writeFieldBegin("playheadTimeMillis",Ooyala.Thrift.Type.I32,1);a.writeI32(this.playheadTimeMillis);a.writeFieldEnd()}if(null!=this.lastSeekTimeMillis){a.writeFieldBegin("lastSeekTimeMillis",Ooyala.Thrift.Type.I32,2);a.writeI32(this.lastSeekTimeMillis);a.writeFieldEnd()}if(null!=this.fromSeekTimeMillis){a.writeFieldBegin("fromSeekTimeMillis",Ooyala.Thrift.Type.I32,4);a.writeI32(this.fromSeekTimeMillis);
    a.writeFieldEnd()}if(null!=this.DEPRECATED_firstForUser){a.writeFieldBegin("DEPRECATED_firstForUser",Ooyala.Thrift.Type.BOOL,3);a.writeBool(this.DEPRECATED_firstForUser);a.writeFieldEnd()}if(null!=this.DEPRECATED_firstForVideo){a.writeFieldBegin("DEPRECATED_firstForVideo",Ooyala.Thrift.Type.BOOL,5);a.writeBool(this.DEPRECATED_firstForVideo);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.CvObjectClickInfo=function(a){this.oid=this.trackId="";this.clickTime=this.mouseY=this.mouseX=0;this.link=this.label="";this.outline=[];if(a!=null){if(null!=a.trackId)this.trackId=a.trackId;if(null!=a.oid)this.oid=a.oid;if(null!=a.mouseX)this.mouseX=a.mouseX;if(null!=a.mouseY)this.mouseY=a.mouseY;if(null!=a.clickTime)this.clickTime=a.clickTime;if(null!=a.label)this.label=a.label;if(null!=a.link)this.link=a.link;if(null!=a.outline)this.outline=a.outline}};
  Ooyala.Logging.CvObjectClickInfo.prototype={};
  Ooyala.Logging.CvObjectClickInfo.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING){var d=a.readString();this.trackId=d.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.STRING){d=a.readString();this.oid=d.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.DOUBLE){d=a.readDouble();this.mouseX=d.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.DOUBLE){d=
    a.readDouble();this.mouseY=d.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.DOUBLE){d=a.readDouble();this.clickTime=d.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.STRING){d=a.readString();this.label=d.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.STRING){d=a.readString();this.link=d.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.LIST){b=0;this.outline=[];b=a.readListBegin().size;for(c=0;c<b;++c){d=null;d=a.readDouble();d=d.value;this.outline.push(d)}a.readListEnd()}else a.skip(c);
    break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.CvObjectClickInfo.prototype.write=function(a){a.writeStructBegin("CvObjectClickInfo");if(null!=this.trackId){a.writeFieldBegin("trackId",Ooyala.Thrift.Type.STRING,1);a.writeString(this.trackId);a.writeFieldEnd()}if(null!=this.oid){a.writeFieldBegin("oid",Ooyala.Thrift.Type.STRING,2);a.writeString(this.oid);a.writeFieldEnd()}if(null!=this.mouseX){a.writeFieldBegin("mouseX",Ooyala.Thrift.Type.DOUBLE,3);a.writeDouble(this.mouseX);a.writeFieldEnd()}if(null!=this.mouseY){a.writeFieldBegin("mouseY",
    Ooyala.Thrift.Type.DOUBLE,4);a.writeDouble(this.mouseY);a.writeFieldEnd()}if(null!=this.clickTime){a.writeFieldBegin("clickTime",Ooyala.Thrift.Type.DOUBLE,5);a.writeDouble(this.clickTime);a.writeFieldEnd()}if(null!=this.label){a.writeFieldBegin("label",Ooyala.Thrift.Type.STRING,6);a.writeString(this.label);a.writeFieldEnd()}if(null!=this.link){a.writeFieldBegin("link",Ooyala.Thrift.Type.STRING,7);a.writeString(this.link);a.writeFieldEnd()}if(null!=this.outline){a.writeFieldBegin("outline",Ooyala.Thrift.Type.LIST,
    8);a.writeListBegin(Ooyala.Thrift.Type.DOUBLE,this.outline.length);for(var b=0;b<this.outline.length;b++)a.writeDouble(this.outline[b]);a.writeListEnd();a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};Ooyala.Logging.WatchedBuckets=function(a){this.maxPerMille=this.minPerMille=0;if(a!=null){if(null!=a.minPerMille)this.minPerMille=a.minPerMille;if(null!=a.maxPerMille)this.maxPerMille=a.maxPerMille}};Ooyala.Logging.WatchedBuckets.prototype={};
  Ooyala.Logging.WatchedBuckets.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.minPerMille=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.maxPerMille=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.WatchedBuckets.prototype.write=function(a){a.writeStructBegin("WatchedBuckets");if(null!=this.minPerMille){a.writeFieldBegin("minPerMille",Ooyala.Thrift.Type.I16,1);a.writeI16(this.minPerMille);a.writeFieldEnd()}if(null!=this.maxPerMille){a.writeFieldBegin("maxPerMille",Ooyala.Thrift.Type.I16,2);a.writeI16(this.maxPerMille);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.BitratePlayed=function(a){this.userBandwidthInKbps=this.audioKbps=this.videoFormat=this.videoKbps=this.timePlayed=0;if(a!=null){if(null!=a.timePlayed)this.timePlayed=a.timePlayed;if(null!=a.videoKbps)this.videoKbps=a.videoKbps;if(null!=a.videoFormat)this.videoFormat=a.videoFormat;if(null!=a.audioKbps)this.audioKbps=a.audioKbps;if(null!=a.userBandwidthInKbps)this.userBandwidthInKbps=a.userBandwidthInKbps}};Ooyala.Logging.BitratePlayed.prototype={};
  Ooyala.Logging.BitratePlayed.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.timePlayed=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.videoKbps=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.videoFormat=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.I32){b=
    a.readI32();this.audioKbps=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.userBandwidthInKbps=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.BitratePlayed.prototype.write=function(a){a.writeStructBegin("BitratePlayed");if(null!=this.timePlayed){a.writeFieldBegin("timePlayed",Ooyala.Thrift.Type.I32,1);a.writeI32(this.timePlayed);a.writeFieldEnd()}if(null!=this.videoKbps){a.writeFieldBegin("videoKbps",Ooyala.Thrift.Type.I32,2);a.writeI32(this.videoKbps);a.writeFieldEnd()}if(null!=this.videoFormat){a.writeFieldBegin("videoFormat",Ooyala.Thrift.Type.I32,3);a.writeI32(this.videoFormat);a.writeFieldEnd()}if(null!=this.audioKbps){a.writeFieldBegin("audioKbps",
    Ooyala.Thrift.Type.I32,4);a.writeI32(this.audioKbps);a.writeFieldEnd()}if(null!=this.userBandwidthInKbps){a.writeFieldBegin("userBandwidthInKbps",Ooyala.Thrift.Type.I32,5);a.writeI32(this.userBandwidthInKbps);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.BitrateTransition=function(a){this.transitionTimeInMillis=this.newAudioKbps=this.oldAudioKbps=this.newVideoKbps=this.oldVideoKbps=0;if(a!=null){if(null!=a.oldVideoKbps)this.oldVideoKbps=a.oldVideoKbps;if(null!=a.newVideoKbps)this.newVideoKbps=a.newVideoKbps;if(null!=a.oldAudioKbps)this.oldAudioKbps=a.oldAudioKbps;if(null!=a.newAudioKbps)this.newAudioKbps=a.newAudioKbps;if(null!=a.transitionTimeInMillis)this.transitionTimeInMillis=a.transitionTimeInMillis}};
  Ooyala.Logging.BitrateTransition.prototype={};
  Ooyala.Logging.BitrateTransition.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.oldVideoKbps=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.newVideoKbps=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.oldAudioKbps=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.I32){b=
    a.readI32();this.newAudioKbps=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.transitionTimeInMillis=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.BitrateTransition.prototype.write=function(a){a.writeStructBegin("BitrateTransition");if(null!=this.oldVideoKbps){a.writeFieldBegin("oldVideoKbps",Ooyala.Thrift.Type.I32,1);a.writeI32(this.oldVideoKbps);a.writeFieldEnd()}if(null!=this.newVideoKbps){a.writeFieldBegin("newVideoKbps",Ooyala.Thrift.Type.I32,2);a.writeI32(this.newVideoKbps);a.writeFieldEnd()}if(null!=this.oldAudioKbps){a.writeFieldBegin("oldAudioKbps",Ooyala.Thrift.Type.I32,3);a.writeI32(this.oldAudioKbps);a.writeFieldEnd()}if(null!=
    this.newAudioKbps){a.writeFieldBegin("newAudioKbps",Ooyala.Thrift.Type.I32,4);a.writeI32(this.newAudioKbps);a.writeFieldEnd()}if(null!=this.transitionTimeInMillis){a.writeFieldBegin("transitionTimeInMillis",Ooyala.Thrift.Type.I32,5);a.writeI32(this.transitionTimeInMillis);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.Sharing=function(a){this.urlCopy=this.twitter=this.facebook=this.stumbleUpon=this.digg=this.embedCodeCopy=this.email=false;if(a!=null){if(null!=a.email)this.email=a.email;if(null!=a.embedCodeCopy)this.embedCodeCopy=a.embedCodeCopy;if(null!=a.digg)this.digg=a.digg;if(null!=a.stumbleUpon)this.stumbleUpon=a.stumbleUpon;if(null!=a.facebook)this.facebook=a.facebook;if(null!=a.twitter)this.twitter=a.twitter;if(null!=a.urlCopy)this.urlCopy=a.urlCopy}};Ooyala.Logging.Sharing.prototype={};
  Ooyala.Logging.Sharing.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.email=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.embedCodeCopy=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.digg=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();
    this.stumbleUpon=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.facebook=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.twitter=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.urlCopy=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.Sharing.prototype.write=function(a){a.writeStructBegin("Sharing");if(null!=this.email){a.writeFieldBegin("email",Ooyala.Thrift.Type.BOOL,1);a.writeBool(this.email);a.writeFieldEnd()}if(null!=this.embedCodeCopy){a.writeFieldBegin("embedCodeCopy",Ooyala.Thrift.Type.BOOL,2);a.writeBool(this.embedCodeCopy);a.writeFieldEnd()}if(null!=this.digg){a.writeFieldBegin("digg",Ooyala.Thrift.Type.BOOL,3);a.writeBool(this.digg);a.writeFieldEnd()}if(null!=this.stumbleUpon){a.writeFieldBegin("stumbleUpon",
    Ooyala.Thrift.Type.BOOL,4);a.writeBool(this.stumbleUpon);a.writeFieldEnd()}if(null!=this.facebook){a.writeFieldBegin("facebook",Ooyala.Thrift.Type.BOOL,5);a.writeBool(this.facebook);a.writeFieldEnd()}if(null!=this.twitter){a.writeFieldBegin("twitter",Ooyala.Thrift.Type.BOOL,6);a.writeBool(this.twitter);a.writeFieldEnd()}if(null!=this.urlCopy){a.writeFieldBegin("urlCopy",Ooyala.Thrift.Type.BOOL,7);a.writeBool(this.urlCopy);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.PersonalizationBucketInfo=function(a){this.bucketInfo="";if(a!=null)if(null!=a.bucketInfo)this.bucketInfo=a.bucketInfo};Ooyala.Logging.PersonalizationBucketInfo.prototype={};Ooyala.Logging.PersonalizationBucketInfo.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING)this.bucketInfo=a.readString().value;else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.PersonalizationBucketInfo.prototype.write=function(a){a.writeStructBegin("PersonalizationBucketInfo");if(null!=this.bucketInfo){a.writeFieldBegin("bucketInfo",Ooyala.Thrift.Type.STRING,1);a.writeString(this.bucketInfo);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.PayPerView=function(a){this.mobilePrice=this.price=this.gateway=this.checkoutType=0;this.currency="";this.playheadTimeInMillis=this.previewWindowInMillis=0;this.error="";if(a!=null){if(null!=a.checkoutType)this.checkoutType=a.checkoutType;if(null!=a.gateway)this.gateway=a.gateway;if(null!=a.price)this.price=a.price;if(null!=a.mobilePrice)this.mobilePrice=a.mobilePrice;if(null!=a.currency)this.currency=a.currency;if(null!=a.previewWindowInMillis)this.previewWindowInMillis=a.previewWindowInMillis;
    if(null!=a.playheadTimeInMillis)this.playheadTimeInMillis=a.playheadTimeInMillis;if(null!=a.error)this.error=a.error}};Ooyala.Logging.PayPerView.prototype={};
  Ooyala.Logging.PayPerView.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.checkoutType=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.gateway=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.DOUBLE){b=a.readDouble();this.price=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.DOUBLE){b=
    a.readDouble();this.mobilePrice=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.currency=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.previewWindowInMillis=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.playheadTimeInMillis=b.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.error=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.PayPerView.prototype.write=function(a){a.writeStructBegin("PayPerView");if(null!=this.checkoutType){a.writeFieldBegin("checkoutType",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.checkoutType);a.writeFieldEnd()}if(null!=this.gateway){a.writeFieldBegin("gateway",Ooyala.Thrift.Type.BYTE,2);a.writeByte(this.gateway);a.writeFieldEnd()}if(null!=this.price){a.writeFieldBegin("price",Ooyala.Thrift.Type.DOUBLE,3);a.writeDouble(this.price);a.writeFieldEnd()}if(null!=this.mobilePrice){a.writeFieldBegin("mobilePrice",
    Ooyala.Thrift.Type.DOUBLE,4);a.writeDouble(this.mobilePrice);a.writeFieldEnd()}if(null!=this.currency){a.writeFieldBegin("currency",Ooyala.Thrift.Type.STRING,5);a.writeString(this.currency);a.writeFieldEnd()}if(null!=this.previewWindowInMillis){a.writeFieldBegin("previewWindowInMillis",Ooyala.Thrift.Type.I32,6);a.writeI32(this.previewWindowInMillis);a.writeFieldEnd()}if(null!=this.playheadTimeInMillis){a.writeFieldBegin("playheadTimeInMillis",Ooyala.Thrift.Type.I32,7);a.writeI32(this.playheadTimeInMillis);
    a.writeFieldEnd()}if(null!=this.error){a.writeFieldBegin("error",Ooyala.Thrift.Type.STRING,8);a.writeString(this.error);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.SasAuthorize=function(a){this.authorized=false;this.latency=this.requestTime=0;this.messages=this.codes="";this.isAuthorizedInPlayerXML=false;if(a!=null){if(null!=a.authorized)this.authorized=a.authorized;if(null!=a.requestTime)this.requestTime=a.requestTime;if(null!=a.latency)this.latency=a.latency;if(null!=a.codes)this.codes=a.codes;if(null!=a.messages)this.messages=a.messages;if(null!=a.isAuthorizedInPlayerXML)this.isAuthorizedInPlayerXML=a.isAuthorizedInPlayerXML}};
  Ooyala.Logging.SasAuthorize.prototype={};
  Ooyala.Logging.SasAuthorize.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.authorized=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.requestTime=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.latency=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.STRING){b=
    a.readString();this.codes=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.messages=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.isAuthorizedInPlayerXML=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.SasAuthorize.prototype.write=function(a){a.writeStructBegin("SasAuthorize");if(null!=this.authorized){a.writeFieldBegin("authorized",Ooyala.Thrift.Type.BOOL,1);a.writeBool(this.authorized);a.writeFieldEnd()}if(null!=this.requestTime){a.writeFieldBegin("requestTime",Ooyala.Thrift.Type.I32,2);a.writeI32(this.requestTime);a.writeFieldEnd()}if(null!=this.latency){a.writeFieldBegin("latency",Ooyala.Thrift.Type.I32,3);a.writeI32(this.latency);a.writeFieldEnd()}if(null!=this.codes){a.writeFieldBegin("codes",
    Ooyala.Thrift.Type.STRING,4);a.writeString(this.codes);a.writeFieldEnd()}if(null!=this.messages){a.writeFieldBegin("messages",Ooyala.Thrift.Type.STRING,5);a.writeString(this.messages);a.writeFieldEnd()}if(null!=this.isAuthorizedInPlayerXML){a.writeFieldBegin("isAuthorizedInPlayerXML",Ooyala.Thrift.Type.BOOL,6);a.writeBool(this.isAuthorizedInPlayerXML);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.SasAuthorizeV2=function(a){this.rootEmbedCode=this.requestId="";this.clientSideLatencyForLastRequest=this.clientSideLatency=this.serverSideLatency=this.responseCode=0;this.continent=this.country="";if(a!=null){if(null!=a.requestId)this.requestId=a.requestId;if(null!=a.rootEmbedCode)this.rootEmbedCode=a.rootEmbedCode;if(null!=a.responseCode)this.responseCode=a.responseCode;if(null!=a.serverSideLatency)this.serverSideLatency=a.serverSideLatency;if(null!=a.clientSideLatency)this.clientSideLatency=
    a.clientSideLatency;if(null!=a.clientSideLatencyForLastRequest)this.clientSideLatencyForLastRequest=a.clientSideLatencyForLastRequest;if(null!=a.country)this.country=a.country;if(null!=a.continent)this.continent=a.continent}};Ooyala.Logging.SasAuthorizeV2.prototype={};
  Ooyala.Logging.SasAuthorizeV2.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.requestId=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.rootEmbedCode=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.responseCode=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.DOUBLE){b=
    a.readDouble();this.serverSideLatency=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.DOUBLE){b=a.readDouble();this.clientSideLatency=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.DOUBLE){b=a.readDouble();this.clientSideLatencyForLastRequest=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.country=b.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.continent=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.SasAuthorizeV2.prototype.write=function(a){a.writeStructBegin("SasAuthorizeV2");if(null!=this.requestId){a.writeFieldBegin("requestId",Ooyala.Thrift.Type.STRING,1);a.writeString(this.requestId);a.writeFieldEnd()}if(null!=this.rootEmbedCode){a.writeFieldBegin("rootEmbedCode",Ooyala.Thrift.Type.STRING,2);a.writeString(this.rootEmbedCode);a.writeFieldEnd()}if(null!=this.responseCode){a.writeFieldBegin("responseCode",Ooyala.Thrift.Type.I32,3);a.writeI32(this.responseCode);a.writeFieldEnd()}if(null!=
    this.serverSideLatency){a.writeFieldBegin("serverSideLatency",Ooyala.Thrift.Type.DOUBLE,4);a.writeDouble(this.serverSideLatency);a.writeFieldEnd()}if(null!=this.clientSideLatency){a.writeFieldBegin("clientSideLatency",Ooyala.Thrift.Type.DOUBLE,5);a.writeDouble(this.clientSideLatency);a.writeFieldEnd()}if(null!=this.clientSideLatencyForLastRequest){a.writeFieldBegin("clientSideLatencyForLastRequest",Ooyala.Thrift.Type.DOUBLE,6);a.writeDouble(this.clientSideLatencyForLastRequest);a.writeFieldEnd()}if(null!=
    this.country){a.writeFieldBegin("country",Ooyala.Thrift.Type.STRING,7);a.writeString(this.country);a.writeFieldEnd()}if(null!=this.continent){a.writeFieldBegin("continent",Ooyala.Thrift.Type.STRING,8);a.writeString(this.continent);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.ReportingIdDescriptor=function(a){this.adSetId=this.syndicationDestinationIdIndex=this.parentContentIdIndex=this.providerReportingIdIndex=this.reportingIdType=0;if(a!=null){if(null!=a.reportingIdType)this.reportingIdType=a.reportingIdType;if(null!=a.providerReportingIdIndex)this.providerReportingIdIndex=a.providerReportingIdIndex;if(null!=a.parentContentIdIndex)this.parentContentIdIndex=a.parentContentIdIndex;if(null!=a.syndicationDestinationIdIndex)this.syndicationDestinationIdIndex=
    a.syndicationDestinationIdIndex;if(null!=a.adSetId)this.adSetId=a.adSetId}};Ooyala.Logging.ReportingIdDescriptor.prototype={};
  Ooyala.Logging.ReportingIdDescriptor.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.reportingIdType=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.providerReportingIdIndex=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.parentContentIdIndex=b.value}else a.skip(c);break;
    case 4:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.syndicationDestinationIdIndex=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.adSetId=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.ReportingIdDescriptor.prototype.write=function(a){a.writeStructBegin("ReportingIdDescriptor");if(null!=this.reportingIdType){a.writeFieldBegin("reportingIdType",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.reportingIdType);a.writeFieldEnd()}if(null!=this.providerReportingIdIndex){a.writeFieldBegin("providerReportingIdIndex",Ooyala.Thrift.Type.BYTE,2);a.writeByte(this.providerReportingIdIndex);a.writeFieldEnd()}if(null!=this.parentContentIdIndex){a.writeFieldBegin("parentContentIdIndex",
    Ooyala.Thrift.Type.BYTE,3);a.writeByte(this.parentContentIdIndex);a.writeFieldEnd()}if(null!=this.syndicationDestinationIdIndex){a.writeFieldBegin("syndicationDestinationIdIndex",Ooyala.Thrift.Type.BYTE,4);a.writeByte(this.syndicationDestinationIdIndex);a.writeFieldEnd()}if(null!=this.adSetId){a.writeFieldBegin("adSetId",Ooyala.Thrift.Type.I32,5);a.writeI32(this.adSetId);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.PlayerEvent=function(a){this.reportingIdIndex=0;this.reportingIdIndices=[];this.eventType=0;this.param2=this.param1="";this.download=new Ooyala.Logging.DownloadStats;this.chunkFailover=new Ooyala.Logging.ChunkFailoverInfo;this.playhead=new Ooyala.Logging.PlayheadStatus;this.cvinfo=new Ooyala.Logging.CvObjectClickInfo;this.DEPRECATED_adClick=new Ooyala.AdsLogging.AdClick;this.buckets=new Ooyala.Logging.WatchedBuckets;this.timePlayed=0;this.bitratePlayed=new Ooyala.Logging.BitratePlayed;
    this.adTracking=new Ooyala.AdsLogging.AdTracking;this.metric=new Ooyala.MetricsLogging.Metric;this.lastEventTime=0;this.firstForVideo=this.firstForRootContent=this.firstForPlayer=false;this.bufferType=0;this.bitrateTransition=new Ooyala.Logging.BitrateTransition;this.bitratesAvailable=[];this.sharing=new Ooyala.Logging.Sharing;this.payPerView=new Ooyala.Logging.PayPerView;this.sasAuthorize=new Ooyala.Logging.SasAuthorize;this.sasAuthorizeV2=new Ooyala.Logging.SasAuthorizeV2;this.autoplay=false;this.customEvent=
      new Ooyala.CustomEventsLogging.CustomEvent;this.personalizationBucketInfo=new Ooyala.Logging.PersonalizationBucketInfo;this.reportingIdIndexToPlayheadPositionMillis={};this.seqnum=this.playthroughPercent=0;if(a!=null){if(null!=a.reportingIdIndex)this.reportingIdIndex=a.reportingIdIndex;if(null!=a.reportingIdIndices)this.reportingIdIndices=a.reportingIdIndices;if(null!=a.eventType)this.eventType=a.eventType;if(null!=a.param1)this.param1=a.param1;if(null!=a.param2)this.param2=a.param2;if(null!=a.download)this.download=
      a.download;if(null!=a.chunkFailover)this.chunkFailover=a.chunkFailover;if(null!=a.playhead)this.playhead=a.playhead;if(null!=a.cvinfo)this.cvinfo=a.cvinfo;if(null!=a.DEPRECATED_adClick)this.DEPRECATED_adClick=a.DEPRECATED_adClick;if(null!=a.buckets)this.buckets=a.buckets;if(null!=a.timePlayed)this.timePlayed=a.timePlayed;if(null!=a.bitratePlayed)this.bitratePlayed=a.bitratePlayed;if(null!=a.adTracking)this.adTracking=a.adTracking;if(null!=a.metric)this.metric=a.metric;if(null!=a.lastEventTime)this.lastEventTime=
      a.lastEventTime;if(null!=a.firstForPlayer)this.firstForPlayer=a.firstForPlayer;if(null!=a.firstForRootContent)this.firstForRootContent=a.firstForRootContent;if(null!=a.firstForVideo)this.firstForVideo=a.firstForVideo;if(null!=a.bufferType)this.bufferType=a.bufferType;if(null!=a.bitrateTransition)this.bitrateTransition=a.bitrateTransition;if(null!=a.bitratesAvailable)this.bitratesAvailable=a.bitratesAvailable;if(null!=a.sharing)this.sharing=a.sharing;if(null!=a.payPerView)this.payPerView=a.payPerView;
      if(null!=a.sasAuthorize)this.sasAuthorize=a.sasAuthorize;if(null!=a.sasAuthorizeV2)this.sasAuthorizeV2=a.sasAuthorizeV2;if(null!=a.autoplay)this.autoplay=a.autoplay;if(null!=a.customEvent)this.customEvent=a.customEvent;if(null!=a.personalizationBucketInfo)this.personalizationBucketInfo=a.personalizationBucketInfo;if(null!=a.reportingIdIndexToPlayheadPositionMillis)this.reportingIdIndexToPlayheadPositionMillis=a.reportingIdIndexToPlayheadPositionMillis;if(null!=a.playthroughPercent)this.playthroughPercent=
        a.playthroughPercent;if(null!=a.seqnum)this.seqnum=a.seqnum}};Ooyala.Logging.PlayerEvent.prototype={};
  Ooyala.Logging.PlayerEvent.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.reportingIdIndex=b.value}else a.skip(c);break;case 11:if(c==Ooyala.Thrift.Type.LIST){c=0;this.reportingIdIndices=[];b=a.readListBegin();c=b.size;for(var d=0;d<c;++d){b=null;b=a.readByte();b=b.value;this.reportingIdIndices.push(b)}a.readListEnd()}else a.skip(c);break;case 2:if(c==
    Ooyala.Thrift.Type.BYTE){b=a.readByte();this.eventType=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.param1=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.param2=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.STRUCT){this.download=new Ooyala.Logging.DownloadStats;this.download.read(a)}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.STRUCT){this.chunkFailover=new Ooyala.Logging.ChunkFailoverInfo;
    this.chunkFailover.read(a)}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.STRUCT){this.playhead=new Ooyala.Logging.PlayheadStatus;this.playhead.read(a)}else a.skip(c);break;case 9:if(c==Ooyala.Thrift.Type.STRUCT){this.cvinfo=new Ooyala.Logging.CvObjectClickInfo;this.cvinfo.read(a)}else a.skip(c);break;case 10:if(c==Ooyala.Thrift.Type.STRUCT){this.DEPRECATED_adClick=new Ooyala.AdsLogging.AdClick;this.DEPRECATED_adClick.read(a)}else a.skip(c);break;case 12:if(c==Ooyala.Thrift.Type.STRUCT){this.buckets=
    new Ooyala.Logging.WatchedBuckets;this.buckets.read(a)}else a.skip(c);break;case 13:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.timePlayed=b.value}else a.skip(c);break;case 14:if(c==Ooyala.Thrift.Type.STRUCT){this.bitratePlayed=new Ooyala.Logging.BitratePlayed;this.bitratePlayed.read(a)}else a.skip(c);break;case 15:if(c==Ooyala.Thrift.Type.STRUCT){this.adTracking=new Ooyala.AdsLogging.AdTracking;this.adTracking.read(a)}else a.skip(c);break;case 16:if(c==Ooyala.Thrift.Type.STRUCT){this.metric=
    new Ooyala.MetricsLogging.Metric;this.metric.read(a)}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.lastEventTime=b.value}else a.skip(c);break;case 17:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.firstForPlayer=b.value}else a.skip(c);break;case 18:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.firstForRootContent=b.value}else a.skip(c);break;case 19:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.firstForVideo=b.value}else a.skip(c);break;case 20:if(c==Ooyala.Thrift.Type.BYTE){b=
    a.readByte();this.bufferType=b.value}else a.skip(c);break;case 21:if(c==Ooyala.Thrift.Type.STRUCT){this.bitrateTransition=new Ooyala.Logging.BitrateTransition;this.bitrateTransition.read(a)}else a.skip(c);break;case 22:if(c==Ooyala.Thrift.Type.LIST){c=0;this.bitratesAvailable=[];b=a.readListBegin();c=b.size;for(d=0;d<c;++d){b=null;b=a.readI16();b=b.value;this.bitratesAvailable.push(b)}a.readListEnd()}else a.skip(c);break;case 23:if(c==Ooyala.Thrift.Type.STRUCT){this.sharing=new Ooyala.Logging.Sharing;
    this.sharing.read(a)}else a.skip(c);break;case 24:if(c==Ooyala.Thrift.Type.STRUCT){this.payPerView=new Ooyala.Logging.PayPerView;this.payPerView.read(a)}else a.skip(c);break;case 25:if(c==Ooyala.Thrift.Type.STRUCT){this.sasAuthorize=new Ooyala.Logging.SasAuthorize;this.sasAuthorize.read(a)}else a.skip(c);break;case 26:if(c==Ooyala.Thrift.Type.STRUCT){this.sasAuthorizeV2=new Ooyala.Logging.SasAuthorizeV2;this.sasAuthorizeV2.read(a)}else a.skip(c);break;case 28:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();
    this.autoplay=b.value}else a.skip(c);break;case 29:if(c==Ooyala.Thrift.Type.STRUCT){this.customEvent=new Ooyala.CustomEventsLogging.CustomEvent;this.customEvent.read(a)}else a.skip(c);break;case 30:if(c==Ooyala.Thrift.Type.STRUCT){this.personalizationBucketInfo=new Ooyala.Logging.PersonalizationBucketInfo;this.personalizationBucketInfo.read(a)}else a.skip(c);break;case 31:if(c==Ooyala.Thrift.Type.MAP){c=0;this.reportingIdIndexToPlayheadPositionMillis={};b=a.readMapBegin();c=b.size;for(d=0;d<c;++d){val43=
    key42=0;b=a.readByte();key42=b.value;b=a.readI32();val43=b.value;this.reportingIdIndexToPlayheadPositionMillis[key42]=val43}a.readMapEnd()}else a.skip(c);break;case 32:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.playthroughPercent=b.value}else a.skip(c);break;case 33:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.seqnum=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.PlayerEvent.prototype.write=function(a){a.writeStructBegin("PlayerEvent");if(null!=this.reportingIdIndex){a.writeFieldBegin("reportingIdIndex",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.reportingIdIndex);a.writeFieldEnd()}if(null!=this.reportingIdIndices){a.writeFieldBegin("reportingIdIndices",Ooyala.Thrift.Type.LIST,11);a.writeListBegin(Ooyala.Thrift.Type.BYTE,this.reportingIdIndices.length);for(var b=0;b<this.reportingIdIndices.length;b++)a.writeByte(this.reportingIdIndices[b]);
    a.writeListEnd();a.writeFieldEnd()}if(null!=this.eventType){a.writeFieldBegin("eventType",Ooyala.Thrift.Type.BYTE,2);a.writeByte(this.eventType);a.writeFieldEnd()}if(null!=this.param1){a.writeFieldBegin("param1",Ooyala.Thrift.Type.STRING,3);a.writeString(this.param1);a.writeFieldEnd()}if(null!=this.param2){a.writeFieldBegin("param2",Ooyala.Thrift.Type.STRING,4);a.writeString(this.param2);a.writeFieldEnd()}if(null!=this.download){a.writeFieldBegin("download",Ooyala.Thrift.Type.STRUCT,5);this.download.write(a);
    a.writeFieldEnd()}if(null!=this.chunkFailover){a.writeFieldBegin("chunkFailover",Ooyala.Thrift.Type.STRUCT,7);this.chunkFailover.write(a);a.writeFieldEnd()}if(null!=this.playhead){a.writeFieldBegin("playhead",Ooyala.Thrift.Type.STRUCT,8);this.playhead.write(a);a.writeFieldEnd()}if(null!=this.cvinfo){a.writeFieldBegin("cvinfo",Ooyala.Thrift.Type.STRUCT,9);this.cvinfo.write(a);a.writeFieldEnd()}if(null!=this.DEPRECATED_adClick){a.writeFieldBegin("DEPRECATED_adClick",Ooyala.Thrift.Type.STRUCT,10);this.DEPRECATED_adClick.write(a);
    a.writeFieldEnd()}if(null!=this.buckets){a.writeFieldBegin("buckets",Ooyala.Thrift.Type.STRUCT,12);this.buckets.write(a);a.writeFieldEnd()}if(null!=this.timePlayed){a.writeFieldBegin("timePlayed",Ooyala.Thrift.Type.I32,13);a.writeI32(this.timePlayed);a.writeFieldEnd()}if(null!=this.bitratePlayed){a.writeFieldBegin("bitratePlayed",Ooyala.Thrift.Type.STRUCT,14);this.bitratePlayed.write(a);a.writeFieldEnd()}if(null!=this.adTracking){a.writeFieldBegin("adTracking",Ooyala.Thrift.Type.STRUCT,15);this.adTracking.write(a);
    a.writeFieldEnd()}if(null!=this.metric){a.writeFieldBegin("metric",Ooyala.Thrift.Type.STRUCT,16);this.metric.write(a);a.writeFieldEnd()}if(null!=this.lastEventTime){a.writeFieldBegin("lastEventTime",Ooyala.Thrift.Type.I32,6);a.writeI32(this.lastEventTime);a.writeFieldEnd()}if(null!=this.firstForPlayer){a.writeFieldBegin("firstForPlayer",Ooyala.Thrift.Type.BOOL,17);a.writeBool(this.firstForPlayer);a.writeFieldEnd()}if(null!=this.firstForRootContent){a.writeFieldBegin("firstForRootContent",Ooyala.Thrift.Type.BOOL,
    18);a.writeBool(this.firstForRootContent);a.writeFieldEnd()}if(null!=this.firstForVideo){a.writeFieldBegin("firstForVideo",Ooyala.Thrift.Type.BOOL,19);a.writeBool(this.firstForVideo);a.writeFieldEnd()}if(null!=this.bufferType){a.writeFieldBegin("bufferType",Ooyala.Thrift.Type.BYTE,20);a.writeByte(this.bufferType);a.writeFieldEnd()}if(null!=this.bitrateTransition){a.writeFieldBegin("bitrateTransition",Ooyala.Thrift.Type.STRUCT,21);this.bitrateTransition.write(a);a.writeFieldEnd()}if(null!=this.bitratesAvailable){a.writeFieldBegin("bitratesAvailable",
    Ooyala.Thrift.Type.LIST,22);a.writeListBegin(Ooyala.Thrift.Type.I16,this.bitratesAvailable.length);for(b=0;b<this.bitratesAvailable.length;b++)a.writeI16(this.bitratesAvailable[b]);a.writeListEnd();a.writeFieldEnd()}if(null!=this.sharing){a.writeFieldBegin("sharing",Ooyala.Thrift.Type.STRUCT,23);this.sharing.write(a);a.writeFieldEnd()}if(null!=this.payPerView){a.writeFieldBegin("payPerView",Ooyala.Thrift.Type.STRUCT,24);this.payPerView.write(a);a.writeFieldEnd()}if(null!=this.sasAuthorize){a.writeFieldBegin("sasAuthorize",
    Ooyala.Thrift.Type.STRUCT,25);this.sasAuthorize.write(a);a.writeFieldEnd()}if(null!=this.sasAuthorizeV2){a.writeFieldBegin("sasAuthorizeV2",Ooyala.Thrift.Type.STRUCT,26);this.sasAuthorizeV2.write(a);a.writeFieldEnd()}if(null!=this.autoplay){a.writeFieldBegin("autoplay",Ooyala.Thrift.Type.BOOL,28);a.writeBool(this.autoplay);a.writeFieldEnd()}if(null!=this.customEvent){a.writeFieldBegin("customEvent",Ooyala.Thrift.Type.STRUCT,29);this.customEvent.write(a);a.writeFieldEnd()}if(null!=this.personalizationBucketInfo){a.writeFieldBegin("personalizationBucketInfo",
    Ooyala.Thrift.Type.STRUCT,30);this.personalizationBucketInfo.write(a);a.writeFieldEnd()}if(null!=this.reportingIdIndexToPlayheadPositionMillis){a.writeFieldBegin("reportingIdIndexToPlayheadPositionMillis",Ooyala.Thrift.Type.MAP,31);b=0;for(key in this.reportingIdIndexToPlayheadPositionMillis)this.reportingIdIndexToPlayheadPositionMillis.hasOwnProperty(key)&&b++;a.writeMapBegin(Ooyala.Thrift.Type.BYTE,Ooyala.Thrift.Type.I32,b);for(var c in this.reportingIdIndexToPlayheadPositionMillis){b=this.reportingIdIndexToPlayheadPositionMillis[c];
    a.writeByte(c);a.writeI32(b)}a.writeMapEnd();a.writeFieldEnd()}if(null!=this.playthroughPercent){a.writeFieldBegin("playthroughPercent",Ooyala.Thrift.Type.I32,32);a.writeI32(this.playthroughPercent);a.writeFieldEnd()}if(null!=this.seqnum){a.writeFieldBegin("seqnum",Ooyala.Thrift.Type.I32,33);a.writeI32(this.seqnum);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.User=function(a){this.city=this.county=this.region=this.country="";this.lon=this.lat=0;this.clientIP="";this.source=this.pmsaCode=this.dmaCode=0;this.cookie="";if(a!=null){if(null!=a.country)this.country=a.country;if(null!=a.region)this.region=a.region;if(null!=a.county)this.county=a.county;if(null!=a.city)this.city=a.city;if(null!=a.lat)this.lat=a.lat;if(null!=a.lon)this.lon=a.lon;if(null!=a.clientIP)this.clientIP=a.clientIP;if(null!=a.dmaCode)this.dmaCode=a.dmaCode;if(null!=a.pmsaCode)this.pmsaCode=
    a.pmsaCode;if(null!=a.source)this.source=a.source;if(null!=a.cookie)this.cookie=a.cookie}};Ooyala.Logging.User.prototype={};
  Ooyala.Logging.User.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.country=b.value}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.region=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.county=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.STRING){b=
    a.readString();this.city=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.lat=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.lon=b.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.clientIP=b.value}else a.skip(c);break;case 9:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.dmaCode=b.value}else a.skip(c);break;case 10:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.pmsaCode=b.value}else a.skip(c);
    break;case 11:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.source=b.value}else a.skip(c);break;case 12:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.cookie=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.User.prototype.write=function(a){a.writeStructBegin("User");if(null!=this.country){a.writeFieldBegin("country",Ooyala.Thrift.Type.STRING,1);a.writeString(this.country);a.writeFieldEnd()}if(null!=this.region){a.writeFieldBegin("region",Ooyala.Thrift.Type.STRING,2);a.writeString(this.region);a.writeFieldEnd()}if(null!=this.county){a.writeFieldBegin("county",Ooyala.Thrift.Type.STRING,3);a.writeString(this.county);a.writeFieldEnd()}if(null!=this.city){a.writeFieldBegin("city",Ooyala.Thrift.Type.STRING,
    4);a.writeString(this.city);a.writeFieldEnd()}if(null!=this.lat){a.writeFieldBegin("lat",Ooyala.Thrift.Type.I32,6);a.writeI32(this.lat);a.writeFieldEnd()}if(null!=this.lon){a.writeFieldBegin("lon",Ooyala.Thrift.Type.I32,7);a.writeI32(this.lon);a.writeFieldEnd()}if(null!=this.clientIP){a.writeFieldBegin("clientIP",Ooyala.Thrift.Type.STRING,8);a.writeString(this.clientIP);a.writeFieldEnd()}if(null!=this.dmaCode){a.writeFieldBegin("dmaCode",Ooyala.Thrift.Type.I16,9);a.writeI16(this.dmaCode);a.writeFieldEnd()}if(null!=
    this.pmsaCode){a.writeFieldBegin("pmsaCode",Ooyala.Thrift.Type.I16,10);a.writeI16(this.pmsaCode);a.writeFieldEnd()}if(null!=this.source){a.writeFieldBegin("source",Ooyala.Thrift.Type.BYTE,11);a.writeByte(this.source);a.writeFieldEnd()}if(null!=this.cookie){a.writeFieldBegin("cookie",Ooyala.Thrift.Type.STRING,12);a.writeString(this.cookie);a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};
  Ooyala.Logging.PlayerLogEntry=function(a){this.version=1;this.user=new Ooyala.Logging.User;this.logTime=0;this.logServer=this.userAgent=this.ipaddr="";this.userTimezone=this.userTime=0;this.documentUrl=this.country=this.guid="";this.authenticationTime=0;this.reportingIds=[];this.reportingIdDescriptors=[];this.tags=[];this.timezoneIds=[];this.clientStat="";this.events=[];this.adSpots=[];this.flashCookieAge=this.playerEmbedType=this.rootContentReportingIdIndex=this.providerReportingIdIndex=0;this.isUntrustedDocUrl=
    false;this.bucketInfo="";this.customEvents=[];this.accountId="";this.variationIds=[];this.playerBrandingId="";this.userTimeMillis=this.logTimeMillis=this.randomSessionSeed=this.sessionStartTimeMillis=0;if(a!=null){if(null!=a.version)this.version=a.version;if(null!=a.user)this.user=a.user;if(null!=a.logTime)this.logTime=a.logTime;if(null!=a.ipaddr)this.ipaddr=a.ipaddr;if(null!=a.userAgent)this.userAgent=a.userAgent;if(null!=a.logServer)this.logServer=a.logServer;if(null!=a.userTime)this.userTime=a.userTime;
    if(null!=a.userTimezone)this.userTimezone=a.userTimezone;if(null!=a.guid)this.guid=a.guid;if(null!=a.country)this.country=a.country;if(null!=a.documentUrl)this.documentUrl=a.documentUrl;if(null!=a.authenticationTime)this.authenticationTime=a.authenticationTime;if(null!=a.reportingIds)this.reportingIds=a.reportingIds;if(null!=a.reportingIdDescriptors)this.reportingIdDescriptors=a.reportingIdDescriptors;if(null!=a.tags)this.tags=a.tags;if(null!=a.timezoneIds)this.timezoneIds=a.timezoneIds;if(null!=
      a.clientStat)this.clientStat=a.clientStat;if(null!=a.events)this.events=a.events;if(null!=a.adSpots)this.adSpots=a.adSpots;if(null!=a.providerReportingIdIndex)this.providerReportingIdIndex=a.providerReportingIdIndex;if(null!=a.rootContentReportingIdIndex)this.rootContentReportingIdIndex=a.rootContentReportingIdIndex;if(null!=a.playerEmbedType)this.playerEmbedType=a.playerEmbedType;if(null!=a.flashCookieAge)this.flashCookieAge=a.flashCookieAge;if(null!=a.isUntrustedDocUrl)this.isUntrustedDocUrl=a.isUntrustedDocUrl;
    if(null!=a.bucketInfo)this.bucketInfo=a.bucketInfo;if(null!=a.customEvents)this.customEvents=a.customEvents;if(null!=a.accountId)this.accountId=a.accountId;if(null!=a.variationIds)this.variationIds=a.variationIds;if(null!=a.playerBrandingId)this.playerBrandingId=a.playerBrandingId;if(null!=a.sessionStartTimeMillis)this.sessionStartTimeMillis=a.sessionStartTimeMillis;if(null!=a.randomSessionSeed)this.randomSessionSeed=a.randomSessionSeed;if(null!=a.logTimeMillis)this.logTimeMillis=a.logTimeMillis;
    if(null!=a.userTimeMillis)this.userTimeMillis=a.userTimeMillis}};Ooyala.Logging.PlayerLogEntry.prototype={};
  Ooyala.Logging.PlayerLogEntry.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.version=b.value}else a.skip(c);break;case 21:if(c==Ooyala.Thrift.Type.STRUCT){this.user=new Ooyala.Logging.User;this.user.read(a)}else a.skip(c);break;case 2:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.logTime=b.value}else a.skip(c);break;case 3:if(c==Ooyala.Thrift.Type.STRING){b=
    a.readString();this.ipaddr=b.value}else a.skip(c);break;case 16:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.userAgent=b.value}else a.skip(c);break;case 22:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.logServer=b.value}else a.skip(c);break;case 8:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.userTime=b.value}else a.skip(c);break;case 9:if(c==Ooyala.Thrift.Type.I16){b=a.readI16();this.userTimezone=b.value}else a.skip(c);break;case 4:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();
    this.guid=b.value}else a.skip(c);break;case 5:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.country=b.value}else a.skip(c);break;case 6:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.documentUrl=b.value}else a.skip(c);break;case 7:if(c==Ooyala.Thrift.Type.I32){b=a.readI32();this.authenticationTime=b.value}else a.skip(c);break;case 10:if(c==Ooyala.Thrift.Type.LIST){c=0;this.reportingIds=[];b=a.readListBegin();c=b.size;for(var d=0;d<c;++d){b=null;b=a.readString();b=b.value;this.reportingIds.push(b)}a.readListEnd()}else a.skip(c);
    break;case 20:if(c==Ooyala.Thrift.Type.LIST){b=0;this.reportingIdDescriptors=[];b=a.readListBegin();b=b.size;for(c=0;c<b;++c){d=null;d=new Ooyala.Logging.ReportingIdDescriptor;d.read(a);this.reportingIdDescriptors.push(d)}a.readListEnd()}else a.skip(c);break;case 24:if(c==Ooyala.Thrift.Type.LIST){c=0;this.tags=[];b=a.readListBegin();c=b.size;for(d=0;d<c;++d){b=null;b=a.readString();b=b.value;this.tags.push(b)}a.readListEnd()}else a.skip(c);break;case 12:if(c==Ooyala.Thrift.Type.LIST){c=0;this.timezoneIds=
    [];b=a.readListBegin();c=b.size;for(d=0;d<c;++d){b=null;b=a.readI32();b=b.value;this.timezoneIds.push(b)}a.readListEnd()}else a.skip(c);break;case 13:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.clientStat=b.value}else a.skip(c);break;case 11:if(c==Ooyala.Thrift.Type.LIST){b=0;this.events=[];b=a.readListBegin();b=b.size;for(c=0;c<b;++c){d=null;d=new Ooyala.Logging.PlayerEvent;d.read(a);this.events.push(d)}a.readListEnd()}else a.skip(c);break;case 14:if(c==Ooyala.Thrift.Type.LIST){b=0;this.adSpots=
    [];b=a.readListBegin();b=b.size;for(c=0;c<b;++c){d=null;d=new Ooyala.AdsLogging.AdSpot;d.read(a);this.adSpots.push(d)}a.readListEnd()}else a.skip(c);break;case 17:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.providerReportingIdIndex=b.value}else a.skip(c);break;case 18:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.rootContentReportingIdIndex=b.value}else a.skip(c);break;case 15:if(c==Ooyala.Thrift.Type.BYTE){b=a.readByte();this.playerEmbedType=b.value}else a.skip(c);break;case 19:if(c==
    Ooyala.Thrift.Type.I32){b=a.readI32();this.flashCookieAge=b.value}else a.skip(c);break;case 23:if(c==Ooyala.Thrift.Type.BOOL){b=a.readBool();this.isUntrustedDocUrl=b.value}else a.skip(c);break;case 25:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.bucketInfo=b.value}else a.skip(c);break;case 26:if(c==Ooyala.Thrift.Type.LIST){b=0;this.customEvents=[];b=a.readListBegin();b=b.size;for(c=0;c<b;++c){d=null;d=new Ooyala.CustomEventsLogging.CustomEvent;d.read(a);this.customEvents.push(d)}a.readListEnd()}else a.skip(c);
    break;case 27:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.accountId=b.value}else a.skip(c);break;case 28:if(c==Ooyala.Thrift.Type.LIST){c=0;this.variationIds=[];b=a.readListBegin();c=b.size;for(d=0;d<c;++d){b=null;b=a.readI32();b=b.value;this.variationIds.push(b)}a.readListEnd()}else a.skip(c);break;case 29:if(c==Ooyala.Thrift.Type.STRING){b=a.readString();this.playerBrandingId=b.value}else a.skip(c);break;case 30:if(c==Ooyala.Thrift.Type.I64){b=a.readI64();this.sessionStartTimeMillis=
    b.value}else a.skip(c);break;case 31:if(c==Ooyala.Thrift.Type.I64){b=a.readI64();this.randomSessionSeed=b.value}else a.skip(c);break;case 32:if(c==Ooyala.Thrift.Type.I64){b=a.readI64();this.logTimeMillis=b.value}else a.skip(c);break;case 33:if(c==Ooyala.Thrift.Type.I64){b=a.readI64();this.userTimeMillis=b.value}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.PlayerLogEntry.prototype.write=function(a){a.writeStructBegin("PlayerLogEntry");if(null!=this.version){a.writeFieldBegin("version",Ooyala.Thrift.Type.BYTE,1);a.writeByte(this.version);a.writeFieldEnd()}if(null!=this.user){a.writeFieldBegin("user",Ooyala.Thrift.Type.STRUCT,21);this.user.write(a);a.writeFieldEnd()}if(null!=this.logTime){a.writeFieldBegin("logTime",Ooyala.Thrift.Type.I32,2);a.writeI32(this.logTime);a.writeFieldEnd()}if(null!=this.ipaddr){a.writeFieldBegin("ipaddr",Ooyala.Thrift.Type.STRING,
    3);a.writeString(this.ipaddr);a.writeFieldEnd()}if(null!=this.userAgent){a.writeFieldBegin("userAgent",Ooyala.Thrift.Type.STRING,16);a.writeString(this.userAgent);a.writeFieldEnd()}if(null!=this.logServer){a.writeFieldBegin("logServer",Ooyala.Thrift.Type.STRING,22);a.writeString(this.logServer);a.writeFieldEnd()}if(null!=this.userTime){a.writeFieldBegin("userTime",Ooyala.Thrift.Type.I32,8);a.writeI32(this.userTime);a.writeFieldEnd()}if(null!=this.userTimezone){a.writeFieldBegin("userTimezone",Ooyala.Thrift.Type.I16,
    9);a.writeI16(this.userTimezone);a.writeFieldEnd()}if(null!=this.guid){a.writeFieldBegin("guid",Ooyala.Thrift.Type.STRING,4);a.writeString(this.guid);a.writeFieldEnd()}if(null!=this.country){a.writeFieldBegin("country",Ooyala.Thrift.Type.STRING,5);a.writeString(this.country);a.writeFieldEnd()}if(null!=this.documentUrl){a.writeFieldBegin("documentUrl",Ooyala.Thrift.Type.STRING,6);a.writeString(this.documentUrl);a.writeFieldEnd()}if(null!=this.authenticationTime){a.writeFieldBegin("authenticationTime",
    Ooyala.Thrift.Type.I32,7);a.writeI32(this.authenticationTime);a.writeFieldEnd()}if(null!=this.reportingIds){a.writeFieldBegin("reportingIds",Ooyala.Thrift.Type.LIST,10);a.writeListBegin(Ooyala.Thrift.Type.STRING,this.reportingIds.length);for(var b=0;b<this.reportingIds.length;b++)a.writeString(this.reportingIds[b]);a.writeListEnd();a.writeFieldEnd()}if(null!=this.reportingIdDescriptors){a.writeFieldBegin("reportingIdDescriptors",Ooyala.Thrift.Type.LIST,20);a.writeListBegin(Ooyala.Thrift.Type.STRUCT,
    this.reportingIdDescriptors.length);for(b=0;b<this.reportingIdDescriptors.length;b++)this.reportingIdDescriptors[b].write(a);a.writeListEnd();a.writeFieldEnd()}if(null!=this.tags){a.writeFieldBegin("tags",Ooyala.Thrift.Type.LIST,24);a.writeListBegin(Ooyala.Thrift.Type.STRING,this.tags.length);for(b=0;b<this.tags.length;b++)a.writeString(this.tags[b]);a.writeListEnd();a.writeFieldEnd()}if(null!=this.timezoneIds){a.writeFieldBegin("timezoneIds",Ooyala.Thrift.Type.LIST,12);a.writeListBegin(Ooyala.Thrift.Type.I32,
    this.timezoneIds.length);for(b=0;b<this.timezoneIds.length;b++)a.writeI32(this.timezoneIds[b]);a.writeListEnd();a.writeFieldEnd()}if(null!=this.clientStat){a.writeFieldBegin("clientStat",Ooyala.Thrift.Type.STRING,13);a.writeString(this.clientStat);a.writeFieldEnd()}if(null!=this.events){a.writeFieldBegin("events",Ooyala.Thrift.Type.LIST,11);a.writeListBegin(Ooyala.Thrift.Type.STRUCT,this.events.length);for(b=0;b<this.events.length;b++)this.events[b].write(a);a.writeListEnd();a.writeFieldEnd()}if(null!=
    this.adSpots){a.writeFieldBegin("adSpots",Ooyala.Thrift.Type.LIST,14);a.writeListBegin(Ooyala.Thrift.Type.STRUCT,this.adSpots.length);for(b=0;b<this.adSpots.length;b++)this.adSpots[b].write(a);a.writeListEnd();a.writeFieldEnd()}if(null!=this.providerReportingIdIndex){a.writeFieldBegin("providerReportingIdIndex",Ooyala.Thrift.Type.BYTE,17);a.writeByte(this.providerReportingIdIndex);a.writeFieldEnd()}if(null!=this.rootContentReportingIdIndex){a.writeFieldBegin("rootContentReportingIdIndex",Ooyala.Thrift.Type.BYTE,
    18);a.writeByte(this.rootContentReportingIdIndex);a.writeFieldEnd()}if(null!=this.playerEmbedType){a.writeFieldBegin("playerEmbedType",Ooyala.Thrift.Type.BYTE,15);a.writeByte(this.playerEmbedType);a.writeFieldEnd()}if(null!=this.flashCookieAge){a.writeFieldBegin("flashCookieAge",Ooyala.Thrift.Type.I32,19);a.writeI32(this.flashCookieAge);a.writeFieldEnd()}if(null!=this.isUntrustedDocUrl){a.writeFieldBegin("isUntrustedDocUrl",Ooyala.Thrift.Type.BOOL,23);a.writeBool(this.isUntrustedDocUrl);a.writeFieldEnd()}if(null!=
    this.bucketInfo){a.writeFieldBegin("bucketInfo",Ooyala.Thrift.Type.STRING,25);a.writeString(this.bucketInfo);a.writeFieldEnd()}if(null!=this.customEvents){a.writeFieldBegin("customEvents",Ooyala.Thrift.Type.LIST,26);a.writeListBegin(Ooyala.Thrift.Type.STRUCT,this.customEvents.length);for(b=0;b<this.customEvents.length;b++)this.customEvents[b].write(a);a.writeListEnd();a.writeFieldEnd()}if(null!=this.accountId){a.writeFieldBegin("accountId",Ooyala.Thrift.Type.STRING,27);a.writeString(this.accountId);
    a.writeFieldEnd()}if(null!=this.variationIds){a.writeFieldBegin("variationIds",Ooyala.Thrift.Type.LIST,28);a.writeListBegin(Ooyala.Thrift.Type.I32,this.variationIds.length);for(b=0;b<this.variationIds.length;b++)a.writeI32(this.variationIds[b]);a.writeListEnd();a.writeFieldEnd()}if(null!=this.playerBrandingId){a.writeFieldBegin("playerBrandingId",Ooyala.Thrift.Type.STRING,29);a.writeString(this.playerBrandingId);a.writeFieldEnd()}if(null!=this.sessionStartTimeMillis){a.writeFieldBegin("sessionStartTimeMillis",
    Ooyala.Thrift.Type.I64,30);a.writeI64(this.sessionStartTimeMillis);a.writeFieldEnd()}if(null!=this.randomSessionSeed){a.writeFieldBegin("randomSessionSeed",Ooyala.Thrift.Type.I64,31);a.writeI64(this.randomSessionSeed);a.writeFieldEnd()}if(null!=this.logTimeMillis){a.writeFieldBegin("logTimeMillis",Ooyala.Thrift.Type.I64,32);a.writeI64(this.logTimeMillis);a.writeFieldEnd()}if(null!=this.userTimeMillis){a.writeFieldBegin("userTimeMillis",Ooyala.Thrift.Type.I64,33);a.writeI64(this.userTimeMillis);a.writeFieldEnd()}a.writeFieldStop();
    a.writeStructEnd()};if(typeof Ooyala==="undefined")Ooyala={};if(typeof Ooyala.Logging==="undefined")Ooyala.Logging={};Ooyala.Logging.Session=function(a){this.log_entries=[];if(a!=null)if(null!=a.log_entries)this.log_entries=a.log_entries};Ooyala.Logging.Session.prototype={};
  Ooyala.Logging.Session.prototype.read=function(a){for(var b=a.readStructBegin();;){b=a.readFieldBegin();var c=b.ftype;if(c==Ooyala.Thrift.Type.STOP)break;switch(b.fid){case 1:if(c==Ooyala.Thrift.Type.LIST){b=0;this.log_entries=[];b=a.readListBegin().size;for(c=0;c<b;++c){var d=null;d=new Ooyala.Logging.PlayerLogEntry;d.read(a);this.log_entries.push(d)}a.readListEnd()}else a.skip(c);break;default:a.skip(c)}a.readFieldEnd()}a.readStructEnd()};
  Ooyala.Logging.Session.prototype.write=function(a){a.writeStructBegin("Session");if(null!=this.log_entries){a.writeFieldBegin("log_entries",Ooyala.Thrift.Type.LIST,1);a.writeListBegin(Ooyala.Thrift.Type.STRUCT,this.log_entries.length);for(var b=0;b<this.log_entries.length;b++)this.log_entries[b].write(a);a.writeListEnd();a.writeFieldEnd()}a.writeFieldStop();a.writeStructEnd()};/*
   http://www.gnu.org/licenses/gpl.html [GNU General Public License]
   @param {jQuery} {sha1:function(string))
   @return string
   */
  Ooyala.Util.createNamespace("Ooyala.ThirdParty.CRC32");
  (function(){Ooyala.ThirdParty.CRC32.computeCrc=function(a){var b=a;a=void 0;b=b;b=b.replace(/\x0d\x0a/g,"\n");for(var c="",d=0;d<b.length;d++){var e=b.charCodeAt(d);if(e<128)c+=String.fromCharCode(e);else{if(e>127&&e<2048)c+=String.fromCharCode(e>>6|192);else{c+=String.fromCharCode(e>>12|224);c+=String.fromCharCode(e>>6&63|128)}c+=String.fromCharCode(e&63|128)}}b=c;if(typeof a=="undefined")a=0;e=e=0;a^=-1;c=0;for(d=b.length;c<d;c++){e=(a^b.charCodeAt(c))&255;e="0x"+"00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F 63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC 51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E 7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D 806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA 11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D".substr(e*
      9,8);a=a>>>8^e}a=a^-1;return(a>>>1)*2+(a&1)}})();Ooyala.Util.createNamespace("Ooyala.ThirdParty.SHA256");
  (function(){function a(f,h){var i=(f&65535)+(h&65535);return(f>>16)+(h>>16)+(i>>16)<<16|i&65535}function b(f,h){return f>>>h|f<<32-h}function c(f,h){var i=Array(1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,
    666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298),g=Array(1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225),j=Array(64),l,n,o,r,m,p,q,s,t,k,u,v;f[h>>5]|=128<<24-h%32;f[(h+
  64>>9<<4)+15]=h;for(t=0;t<f.length;t+=16){l=g[0];n=g[1];o=g[2];r=g[3];m=g[4];p=g[5];q=g[6];s=g[7];for(k=0;k<64;k++){j[k]=k<16?f[k+t]:a(a(a(b(j[k-2],17)^b(j[k-2],19)^j[k-2]>>>10,j[k-7]),b(j[k-15],7)^b(j[k-15],18)^j[k-15]>>>3),j[k-16]);u=a(a(a(a(s,b(m,6)^b(m,11)^b(m,25)),m&p^~m&q),i[k]),j[k]);v=a(b(l,2)^b(l,13)^b(l,22),l&n^l&o^n&o);s=q;q=p;p=m;m=a(r,u);r=o;o=n;n=l;l=a(u,v)}g[0]=a(l,g[0]);g[1]=a(n,g[1]);g[2]=a(o,g[2]);g[3]=a(r,g[3]);g[4]=a(m,g[4]);g[5]=a(p,g[5]);g[6]=a(q,g[6]);g[7]=a(s,g[7])}return g}
    function d(f){for(var h=[],i=(1<<e)-1,g=0;g<f.length*e;g+=e)h[g>>5]|=(f.charCodeAt(g/e)&i)<<24-g%32;return h}var e=8;Ooyala.ThirdParty.SHA256.sha256ToHexString=function(f){f=c(d(f),f.length*e);for(var h="",i=0;i<f.length*4;i++)h+="0123456789abcdef".charAt(f[i>>2]>>(3-i%4)*8+4&15)+"0123456789abcdef".charAt(f[i>>2]>>(3-i%4)*8&15);return h};Ooyala.ThirdParty.SHA256.sha256ToBase64String=function(f){f=c(d(f),f.length*e);for(var h="",i=0;i<f.length*4;i+=3)for(var g=(f[i>>2]>>8*(3-i%4)&255)<<16|(f[i+1>>
      2]>>8*(3-(i+1)%4)&255)<<8|f[i+2>>2]>>8*(3-(i+2)%4)&255,j=0;j<4;j++)h+=i*8+j*6>f.length*32?"":"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(g>>6*(3-j)&63);return h};Ooyala.ThirdParty.SHA256.sha256ToString=function(f){f=c(d(f),f.length*e);for(var h="",i=(1<<e)-1,g=0;g<f.length*32;g+=e)h+=String.fromCharCode(f[g>>5]>>>24-g%32&i);return h}})();Ooyala.Constants={LOGGING_SERVER_DOMAIN:(window.location.protocol=="https:"?"https:":"http:")+"//l.ooyala.com",IFRAME_PINGER_PATH:"/analytics/iframe.html",SAS_URL:(window.location.protocol=="https:"?"https:":"http:")+"//player.ooyala.com/sas/analytics",HIGH_PRIORITY_EVENT:0,LOW_PRIORITY_EVENT:1,HIGH_PRIORITY_EVENT_FLUSH_INTERVAL_MS:1E3,LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS:1E4,MIN_DURATION_FOR_STEP_BACKOFF:24E4};Ooyala.Util.createNamespace("Ooyala.Pinger");Ooyala.Pinger.ALIVE_MESSAGE="&handshake!";Ooyala.Pinger.COOKIE_NAME="gi";Ooyala.Pinger.DAYS_TO_LIVE=7300;Ooyala.Pinger._numCompare=function(){return-1};Ooyala.Pinger.RegisterMessageListener=function(a){window.addEventListener?window.addEventListener("message",a,false):window.attachEvent("onmessage",a)};Ooyala.Pinger.RemoveMessageListener=function(a){window.removeEventListener?window.removeEventListener("message",a):window.detachEvent("onmessage",a)};
  Ooyala.Pinger._createAndSetGuid=function(){var a=(new Date).getTime(),b=window.navigator.userAgent,c=Math.random();c=c>0?c.toString(16).split(".")[1]:"00000000";a=Ooyala.ThirdParty.SHA256.sha256ToBase64String(a+b+c);(new Ooyala.Util.CookieManager(Ooyala.Pinger.COOKIE_NAME,Ooyala.Pinger.DAYS_TO_LIVE,Ooyala.Pinger._numCompare)).set("guid",a);return a};
  Ooyala.Pinger.getOrCreateGuid=function(){var a=(new Ooyala.Util.CookieManager(Ooyala.Pinger.COOKIE_NAME,Ooyala.Pinger.DAYS_TO_LIVE,Ooyala.Pinger._numCompare)).get("guid");if(a==null)a=Ooyala.Pinger._createAndSetGuid();return a};Ooyala.Pinger.Listener=function(a){this._reconstructor=new Ooyala.Pinger.ChunkReconstructor(a)};Ooyala.Pinger.Listener.POLL_INTERVAL=500;
  Ooyala.Pinger.Listener.prototype={_pollAndSend:function(){var a=window.location.hash;if(a.length>1){window.location.hash="";this._reconstructor.push(a.substring(1))}window.setTimeout(Ooyala.Util.bind(this._pollAndSend,this),Ooyala.Pinger.Listener.POLL_INTERVAL)},_messageHandler:function(a){this._reconstructor.push(a.data)},start:function(){if(window.postMessage){try{parent.postMessage(Ooyala.Pinger.ALIVE_MESSAGE+";"+Ooyala.Pinger.getOrCreateGuid(),"*")}catch(a){}Ooyala.Pinger.RegisterMessageListener(Ooyala.Util.bind(this._messageHandler,
    this))}else this._pollAndSend()}};Ooyala.Pinger.ChunkReconstructor=function(a){this._receiver=a;this._reset()};
  Ooyala.Pinger.ChunkReconstructor.prototype={_parseChunk:function(a){var b=a.split("~");if(b.length!=3){window.console&&console.log("Warning - Ooyala iframe is receiving data from non-Ooyala sources. Shouldn't be the case, ignored the data: "+a);return null}a={};a.data=b[0];a.id=parseInt(b[1]);a.count=parseInt(b[2]);if(a.id<=0||a.count<=0||a.id>a.count)throw"Bad chunk ID or total chunk count in ping chunk.";return a},_reset:function(){this._data="";this._totalChunks=this._chunksSeen=0},_handleChunk:function(a){if(this._totalChunks==
    0){if(!(a.id>1))if(a.count==1)this._receiver.sendPing(a.data);else{this._chunksSeen=1;this._totalChunks=a.count;this._data=a.data}}else if(a.count==this._totalChunks&&a.id==this._chunksSeen+1)if(a.count==a.id){a=this._data+a.data;this._reset();this._receiver.sendPing(a)}else{this._chunksSeen+=1;this._data+=a.data}else{this._reset();this._handleChunk(a)}},push:function(a){a=this._parseChunk(a);a!==null&&this._handleChunk(a)}};Ooyala.Pinger.ServerPinger=function(a){this._pingUrl=a};
  Ooyala.Pinger.MAX_XVERIFY_HEADER_LENGTH=7500;Ooyala.Pinger.ServerPinger.prototype={sendPing:function(a){if(a.length>Ooyala.Pinger.MAX_XVERIFY_HEADER_LENGTH)throw"Ping (length = "+a.length+") is too long.";var b=Ooyala.Util.Http.createXMLHttpRequest();b.open("POST",this._pingUrl,true);b.setRequestHeader("X-Verify",a);b.send(null)}};Ooyala.Util.createNamespace("Ooyala.Pinger");Ooyala.Pinger.OuterPinger=function(a){this._pingerIFrameWindow=this._pingerIFrame=null;this._browserCompatible=true;this._onReadyFn=a;this._initializePingerIFrame();this._bufferedChunks=[];this._scheduleFlushInMillis(Ooyala.Pinger.OuterPinger.SEND_INTERVAL_MILLIS)};Ooyala.Pinger.OuterPinger.IFRAME_BASE_URL=Ooyala.Constants.LOGGING_SERVER_DOMAIN+Ooyala.Constants.IFRAME_PINGER_PATH;Ooyala.Pinger.OuterPinger.MAX_MESSAGE_LENGTH=7500;
  Ooyala.Pinger.OuterPinger.MAX_CHUNKS_PER_MESSAGE=2;Ooyala.Pinger.OuterPinger.MAX_CHUNK_LENGTH=Math.ceil(Ooyala.Pinger.OuterPinger.MAX_MESSAGE_LENGTH/Ooyala.Pinger.OuterPinger.MAX_CHUNKS_PER_MESSAGE);Ooyala.Pinger.OuterPinger.SEND_INTERVAL_MILLIS=1E3;
  Ooyala.Pinger.OuterPinger.prototype={sendMessage:function(a){if(window.navigator.userAgent.indexOf("Netgem")!==-1){if(a.length>7500)throw"Ping (length = "+a.length+") is too long.";var b=Ooyala.Util.Http.createXMLHttpRequest();b.open("POST",Ooyala.Constants.LOGGING_SERVER_DOMAIN+"/verify",true);b.setRequestHeader("X-Verify",a);b.send(null)}else if(this._browserCompatible)this._bufferedChunks=this._bufferedChunks.concat(this._convertMessageToChunks(a))},_convertMessageToChunks:function(a){if(a.length<=
    Ooyala.Pinger.OuterPinger.MAX_MESSAGE_LENGTH){for(var b=[],c=Math.ceil(a.length/Ooyala.Pinger.OuterPinger.MAX_CHUNK_LENGTH),d=0;d<c;d++){var e=a.substr(d*Ooyala.Pinger.OuterPinger.MAX_CHUNK_LENGTH,Ooyala.Pinger.OuterPinger.MAX_CHUNK_LENGTH)+"~"+(d+1).toString()+"~"+c.toString();b.push(e)}return b}else throw Error("Message (length = "+a.length+") is too long.");},_flushNextChunk:function(){var a=this._bufferedChunks.length>0?this._bufferedChunks.shift():null;if(a)window.postMessage?this._pingerIFrameWindow.postMessage(a,
    Ooyala.Constants.LOGGING_SERVER_DOMAIN):this._pingerIFrame.setAttribute("src",Ooyala.Pinger.OuterPinger.IFRAME_BASE_URL+"#"+a);this._scheduleFlushInMillis(Ooyala.Pinger.OuterPinger.SEND_INTERVAL_MILLIS)},_scheduleFlushInMillis:function(a){setTimeout(Ooyala.Util.bind(this._flushNextChunk,this),a)},_getUnusedId:function(a){for(var b=0;document.getElementById(a+b.toString());)b+=1;return a+b.toString()},_initializePingerIFrame:function(){var a=this._getUnusedId("OoyalaPingerIFrame");if(window.postMessage){this._pingerIFrame=
    document.createElement("iframe");this._setUpHiddenIFrame(this._pingerIFrame,a);document.body.appendChild(this._pingerIFrame);this._pingerIFrameWindow=window.frames[a];Ooyala.Pinger.RegisterMessageListener(Ooyala.Util.bind(this._handleHandshake,this))}else if(window.navigator.userAgent.indexOf("Netgem")!==-1){document.write("<IFRAME id='"+a+"'></IFRAME>");this._pingerIFrame=document.getElementById(a);this._setUpHiddenIFrame(this._pingerIFrame,a);this._pingerIFrameWindow=null;this._onReadyFn&&this._onReadyFn()}else if(window.ActiveXObject){var b=
    new ActiveXObject("htmlfile");b.open();b.write("<html><body><iframe id='"+a+"' src='"+Ooyala.Pinger.OuterPinger.IFRAME_BASE_URL+"'></iframe></body></html>");b.close();this._pingerIFrame=b.getElementById(a);this._pingerIFrameWindow=null;this._pingerIFrameDocument=b;this._onReadyFn&&this._onReadyFn()}else this._browserCompatible=false},_handleHandshake:function(a){if(!(!a||typeof a.data!="string")){a=a.data.split(";");a.length==2&&a[0]==Ooyala.Pinger.ALIVE_MESSAGE&&this._onReadyFn&&this._onReadyFn(a[1])}},
    _setUpHiddenIFrame:function(a,b){a.setAttribute("name",b);a.setAttribute("id",b);a.setAttribute("src",Ooyala.Pinger.OuterPinger.IFRAME_BASE_URL);a.style.visibility="hidden";a.style["border-style"]="none";a.style.width="1px";a.style.height="1px";a.style.position="absolute";a.style.top="-5px";a.style.left="-5px"}};Ooyala.PlaytimeTracker=function(a,b,c,d){this._lastPlayheadPosition=0;this._totalTimeBetweenPlayheadUpdates=Ooyala.PlaytimeTracker.INITIAL_ESTIMATE_FOR_TIME_BETWEEN_PLAYHEAD_UPDATES;this._numPlayheadUpdateDataPoints=1;this._bucketsWatched=Ooyala.Util.Enumerable.map(Array(Ooyala.PlaytimeTracker.NUM_BUCKETS),function(){return false});this._numBucketsWatched=0;this._updateWasSeek=false;this._lastBucketWatchedIndex=0;this._duration=a;this._reportTimePlayedHandle=b;this._reportBucketWatchedHandle=c;this._reportPercentageWatchedHandle=
    d};Ooyala.PlaytimeTracker.INITIAL_ESTIMATE_FOR_TIME_BETWEEN_PLAYHEAD_UPDATES=250;Ooyala.PlaytimeTracker.MILLIS_BETWEEN_PLAYHEAD_UPDATES_FOR_SEEK=5E3;Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET=25;Ooyala.PlaytimeTracker.NUM_BUCKETS=1E3/Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET;
  Ooyala.PlaytimeTracker.prototype={processPlayheadUpdate:function(a){var b=this._computeTimeDiff(a),c=this._getRangeBucketsWatched(a),d=c[0];c=c[1];this._lastPlayheadPosition=a;b>0&&this._reportTimePlayedHandle(b,a);a=0;for(d=d;d<c;d++){if(!this._bucketsWatched[d]){this._bucketsWatched[d]=true;a++}b=this._bucketToMinMaxPerMille(d);this._reportBucketWatchedHandle.call(undefined,b[0],b[1])}if(a>0){c=this._numBucketsWatched*Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET+1;this._numBucketsWatched+=a;this._reportPercentageWatchedHandle.call(undefined,
    c,this._numBucketsWatched*Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET)}},_computeTimeDiff:function(a){if(a==0){this._updateWasSeek=true;return 0}if(a-this._lastPlayheadPosition>Ooyala.PlaytimeTracker.MILLIS_BETWEEN_PLAYHEAD_UPDATES_FOR_SEEK||a<this._lastPlayheadPosition){this._updateWasSeek=true;return this._estimatedTimeBetweenPlayheadUpdates()}else{a=a-this._lastPlayheadPosition;this._updateEstimatedTimeBetweenPlayheadUpdates(a);this._updateWasSeek=false;return a}},_getRangeBucketsWatched:function(a){var b=
    [0,0];if(a==0)return b;if(this._updateWasSeek){a=this._timeToBucket(a);a==-1&&a++;b=[a,a+1]}else{b=this._timeToBucket(this._lastPlayheadPosition)+1;a=this._timeToBucket(a);b=[b,a+1]}return b},_timeToBucket:function(a){if(a<0)return 0;if(a>=this._duration)return Ooyala.PlaytimeTracker.NUM_BUCKETS-1;return this._perMilleToBucket(parseInt(a/this._duration*1E3))},_perMilleToBucket:function(a){if(a==0)return-1;return parseInt((a-1)/Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET)},_bucketToMinMaxPerMille:function(a){return[a*
  Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET+1,(a+1)*Ooyala.PlaytimeTracker.PER_MILLE_PER_BUCKET]},_estimatedTimeBetweenPlayheadUpdates:function(){return this._totalTimeBetweenPlayheadUpdates/this._numPlayheadUpdateDataPoints},_updateEstimatedTimeBetweenPlayheadUpdates:function(a){this._totalTimeBetweenPlayheadUpdates+=a;this._numPlayheadUpdateDataPoints+=1}};Ooyala.HistoryTracker=function(){this._cookieManager=new Ooyala.Util.CookieManager(Ooyala.HistoryTracker.COOKIE_NAME,Ooyala.HistoryTracker.DAYS_TO_LIVE,Ooyala.HistoryTracker.timestampCompare);this._cookieManager.deDupe()};Ooyala.HistoryTracker.COOKIE_NAME="Ooyala";Ooyala.HistoryTracker.DAYS_TO_LIVE=365;Ooyala.HistoryTracker.timestampCompare=function(a,b){var c=a==null?0:parseFloat(a),d=b==null?0:parseFloat(b);return c-d};
  Ooyala.HistoryTracker.prototype={getAndSetLastEventTime:function(a,b){if(a==null||b==null)return null;var c=a+"|"+b,d=this._cookieManager.get(c);d=d==null?null:parseFloat(d);this._currentTimestamp();this._cookieManager.set(c,this._currentTimestamp());return d},_currentTimestamp:function(){return Math.round((new Date).getTime()/1E3)}};Ooyala.Reporter=function(a,b){if(!a)throw"No Provider Code was provided to the Reporter";this._id=Ooyala.Reporter._next_id.toString();Ooyala.Reporter._next_id+=1;Ooyala.Reporter._map[this._id]=this;this._pCode=a;this._playerLoaded=false;this._resetState(null,null);var c=b&&b.accountId;if(typeof c!=="string")c=null;var d=b&&b.guid;if(typeof d!=="string")d=null;var e=b&&b.documentUrl;if(typeof e!=="string")e=null;var f=b&&b.playerBrandingId;if(typeof f!=="string")f=null;this._logger=new Ooyala.ThriftLogger(this._pCode,
    c,d,e,f);this._historyTracker=new Ooyala.HistoryTracker;this._logger.wait("SAS_Response");this._requestSasInformation();this._logger.logPlayerEvents(this._createEventWithLastEventTime(Ooyala.Logging.PlayerEventType.PLAYER_LOAD,[Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX,Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX]));this._playerLoaded=true;this._adSpot=new Ooyala.AdsLogging.AdSpot;this._adInfo={};(c=b&&b.tags)&&this.setTags(c);this._nextPlaythroughToReport=this._playthroughReportFrequency=
    25};Ooyala.Reporter._next_id=0;Ooyala.Reporter._map={};
  Ooyala.Reporter._NULL_PLAYER_EVENT_FIELDS=["bitratePlayed","download","chunkFailover","playhead","cvinfo","DEPRECATED_adClick","buckets","adTracking","metric","bitrateTransition","sharing","payPerView","sasAuthorize","sasAuthorizeV2","personalizationBucketInfo","customEvent","reportingIdIndex","lastEventTime","timePlayed","firstForPlayer","param1","param2","firstForRootContent","firstForVideo","bufferType","bitratesAvailable","reportingIdIndexToPlayheadPositionMillis","autoplay","playthroughPercent",
    "seqnum"];Ooyala.Reporter.AdSource={OOYALA:1,DOUBLECLICK:2,LIGHTNINGCAST:3,YUME:4,TREMOR:5,ADSENSE:6,TV2N:7,OAS:8,ADTECH:9,SCANSCOUT:10,ATLAS:11,FREEWHEEL:12,OPENX:13,LIVERAIL:14,VAST:15,ADIFY:16,DART_ENTERPRISE:17,CBSI:18,BRIGHTROLL:19,UNKNOWN:20,ADAPTV:21,VIDEOPLAZA:22,SPOTXCHANGE:23};Ooyala.Reporter.AdPositionType={PREROLL:1,MIDROLL:2,POSTROLL:3,OVERLAY:4,ENDSLATE:5,STANDALONE:6};Ooyala.Reporter.AdFormat={VIDEO:1,OVERLAY:2,ENDCAP:3,COMPANION:4};
  Ooyala.Reporter.AdFailureReason={LOAD_ERROR:1,LOAD_TIMEOUT:2,LOAD_IO_ERROR:3,PREFETCH_ERROR:4,PREFETCH_TIMEOUT:5,PREFETCH_IO_ERROR:6,PLAY_ERROR:7,PLAY_TIMEOUT:8,PLAY_IO_ERROR:9,INVALID_PLAYER_CONFIGURATION:10,INVALID_AD_CONFIGURATION:11,AD_NOT_FOUND:12,EXCEPTION:13,AD_ERROR:14,INVALID_AD_RESPONSE:15,CONNECTION_ERROR:16,BUFFERING_TIMEOUT:17,POLICY_RESTRICTION:18};
  Ooyala.Reporter.prototype={reportPlayerLoad:function(){},initializeVideo:function(a,b){if(window.Ooyala){this._resetState(a,b);this._backoff=Ooyala.Backoff.getAppropriateBackoff(b);this._logger.initializeVideo(a,this._backoff);this._reportGeneralEvent(Ooyala.Logging.PlayerEventType.DISPLAY,this._reportedDisplays,this._firstDisplayForPlayer);this._firstDisplayForPlayer=false;this._nextPlaythroughToReport=this._playthroughReportFrequency}},reportPlayRequested:function(){if(window.Ooyala){this._reportGeneralEvent(Ooyala.Logging.PlayerEventType.PLAY,
    this._reportedPlays,this._firstPlayForPlayer);this._firstPlayForPlayer=false}},reportPlayStarted:function(){this.reportPlayRequested()},reportVideoStarted:function(){if(window.Ooyala){this._reportGeneralEvent(Ooyala.Logging.PlayerEventType.VIDEO_START,this._reportedVideoStarts,this._firstVideoStartForPlayer);this._firstVideoStartForPlayer=false}},reportPlayheadUpdate:function(a){if(window.Ooyala){this._backoff.setPlayheadPosition(a);this._tracker.processPlayheadUpdate(a);if(a>0){this._reportGeneralEvent(Ooyala.Logging.PlayerEventType.PLAY,
    this._reportedPlays,this._firstPlayForPlayer);this._reportGeneralEvent(Ooyala.Logging.PlayerEventType.VIDEO_START,this._reportedVideoStarts,this._firstVideoStartForPlayer)}}},reportReplay:function(){window.Ooyala&&this._logger.logPlayerEvents(this._createEventWithLastEventTime(Ooyala.Logging.PlayerEventType.REPLAY,[Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX,Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX,Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]))},setAdSource:function(a,b,c){if(typeof a!==
    "number"||a<=0||a>Object.keys(Ooyala.Reporter.AdSource).length)a=Ooyala.Reporter.AdSource.UNKNOWN;this._adSpot.adSource=a;if(a===Ooyala.Reporter.AdSource.OOYALA){if(!b||typeof b!=="string"||b.length!==32)throw"No valid embed code specified";this._adInfo.ooyalaEmbedCode=b;if(c&&typeof c!=="string")throw"Invalid Ad Click URL";this._adInfo.clickUrl=c}},setAdFormat:function(a){if(typeof a!=="number"||a<=0||a>Object.keys(Ooyala.Reporter.AdFormat).length)throw"Invalid Ad Format";this._adSpot.adFormat=a},
    setAdPositionType:function(a){if(typeof a!=="number"||a<=0||a>Object.keys(Ooyala.Reporter.AdPositionType).length)throw"Invalid Ad Position Type";this._adSpot.adPositionType=a},setAdPosition:function(a){if(typeof a!=="number")throw"Invalid Ad Position";this._adSpot.adPositionInMillis=a},setAdSourceContentId:function(a){if(typeof a!=="number")throw"Ad Source Content ID should be a number.";this._adSpot.adSourceContentId=a},setAdTagUrl:function(a){if(typeof a!=="string")throw"Invalid Tag URL";this._adSpot.tagUrl=
      a},setAdId:function(a){if(typeof a!=="number")throw"Ad ID should be a number.";this._adSpot.adId=a},setAdPassthroughParameters:function(a){if(typeof a!=="object")throw"Passthrough params should be given as an object.";this._adSpot.passthroughParameters=a},resetAdInformation:function(){window.Ooyala&&this._resetAdState()},reportAdRequest:function(){this._reportAdEvent(Ooyala.Logging.PlayerEventType.AD_REQUESTED,new Ooyala.AdsLogging.AdTracking)},reportAdImpression:function(){this._adInfo.adImpression=
      true;this._reportAdEvent(Ooyala.Logging.PlayerEventType.AD_IMPRESSION,new Ooyala.AdsLogging.AdTracking)},reportAdClickToSite:function(){var a=this._clickTracking();if(this._adSpot.adSource===1)a.clickUrl=this._adInfo.clickUrl;this._reportAdEvent(Ooyala.Logging.PlayerEventType.AD_CLICK,a)},reportAdClickToVideo:function(){var a=this._clickTracking();a.clickToVideo=true;this._reportAdEvent(Ooyala.Logging.PlayerEventType.AD_CLICK,a)},reportAdPlaythrough:function(a,b){if(typeof a!=="number"||typeof b!==
      "number")throw"Playhead time and total time should be numbers.";if(!(b<=0)){a>=b*0.25&&this._reportPlaythroughIfNotReported(25);a>=b*0.5&&this._reportPlaythroughIfNotReported(50);a>=b*0.75&&this._reportPlaythroughIfNotReported(75);a>=b&&this._reportPlaythroughIfNotReported(100)}},reportAdPlayFailure:function(a){if(a&&(typeof a!=="number"||a<=0||a>Object.keys(Ooyala.Reporter.AdFailureReason).length))throw"Invalid Ad Failure Reason";var b=new Ooyala.AdsLogging.AdTracking;if(this._adInfo.adImpression)b.failureAfterAdImpression=
      true;if(a)b.failureReason=a;this._reportAdEvent(Ooyala.Logging.PlayerEventType.AD_PLAY_FAILED,b)},reportDiscoveryImpression:function(a,b){if(window.Ooyala){if(a.constructor!==Array)throw"The relatedVideos argument must be an Array";else if(a.length===0)throw"The relatedVideos array must not be empty";else if(!a[0].bucket_info)throw"The relatedVideos[0] element does not have a bucket_info";var c=this._createPlayerEvent(Ooyala.Logging.PlayerEventType.RELATED_VIDEOS_DISPLAYED,[Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX,
      Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX,Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]),d=null;d=b?this._updateBucketInfoWithCustomData(a[0].bucket_info,b):a[0].bucket_info;c.personalizationBucketInfo=new Ooyala.Logging.PersonalizationBucketInfo;c.personalizationBucketInfo.bucketInfo=d;this._logger.logPlayerEvents([c])}},reportDiscoveryClick:function(a,b){if(window.Ooyala){if(a.bucket_info){if(!a.embed_code)throw"The clickedVideo argument does not have an embed_code";}else throw"The clickedVideo argument does not have a bucket_info";
      var c=[Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX],d=null;d=a.pcode?this._logger.getOrCreateExtraPcodeId(a.pcode):Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX;c.push(d);d=this._logger.getOrCreateExtraEmbedCodeId(a.embed_code,d);c.push(d);c=this._createPlayerEvent(Ooyala.Logging.PlayerEventType.RELATED_VIDEO_SELECTED,c);d=null;d=b?this._updateBucketInfoWithCustomData(a.bucket_info,b):a.bucket_info;c.personalizationBucketInfo=new Ooyala.Logging.PersonalizationBucketInfo;c.personalizationBucketInfo.bucketInfo=
        d;this._logger.logPlayerEvents([c])}},getSessionStartTimeMillis:function(){return this._logger.getSessionStartTimeMillis()},getRandomSessionSeed:function(){return this._logger.getRandomSessionSeed()},getAndIncrementNextEventSeqnum:function(){return this._logger.getAndIncrementNextEventSeqnum()},_reportAdEvent:function(a,b){if(window.Ooyala){var c=[Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX,Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX,Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX];if(this._adSpot.adSource===
      1){var d=this._logger.addReportingId(this._adInfo.ooyalaEmbedCode);c.push(d)}c=this._createPlayerEvent(a,c);c.adTracking=b;c.adTracking.adSpotIndex=this._logger.getOrCreateAdSpotIndex(this._adSpot);this._adSpot.parentContentReportingIdIndex=Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX;this._logger.logPlayerEvents([c])}},_clickTracking:function(){var a=new Ooyala.AdsLogging.AdTracking;if(this._adInfo.clicked)a.dupClick=true;else this._adInfo.clicked=true;return a},_reportPlaythroughIfNotReported:function(a){if(!this._adInfo.playthrough)this._adInfo.playthrough=
      Array(4);if(!this._adInfo.playthrough[a/25-1]){this._adInfo.playthrough[a/25-1]=true;var b=new Ooyala.AdsLogging.AdTracking;b.playThroughCompletion=a;this._reportAdEvent(Ooyala.Logging.PlayerEventType.AD_PLAYTHROUGH,b)}},setTags:function(a){this._logger.removeAllTags();for(var b=0;b<a.length;b++)this._logger.addTag(a[b]);return true},getTags:function(){return this._logger.getTags()},_reportTimePlayed:function(a,b){var c=this._createPlayerEvent(Ooyala.Logging.PlayerEventType.TOTAL_TIME_PLAYED,[Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX,
      Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX,Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]);c.timePlayed=a;c.reportingIdIndexToPlayheadPositionMillis={};c.reportingIdIndexToPlayheadPositionMillis[Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]=b;this._logger.logPlayerEvents([c])},_reportBucketWatched:function(a,b){for(this._reportBucketWatchedEvent(Ooyala.Logging.PlayerEventType.BUCKETS_WATCHED,[Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX],a,b);b/10>this._nextPlaythroughToReport||this._nextPlaythroughToReport==
    100&&b/10>95;){this._reportPlaythrough(this._nextPlaythroughToReport,[Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]);this._nextPlaythroughToReport+=this._playthroughReportFrequency}},_reportPercentageWatched:function(a,b){this._reportBucketWatchedEvent(Ooyala.Logging.PlayerEventType.PERCENTAGE_WATCHED,[Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX],a,b)},_reportBucketWatchedEvent:function(a,b,c,d){a=this._createPlayerEvent(a,b);a.buckets=new Ooyala.Logging.WatchedBuckets;a.buckets.minPerMille=c;a.buckets.maxPerMille=
      d;this._logger.logPlayerEvents([a])},_reportPlaythrough:function(a,b){var c=this._createPlayerEvent(Ooyala.Logging.PlayerEventType.PLAYTHROUGH_PERCENT,b);c.playthroughPercent=a;this._logger.logPlayerEvents([c])},_filterAndUpdateAlreadyReported:function(a,b){return Ooyala.Util.Enumerable.select(a,function(c){if(!b[c])return b[c]=true;return false})},_reportGeneralEvent:function(a,b,c){var d=[];b=this._filterAndUpdateAlreadyReported([Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX],b);if(b.length>0){b.push(Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX);
      b.push(Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX);d=this._createEventWithLastEventTime(a,b);c&&Ooyala.Util.Enumerable.foreach(d,function(e){e.firstForPlayer=true})}this._logger.logPlayerEvents(d);return d},_createEventWithLastEventTime:function(a,b){for(var c=[],d=0;d<b.length;d++){var e=this._createPlayerEvent(a,b[d]),f=this._getReportingCode(b[d]);e.lastEventTime=this._historyTracker.getAndSetLastEventTime(f,a);c.push(e)}return c},_getReportingCode:function(a){switch(a){case Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX:return this._embedCode;
      case Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX:return this._pCode;case Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX:return Ooyala.ThriftLogger.OOYALA_GLOBAL_ID}return""},_createPlayerEvent:function(a,b){var c=new Ooyala.Logging.PlayerEvent;Ooyala.Util.Enumerable.foreach(Ooyala.Reporter._NULL_PLAYER_EVENT_FIELDS,function(e){c[e]=null});c.eventType=a;if(b.constructor.toString().indexOf("Array")==-1)c.reportingIdIndices.push(b);else for(var d=0;d<b.length;d++)c.reportingIdIndices.push(b[d]);return c},
    _resetState:function(a,b){var c=Ooyala.Util.bind(this._reportTimePlayed,this),d=Ooyala.Util.bind(this._reportBucketWatched,this),e=Ooyala.Util.bind(this._reportPercentageWatched,this);this._tracker=new Ooyala.PlaytimeTracker(b,c,d,e);this._embedCode=a;this._reportedDisplays={};this._firstDisplayForPlayer=true;this._reportedPlays={};this._firstPlayForPlayer=true;this._reportedVideoStarts={};this._firstVideoStartForPlayer=true},_resetAdState:function(){this._adInfo={};this._adSpot=new Ooyala.AdsLogging.AdSpot},
    _requestSasInformation:function(){var a="id="+this._id+"&pcode="+encodeURIComponent(this._pCode);var b=Ooyala.Constants.SAS_URL+"?"+a;var c=Ooyala.Util.Http.createXMLHttpRequest();c.open("GET",b,true);c.onreadystatechange=function(){if(c.readyState==4){if(c.status==200){Ooyala.Reporter.processSAS(JSON.parse(c.response));}else{console.log("SAS Analytics Invocation Error: "+c.status);}}};c.send();},_setSASInfo:function(a){this._logger.setKey(a.key);this._logger.setTimezoneId(a.timezone);this._logger.setAuthenticationTime(a.authentication_time);this._logger.setGeoData(a.geo_data);
      this._logger.signal("SAS_Response")},_updateBucketInfoWithCustomData:function(a,b){if(a&&a.length>0&&a.charAt(0)=="2"){var c=JSON.parse(a.substring(1)),d=JSON.parse(window.atob(c.encoded));if(d.custom)for(var e in b){if(b.hasOwnProperty(e))d.custom[e]=b[e]}else d.custom=b;c.encoded=window.btoa(JSON.stringify(d));return"2"+JSON.stringify(c)}else throw"Not a version 2 bucket_info: "+a;}};Ooyala.Reporter.processSAS=function(a){var b=Ooyala.Reporter._map[a.id];b&&b._setSASInfo(a)};Ooyala.Util.createNamespace("Ooyala.Signing");Ooyala.Signing.getSignature=function(a,b){return Ooyala.ThirdParty.SHA256.sha256ToBase64String(a+b)};Ooyala.Signing.getXVerify=function(a,b){var c=Ooyala.Signing.getSignature(a,b),d=Ooyala.ThirdParty.CRC32.computeCrc(a);return a+"&sig="+c.substr(1,20)+"&crc="+d.toString()};Ooyala.Util.createNamespace("Ooyala.Backoff");Ooyala.Backoff.getAppropriateBackoff=function(a){return a>Ooyala.Constants.MIN_DURATION_FOR_LINEAR_BACKOFF?new Ooyala.Backoff.StepBackoff(a):new Ooyala.Backoff.NoBackoff};Ooyala.Backoff.StepBackoff=function(a){this._duration=a;this._playheadPosition=0;this.resetBackoffBehavior()};Ooyala.Backoff.StepBackoff.DURATION_FLUSH_FREQUENCY={};
  Ooyala.Backoff.StepBackoff.DURATION_FLUSH_FREQUENCY[Ooyala.Constants.LOW_PRIORITY_EVENT]=[[Ooyala.Constants.MIN_DURATION_FOR_STEP_BACKOFF*5,Ooyala.Constants.LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS*18],[Ooyala.Constants.MIN_DURATION_FOR_STEP_BACKOFF*2,Ooyala.Constants.LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS*6],[Ooyala.Constants.MIN_DURATION_FOR_STEP_BACKOFF,Ooyala.Constants.LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS*3],[-Infinity,Ooyala.Constants.LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS]];
  Ooyala.Backoff.StepBackoff.DURATION_FLUSH_FREQUENCY[Ooyala.Constants.HIGH_PRIORITY_EVENT]=[[Ooyala.Constants.MIN_DURATION_FOR_STEP_BACKOFF*2,Ooyala.Constants.HIGH_PRIORITY_EVENT_FLUSH_INTERVAL_MS*30],[Ooyala.Constants.MIN_DURATION_FOR_STEP_BACKOFF,Ooyala.Constants.HIGH_PRIORITY_EVENT_FLUSH_INTERVAL_MS*10],[-Infinity,Ooyala.Constants.HIGH_PRIORITY_EVENT_FLUSH_INTERVAL_MS]];
  Ooyala.Backoff.StepBackoff.prototype={setPlayheadPosition:function(a){this._playheadPosition=a},getFlushInterval:function(a){for(var b=Ooyala.Backoff.StepBackoff.DURATION_FLUSH_FREQUENCY[a],c=this._playheadPosition-this._resetPosition,d=null,e=0;e<b.length;e++){var f=b[e];if(f[0]<c){d=f;break}}return d!==null?d[1]:a==Ooyala.Constants.HIGH_PRIORITY_EVENT?Ooyala.Constants.HIGH_PRIORITY_EVENT_FLUSH_INTERVAL_MS:Ooyala.Constants.LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS},resetBackoffBehavior:function(){this._resetPosition=
    this._playheadPosition}};Ooyala.Backoff.NoBackoff=function(){};Ooyala.Backoff.NoBackoff.prototype={setPlayheadPosition:function(){},resetBackoffBehavior:function(){},getFlushInterval:function(a){if(a==Ooyala.Constants.HIGH_PRIORITY_EVENT)return Ooyala.Constants.HIGH_PRIORITY_EVENT_FLUSH_INTERVAL_MS;return Ooyala.Constants.LOW_PRIORITY_EVENT_FLUSH_INTERVAL_MS}};Ooyala.ThriftLogger=function(a,b,c,d,e){var f=this._createReportingIdDescriptor(Ooyala.Logging.ReportingIdType.GLOBAL),h=this._createReportingIdDescriptor(Ooyala.Logging.ReportingIdType.PROVIDER);this._reportingIdDescriptors=[f,h];this._reportingIds=[Ooyala.ThriftLogger.OOYALA_GLOBAL_ID,a];this._playerEvents=[];this._totalTimePlayedEvent=null;this._serializer=new Ooyala.Thrift.Serializer;this._logTimer=new Ooyala.LogTimer;this._waitConditions=[];this._documentUrl=d?d:window.location.href;this._signingKey=
    "";this._backoff=new Ooyala.Backoff.NoBackoff;this._adSpots=[];this._adSpotToIndex={};this._tags=[];this._flushInturruptedByWaitConditions=false;this._timezoneId=27;this._user=null;this._guid=c;this._accountId=b;this._playerBrandingId=e;this._sessionStartTimeMillis=Math.round((new Date).getTime());this._randomSessionSeed=Math.round(Math.random()*4503599627370496);this._nextEventSeqnum=1;this.wait("pinger_ready");this._pinger=new Ooyala.Pinger.OuterPinger(Ooyala.Util.bind(this._onReady,this))};
  Ooyala.ThriftLogger.OOYALA_GLOBAL_ID="o";Ooyala.ThriftLogger.GLOBAL_REPORTING_ID_INDEX=0;Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX=1;Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX=2;Ooyala.ThriftLogger.ANALYTICS_VERSION=2;Ooyala.ThriftLogger.MAX_PLAYER_EVENTS=42;Ooyala.ThriftLogger.EVENT_PRIORITIES={HIGH:Ooyala.Constants.HIGH_PRIORITY_EVENT,LOW:Ooyala.Constants.LOW_PRIORITY_EVENT};
  Ooyala.ThriftLogger.HIGH_PRIORITY_EVENT_TYPES=[Ooyala.Logging.PlayerEventType.UNKNOWN,Ooyala.Logging.PlayerEventType.DISPLAY,Ooyala.Logging.PlayerEventType.PLAY,Ooyala.Logging.PlayerEventType.PERCENTAGE_WATCHED,Ooyala.Logging.PlayerEventType.SEEK,Ooyala.Logging.PlayerEventType.REPLAY,Ooyala.Logging.PlayerEventType.PAUSE,Ooyala.Logging.PlayerEventType.BUCKETS_WATCHED,Ooyala.Logging.PlayerEventType.AD_CLICK,Ooyala.Logging.PlayerEventType.AD_IMPRESSION,Ooyala.Logging.PlayerEventType.AD_PLAYTHROUGH,Ooyala.Logging.PlayerEventType.AD_PLAY_FAILED,
    Ooyala.Logging.PlayerEventType.PLAYER_LOAD,Ooyala.Logging.PlayerEventType.SHARE,Ooyala.Logging.PlayerEventType.PAY_PER_VIEW,Ooyala.Logging.PlayerEventType.SAS_AUTHORIZE,Ooyala.Logging.PlayerEventType.SAS_AUTHORIZE_V2,Ooyala.Logging.PlayerEventType.AD_REQUESTED,Ooyala.Logging.PlayerEventType.AD_MOUSEOVER,Ooyala.Logging.PlayerEventType.VIDEO_START,Ooyala.Logging.PlayerEventType.CUSTOM,Ooyala.Logging.PlayerEventType.RELATED_VIDEO_SELECTED,Ooyala.Logging.PlayerEventType.RELATED_VIDEOS_DISPLAYED];
  Ooyala.ThriftLogger.LOW_PRIORITY_EVENT_TYPES=[Ooyala.Logging.PlayerEventType.TOTAL_TIME_PLAYED,Ooyala.Logging.PlayerEventType.BITRATE_PLAYED,Ooyala.Logging.PlayerEventType.DOWNLOAD,Ooyala.Logging.PlayerEventType.CHUNK_FAILOVER,Ooyala.Logging.PlayerEventType.BUFFER,Ooyala.Logging.PlayerEventType.CV_INFO,Ooyala.Logging.PlayerEventType.METRIC,Ooyala.Logging.PlayerEventType.BITRATE_TRANSITION,Ooyala.Logging.PlayerEventType.BITRATES_AVAILABLE];Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY=null;
  Ooyala.ThriftLogger.BUCKETIZED_EVENT_TYPES=[Ooyala.Logging.PlayerEventType.PERCENTAGE_WATCHED,Ooyala.Logging.PlayerEventType.BUCKETS_WATCHED];Ooyala.ThriftLogger._NULL_PLAYER_LOG_ENTRY_FIELDS=["logTime","ipaddr","userAgent","logServer","country","clientStat","adSpots","rootContentReportingIdIndex","flashCookieAge","bucketInfo","accountId","logTimeMillis"];Ooyala.ThriftLogger._NULL_USER_FIELDS=["region","county","city","lat","lon","dmaCode","pmsaCode","cookie","clientIP"];
  Ooyala.ThriftLogger.prototype={initializeVideo:function(a,b){this._backoff=b||new Ooyala.Backoff.NoBackoff;if(this._reportingIds.length>=3&&this._reportingIds[Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]!=a){this.flushEventBufferInAtMostMillis(0);this._reportingIds[Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX]=a}else if(this._reportingIds.length<3){var c=this._createReportingIdDescriptor(Ooyala.Logging.ReportingIdType.VIDEO);c.providerReportingIdIndex=Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX;
    this._reportingIdDescriptors.push(c);this._reportingIds.push(a)}this._clearExtraReportingIds()},getOrCreateExtraPcodeId:function(a){for(var b=-1,c=0;c<this._reportingIds.length;c++)if(this._reportingIds[c]===a)b=c;if(b>=0)return b;else{b=this._reportingIds.length;this._reportingIds.push(a);this._reportingIdDescriptors.push(this._createReportingIdDescriptor(Ooyala.Logging.ReportingIdType.PROVIDER));return b}},getOrCreateExtraEmbedCodeId:function(a,b){for(var c=-1,d=0;d<this._reportingIds.length;d++)if(this._reportingIds[d]===
    a)c=d;if(c>=0)return c;else{c=this._reportingIds.length;this._reportingIds.push(a);d=this._createReportingIdDescriptor(Ooyala.Logging.ReportingIdType.VIDEO);d.providerReportingIdIndex=b;this._reportingIdDescriptors.push(d);return c}},_clearExtraReportingIds:function(){if(this._reportingIds.length>3){this._reportingIds=this._reportingIds.slice(0,3);this._reportingIdDescriptors=this._reportingIdDescriptors.slice(0,3)}},getOrCreateAdSpotIndex:function(a){var b=this._adSpotToIndex[a];if(!b){this._adSpotToIndex[a]=
    b=this._adSpots.length;this._adSpots.push(a)}return b},addReportingId:function(a){this._reportingIds.push(a);a=this._createReportingIdDescriptor(Ooyala.Logging.ReportingIdType.VIDEO);a.providerReportingIdIndex=Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX;this._reportingIdDescriptors.push(a);return this._reportingIds.length-1},logPlayerEvents:function(a){for(var b=0;b<a.length;b++)this._logPlayerEvent(a[b]);this._playerEvents.length>=Ooyala.ThriftLogger.MAX_PLAYER_EVENTS&&this.flushEventBufferInAtMostMillis(0)},
    flushEventBufferInAtMostMillis:function(a){!a||a<=0?this.flushEventBuffer():this._logTimer.setLogTimeout(Ooyala.Util.bind(this.flushEventBuffer,this),a)},flushEventBuffer:function(){if(this._playerEvents.length!=0)if(this._waitConditions.length>0)this._flushInturruptedByWaitConditions=true;else{var a=this._serializer.serialize(this._playerEventsToPlayerLogEntry());a=Ooyala.Util.base64Encode(a);this._pinger.sendMessage(Ooyala.Signing.getXVerify(a,this._signingKey));this._resetPlayerEvents();this._clearExtraReportingIds()}},
    arrayIndexOf:function(a,b){for(var c=0;c<a.length;c++)if(a[c]===b)return c;return-1},wait:function(a){this._waitConditions.push(a)},signal:function(a){a=this.arrayIndexOf(this._waitConditions,a);if(a<0)return false;this._waitConditions[a]=this._waitConditions[this._waitConditions.length-1];this._waitConditions.pop();if(this._waitConditions.length==0&&this._flushInturruptedByWaitConditions){this._flushInturruptedByWaitConditions=false;this.flushEventBuffer()}return true},setKey:function(a){this._signingKey=
      a},setTimezoneId:function(a){this._timezoneId=a},setAuthenticationTime:function(a){this._authenticationTime=a},setGeoData:function(a){var b=new Ooyala.Logging.User;Ooyala.Util.Enumerable.foreach(Ooyala.ThriftLogger._NULL_USER_FIELDS,function(c){b[c]=null});b.country=a;b.source=Ooyala.Logging.UserInfoSource.ENCRYPTED_SAS;this._user=b},addTag:function(a){if(this.arrayIndexOf(this._tags,a)>=0)return false;this._tags.push(a);return true},getTags:function(){return[].concat(this._tags)},removeTag:function(a){a=
      this.arrayIndexOf(this._tags,a);if(a<0)return false;this._tags[a]=this._tags[this._tags.length-1];this._tags.pop();return true},removeAllTags:function(){this._tags=[];return true},getSessionStartTimeMillis:function(){return this._sessionStartTimeMillis},getRandomSessionSeed:function(){return this._randomSessionSeed},getAndIncrementNextEventSeqnum:function(){var a=this._nextEventSeqnum;this._nextEventSeqnum+=1;return a},_onReady:function(a){this._guid=this._guid||a;this.signal("pinger_ready")},_logPlayerEvent:function(a){switch(a.eventType){case Ooyala.Logging.PlayerEventType.TOTAL_TIME_PLAYED:this._logTotalTimePlayedEvent(a);
      break;default:this._playerEvents.push(a);break}this.flushEventBufferInAtMostMillis(this._playerEventTypeToFlushInterval(a.eventType))},_logTotalTimePlayedEvent:function(a){var b=this._totalTimePlayedEvent;if(b){b.timePlayed+=a.timePlayed;b.reportingIdIndexToPlayheadPositionMillis=a.reportingIdIndexToPlayheadPositionMillis}else{this._totalTimePlayedEvent=a;this._playerEvents.push(a)}},_playerEventTypeToFlushInterval:function(a){Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY||this._initializeEventTypeToPriorityHash();
      return this._backoff.getFlushInterval(Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY[a]||Ooyala.ThriftLogger.EVENT_PRIORITIES.HIGH)},_initializeEventTypeToPriorityHash:function(){if(!Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY){Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY={};for(var a=0;a<Ooyala.ThriftLogger.HIGH_PRIORITY_EVENT_TYPES.length;a++){var b=Ooyala.ThriftLogger.HIGH_PRIORITY_EVENT_TYPES[a];Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY[b]=Ooyala.ThriftLogger.EVENT_PRIORITIES.HIGH}for(a=0;a<Ooyala.ThriftLogger.LOW_PRIORITY_EVENT_TYPES.length;a++){b=
      Ooyala.ThriftLogger.LOW_PRIORITY_EVENT_TYPES[a];Ooyala.ThriftLogger.EVENT_TYPE_TO_PRIORITY[b]=Ooyala.ThriftLogger.EVENT_PRIORITIES.LOW}}},_compressAllBucketizedEvents:function(a){for(var b=0;b<Ooyala.ThriftLogger.BUCKETIZED_EVENT_TYPES.length;b++)a=this._compressBucketizedEventsForType(Ooyala.ThriftLogger.BUCKETIZED_EVENT_TYPES[b],a);return a},_compressBucketizedEventsForType:function(a,b){if(!this._isBucketizedEventType(a))return b;var c=Ooyala.Util.Enumerable.select(b,function(i){return i.eventType==
      a});if(!c||c.length<2)return b;c.sort(function(i,g){return i.buckets.minPerMille-g.buckets.minPerMille||i.buckets.maxPerMille-g.buckets.maxPerMille});for(var d=[],e=c.shift(),f=false;c.length!=0;){var h=c.shift();if(e.buckets.maxPerMille!=h.buckets.minPerMille-1){d.push(e);e=h}else{e.buckets.maxPerMille=h.buckets.maxPerMille;f=true}}if(!f)return b;d.push(e);b=Ooyala.Util.Enumerable.reject(b,function(i){return i.eventType==a});return b=b.concat(d)},_isBucketizedEventType:function(a){for(var b=0;b<
    Ooyala.ThriftLogger.BUCKETIZED_EVENT_TYPES.length;b++)if(a==Ooyala.ThriftLogger.BUCKETIZED_EVENT_TYPES[b])return true;return false},_resetPlayerEvents:function(){this._playerEvents=[];this._totalTimePlayedEvent=null},_playerEventsToPlayerLogEntry:function(){var a=new Ooyala.Logging.PlayerLogEntry,b=new Date,c=b.getTimezoneOffset();Ooyala.Util.Enumerable.foreach(Ooyala.ThriftLogger._NULL_PLAYER_LOG_ENTRY_FIELDS,function(d){a[d]=null});a.user=this._user;a.guid=this._guid;a.playerBrandingId=this._playerBrandingId;
      a.version=Ooyala.ThriftLogger.ANALYTICS_VERSION;a.userTimeMillis=Math.round(b.getTime());a.userTime=Math.round(a.userTimeMillis/1E3);a.userTimezone=c;a.documentUrl=this._documentUrl;a.authenticationTime=this._authenticationTime;a.reportingIds=this._reportingIds.slice(0);if(Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX<a.reportingIds.length)a.rootContentReportingIdIndex=Ooyala.ThriftLogger.VIDEO_REPORTING_ID_INDEX;a.reportingIdDescriptors=this._reportingIdDescriptors.slice(0);a.timezoneIds=[0];a.tags=
        this._tags;a.sessionStartTimeMillis=this._sessionStartTimeMillis;a.randomSessionSeed=this._randomSessionSeed;if(this._accountId)a.accountId=this._accountId;for(b=0;b<this._playerEvents.length;b++){c=this._playerEvents[b];if(c.adTracking&&typeof c.adTracking.adSpotIndex==="number"){if(!a.adSpots)a.adSpots=[];a.adSpots.push(this._adSpots[c.adTracking.adSpotIndex])}}for(;a.timezoneIds.length<a.reportingIds.length;)a.timezoneIds.push(this._timezoneId);a.events=this._compressAllBucketizedEvents(this._playerEvents);
      a.providerReportingIdIndex=Ooyala.ThriftLogger.PROVIDER_REPORTING_ID_INDEX;a.playerEmbedType=Ooyala.Logging.PlayerEmbedType.EXTERNAL_ANALYTICS;a.isUntrustedDocUrl=false;for(b=0;b<a.events.length;b++){a.events[b].seqnum=this._nextEventSeqnum;this._nextEventSeqnum+=1}return a},_isPlayerLogEntryValid:function(a){if(!a.events||a.events.length==0||!a.documentUrl||a.documentUrl.length==0||!a.reportingIds||a.reportingIds.length==0||!a.reportingIdDescriptors||a.reportingIdDescriptors.length==0)return false;
      return true},_createReportingIdDescriptor:function(a){var b=new Ooyala.Logging.ReportingIdDescriptor;b.reportingIdType=a;Ooyala.Util.Enumerable.foreach(["providerReportingIdIndex","parentContentIdIndex","syndicationDestinationIdIndex","adSetId"],function(c){b[c]=null});return b}};Ooyala.LogTimer=function(){this._nextTimeout=this._timeoutId=null};
  Ooyala.LogTimer.prototype={setLogTimeout:function(a,b){var c=(new Date).getTime(),d=c+b;if(this._nextTimeout!==null&&d>this._nextTimeout||d<c)return false;this._clearLogTimer();this._nextTimeout=d;c=Ooyala.Util.bind(this._clearTimerAndCallCallback,this,a);this._timeoutId=setTimeout(c,b);return true},_clearTimerAndCallCallback:function(a){this._clearLogTimer();a()},_clearLogTimer:function(){if(this._timeoutId!==null){clearTimeout(this._timeoutId);this._nextTimeout=this._timeoutId=null}}};global=this;global.Ooyala=Ooyala;global.Ooyala.Reporter=Ooyala.Reporter;global.Ooyala.Reporter.prototype.reportPlayerLoad=Ooyala.Reporter.prototype.reportPlayerLoad;global.Ooyala.Reporter.prototype.initializeVideo=Ooyala.Reporter.prototype.initializeVideo;global.Ooyala.Reporter.prototype.reportPlayheadUpdate=Ooyala.Reporter.prototype.reportPlayheadUpdate;global.Ooyala.Reporter.prototype.reportReplay=Ooyala.Reporter.prototype.reportReplay;
  //end Reporter.js
}(OO, OO.$, OO._));
  /* eslint-disable */
  OO.exposeStaticApi('EVENTS', OO.EVENTS);
  OO.exposeStaticApi('CONSTANTS', OO.CONSTANTS);
  OO.publicApi.log = OO.log;
  OO.exposeStaticApi('ERROR', OO.ERROR);
  OO.exposeStaticApi('STATE', OO.STATE);
  OO.exposeStaticApi('VERSION', OO.VERSION);
  OO.exposeStaticApi('VIDEO', OO.VIDEO);
  OO.publicApi.$ = OO.$;
  OO.publicApi._ = OO._;
  OO.publicApi.__static.apiReady = true;
  OO.$(document).ready(function() {
    OO.publicApi.__static.docReady = true;
    OO.tryCallReady();
  });
}());

} catch (err) {
  if (err && window.console && window.console.log) { window.console.log(err, err.stack); }
}
